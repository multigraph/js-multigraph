(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * ajaxthrottle.js
 * 
 * Usage:
 * 
 *     var t = $.ajaxthrottle({
 *        numRequestsPerTimePeriod : N,
 *        timePeriod               : P,
 *        maxConcurrent            : M
 *     });
 *    
 *     t.ajax(args);
 *
 * This is just like calling $.ajax(args), except that requests are throttled
 * so that no more than N are initiated in any time period of P milliseconds,
 * and no more than M concurrent (outstanding at the same time) requests are allowed.
 * If N or P is 0, there is no time period based constraint, and if M is 0, there
 * is no constraint on the number of concurrent requests.
 * 
 * Mark Phillips <mphillip@unca.edu>
 * Thu Dec 20 11:04:19 2012
 */
(function($) {
    $.ajaxthrottle = function(options) {

        var timeout,

            settings = $.extend({
                numRequestsPerTimePeriod : 0,
                timePeriod               : 0,
                maxConcurrent            : 1
            }, options),

            time = function() {
                return (new Date()).getTime();
            },

            // Array of outstanding requests; these are requests that have
            // been initiated with a call to $.ajax() but that have not
            // completed yet.  Each entry in this array is an object of the form
            //    {
            //         arguments: the original arguments list passed to .ajax()
            //              time: the time this request was passed to $.ajax()
            //          deferred: the jQuery deferred object for this request
            //    }
            outstanding_reqs = [],

            // Array of initiated requests; each entry in this array
            // is an object just like the ones in the outstanding_reqs
            // array above, but this array keeps track of all
            // requests, regardless of whether they have completed.
            // This list is used to keep track of how many requests
            // have been initiated in settings.timePeriod.  Requests
            // that are older than settings.timePeriod milliseconds
            // get removed from this list when it is purged.
            initiated_reqs = [],

            // Array of requests waiting to be initiated
            waiting_reqs = [],

            // Purge the initiated reqs list so that it doesn't contain any
            // reqs from more than settings.timePeriod ms ago.  Return the
            // amount of time that needs to be waited until the oldest remaining
            // (after purging) req in the list will be settings.timePeriod ms old.
            // Do all of this relative to the passed in 'now' value.
            purge_initiated_reqs = function(now) {
                if (settings.timePeriod >= 0) {
                    while ((initiated_reqs.length > 0)
                           &&
                           (initiated_reqs[0].time + settings.timePeriod - now <= 0)) {
                        initiated_reqs.shift();
                    }
                    if (initiated_reqs.length > 0) {
                        return initiated_reqs[0].time + settings.timePeriod - now;
                    }
                }
                return 0;
            },

            // remove a req from the outstanding_reqs list
            remove_outstanding_req = function(obj) {
                $.each(outstanding_reqs, function(i) {
                    if (outstanding_reqs[i] === obj) {
                        outstanding_reqs.splice(i,1);
                        return false;
                    }
                    return true;
                });
            },

            // Initiate the next request on the waiting list, unless we need to wait
            // till some time has passed or some outstanding requests have completed.
            process_waiting = function() {
                var now = time(),
                    delay, req, deferred;

                if (waiting_reqs.length <= 0) {
                    return;
                }

                delay = purge_initiated_reqs(now);

                // If we have a timePeriod constraint, and the max number of allowed
                // requests have gone out in that time period, arrange to wait for
                // 'delay' ms
                if ((settings.numRequestsPerTimePeriod > 0) && (settings.timePeriod > 0)
                    &&
                    (delay > 0)
                    &&
                    (initiated_reqs.length >= settings.numRequestsPerTimePeriod)) {
                    // clear any existing timeout first, because this one will
                    // require waiting till after it would finish anyway
                    if (timeout !== undefined) {
                        clearTimeout(timeout);
                    }
                    timeout = setTimeout(function() {
                        timeout = undefined;
                        process_waiting();
                    }, delay);
                    return;
                }

                // If the max number of allowed requests is outstanding, do nothing;
                // process_waiting() will get called again when a request completes.
                if ((settings.maxConcurrent > 0)
                           &&
                           (outstanding_reqs.length >= settings.maxConcurrent)) {
                    return;
                }

                // If we make it to here, then it's OK to initiate the next
                // request in the waiting list
                req = waiting_reqs.shift();
                req.time = time();
                initiated_reqs.push(req);
                outstanding_reqs.push(req);
                $.ajax.apply($,req.arguments).done(function() {
                    req.deferred.resolve.apply(req.deferred, arguments);
                }).fail(function() {
                    req.deferred.reject.apply(req.deferred, arguments);
                }).always(function() {
                    remove_outstanding_req(req);
                    process_waiting();
                });
                
            }
        ;

        return {
            ajax : function() {
                var deferred = $.Deferred();
                waiting_reqs.push({ arguments : arguments, deferred : deferred });
                process_waiting();
                return deferred.promise();
            }
        };
    };
}(jQuery));

},{}],2:[function(require,module,exports){
(function ($) {
    "use strict";

    var methods = {
        on : function(on) {
            if (on === undefined) {
                return $(this).data('busy_spinner').on;
            } else {
                return this.each(function() {
                    if (on) {
                        $(this).data('busy_spinner').on    = true;
                        $(this).data('busy_spinner').level = 1;
                        $(this).show();
                    } else {
                        $(this).data('busy_spinner').on    = false;
                        $(this).data('busy_spinner').level = 0;
                        $(this).hide();
                    }
                    return this;
                });
            }            
        },

        level : function(delta) {
            if (delta === undefined) {
                return $(this).data('busy_spinner').level;
            } else {
                return this.each(function() {
                    if ($(this).data('busy_spinner').level + delta >= 0) {
                        $(this).data('busy_spinner').level = $(this).data('busy_spinner').level + delta;
                        if ($(this).data('busy_spinner').level === 1) {
                            $(this).busy_spinner('on', true);
                        } else if ($(this).data('busy_spinner').level === 0) {
                            $(this).busy_spinner('on', false);
                        }
                    }
                    return this;
                });
            }
        },

        init : function(options) {
            return this.each(function() {
                var $this = $(this),
                    data = $this.data('busy_spinner'),
                    settings = $.extend({
                        on : false
                    }, options);
                if ( ! data ) {
                    $this.data('busy_spinner', {
                        on    : settings.on,
                        level : 0
                    });
                    if (settings.on) {
                        $(this).show();
                    } else {
                        $(this).hide();
                    }
                    $(this).css({
                        width  : 32,
                        height : 32
                    }).append($('<img src="data:image/gif;base64,R0lGODlhIAAgAPMAAP///wAAAMbGxoSEhLa2tpqamjY2NlZWVtjY2OTk5Ly8vB4eHgQEBAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAAACwAAAAAIAAgAAAE5xDISWlhperN52JLhSSdRgwVo1ICQZRUsiwHpTJT4iowNS8vyW2icCF6k8HMMBkCEDskxTBDAZwuAkkqIfxIQyhBQBFvAQSDITM5VDW6XNE4KagNh6Bgwe60smQUB3d4Rz1ZBApnFASDd0hihh12BkE9kjAJVlycXIg7CQIFA6SlnJ87paqbSKiKoqusnbMdmDC2tXQlkUhziYtyWTxIfy6BE8WJt5YJvpJivxNaGmLHT0VnOgSYf0dZXS7APdpB309RnHOG5gDqXGLDaC457D1zZ/V/nmOM82XiHRLYKhKP1oZmADdEAAAh+QQJCgAAACwAAAAAIAAgAAAE6hDISWlZpOrNp1lGNRSdRpDUolIGw5RUYhhHukqFu8DsrEyqnWThGvAmhVlteBvojpTDDBUEIFwMFBRAmBkSgOrBFZogCASwBDEY/CZSg7GSE0gSCjQBMVG023xWBhklAnoEdhQEfyNqMIcKjhRsjEdnezB+A4k8gTwJhFuiW4dokXiloUepBAp5qaKpp6+Ho7aWW54wl7obvEe0kRuoplCGepwSx2jJvqHEmGt6whJpGpfJCHmOoNHKaHx61WiSR92E4lbFoq+B6QDtuetcaBPnW6+O7wDHpIiK9SaVK5GgV543tzjgGcghAgAh+QQJCgAAACwAAAAAIAAgAAAE7hDISSkxpOrN5zFHNWRdhSiVoVLHspRUMoyUakyEe8PTPCATW9A14E0UvuAKMNAZKYUZCiBMuBakSQKG8G2FzUWox2AUtAQFcBKlVQoLgQReZhQlCIJesQXI5B0CBnUMOxMCenoCfTCEWBsJColTMANldx15BGs8B5wlCZ9Po6OJkwmRpnqkqnuSrayqfKmqpLajoiW5HJq7FL1Gr2mMMcKUMIiJgIemy7xZtJsTmsM4xHiKv5KMCXqfyUCJEonXPN2rAOIAmsfB3uPoAK++G+w48edZPK+M6hLJpQg484enXIdQFSS1u6UhksENEQAAIfkECQoAAAAsAAAAACAAIAAABOcQyEmpGKLqzWcZRVUQnZYg1aBSh2GUVEIQ2aQOE+G+cD4ntpWkZQj1JIiZIogDFFyHI0UxQwFugMSOFIPJftfVAEoZLBbcLEFhlQiqGp1Vd140AUklUN3eCA51C1EWMzMCezCBBmkxVIVHBWd3HHl9JQOIJSdSnJ0TDKChCwUJjoWMPaGqDKannasMo6WnM562R5YluZRwur0wpgqZE7NKUm+FNRPIhjBJxKZteWuIBMN4zRMIVIhffcgojwCF117i4nlLnY5ztRLsnOk+aV+oJY7V7m76PdkS4trKcdg0Zc0tTcKkRAAAIfkECQoAAAAsAAAAACAAIAAABO4QyEkpKqjqzScpRaVkXZWQEximw1BSCUEIlDohrft6cpKCk5xid5MNJTaAIkekKGQkWyKHkvhKsR7ARmitkAYDYRIbUQRQjWBwJRzChi9CRlBcY1UN4g0/VNB0AlcvcAYHRyZPdEQFYV8ccwR5HWxEJ02YmRMLnJ1xCYp0Y5idpQuhopmmC2KgojKasUQDk5BNAwwMOh2RtRq5uQuPZKGIJQIGwAwGf6I0JXMpC8C7kXWDBINFMxS4DKMAWVWAGYsAdNqW5uaRxkSKJOZKaU3tPOBZ4DuK2LATgJhkPJMgTwKCdFjyPHEnKxFCDhEAACH5BAkKAAAALAAAAAAgACAAAATzEMhJaVKp6s2nIkolIJ2WkBShpkVRWqqQrhLSEu9MZJKK9y1ZrqYK9WiClmvoUaF8gIQSNeF1Er4MNFn4SRSDARWroAIETg1iVwuHjYB1kYc1mwruwXKC9gmsJXliGxc+XiUCby9ydh1sOSdMkpMTBpaXBzsfhoc5l58Gm5yToAaZhaOUqjkDgCWNHAULCwOLaTmzswadEqggQwgHuQsHIoZCHQMMQgQGubVEcxOPFAcMDAYUA85eWARmfSRQCdcMe0zeP1AAygwLlJtPNAAL19DARdPzBOWSm1brJBi45soRAWQAAkrQIykShQ9wVhHCwCQCACH5BAkKAAAALAAAAAAgACAAAATrEMhJaVKp6s2nIkqFZF2VIBWhUsJaTokqUCoBq+E71SRQeyqUToLA7VxF0JDyIQh/MVVPMt1ECZlfcjZJ9mIKoaTl1MRIl5o4CUKXOwmyrCInCKqcWtvadL2SYhyASyNDJ0uIiRMDjI0Fd30/iI2UA5GSS5UDj2l6NoqgOgN4gksEBgYFf0FDqKgHnyZ9OX8HrgYHdHpcHQULXAS2qKpENRg7eAMLC7kTBaixUYFkKAzWAAnLC7FLVxLWDBLKCwaKTULgEwbLA4hJtOkSBNqITT3xEgfLpBtzE/jiuL04RGEBgwWhShRgQExHBAAh+QQJCgAAACwAAAAAIAAgAAAE7xDISWlSqerNpyJKhWRdlSAVoVLCWk6JKlAqAavhO9UkUHsqlE6CwO1cRdCQ8iEIfzFVTzLdRAmZX3I2SfZiCqGk5dTESJeaOAlClzsJsqwiJwiqnFrb2nS9kmIcgEsjQydLiIlHehhpejaIjzh9eomSjZR+ipslWIRLAgMDOR2DOqKogTB9pCUJBagDBXR6XB0EBkIIsaRsGGMMAxoDBgYHTKJiUYEGDAzHC9EACcUGkIgFzgwZ0QsSBcXHiQvOwgDdEwfFs0sDzt4S6BK4xYjkDOzn0unFeBzOBijIm1Dgmg5YFQwsCMjp1oJ8LyIAACH5BAkKAAAALAAAAAAgACAAAATwEMhJaVKp6s2nIkqFZF2VIBWhUsJaTokqUCoBq+E71SRQeyqUToLA7VxF0JDyIQh/MVVPMt1ECZlfcjZJ9mIKoaTl1MRIl5o4CUKXOwmyrCInCKqcWtvadL2SYhyASyNDJ0uIiUd6GGl6NoiPOH16iZKNlH6KmyWFOggHhEEvAwwMA0N9GBsEC6amhnVcEwavDAazGwIDaH1ipaYLBUTCGgQDA8NdHz0FpqgTBwsLqAbWAAnIA4FWKdMLGdYGEgraigbT0OITBcg5QwPT4xLrROZL6AuQAPUS7bxLpoWidY0JtxLHKhwwMJBTHgPKdEQAACH5BAkKAAAALAAAAAAgACAAAATrEMhJaVKp6s2nIkqFZF2VIBWhUsJaTokqUCoBq+E71SRQeyqUToLA7VxF0JDyIQh/MVVPMt1ECZlfcjZJ9mIKoaTl1MRIl5o4CUKXOwmyrCInCKqcWtvadL2SYhyASyNDJ0uIiUd6GAULDJCRiXo1CpGXDJOUjY+Yip9DhToJA4RBLwMLCwVDfRgbBAaqqoZ1XBMHswsHtxtFaH1iqaoGNgAIxRpbFAgfPQSqpbgGBqUD1wBXeCYp1AYZ19JJOYgH1KwA4UBvQwXUBxPqVD9L3sbp2BNk2xvvFPJd+MFCN6HAAIKgNggY0KtEBAAh+QQJCgAAACwAAAAAIAAgAAAE6BDISWlSqerNpyJKhWRdlSAVoVLCWk6JKlAqAavhO9UkUHsqlE6CwO1cRdCQ8iEIfzFVTzLdRAmZX3I2SfYIDMaAFdTESJeaEDAIMxYFqrOUaNW4E4ObYcCXaiBVEgULe0NJaxxtYksjh2NLkZISgDgJhHthkpU4mW6blRiYmZOlh4JWkDqILwUGBnE6TYEbCgevr0N1gH4At7gHiRpFaLNrrq8HNgAJA70AWxQIH1+vsYMDAzZQPC9VCNkDWUhGkuE5PxJNwiUK4UfLzOlD4WvzAHaoG9nxPi5d+jYUqfAhhykOFwJWiAAAIfkECQoAAAAsAAAAACAAIAAABPAQyElpUqnqzaciSoVkXVUMFaFSwlpOCcMYlErAavhOMnNLNo8KsZsMZItJEIDIFSkLGQoQTNhIsFehRww2CQLKF0tYGKYSg+ygsZIuNqJksKgbfgIGepNo2cIUB3V1B3IvNiBYNQaDSTtfhhx0CwVPI0UJe0+bm4g5VgcGoqOcnjmjqDSdnhgEoamcsZuXO1aWQy8KAwOAuTYYGwi7w5h+Kr0SJ8MFihpNbx+4Erq7BYBuzsdiH1jCAzoSfl0rVirNbRXlBBlLX+BP0XJLAPGzTkAuAOqb0WT5AH7OcdCm5B8TgRwSRKIHQtaLCwg1RAAAOwAAAAAAAAAAAA==" width="32" height="32" alt="ajax loading">'));
                }

                return this;
            });
        }
    };

    $.fn.busy_spinner = function( method ) {
        if ( methods[method] ) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.busy_spinner' );
            return null;
        }    
    };
    
}(jQuery));

},{}],3:[function(require,module,exports){
(function ($) {
    "use strict";

    var errorDisplayHtml = (
        ''
            + '<div class="errorDisplay">'
            +   '<span class="errorDisplayOptions">'
            +     '<button class="errorDisplayDetailsButton">See Details</button>'
            +     '<a href="" class="errorDisplayXButton">&#10006;</a>'
            +   '</span>'
            +   '<span class="errorDisplayShortMessage"></span>'
            + '</div>'
            + '<span class="errorDisplayRetriever"></span>'
    );
    
    var detailDisplayHtml = (
        ''
            + '<div class="errorDisplayDetails">'
            +   '<span class="errorDisplayOptions">'
            +     '<a href="" class="errorDisplayXButton">&#10006;</a>'
            +   '</span>'
            +   '<span class="errorDisplayFullMessageArea"></span>'
            + '</div>'
    );
    
    var detailDisplayListHtml = (
        ''
            + '<ul class="errorDisplayFullMessageList">'
            + '</ul>'
    );
    
    var methods = {
        init : function(options) {
            return this.each(function() {
                var $this = $(this),
                    data = $this.data('errorDisplay'),
                    settings = $.extend({
                        'fontColor' : '#ff0000',
                        'backgroundColor' : '#ffffff',
                        'displayTime' : 1000,
                        'indicatorColor' : '#ff0000'
                    }, options);
                
                if ( ! data ) {
                    
                    $this.append(errorDisplayHtml);
                    $this.find('.errorDisplay').width($this.width()-6);  
                    
                    var detailDisplay = $(detailDisplayHtml).appendTo($("body"));
                    var detailDisplayList = $(detailDisplayListHtml);
                    
                    $(detailDisplay).find('.errorDisplayXButton').click(function(event) {
                        event.preventDefault();
                        $(detailDisplay).find('.errorDisplayOptions').hide();   
                        $(detailDisplay).hide();
                        $this.find('.errorDisplayRetriever').css('background-color', settings.indicatorColor).show();
                    });         
                    
                    $this.data('errorDisplay', {
                        'detailDisplay' : detailDisplay,
                        'detailDisplayList' : detailDisplayList,
                        'fontColor' : settings.fontColor,
                        'backgroundColor' : settings.backgroundColor,
                        'displayTime' : settings.displayTime,
                        'indicatorColor' : settings.indicatorColor
                    });
                    
                    
                    $this.find('.errorDisplayXButton').click(function(event) {
                        event.preventDefault(); 
                        $this.find('.errorDisplayOptions').hide();
                        $this.find('.errorDisplay').slideUp(settings.displayTime, function(){
                            $this.find('.errorDisplayRetriever').show();
                        });
                    });         
                    
                    
                    $this.find('.errorDisplayDetailsButton').click(function(event) {
                        event.preventDefault(); 
                        $this.find('.errorDisplay').off(); //stops mouseleaveevent when details button is clicked
                        $this.find('.errorDisplay').hide();                 
                        $this.find('.errorDisplayRetriever').hide();
                        $(detailDisplay).find('.errorDisplayFullMessageArea').empty().append($(detailDisplayList));
                        $(detailDisplay).find('.errorDisplayOptions').show();
                        $(detailDisplay).show();                     
                    });
                    
                }
                return this;
            });
        }, // init() method
        
        displayError : function(fullMessage, shortMessage, options) {
            return this.each(function() {
                var $this = $(this),
                    data = $this.data('errorDisplay'),
                    settings = $.extend({
                        'fontColor' : data.fontColor,
                        'backgroundColor' : data.backgroundColor,
                        'displayTime' : data.displayTime,
                        'indicatorColor' : data.indicatorColor
                    }, options);
                $this.find('.errorDisplayRetriever').hide();
                $this.find('.errorDisplayOptions').hide();
                $this.find('.errorDisplayShortMessage').css('color', settings.fontColor);   
                $this.find('.errorDisplay').css('background-color', settings.backgroundColor);
                  $this.find('.errorDisplayOptions').css('background-color', settings.backgroundColor);           
                  $this.find('.errorDisplayShortMessage').text(shortMessage);
                  $this.find('.errorDisplay').show();
                  $this.find('.errorDisplayRetriever').css('background-color', settings.indicatorColor);
                  
               if(settings.displayTime != -1){   
                  $this.find('.errorDisplay').slideUp(settings.displayTime, function(){
                      $this.find('.errorDisplayRetriever').show();
                  });                              
              }
                
               else{                   
                   $this.find('.errorDisplayOptions').show();
                   $this.find('.errorDisplay').show();
                 }
                
                $(data.detailDisplayList).append($('<li>'+fullMessage+'</li>').css('color', settings.fontColor));
                
                $this.find('.errorDisplayRetriever').hover(function(event) {
                    event.preventDefault();                 
                    $this.find('.errorDisplayOptions').hide();
                    $this.find('.errorDisplayShortMessage').text(shortMessage).css('color', settings.fontColor);                        
                    $this.find('.errorDisplay').slideDown(function(){
                      $this.find('.errorDisplayOptions').show();
                      $this.find('.errorDisplay').mouseleave(function(event){
                        event.preventDefault(); 
                        $this.find('.errorDisplayOptions').hide();
                        $this.find('.errorDisplay').slideUp(settings.displayTime, function(){
                            $this.find('.errorDisplayRetriever').show();
                        });                     
                      });     
                    });                   
                    $this.find('.errorDisplayRetriever').hide();
                });
            });

        } // displayError() method


    };

    $.fn.errorDisplay = function( method ) {
        if ( methods[method] ) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.errorDisplay' );
            return null;
        }    
    };

}(jQuery));
jQuery('head').append(jQuery('<style type="text/css">.errorDisplay { font-family: Helvetica, sans-serif; color: #32446B; background-color: white; text-align: left; font-size: 12px; line-height: 12px; height: 45px; position: absolute; bottom: 0px; left: 0px; width: inherit; width: expression(this.parentNode.currentStyle[\'width\']); border: solid; border-color: #A9BADE; border-style: ridge; display: none; } .errorDisplayRetriever{ height: 8px; background-color: #ff0000; border-top-right-radius: 10px; width: 8px; position: absolute; bottom: 0px; left: 0px; display: none; } .errorDisplayShortMessage{ overflow-x: hidden; overflow-y: hidden; white-space: nowrap; position: absolute; bottom: 0px; left: 0px; width: 95%; margin-top: 20px; margin-left: 10px; margin-bottom: 5px; } .errorDisplayXButton { text-decoration: none; font-size: 15px; margin-top: 2px; position: absolute; right: 3px; top: 0px; color: #4D68A3; } .errorDisplayDetailsButton { margin-left: 10px; margin-right: 10px; position: relative; } .errorDisplayDetails{ position: fixed; top: 25%; height: 100px; width: 75%; text-align: left; border: solid; border-color: #A9BADE; border-style: ridge; background-color: white; display: none; } .errorDisplayFullMessageArea { font-family: Helvetica, sans-serif; font-size: .833em; color: #32446B; height: 80px; width: inherit; width: expression(this.parentNode.currentStyle[\'width\']); position: fixed; margin-top: 15px; } .errorDisplayFullMessageList { overflow: auto; white-space: nowrap; height: 80px; margin-top: 5px; } .errorDisplayOptions{ background-color: #FFFFFF; display: inline; } </style>'));

},{}],4:[function(require,module,exports){
/**
 * Attr
 * 
 * Creates an encapsulated, chainable attribute that are validated by 
 * user-specified validation functions and can be attached to an arbitrary
 * JavaScript object. They can also call user-specified listeners upon being
 * accessed or changed.
 *
 * Jermaine models hold and manipulate Attr (and AttrList) objects until they
 * are attached to an object.
 */

/*!
 *
 * Notes and ToDos:
 * + what about isNotGreaterThan()?, isNotLessThan()?  Or, better still: a
 *   general 'not' operator, as in jasmine?
 *
 * + Attr should be decoupled from AttrList, see the clone() method
 *
 * + See issue 24 on github
 */
"use strict";
 
var Attr = function (name) {
    var AttrList = require('./attr_list.js'),
        Validator = require('./validator.js');

    var validators = [],
        that = this,
        errorMessage = "invalid setter call for " + name,
        defaultValueOrFunction,
        i,
        prop,
        addValidator,
        immutable = false,
        validator,
        listeners = {};

    // check for errors with constructor parameters
    if (name === undefined || typeof(name) !== 'string') {
        throw new Error("Attr: constructor requires a name parameter " +
                        "which must be a string");
    }

    // set up the validator that combines all validators
    validator = function (thingBeingValidated) {
        for (i = 0; i < validators.length; ++i) {
            validators[i](thingBeingValidated);
        }
        return true;
    };


    ////////////////////////////////////////////////////////////////////////
    /////////////////////////// MODIFIERS //////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    /**
     * Validate this attribute with the given validator. This also allows
     * this.message to be overridden to specify the error message on
     * validation failure.
     *
     * Examples:
     *
     *     age.validatesWith(function (age) {
     *         this.message = "age must be between 18 and 99, " + age +
     *                        " fails.";
     *         return age >= 18 && age <= 99;
     *     });
     *
     *     name.validatesWith(function (name) {
     *         this.message = "name must be a string and contain at least" +
     *                        " 3 letters, " + name + " fails.";
     *         return typeof(name) === "string && name.length >= 3;
     *     });
     *
     *
     * @param {Function} returns true if the argument passes validation 
     */
    this.validatesWith = function (v) {
        if (typeof(v) === 'function') {
            validators.push(new Validator(v));
            return this;
        } else {
            throw new Error("Attr: validator must be a function");
        }
    };

    /**
     * Assign a default value to all attributes of this type. The default
     * value may be an explicit value or object, or it may be a function
     * that returns a default value.
     *
     * Examples:
     *
     * @param {value} the explicit default value, or a function that
     *                returns the default value
     */
    this.defaultsTo = function (value) {
        defaultValueOrFunction = value;
        return this;
    };

    /**
     * Make this attribute read-only. If a setter is called on this
     * attribute, it will throw an error
     *
     * Examples:
     */
    this.isReadOnly = function () {
        immutable = true;
        return this;
    };

    /**
     * Make this attribute writable. Note that this is the default for all 
     * attributes, but this may be called if an attribute has been set to
     * read only and then needs to be changed back
     *
     * Examples:
     */
    this.isWritable = function () {
        immutable = false;
        return this;
    };

    /**
     * Sets up a listener for 'sets' or 'gets' to this attribute. It throws
     * an error if the event is not "set" or "get", and if a setter is
     * already set up for the event, it overrides it.
     *
     * Examples:
     *
     * @param {event} String that can only be "set" or "get"
     * @param {listener} Function that is called when the event occurs
     */
    this.on = function (event, listener) {
        if (event !== "set" && event !== "get") {
            throw new Error("Attr: first argument to the 'on' method " +
                            "should be 'set' or 'get'");
        } else if (typeof(listener) !== "function") {
            throw new Error("Attr: second argument to the 'on' method " +
                            "should be a function");
        } else {
            listeners[event] = listener;
        }
    };

    ////////////////////////////////////////////////////////////////////////
    /////////////////////////// END MODIFIERS //////////////////////////////
    ////////////////////////////////////////////////////////////////////////



    ////////////////////////////////////////////////////////////////////////
    /////////////////////// GETTERS ////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    /**
     * Returns the name of this attribute
     */
    this.name = function () {
        return name;
    };

    /**
     * Returns a function that combines all of the validators into
     * a single function that returns true or false.
     */
    this.validator = function () {
        return validator;
    };

    ////////////////////////////////////////////////////////////////////////
    /////////////////////// END GETTERS ////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////



    ////////////////////////////////////////////////////////////////////////
    /////////////////////// SYNTACTIC SUGAR ////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    /**
     * An alias for this object, for readability when calling multiple
     * modifiers
     *
     * Examples:
     */
    this.and = this;

    /**
     * An alias for this object, for readability.
     *
     * Examples:
     */
    this.which = this;

    /**
     * An alias for isReadOnly
     */
    this.isImmutable = this.isReadOnly;

    /**
     * An alias for isWritable
     */
    this.isMutable = this.isWritable;

    ////////////////////////////////////////////////////////////////////////
    /////////////////////// END SYNTACTIC SUGAR ////////////////////////////
    ////////////////////////////////////////////////////////////////////////



    ////////////////////////////////////////////////////////////////////////
    /////////////////////// UTILITIES //////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    /**
     * Returns an attribute with the same modifiers, defaultValue, and
     * validators. This is used in Jermaine's approach to inheritance.
     *
     * Examples:
     */
    this.clone = function () {
        var result,
            i;

        // set the result to the default attribute or attribute list
        // TODO: figure out how to make this work without explicitly
        //       knowing about AttrList so it can be decoupled from this
        //       code
        result = this instanceof AttrList?new AttrList(name):new Attr(name);

        // add this attributes validators to the new attribute
        for (i = 0; i < validators.length; ++i) {
            result.validatesWith(validators[i]);
        }

        // set up the same default for the new attribute
        result.defaultsTo(defaultValueOrFunction);

        // if the this attr is immutable, the cloned attr should also be
        // immutable
        if (immutable) {
            result.isImmutable();
        }

        return result;
    };

    /**
     * This attaches the attribute to a concrete object. It adds the
     * getter/setter function to the object, and captures the actual
     * value of the attribute in a closure.
     *
     * The resulting getter/setter calls all validators on the parameter
     * and calls the appropriate listener on this attribute. It also
     * returns the object itself so that attribute setters can be chained.
     *
     * Examples:
     *
     * @param {obj} the object to which this attribute will be attached
     */
    this.addTo = function (obj) {
        var attribute,
            listener,
            defaultValue;

        if (!obj || typeof(obj) !== 'object') {
            throw new Error("Attr: addAttr method requires an object " +
                            "parameter");
        }

        // This is the attribute getter/setter method that gets addded to
        // the object
        obj[name] = function (newValue) {
            var preValue;

            if (newValue !== undefined) {
                // setter
                if (immutable && attribute !== undefined) {
                    throw new Error("cannot set the immutable property " +
                                    name + " after it has been set");
                } else if (!validator(newValue)) {
                    throw new Error(errorMessage);
                } else {
                    // get the oldValue
                    preValue = attribute;

                    // first set the value
                    attribute = newValue;

                    // call the set listener
                    if (listeners.set !== undefined) {
                        listeners.set.call(obj, newValue, preValue);
                    }
                }
                return obj;
            } else {
                // call the get listener
                if (listeners.get !== undefined) {
                    listeners.get.call(obj, attribute);
                }
                return attribute;
            }
        };


        // assign the default value, depends on whether it is a function
        // or an explicit value
        defaultValue = typeof(defaultValueOrFunction) === 'function'?
            defaultValueOrFunction():
            defaultValueOrFunction;

        // call the setter with the defaultValue upon attaching it to the
        // object
        if (defaultValue !== undefined && validator(defaultValue)) {
            obj[name](defaultValue);
        } else if (defaultValue !== undefined && !validator(defaultValue)) {
            throw new Error("Attr: Default value of " + defaultValue +
                            " does not pass validation for " + name);
        }
    };

    ////////////////////////////////////////////////////////////////////////
    /////////////////////// END UTILITIES //////////////////////////////////
    ////////////////////////////////////////////////////////////////////////



    ////////////////////////////////////////////////////////////////////////
    /////////////////////// VALIDATOR RELATED //////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    // add a single validator object to the attribute
    addValidator = function (name) {
        that[name] = function (param) {
            validators.push(Validator.getValidator(name)(param));
            return that;
        };
    };

    // the Validator object contains several default validators
    // that need to be attached to all Attrs
    for (i = 0; i < Validator.validators().length; ++i) {
        addValidator(Validator.validators()[i]);
    }

    ////////////////////////////////////////////////////////////////////////
    /////////////////////// END VALIDATOR RELATED //////////////////////////
    ////////////////////////////////////////////////////////////////////////
};

module.exports = Attr;

},{"./attr_list.js":5,"./validator.js":8}],5:[function(require,module,exports){
"use strict";

var Attr = require('./attr.js');

var AttrList = function(name) {
    var that = this,
        listeners = {};


    //this is where the inheritance happens now
    Attr.call(this, name);

    var delegate = function (obj, func) {
        return function () { return obj[func].apply(obj, arguments); };
    };

    //syntactic sugar to keep things grammatically correct
    this.validateWith = this.validatesWith;

    //disable defaultsTo and isImmutable until we figure out how to make it make sense
    this.defaultsTo = function () {
        //no op
    };

    this.isImmutable = function () {
        //no op
    };

    this.isMutable = function () {
        //no op
    };

    this.eachOfWhich = this;

    this.on = function (event, listener) {
        if (event !== "add") {
            throw new Error("AttrList: 'on' only responds to 'add' event");
        }

        if (typeof(listener) !== "function") {
            throw new Error("AttrList: 'on' requires a listener function as the second parameter");
        }

        listeners[event] = listener;
    };


    this.addTo = function (obj) {
        var prop,
            arr = [],
            actualList = {};
        if(!obj || typeof(obj) !== 'object') {
            throw new Error("AttrList: addTo method requires an object parameter");                
        } else {
            actualList.pop = delegate(arr, "pop");
            
            actualList.add = function (item) {
                if ((that.validator())(item)) {
                    arr.push(item);
                    if (listeners.add !== undefined) {
                        //listeners.add.call();
                        listeners.add.call(obj, item, actualList.size());
                    }
                    return this;         
                } else {
                    throw new Error(that.errorMessage());
                }
            };

            actualList.replace = function (index, obj) {
                if ((typeof(index) !== 'number') || (parseInt(index, 10) !== index)) {
                    throw new Error("AttrList: replace method requires index parameter to be an integer");
                }

                if (index < 0 || index >= this.size()) {
                    throw new Error("AttrList: replace method index parameter out of bounds");
                }

                if (!(that.validator())(obj)) {
                    throw new Error(that.errorMessage());
                }

                arr[index] = obj;
                return this;
            };

            actualList.at = function (index) {
                if (index < 0 || index >= this.size()) {
                    throw new Error("AttrList: Index out of bounds");
                }
                return arr[index];
            };

            //to keep things more java-y
            actualList.get = actualList.at;

            actualList.size = function () {
                return arr.length;
            };

            actualList.toJSON = function (JSONreps) {
                var result = [], 
                    i, j;

                //check to make sure the current list is not in JSONreps
                if (JSONreps !== undefined) {
                    for (i = 0;i < JSONreps.length; ++i) {
                        if (JSONreps[i].object === this) {
                            result = JSONreps[i].JSONrep;
                        }
                    }
                }
                
                for (i = 0; i < arr.length; ++i) {
                    if (arr[i].toJSON) {
                        result.push(arr[i].toJSON(JSONreps));
                    } else {
                        result.push(arr[i]);
                    }
                }
                return result;
            };

            obj[name] = function () {
                return actualList;
            };
        }
    };
};

// //this needs to stay if we're going to use instanceof
// //but note we override all of the methods via delegation
// //so it's not doing anything except for making an AttrList
// //an instance of Attr
//AttrList.prototype = new Attr(name);
AttrList.prototype = new Attr("???");

module.exports = AttrList;

},{"./attr.js":4}],6:[function(require,module,exports){
"use strict";

var Method = function (name, method) {
    if (!name || typeof(name) !== "string") { 
        throw new Error("Method: constructor requires a name parameter which must be a string");
    } else if (!method || typeof(method) !== "function") {
        throw new Error("Method: second parameter must be a function");
    }
    
    this.addTo = function (obj) {
        if (!obj || typeof(obj) !== 'object') {
            throw new Error("Method: addTo method requires an object parameter");
        }
        
        obj[name] = method;
    };
};

module.exports = Method;

},{}],7:[function(require,module,exports){
"use strict";

require('../util/index_of.js');

var models = {};

/**
 * this function return a model associated with a name
 */
var getModel = function (name) {
    if (typeof(name) !== "string") {
        throw new Error("Jermaine: argument to getModel must be a string");
    }

    if (models[name] === undefined) {
        throw new Error("No model by the name of " + name + " found");
    } else {
        return models[name];
    }
};

/**
 * this function returns an array of all model names stored by
 * jermaine
 */
var getModels = function (name) {
    var model,
        result = [];
    
    for (model in models) {
        result.push(model);
    }
    return result;
};

/**
 * This is the model constructor
 */

var Model = function (specification) {
    var methods = {},
        attributes = {},
        pattern,
        modelName,
        modified = true,
        requiredConstructorArgs = [],
        optionalConstructorArgs = [],
        parents = [],
        Method = require('./method.js'),
        Attr = require('./attr.js'),
        AttrList = require('./attr_list.js'),
        EventEmitter = require('../util/event_emitter.js'),
        property,
        listProperties,
        updateConstructor,
        isImmutable,
        initializer = function () {},
        constructor = function () {},
        model = function () {
            if (modified) {
                //validate the model if it has been modified
                model.validate();
                updateConstructor();
            }
            return constructor.apply(this, arguments);
        };

    if (arguments.length === 1) {
        if (typeof(specification) === "string") {
            modelName = specification;
            specification = undefined;
        }
    }

    if (arguments.length > 1) {
        modelName = specification;
        specification = arguments[arguments.length-1];
    }

    //handle specification function
    if (specification && typeof(specification) === "function") {
        model = new Model(modelName);
        specification.call(model);
        return model;
    } else if (specification) {
        throw new Error("Model: specification parameter must be a function");
    }

    //handle model name
    if (modelName !== undefined && typeof(modelName) === "string") {
        models[modelName] = model;
    } else if (modelName !== undefined) {
        throw new Error("Model: model name must be a string");
    }

    
    /********** BEGIN PRIVATE METHODS ****************/
    /* private method that abstracts hasA/hasMany */
    var hasAProperty = function (type, name) {
        var Property,
            methodName,
            attribute;

        //Property is one of Attr or AttrList
        Property = type==="Attr"?Attr:AttrList;

        //methodName is either hasA or hasMany
        methodName = type==="Attr"?"hasA":"hasMany";

        modified = true;
        
        if (typeof(name) === 'string') {
            attribute = new Property(name);
            attributes[name] = attribute;
            return attribute;
        } else {
            throw new Error("Model: " + methodName + " parameter must be a string");
        }
    };

    /* private method that abstracts attribute/method */
    property = function (type, name) {
        var result;

        if (typeof(name) !== "string") {
            throw new Error("Model: expected string argument to " + type + " method, but recieved " + name);
        }

        result = type==="attribute" ? attributes[name] : methods[name];

        if (result === undefined) {
            throw new Error("Model: " + type + " " + name  + " does not exist!");
        }

        return result;
    };

    /* private method that abstracts attributes/methods */
    listProperties = function (type) {
        var i,
            list = [],
            properties = type==="attributes"?attributes:methods;

        for (i in properties) {
            if (properties.hasOwnProperty(i)) {
                list.push(i);
            }
        }

        return list;
    };

    /* private function that updates the constructor */
    updateConstructor = function () {
        constructor = function () {
            var i, j,
                err,
                attribute,
                attributeList = model.attributes(), 
                methodList = model.methods(), 
                emitter = new EventEmitter(),
                attr,
                attrChangeListeners = {},
                changeHandler,
                addProperties,
                that = this;

            if (!(this instanceof model)) {
                if (arguments.length > 0) {
                    //bad form, but hopefully temporary
                    /*jshint newcap:false */
                    return new model(arguments);
                } else {
                    //bad form, but hopefully temporary
                    /*jshint newcap:false */
                    return new model();
                }
                //throw new Error("Model: instances must be created using the new operator");
            }


            ////////////////////////////////////////////////////////////////
            ////////////// PUBLIC API FOR ALL INSTANCES ////////////////////
            ////////////////////////////////////////////////////////////////

            // this is a method associated with unit test
            // it("should not increment the listeners associated with the last object created"
            // it has been removed now that the bug has been fixed
            /*this.attrChangeListeners = function () {
             return attrChangeListeners;
             };*/

            /**
             * Returns the EventEmitter associated with this instance.
             *
             */
            this.emitter = function () {
                return emitter;
            };

            /**
             * Wrapper methods added to the internal EventEmitter object
             * 
             */

            this.emitter().removeJermaineChangeListener = function (attrName, obj) {
                if (typeof(attrName) !== "string") {
                    throw new Error("attrName must be a string");
                } else if (typeof(obj) !== "object" || obj.toJSON === undefined ||
                           obj.emitter === undefined) {
                    throw new Error("obj must be a jermaine object");
                } else {
                    obj.emitter().removeListener("change", attrChangeListeners[attrName]);
                }
            };

            this.emitter().addJermaineChangeListener = function (attrName, obj) {
                if (typeof(attrName) !== "string") {
                    throw new Error("attrName must be a string");
                } else if (typeof(obj) !== "object" || obj.toJSON === undefined ||
                           obj.emitter === undefined) {
                    throw new Error("obj must be a jermaine object");
                } else {
                    if (attrChangeListeners[attrName] === undefined) {
                        attrChangeListeners[attrName] = function (data) {
                            var newData = [],
                                emit = true;
                            
                            for (i = 0; i < data.length && emit === true; ++i) {
                                newData.push(data[i]);
                                if (data[i].origin === that) {
                                    emit = false;
                                }
                            }
                            
                            if (emit) {
                                newData.push({key:attrName, origin:that});
                                that.emit("change", newData);
                            }
                        };
                        
                    }
                    obj.emitter().on("change", attrChangeListeners[attrName]);
                }
            };


            /**
             * Registers a listener for this instance's changes.
             *
             */
            this.on = this.emitter().on;

            /**
             * Emits an event
             */
            this.emit = this.emitter().emit;

            /**
             * Returns a JSON representation of this instance.
             *
             */
            this.toJSON = function (JSONreps) {
                var attributeValue,
                    i, j,
                    thisJSONrep = {},
                    attributeJSONrep;

                if (JSONreps === undefined) {
                    // first call
                    JSONreps = [];
                    JSONreps.push({object:this, JSONrep:thisJSONrep});
                } else if (typeof(JSONreps) !== "object") {
                    // error condition 
                    throw new Error("Instance: toJSON should not take a parameter (unless called recursively)");
                } else {
                    // find the current JSON representation of this object, if it exists
                    for (i = 0; i < JSONreps.length; ++i) {
                        if (JSONreps[i].object === this) {
                            thisJSONrep = JSONreps[i].JSONrep;
                        }
                    }
                }

                for (i = 0; i < attributeList.length; ++i) {
                    attributeJSONrep = null;
                    // get the attribute
                    attributeValue = this[attributeList[i]]();
                    
                    // find the current JSON representation for the attribute, if it exists
                    for (j = 0; j < JSONreps.length; ++j) {
                        if (JSONreps[j].object === attributeValue) {
                            attributeJSONrep = JSONreps[j].JSONrep;
                        }
                    }

                    if (attributeValue !== undefined && attributeValue !== null && attributeValue.toJSON !== undefined && attributeJSONrep === null) {
                        // create a new entry for the attribute
                        attributeJSONrep = (attributes[attributeList[i]] instanceof AttrList)?[]:{};
                        JSONreps.push({object:attributeValue, JSONrep:attributeJSONrep});
                        JSONreps[JSONreps.length-1].JSONrep = attributeValue.toJSON(JSONreps);
                    }

                    // fill out the JSON representation for this object
                    if(attributeJSONrep === null) {
                        thisJSONrep[attributeList[i]] = attributeValue;
                    } else {
                        thisJSONrep[attributeList[i]] = attributeJSONrep;
                    }
                }
                return thisJSONrep;
            };

            /**
             * Returns a String representation of this instance
             *
             */
            this.toString = (pattern !== undefined)?pattern:function () {
                return "Jermaine Model Instance";
            };


            ////////////////////////////////////////////////////////////////
            ////////////// END PUBLIC API FOR ALL INSTANCES ////////////////
            ////////////////////////////////////////////////////////////////


            /**
             * This is a private method that sets up handling for the setter
             * It attaches a change listener on new objects
             * and it removes the change listener from old objects
             */
            changeHandler = function (attr) {
                if (!(attr instanceof AttrList)) {
                    //when set handler is called, this should be the current object
                    attr.on("set", function (newValue, preValue) {
                        // if preValue is a model instance, we need to remove the listener from it
                        if (preValue !== undefined && preValue !== null && preValue.on !== undefined &&
                            preValue.toJSON !== undefined && preValue.emitter !== undefined) {
                            // we now assume preValue is a model instance
                            
                            // sanity check 1
                            if (preValue.emitter().listeners("change").length < 1) {
                                throw new Error("preValue should always have a listener defined if it is a model");
                            }
                            
                            this.emitter().removeJermaineChangeListener(attr.name(), preValue);
                        }
                        
                        // if newValue is a model instance, we need to attach a listener to it
                        if (newValue !== undefined && newValue !== null && newValue.on !== undefined &&
                            newValue.toJSON !== undefined && newValue.emitter !== undefined) {
                            // we now assume newValue is a model instance
                            
                            // attach a listener
                            this.emitter().addJermaineChangeListener(attr.name(), newValue);
                        }

                        // finally emit that a change has happened
                        this.emit("change", [{key:attr.name(), value:newValue, origin:this}]);
                    });
                } else {
                    attr.on("add", function (newValue, newSize) {
                        this.emit("change", [{action:"add", key:attr.name(), value:newValue, origin:this}]);
                    });
                }
            };

            //set up event handling for sub objects
            for (i = 0; i < attributeList.length;  ++i) {
                attr = model.attribute(attributeList[i]);

                // temporarily not adding handlers to attr lists
                // until we get the bugs sorted out
                // see model test "should not add change listeners to attr list"
                //if (!(attr instanceof AttrList)) {
                changeHandler.call(this, attr);
                //}
            }


            // add all of the attributes and the methods to the object
            for (i = 0; i < attributeList.length + methodList.length; ++i)  {
                if (i < attributeList.length) {
                    //if the object is immutable, all attributes should be immutable
                    if (isImmutable) {
                        model.attribute(attributeList[i]).isImmutable();
                    }
                    model.attribute(attributeList[i]).addTo(this);
                } else {
                    model.method(methodList[i-attributeList.length]).addTo(this);
                }
            }

            // build the object using the constructor arguments
            if(arguments.length > 0) {
                if (arguments.length < requiredConstructorArgs.length) {
                    //construct and throw error
                    err = "Constructor requires ";
                    for(i = 0; i < requiredConstructorArgs.length; ++i) {
                        err += requiredConstructorArgs[i];
                        err += i===requiredConstructorArgs.length-1?"":", ";
                    }
                    err += " to be specified";
                    throw new Error(err);
                } if (arguments.length > requiredConstructorArgs.length + optionalConstructorArgs.length) {
                    throw new Error("Too many arguments to constructor. Expected " + requiredConstructorArgs.length + " required arguments and " +
                                    optionalConstructorArgs.length + " optional arguments");
                }
                else {
                    for (i = 0; i < arguments.length; ++i) {
                        attribute = i < requiredConstructorArgs.length?
                            requiredConstructorArgs[i]:
                            optionalConstructorArgs[i-requiredConstructorArgs.length];

                        if (model.attribute(attribute) instanceof AttrList) {
                            //make sure that arguments[i] is an array
                            if (Object.prototype.toString.call(arguments[i]) !== "[object Array]") {
                                throw new Error("Model: Constructor requires 'names' attribute to be set with an Array");
                            } else {
                                //iterate over the array adding the elements
                                for (j = 0; j < arguments[i].length; ++j) {
                                    this[attribute]().add(arguments[i][j]);
                                }
                            }
                        } else {
                            //go ahead and set it like normal
                            this[attribute](arguments[i]);
                        }
                    }
                }
            }

            // finally, call the initializer
            initializer.call(this);
        };
    };
    /*********** END PRIVATE METHODS **************/


    /*********** BEGIN PUBLIC API *****************/
    model.hasA = function (attr) {
        return hasAProperty("Attr", attr);
    };
    
    model.hasAn = model.hasA;
    model.hasSome = model.hasA;
    
    model.hasMany = function (attrs) {
        return hasAProperty("AttrList", attrs);
    };

    model.isA = function (parent) {
        var i,
            parentAttributes,
            parentMethods,
            isAModel;

        modified = true;

        //checks to make sure a potentialModel has all attributes of a model
        isAModel = function (potentialModel) {
            var i,
                M = new Model();
            for (i in M) {
                if (M.hasOwnProperty(i) && typeof(potentialModel[i]) !== typeof(M[i])) {
                    return false;
                }
            }
            return true;
        };

        //confirm parent is a model via duck-typing
        if (typeof (parent) !== "function" || !isAModel(parent)) {
            throw new Error("Model: parameter sent to isA function must be a Model");
        }

        //only allow single inheritance for now
        if (parents.length === 0) {
            parents.push(parent);
        } else {
            throw new Error("Model: Model only supports single inheritance at this time");
        }

        //add attributes and methods to current model
        parentAttributes = parents[0].attributes();
        for (i = 0; i < parentAttributes.length; ++i) {
            if (attributes[parentAttributes[i]] === undefined) {
                attributes[parentAttributes[i]] = parents[0].attribute(parentAttributes[i]).clone();
                //subclass attributes are mutable by default
                attributes[parentAttributes[i]].isMutable();
            }
        }

        parentMethods = parents[0].methods();
        for (i = 0; i < parentMethods.length; ++i) {
            if (methods[parentMethods[i]] === undefined) {
                methods[parentMethods[i]] = parents[0].method(parentMethods[i]);
            }
        }            

        for (i = 0; i < parents.length; i++) {
            model.prototype = new parents[i]();
        }
    };

    model.isAn = model.isA;

    model.parent = function () {
        return parents[0].apply(this, arguments);
    };

    model.attribute = function (attr) {
        return property("attribute", attr);
    };

    model.attributes = function () {
        return listProperties("attributes");
    };

    model.method = function (m) {
        return property("method", m);
    };
    
    model.methods = function () {
        return listProperties("methods");
    };

    model.isBuiltWith = function () {
        var optionalParamFlag = false,
            i;

        modified = true;
        requiredConstructorArgs = [];
        optionalConstructorArgs = [];

        for (i = 0; i < arguments.length; ++i) {
            if (typeof(arguments[i]) === "string" && arguments[i].charAt(0) !== '%') {
                //in required parms
                if (optionalParamFlag) {
                    //throw error
                    throw new Error("Model: isBuiltWith requires parameters preceded with a % to be the final parameters before the optional function");
                } else {
                    //insert into required array
                    requiredConstructorArgs.push(arguments[i]);
                }
            } else if(typeof(arguments[i]) === "string" && arguments[i].charAt(0) === '%') {
                //in optional parms
                optionalParamFlag = true;
                //insert into optional array
                optionalConstructorArgs.push(arguments[i].slice(1));
            } else if(typeof(arguments[i]) === "function" && i === arguments.length - 1) {
                //init function
                initializer = arguments[i];
            } else {
                throw new Error("Model: isBuiltWith parameters must be strings except for a function as the optional final parameter");
            }
        }
    };
    
    model.isImmutable = function () {
        isImmutable = true;
    };

    model.looksLike = function (p) {
        modified = true;
        pattern = p;
    };

    model.respondsTo = function (methodName, methodBody) {
        var m = new Method(methodName, methodBody);
        modified = true;
        methods[methodName] = m;
    };
    
    model.validate = function () {
        var i,
            attributes = this.attributes(),
            methods = this.methods();

        //check to make sure that isBuiltWith has actual attributes
        for (i = 0; i < requiredConstructorArgs.length; ++i) {
            try {
                this.attribute(requiredConstructorArgs[i]);
            } catch (e) {
                throw new Error(requiredConstructorArgs[i] + ", specified in the isBuiltWith method, is not an attribute");
            }
        }

        for (i = 0; i < optionalConstructorArgs.length; ++i) {
            try {
                this.attribute(optionalConstructorArgs[i]);
            } catch (e) {
                throw new Error(optionalConstructorArgs[i] + ", specified in the isBuiltWith method, is not an attribute");
            }
        }

        //check for method/attribute collisions
        for (i = 0; i < attributes.length; i++) {
            if (methods.indexOf(attributes[i]) > -1) {
                throw new Error("Model: invalid model specification to " + attributes[i] + " being both an attribute and method");
            }
        }

        //check to make sure that all attributes are requiredConstructorArgs if the object is immutable
        if (isImmutable) {
            for (i = 0; i < attributes.length; i++) {
                if (requiredConstructorArgs.indexOf(attributes[i]) < 0) {
                    throw new Error("immutable objects must have all attributes required in a call to isBuiltWith");
                }
            }
        }

        //set modifiedSinceLastValidation to false
        modified = false;
    };
    /************** END PUBLIC API ****************/
    
    //here we are returning our model object
    //which is a function with a bunch of methods that
    //manipulate how the function behaves
    return model;
};

//ns.getModel = getModel;
//ns.getModels = getModels;

Model.getModel = getModel;
Model.getModels = getModels;

module.exports = Model;



},{"../util/event_emitter.js":10,"../util/index_of.js":11,"./attr.js":4,"./attr_list.js":5,"./method.js":6}],8:[function(require,module,exports){
/**
 * Validator
 * 
 * Creates a named function that can be attached to attribute for validation.
 * The Validator function allows for customization of the thrown error message.
 *
 * This source file also handles all default validators that come packaged with
 * Jermaine. This includes isA, isOneOf, isGreaterThan, isLessThan, etc.
 *
 * Simple example:
 *
 * isGreaterThan = new Validator(function (number) {
 *     //this.message points to the error message
 *     //that will be thrown
 *     this.message = "Validation Error: " + 
 *                    this.param + " should be greater than " + number;
 *
 *     //this.param points to the actual parameter sent to the validator
 *     //return true if the validation passes, false otherwise
 *     return this.param > number;
 * });
 *
 * Later, a validator can be attached to the attribute object.
 *
 * Attr.isGreaterThan = isGreaterThan;
 *
 * and can be used when creating attributes:
 *
 * var age = new Attr("age").which.isGreaterThan(0);
 *
 */

"use strict";

require('../util/index_of.js');

var Model = require('./model.js');

var validators = {};  //the set of static validators

/**
 * Validator 'Constructor'
 *
 * This simply returns a validation function that handles the custom error
 * message and can be attached to an attribute. So it's not really
 * technically a constructor. This is only important to know so that you
 * don't try something like this:
 *
 * var v = new Validator( ... );
 * 
 * //this will always fail, bc v is not an object
 * if (v instanceof Validator) { ... }
 * 
 * The spec function is just a specification for the validator. It allows
 * for a couple of things to be attached to "this" that will be used
 * in the return function. This includes "this.message" and "this.param".
 * The message is the error string that is thrown on failure and
 * this.param is the actual parameter that gets sent in to be validated.
 */
var Validator = function (spec) {
    // this is the actual function that is returned
    var validatorFunction = function (arg) {
        var result, 
            resultObject = {},
            errorMessage;

        // spec is called on the argument with 'this' pointing
        // to an empty object (resultObject),
        // note the validator will return either true or false
        result = spec.call(resultObject, arg);

        // if it's false, the parameter has failed validation
        if (!result) {
            // throw the error
            errorMessage = resultObject.message ||
                "validator failed with parameter " + arg;
            throw new Error(errorMessage);
        }
        return result;
    };

    // see? all that's being returned is a function
    // also note that since 'this' is never used,
    // we can call this constructor with or without 'new'
    return validatorFunction;
};

/**
 * This static function adds a named validator to the list of
 * validators. The second argument is a validation function
 * that simply returns a Validator function created as above.
 *
 * The nice thing about adding a Validator this way is that
 * you can actually validate the parameter sent to the validator!
 * Why might that be important? Well, consider the following:
 *
 * var isGreaterThanInteger = new Validator(function (val) {
 *     this.message = this.param + " should be greater than " + val;
 *     return this.param > val;
 * });
 *
 * Now we can call isGreaterThanNumber like this:
 *
 * isGreaterThanNumber(5)(6); // will pass validation
 * isGreaterThanNumber(5)(3); // will throw
 * isGreaterThanNumber("dog")(3); // ???
 *
 * So we need to confirm that the user sends in an integer as a parameter.
 * You might want to try something like this:
 *
 * var isGreaterThanInteger = new Validator(function (val) {
 *     if (typeof(val) !== "number") throw Error("Not cool!");
 *     this.message = this.param + " should be greater than " + val;
 *     return this.param > val;
 * });
 *
 * This will actually work on the example above:
 *
 * isGreaterThanNumber("dog")(3); // throws error now
 *
 * The problem is that with Jermaine, we create the validator
 * and then don't actually call it until an attribute is about to be
 * set. So, in other words:
 *
 * var a = new Attr("thing").which.isGreaterThanNumber("dog"); //no error (yet)
 *
 * will not cause an error until it's attached to an object and thing
 * is attempted to be set.
 *
 * So a temporary workaround is to validate the validator in the
 * addValidator function below. That's handled by the argValidator
 * validator. (Phew, this is getting really meta)
 *
 * I'm not sure this is the best solution. Seems like there should be
 * a way to validate the argument in the constructor function, but
 * that might require some rewiring that breaks multigraph. This is
 * the best I could come up with for now.
 *
 * @name The name of the validator for the attribute, must be a string
 *       or an error will be thrown
 *
 * @v The validator specification (returns a boolean)
 *    must be a function or an error will be thrown
 *
 * @argValidator optional function that checks the types of args sent
 *           to the validator, must be a function or an error will be thrown
 *
 * So an error will be thrown in the cases that "name" is not a string,
 * v is not a function, argValidator is not a function, or if the static
 * validator is already defined.
 */
Validator.addValidator = function (name, v, argValidator) {
    if (name === undefined || typeof(name) !== "string") {
        throw new Error("addValidator requires a name to be specified as the first parameter");
    }

    if (v === undefined || typeof(v) !== "function") {
        throw new Error("addValidator requires a function as the second parameter");
    }

    // optional third argument to validate the 
    // expected value that gets sent to the validator
    // for example, isA("number") works but isA("nmber")
    // doesn't work
    if (argValidator !== undefined && typeof(argValidator) !== "function") {
        throw new Error("addValidator third optional argument must be a "+
                        "function");
    }

    if (validators[name] === undefined) {
        validators[name] = function (expected) {
            if (argValidator !== undefined) {
                if (!argValidator(expected)) {
                    throw new Error ("Validator: Invalid argument for " +
                                     name + " validator");
                }
            }
            return new Validator(function (val) {
                var resultObject = {"actual":val, "param":val},
                    result = v.call(resultObject, expected);
                this.message = resultObject.message;
                return result;
            });
        };
    } else {
        throw new Error("Validator '" + name +"' already defined");
    }
};


/**
 * Get the built-in validator by its name.
 *
 * @name a string representing the name of the validator to return
 * 
 * throws an error if name is not a string
 */
Validator.getValidator = function (name) {
    var result;

    if (name === undefined) {
        throw new Error("Validator: getValidator method requires a string parameter");
    } else if (typeof (name) !== "string") {
        throw new Error("Validator: parameter to getValidator method must be a string");
    }

    result = validators[name];

    if (result === undefined) {
        throw new Error("Validator: '" + name + "' does not exist");
    }

    return result;
};



/**
 * return an array of of static validator names
 */
Validator.validators = function () {
    var prop,
        result = [];
    for (prop in validators) {
        if (validators.hasOwnProperty(prop)) {
            result.push(prop);
        }
    }

    return result;
};

/**
 * Built-In validators. Hopefully these are self-explanatory
 * Will document them more later.
 */
Validator.addValidator("isGreaterThan", function (val) {
    this.message = this.param + " should be greater than " + val;
    return this.param > val;
});

Validator.addValidator("isLessThan", function (val) {
    this.message = this.param + " should be less than " + val;
    return this.param < val;
});


// TODO: add array validation for val
Validator.addValidator("isOneOf", function (val) {
    this.message = this.param + " should be one of the set: " + val;
    return val.indexOf(this.param) > -1;
});

/**
 * This one is the only one that uses an argument validator. It confirms
 * that the argument is a primitive javascript type or a named Jermaine
 * model.
 */
Validator.addValidator("isA", function (val) {
    var types = ["string", "number", "boolean", "function", "object"],
        models = Model.getModels();
    if (typeof(val) === "string" && types.indexOf(val) > -1) {
        this.message = this.param + " should be a " + val;
        return typeof(this.param) === val;
    } else if (typeof(val) === "string" && models.indexOf(val) > -1) {
        this.message = "parameter should be an instance of " + val;
        return this.param instanceof Model.getModel(val);
    } else if (val === 'integer') {
        // special case for 'integer'; since javascript has no integer type,
        // just check for number type and check that it's numerically an int
        if (this.param.toString !== undefined)  {
            this.message = this.param.toString() + " should be an integer";
        } else {
            this.message = "parameter should be an integer";
        }
        return (typeof(this.param) === 'number') && (parseInt(this.param,10) === this.param);
    } /*else if (typeof(val) === "string") {
       throw new Error("Validator: isA accepts a string which is one of " + types);
       } else {
       throw new Error("Validator: isA only accepts a string for a primitive types for the time being");
       }*/
},
                       //argument validator
                       function (val) {
                           var typesAndModels = ["string", "number", "boolean", "function",
                                                 "object", "integer"].concat(Model.getModels());
                           return typesAndModels.indexOf(val) >= 0;
                       });


// grammatical alias for isA
validators.isAn = validators.isA;

module.exports = Validator;

},{"../util/index_of.js":11,"./model.js":7}],9:[function(require,module,exports){
require('./util/index_of.js');

var Model = require('./core/model.js');

module.exports = {
    'Attr'      : require('./core/attr.js'),
    'AttrList'  : require('./core/attr_list.js'),
    'Model'     : Model,
    'getModel'  : Model.getModel,
    'getModels' : Model.getModels,
    'Validator' : require('./core/validator.js'),
    'Method'    : require('./core/method.js'),
    'util'      : {
        'EventEmitter' : require('./util/event_emitter.js'),
        'namespace'    : require('./util/namespace.js')
    }
};

},{"./core/attr.js":4,"./core/attr_list.js":5,"./core/method.js":6,"./core/model.js":7,"./core/validator.js":8,"./util/event_emitter.js":10,"./util/index_of.js":11,"./util/namespace.js":12}],10:[function(require,module,exports){
"use strict";

require('./index_of.js');

var EventEmitter = function () {
    var that = this,
        listeners = {};

    //an registers event and a listener
    this.on = function (event, listener) {
        if (typeof(event) !== "string") {
            throw new Error("EventEmitter: first argument to 'on' should be a string");
        }
        if (typeof(listener) !== "function") {
            throw new Error("EventEmitter: second argument to 'on' should be a function");
        }
        if (!listeners[event]) {
            listeners[event] = [];
        }
        listeners[event].push(listener);
        return that;
    };

    //alias addListener
    this.addListener = this.on;
    
    this.once = function (event, listener) {
        var f = function () {
            listener(arguments);
            that.removeListener(event, f);
        };

        that.on(event, f);
        return that;
    };

    this.removeListener = function (event, listener) {
        var index;

        if (typeof(event) !== "string") {
            throw new Error("EventEmitter: first parameter to removeListener method must be a string representing an event");
        }
        if (typeof(listener) !== "function") {
            throw new Error("EventEmitter: second parameter must be a function to remove as an event listener");
        }
        if (listeners[event] === undefined || listeners[event].length === 0) {
            throw new Error("EventEmitter: there are no listeners registered for the '" + event + "' event");
        }

        index = listeners[event].indexOf(listener);

        if (index !== -1) {
            //remove it from the list
            listeners[event].splice(index,1);
        }

        return that;
    };

    this.removeAllListeners = function (event) {
        if (typeof(event) !== "string") {
            throw new Error("EventEmitter: parameter to removeAllListeners should be a string representing an event");
        }

        if (listeners[event] !== undefined) {
            listeners[event] = [];
        }
        
        return that;
    };
    
    this.setMaxListeners = function (number) {
        return that;
    };

    //get the listeners for an event
    this.listeners = function (event) {
        if (typeof(event) !== 'string') {
            throw new Error("EventEmitter: listeners method must be called with the name of an event");
        } else if (listeners[event] === undefined) {
            return [];
        }
        return listeners[event];
    };

    //execute each of the listeners in order with the specified arguments
    this.emit = function (event, data) {
        var i,
            params;


        if (arguments.length > 1) {
            params = [];
        }

        for (i = 1; i < arguments.length; ++i) {
            params.push(arguments[i]);
        }

        if (listeners[event] !== undefined) {
            for (i = 0; i < listeners[event].length; i=i+1) {
                listeners[event][i].apply(this, params);
            }
        }
    };

    return that;
}; //end EventEmitter

module.exports = EventEmitter;

},{"./index_of.js":11}],11:[function(require,module,exports){
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
        "use strict";
        if (this === null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (len === 0) {
            return -1;
        }
        var n = 0;
        if (arguments.length > 0) {
            n = Number(arguments[1]);
            if (n !== n) { // shortcut for verifying if it's NaN
                n = 0;
            } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
        }
        if (n >= len) {
            return -1;
        }
        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
        for (; k < len; k++) {
            if (k in t && t[k] === searchElement) {
                return k;
            }
        }
        return -1;
    };
}

module.exports = undefined;

},{}],12:[function(require,module,exports){
module.exports = function namespace (ns, aliases, func) {
    var nsRegExp = /^([a-zA-Z]+)(\.[a-zA-Z]*)*$/,
        nsArray,
        currentNS,
        i;

    //check to assure ns is a properly formatted namespace string
    if (ns.match(nsRegExp) === null || ns === "window") {
        throw new Error("namespace: " + ns + " is a malformed namespace string");
    }

    //check to assure that if alias is defined that func is defined
    if (aliases !== undefined && func === undefined) {
        if (typeof (aliases) === "function") {
            func = aliases;
            aliases = undefined;
        } else if (typeof (aliases) === "object") {
            throw new Error("namespace: if second argument exists, final function argument must exist");
        } else if (typeof (aliases) !== "object") {
            throw new Error("namespace: second argument must be an object of aliased local namespaces");
        }
    } else if (typeof (aliases) !== "object" && typeof (func) === "function") {
        throw new Error("namespace: second argument must be an object of aliased local namespaces");
    }

    //parse namespace string
    nsArray = ns.split(".");

    //set the root namespace to window (if it's not explictly stated)
    if (nsArray[0] === "window") {
        currentNS = window;
    } else {
        currentNS = (window[nsArray[0]] === undefined) ? window[nsArray[0]] = {} : window[nsArray[0]];
    }

    //confirm func is actually a function
    if (func !== undefined && typeof (func) !== "function") {
        throw new Error("namespace: last parameter must be a function that accepts a namespace parameter");
    }

    //build namespace
    for (i = 1; i < nsArray.length; i = i + 1) {
        if (currentNS[nsArray[i]] === undefined) {
            currentNS[nsArray[i]] = {};
        }
        currentNS = currentNS[nsArray[i]];
    }

    //namespaces.push(currentNS);
    //namespace = currentNS;

    //if the function was defined, but no aliases run it on the current namespace
    if (aliases === undefined && func) {
        func(currentNS);
    } else if (func) {
        for (i in aliases) {
            if (aliases.hasOwnProperty(i)) {
                aliases[i] = namespace(aliases[i]);
            }
        }
        func.call(aliases, currentNS);
    }

    //return namespace
    return currentNS;
};

},{}],13:[function(require,module,exports){
/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */

(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

if ($.event.fixHooks) {
    for ( var i=types.length; i; ) {
        $.event.fixHooks[ types[--i] ] = $.event.mouseHooks;
    }
}

$.event.special.mousewheel = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },
    
    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    mousewheel: function(fn) {
        return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
    },
    
    unmousewheel: function(fn) {
        return this.unbind("mousewheel", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "mousewheel";
    
    // Old school scrollwheel delta
    if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta/120; }
    if ( orgEvent.detail     ) { delta = -orgEvent.detail/3; }
    
    // New school multidimensional scroll (touchpads) deltas
    deltaY = delta;
    
    // Gecko
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }
    
    // Webkit
    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }
    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120; }
    
    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);
    
    return ($.event.dispatch || $.event.handle).apply(this, args);
}

})(jQuery);

},{}],14:[function(require,module,exports){
(function ($) {
    var defaults = {
        fullscreen : false,
        scale : false,
        defaultEventHandling : true,
        preopen : function () {},
        postopen : function () {},
        preclose : function () {},
        postclose : function () {},
        preresize : function () {},
        postresize : function () {}
    };

    var methods = {
        open : function () {
            var clone = this.clone(true),
                data = this.data("lightbox"),
                w, h;

            data.contents = clone;
            data.preopen.call(this);
            clone = data.contents; // data.contents might have been altered by data.preopen
            var cloneData = clone.data("lightbox");

            data.overlay = $("<div/>")
                .css({
                    "position"         : "fixed",
                    "left"             : "0px",
                    "top"              : "0px",
                    "height"           : "100%",
                    "min-height"       : "100%",
                    "width"            : "100%",
                    "z-index"          : "9999",
                    "background-color" : "black",
                    "opacity"          : "0.5"
                })
                .appendTo("body");

            data.box = $("<div/>")
                .css({
                    "position"         : "fixed",
                    "z-index"          : "9999"
                })
                .appendTo("body");
            

            data.box.append(clone);

            if (data.fullscreen === true) {
                w = window.innerWidth;
                h = window.innerHeight;
            } else {
                w = clone.width();
                h = clone.height();
                if (data.scale === true) {
                    var r = computeRatio(w, h);
                    w = parseInt(w * r, 10);
                    h = parseInt(h * r, 10);
                }
            }

            scaleElement(data.box, w, h);
            positionElement(data.box, w, h);

            scaleElement(clone, w, h);
            positionElement(clone, w, h);
            clone.css("position", "fixed")
                .css("z-index", 9999);

            data.box.append(
                $("<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NkY4OUE4QUE2MDEyMTFFMkFBMEM4Q0Y2RTlFNkI4QzEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NkY4OUE4QUI2MDEyMTFFMkFBMEM4Q0Y2RTlFNkI4QzEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2Rjg5QThBODYwMTIxMUUyQUEwQzhDRjZFOUU2QjhDMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2Rjg5QThBOTYwMTIxMUUyQUEwQzhDRjZFOUU2QjhDMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PvXC/ukAAAcjSURBVHjaxFlpTFVXEJ7HDrIIUkCRzYitQJQK/kBTxAop2EQhaqkEqjZqK9FGa+2Cf2pabdIlEbE0FEkTArFaF6CAKCCStG5BokXAglpUIkKqgn0KyNb5jve+PB9vfyyTfIF7373nzJkzZ76ZuYqRkRGyUKwYoYwQxqsMD4aj9FsPo4Nxg1HP6LR0Mhsz37NlxDNSGLHt7e2e9+/fpwcPHtDTp0/p+fPn4iFHR0eaOnUqTZ8+nQICAsjV1bWJb5cwChiN5kysMNHCsNwHjE+uXr3qe+nSJWpsbCSlUmnUyzNmzKDw8HCKiooiX1/fGr61l1E9XgonMjLPnDnjX1NTI6xpiURGRtLSpUspJCSklC8/YvwzVgo7M7Lr6+vTzp49S9evX6exlISEBEpOTsYWfcgotFRhX0ZFeXl52JEjR2i8JDg4mJYtWwZXyeTLjxnD5ig8m1F17NixgJKSEhpvsbGxoZSUFIqNjf2VL1MZQ6Yo7M34o7CwcPapU6doImXdunUUFxf3E/+bbqzCCFm1x48fjzpx4gRNhmzYsAGWxkHM0hb0NeWrioqKKFaYsJjJwOnTp6HH94zXDSkczth59OjRSVMWYCKi3NxcO9blZ4a1PqbL5AdtwFa6ZM6cOWRvb09WVlakUChU95uamlQMpynu7u4gCvEOIEtnZyd1dHRofaeqqopmzZoVydHjfb7M1aZwDLNWdGVlpV7/6u3tpSVLlgjKtbW1Vd338vKSt/IlsbOzE8w2c+ZMcnNzU73z5MkTOnToEOkLq0xSCHdf8L+/MAY1Fd6JCYeHh/Uq3NbWRq2trbR8+XJhOdlisCDyiWvXrr30/Pz588VvgYGB5OnpSdbWL3Y4MzOT9O0k5NatW3ThwoUgXnASX/6m7sNeSGYuXrxolI9hu27fvi1cYsqUKeTs7CyUx+n28PBQPRcUFERz584VOYSPjw+SH/FsbW0tMXMaNde5c+eg33uahy6JrWszMDAgLGwM8vPz6d69e9Tf3y8GgOW8vb1py5Yt4ncoFhERIRQFkLlhgTdv3hSuYOw8V65cwfBvMVzUFY5paGgwehDg0aNHxCwo/g4ODr4I4OyfsOiKFSsE/Pz8hHVhWbgO/H///v0mzQMjstJw/DfUFV7U3Nxscvipq6sjJEQ4QLLvI4KsWrVKWBd+CxcB7UI4AtHdu3dNnufGDeT/FCUfOieGX1dXF5lTfRQXFwtLQkH4s+zXcuiTla2urhan3hzBIllekxUO5BsKQ9FBlzx79owKCgrI399fuAQUhT/L0QACIsjLyyNzyzEp9w6SXcIVk5riV5qAQkg/u7u7aWhoaFTcRgh7/Pix2eNL4c9VtrCdHB0sEQz68OFDcnFxIScnJ9V9BwcHsQhLxpcikb1s4X5spSUWBiEsXLhQe8LNPr1t2zaxCHPHl9ixV1a4B4fE3EQFPsv5K02bNk0A16PKFmY65LnmzoFdYvlPdok2PuVwPGtzti0mJkZECeQKYDv1w6ZKsNlCWBQSJLCkqYJYztIqW7gPSoOlTF15aGioinrhFnJic/LkSVH+I3vDc3ALMN369euRgZk8DwzC8rc6cZznctskv0J2tnjx4lHU29LSIths3759In729fW9yAE4JuOd9PR0k304LCwMQ/yprnD1ggULTBoEPQX4JqyLyCBT765du8TvUDY7O1tQN6KQXGjCMBs3bjR6HrgYk1K/psLFCQkJ/RjQmC2CssjEoCz8VmazrKwsEdrk5y5fviyYsKenRxWfcSgTExPF7hgzF56T2lu96gp3Q2kcDEMrRsWBrg2UxRbLUYHrQCoqKhr1PFgQOTLISfZnhLitW7eK7M7QfPHxaOFRvraa7rukpCSD4YWrWeGzaPBhYiiANHPPnj0630M6CRfRTEW3b9+udz704djCaBqWayuR6vjElyUnJ799+PBhreEFHUhUG6BgHC45hCEh1xcSkezn5OTQvHnzVIuEIIpgx6RsbJTAgKji1TtBmn2JYMZfK1eudNBVHE6UrF27lnbs2IFy403GiK4yH8H5y7S0tEkt87ETrKxSau2OGGpof7t69eoYpVIZj1M/0YLqBAWA1M1sMabzgxW9y6zUsGnTpgm1LCIOiIVD7F5drVd93UsfRiUn3mEHDx4cd8siTIK616xZ8wM6/Ob2h90ZRRw1oqG0oT6CuRIdHU0HDhyAIp/DJS3twMPPv2Z8mpGRoSgrKxszRUHnaAts3ry5C01L9Xg7Ft84FjF+ZEYLRzkk9QvMbl7jYO3evRvxNY+Rwfh3PL4i4ZC+w/iMc9vw0tJStJJEc8SQ4ECBuZA/p6amDkitp28YJn00UVjwYTFCau3HcYEZCqXv3LkjEh18BkNuDFYDBaM/wSyK5OU843cGqLRrIr7T6ZJXpK+hwdKXUDcwLwPBv11KvpulYsEiGSuFJ0z+F2AAyCap34M2ukUAAAAASUVORK5CYII=\" alt=\"close\"/>")
                    .css({
                        "position" : "absolute",
                        "right"    : "-9px",
                        "top"      : "-8px",
                        "width"    : "44px",
                        "height"   : "44px",
                        "z-index"  : "10000"
                    })
                    .click(function () {
                        clone.lightbox("close");
                    })
            );

            cloneData.contentWidth = w;
            cloneData.contentHeight = h;
            cloneData.opened = true;
            cloneData.resizeHandler = function () {
                clone.lightbox("resize");
            };

            $(window).on("resize", cloneData.resizeHandler);
            $(window).on("orientationchange", cloneData.resizeHandler);

            data.postopen.call(this);

            return this;
        },
                
        close : function () {
            var data = this.data("lightbox");

            data.preclose.call(this);

            $(window).off("resize", data.resizeHandler);
            $(window).off("orientationchange", data.resizeHandler);

            data.opened = false;
            data.overlay.remove();
            data.overlay = undefined;

            data.postclose.call(this);

            data.box.remove();
            return this;
        },
                
        resize : function () {
            var data = this.data("lightbox"),
                w, h;

            data.preresize.call(this);

            if (data.fullscreen === true) {
                w = window.innerWidth;
                h = window.innerHeight;
            } else {
                w = data.contentWidth;
                h = data.contentHeight;
                if (data.scale === true) {
                    var r = computeRatio(w, h);
                    w = parseInt(w * r, 10);
                    h = parseInt(h * r, 10);
                }
            }

            scaleElement(data.box, w, h);
            positionElement(data.box, w, h);

            scaleElement(data.contents, w, h);
            positionElement(data.contents, w, h);

            data.contentWidth = w;
            data.contentHeight = h;

            data.postresize.call(this);

            return this;
        },

        toggle : function () {
            if (this.data("lightbox").opened === true) {
                this.lightbox("close");
            } else {
                this.lightbox("open");
            }
            return this;
        },

        init : function (options) {
            return this.each(function() {
                var $this = $(this),
                data = $this.data("lightbox");
                if ( !data ) {
                    var settings = $.extend(defaults, options, { opened : false });
                    $this.data("lightbox", settings);
                }

                if ($this.data("lightbox").defaultEventHandling === true) {
                    // modified from ecmanaut's answer at
                    // http://stackoverflow.com/questions/3103842/safari-ipad-prevent-zoom-on-double-tap
                    $this.on("touchstart", function (e) {
                        var t2 = e.timeStamp,
                            t1 = $this.data("lightbox").lastTouch || t2,
                            dt = t2 - t1,
                            fingers = e.originalEvent.touches.length;
                        $this.data("lightbox").lastTouch = t2;
                        if (!dt || dt > 500 || fingers > 1) {
                            return;
                        }
                        e.preventDefault(); // double tap - prevent the zoom
                        $this.lightbox("toggle");
                    });
                }

                return this;
            });
        }
    };

    $.fn.lightbox = function (method) {
        if ( methods[method] ) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === "object" || !method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( "Method " +  method + " does not exist on jQuery.lightbox" );
            return null;
        }
    };

    var computeRatio = function (originalWidth, originalHeight) {
        var wr = (originalWidth > 0) ? window.innerWidth / originalWidth : 1,
            hr = (originalHeight > 0) ? window.innerHeight / originalHeight : 1,
            r = Math.min(wr, hr);
        return r;
    };

    var scaleElement = function (elem, width, height) {
        elem.css("width", width + "px")
            .css("height", height + "px");
    };

    var positionElement = function (elem, width, height) {
        var left = (window.innerWidth  - width) / 2,
            top = (window.innerHeight - height) / 2;
        if (left < 0) {
            left = 0;
        }
        if (top < 0) {
            top = 0;
        }

        elem.css("left", left + "px")
            .css("top", top + "px");
    };

}(jQuery));

},{}],15:[function(require,module,exports){
(function() {
    "use strict";

    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
 
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }
 
    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
    }
}());

},{}],16:[function(require,module,exports){
/**
sprintf() for JavaScript 0.7-beta1
http://www.diveintojavascript.com/projects/javascript-sprintf

Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of sprintf() for JavaScript nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Changelog:
2010.11.07 - 0.7-beta1-node
  - converted it to a node.js compatible module

2010.09.06 - 0.7-beta1
  - features: vsprintf, support for named placeholders
  - enhancements: format cache, reduced global namespace pollution

2010.05.22 - 0.6:
 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
 Note:
 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
 who warned me about a bug in 0.5, I discovered that the last update was
 a regress. I appologize for that.

2010.05.09 - 0.5:
 - bug fix: 0 is now preceeded with a + sign
 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
 - switched from GPL to BSD license

2007.10.21 - 0.4:
 - unit test and patch (David Baird)

2007.09.17 - 0.3:
 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)

2007.09.11 - 0.2:
 - feature: added argument swapping

2007.04.03 - 0.1:
 - initial release
**/

var sprintf = (function() {
	function get_type(variable) {
		return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
	}
	function str_repeat(input, multiplier) {
		for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
		return output.join('');
	}

	var str_format = function() {
		if (!str_format.cache.hasOwnProperty(arguments[0])) {
			str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
		}
		return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
	};

	// convert object to simple one line string without indentation or
	// newlines. Note that this implementation does not print array
	// values to their actual place for sparse arrays. 
	//
	// For example sparse array like this
	//    l = []
	//    l[4] = 1
	// Would be printed as "[1]" instead of "[, , , , 1]"
	// 
	// If argument 'seen' is not null and array the function will check for 
	// circular object references from argument.
	str_format.object_stringify = function(obj, depth, maxdepth, seen) {
		var str = '';
		if (obj != null) {
			switch( typeof(obj) ) {
			case 'function': 
				return '[Function' + (obj.name ? ': '+obj.name : '') + ']';
			    break;
			case 'object':
				if ( obj instanceof Error) { return '[' + obj.toString() + ']' };
				if (depth >= maxdepth) return '[Object]'
				if (seen) {
					// add object to seen list
					seen = seen.slice(0)
					seen.push(obj);
				}
				if (obj.length != null) { //array
					str += '[';
					var arr = []
					for (var i in obj) {
						if (seen && seen.indexOf(obj[i]) >= 0) arr.push('[Circular]');
						else arr.push(str_format.object_stringify(obj[i], depth+1, maxdepth, seen));
					}
					str += arr.join(', ') + ']';
				} else if ('getMonth' in obj) { // date
					return 'Date(' + obj + ')';
				} else { // object
					str += '{';
					var arr = []
					for (var k in obj) { 
						if(obj.hasOwnProperty(k)) {
							if (seen && seen.indexOf(obj[k]) >= 0) arr.push(k + ': [Circular]');
							else arr.push(k +': ' +str_format.object_stringify(obj[k], depth+1, maxdepth, seen)); 
						}
					}
					str += arr.join(', ') + '}';
				}
				return str;
				break;
			case 'string':				
				return '"' + obj + '"';
				break
			}
		}
		return '' + obj;
	}

	str_format.format = function(parse_tree, argv) {
		var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
		for (i = 0; i < tree_length; i++) {
			node_type = get_type(parse_tree[i]);
			if (node_type === 'string') {
				output.push(parse_tree[i]);
			}
			else if (node_type === 'array') {
				match = parse_tree[i]; // convenience purposes only
				if (match[2]) { // keyword argument
					arg = argv[cursor];
					for (k = 0; k < match[2].length; k++) {
						if (!arg.hasOwnProperty(match[2][k])) {
							throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
						}
						arg = arg[match[2][k]];
					}
				}
				else if (match[1]) { // positional argument (explicit)
					arg = argv[match[1]];
				}
				else { // positional argument (implicit)
					arg = argv[cursor++];
				}

				if (/[^sO]/.test(match[8]) && (get_type(arg) != 'number')) {
					throw new Error(sprintf('[sprintf] expecting number but found %s "' + arg + '"', get_type(arg)));
				}
				switch (match[8]) {
					case 'b': arg = arg.toString(2); break;
					case 'c': arg = String.fromCharCode(arg); break;
					case 'd': arg = parseInt(arg, 10); break;
					case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
					case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
				    case 'O': arg = str_format.object_stringify(arg, 0, parseInt(match[7]) || 5); break;
					case 'o': arg = arg.toString(8); break;
					case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
					case 'u': arg = Math.abs(arg); break;
					case 'x': arg = arg.toString(16); break;
					case 'X': arg = arg.toString(16).toUpperCase(); break;
				}
				arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
				pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
				pad_length = match[6] - String(arg).length;
				pad = match[6] ? str_repeat(pad_character, pad_length) : '';
				output.push(match[5] ? arg + pad : pad + arg);
			}
		}
		return output.join('');
	};

	str_format.cache = {};

	str_format.parse = function(fmt) {
		var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
		while (_fmt) {
			if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
				parse_tree.push(match[0]);
			}
			else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
				parse_tree.push('%');
			}
			else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosOuxX])/.exec(_fmt)) !== null) {
				if (match[2]) {
					arg_names |= 1;
					var field_list = [], replacement_field = match[2], field_match = [];
					if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
						field_list.push(field_match[1]);
						while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
							if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
								field_list.push(field_match[1]);
							}
							else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
								field_list.push(field_match[1]);
							}
							else {
								throw new Error('[sprintf] ' + replacement_field);
							}
						}
					}
					else {
                        throw new Error('[sprintf] ' + replacement_field);
					}
					match[2] = field_list;
				}
				else {
					arg_names |= 2;
				}
				if (arg_names === 3) {
					throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
				}
				parse_tree.push(match);
			}
			else {
				throw new Error('[sprintf] ' + _fmt);
			}
			_fmt = _fmt.substring(match[0].length);
		}
		return parse_tree;
	};

	return str_format;
})();

var vsprintf = function(fmt, argv) {
	var argvClone = argv.slice();
	argvClone.unshift(fmt);
	return sprintf.apply(null, argvClone);
};

module.exports = sprintf;
sprintf.sprintf = sprintf;
sprintf.vsprintf = vsprintf;

},{}],17:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Data = require('./data.js'),
    DataValue = require('./data_value.js');

/**
 * @class ArrayData
 * @for ArrayData
 * @constructor
 * @param {array} columns A array of DataVariables
 * @param {array} stringArray A array of strings which will later be parsed into DataValues
 */
var ArrayData = new jermaine.Model(function () {
    var ArrayData = this; // huh?  This shadows the ArrayData defined on the previous line.
    //                       Is that intended/correct?  Probably, but need to check for sure.
    //                       mbp Wed Feb 25 18:31:15 2015

    this.isA(Data);
    this.hasAn("array");
    this.hasA("stringArray");
    this.isBuiltWith("columns", "stringArray", function () {
        this.init();
        this.addListener("listenerAdded", function (event) {
            if (event.targetType === "dataReady") {
                var data = this.array();
                event.listener(data[0][0], data[data.length-1][0]);
            }
        });
    });

    /**
     * 
     *
     * @method getIterator
     * @param {string array} columnIDs
     * @param {DataValue} min
     * @param {DataValue} max
     * @param {Integer} buffer
     * @author jrfrimme
     */
    this.respondsTo("getIterator", function (columnIds, min, max, buffer) {
        return ArrayData.getArrayDataIterator(this, columnIds, min, max, buffer);
    });

    /**
     * Determines the upper and lower bounds of a column in a dataset.
     *
     * @method getBounds
     * @param {Integer} columnNumber Column in the dataset to have its bounds determined.
     * @return {array} Array in the form: [lowerBound, upperBound].
     * @author jrfrimme
     */
    this.respondsTo("getBounds", function (columnNumber) {
        var data = this.array(),
            min = data[0][columnNumber],
            max = min,
            i;

        for (i = 1; i < data.length; i++) {
            if (data[i][columnNumber] < min) {
                min = data[i][columnNumber];
            }
            if (data[i][columnNumber] > max) {
                max = data[i][columnNumber];
            }
        }

        return [min, max];
    });

    /**
     * @method onReady
     * @param callback
     */

    /**
     * @method getArrayDataIterator
     * @static
     * @param {ArrayData} arrayData
     * @param {string array} columnIDs
     * @param {DataValue} min
     * @param {DataValue} max
     * @param {Integer} buffer
     * @return iter
     * @author jrfrimme
     */
    ArrayData.getArrayDataIterator = function (arrayData, columnIds, min, max, buffer) {

        var i, j,
            firstIndex, lastIndex,
            currentIndex,
            columnIndices,
            array = arrayData.array();

        buffer = buffer || 0;

        // columnIds argument should be an array of strings
        if (Object.prototype.toString.apply(columnIds) !== "[object Array]") {
            throw new Error("ArrayData: getIterator method requires that the first parameter be an array of strings");
        } else {
            for (i = 0; i < columnIds.length; ++i) {
                if (typeof(columnIds[i]) !== "string") {
                    throw new Error("ArrayData: getIterator method requires that the first parameter be an array of strings");
                }
            }
        }

        //min,max arguments should be data values
        if (!DataValue.isInstance(min) || !DataValue.isInstance(max)) {
            throw new Error("ArrayData: getIterator method requires the second and third argument to be number values");
        }

        //buffer argument should be an integer
        if (typeof(buffer) !== "number") {
            throw new Error("ArrayData: getIterator method requires last argument to be an integer");
        }

        // if we have no data, return an empty iterator
        if (array.length === 0) {
            return {
                "next"    : function () {},
                "hasNext" : function () { return false; }
            };
        }

        // find the index of the first row in the array whose column0 value is >= min
        for (firstIndex = 0; firstIndex < array.length; ++firstIndex) {
            if (array[firstIndex][0].ge(min)) {
                break;
            }
        }
        // back up 'buffer' steps
        firstIndex = firstIndex - buffer;
        if (firstIndex < 0) {
            firstIndex = 0;
        }
        
        // find the index of the last row in the array whose column0 value is <= max
        if (firstIndex === array.length-1) {
            lastIndex = firstIndex;
        } else {
            for (lastIndex = firstIndex; lastIndex < array.length-1; ++lastIndex) {
                if (array[lastIndex+1][0].gt(max)) {
                    break;
                }
            }
        }
        // move forward 'buffer' steps
        lastIndex = lastIndex + buffer;
        if (lastIndex > array.length-1) {
            lastIndex = array.length-1;
        }

        columnIndices = [];
        for (j = 0; j < columnIds.length; ++j) {
            var k = arrayData.columnIdToColumnNumber(columnIds[j]);
            columnIndices.push( k );
        }

        currentIndex = firstIndex;
        
        return {
            next : function () {
                var projection = [],
                    i;
                if (currentIndex > lastIndex) {
                    return null;
                }
                for (i = 0; i < columnIndices.length; ++i) {
                    projection.push(array[currentIndex][columnIndices[i]]);
                }
                ++currentIndex;
                return projection;
            },
            hasNext : function () {
                return currentIndex <= lastIndex;
            }
        };
    };

    /**
     * @method textToDataValuesArray
     * @static
     * @param {array} dataVariableArray
     * @param {string} text
     * @return {array} dataValues
     * @author jrfrimme
     * @todo If the number of comma-separated values on the current line is not the same as the number of columns in the metadata, should throw an error.
     */
    ArrayData.textToDataValuesArray = function (dataVariableArray, text) {
        //IMPORTANT NOTE: dataVariableArray is a plain javascript array of DataVariable instances; it
        //is NOT a jermaine attr_list.
        var dataValues = [],
            lines = text.split("\n"),
            i;
        for (i = 0; i < lines.length; ++i) {
            if (/\d/.test(lines[i])) { // skip line unless it contains a digit
                var stringValuesThisRow = lines[i].split(/\s*,\s*/),
                    dataValuesThisRow = [],
                    j;
                if (stringValuesThisRow.length === dataVariableArray.length) {
                    for (j = 0; j < stringValuesThisRow.length; ++j) {
                        dataValuesThisRow.push(DataValue.parse(dataVariableArray[j].type(), stringValuesThisRow[j]));
                    }
                    dataValues.push( dataValuesThisRow );
                    //} else {
                    // we get here if the number of comma-separated values on the current line
                    // (lines[i]) is not the same as the number of columns in the metadata.  This
                    // should probably throw an error, or something like that.  For now, though, we
                    // just ignore it.
                    //console.log('bad line: ' + lines[i]);
                }
            }
        }
        return dataValues;
    };

    /**
     * @method textToStringArray
     * @static
     * @param {string} text 
     * @return {array} stringValues
     * @author jrfrimme
     */
    ArrayData.textToStringArray = function (dataVariables, text) {
        var stringValues = [],
            lines = text.split("\n"),
            stringValuesThisRow,
            numColumns,
            i;

        // clean up each line
        for (i = 0; i < lines.length; ++i) {
            lines[i] = lines[i]
                .replace(/^\s+/,     "")   // remove leading whitespace
                .replace(/\s+$/,     "")   // remove trailing whitespace
                .replace(/\s*,\s*/g, ",")  // remove any whitespace next to commas
                .replace(/\s+/g,     ","); // replace any remaining whitespace runs with a comma
            // now line consists of comma-separated values, with no whitespace
        }

        for (i = 0; i < lines.length; ++i) {
            if (/\d/.test(lines[i])) { // skip line unless it contains a digit
                numColumns = lines[i].split(/,/).length;
                break;
            }
        }

        for (i = 0; i < lines.length; ++i) {
            if (/\d/.test(lines[i])) { // skip line unless it contains a digit
                stringValuesThisRow = lines[i].split(/,/);
                if (stringValuesThisRow.length === numColumns) {
                    stringValues.push( stringValuesThisRow );
                } else {
                    throw new Error("Data Parsing Error: The line '" + lines[i] + "' has " + stringValuesThisRow.length + " data columns when it requires " + numColumns + " columns");
                }
            }
        }
        return stringValues;
    };

    /**
     * Parses an array of strings into an array of DataValues.
     * 
     * @method textToStringArray
     * @static
     * @param {array} dataVariableArray plain javascript array of DataVariables
     * @param {array} stringArray plain javascript array of strings
     * @return {array} plain javascript array of DataValue instances
     * @author jrfrimme
     */
    ArrayData.stringArrayToDataValuesArray = function (dataVariableArray, stringArray) {
        //IMPORTANT NOTE: dataVariableArray is a plain javascript array of DataVariable instances; it
        //is NOT a jermaine attr_list.

        var dataValues = [],
            dataValuesThisRow,
            i,
            j;

        for (i = 0; i < stringArray.length; ++i) {
            dataValuesThisRow = [];
            for (j = 0; j < stringArray[i].length; ++j) {
                dataValuesThisRow.push(DataValue.parse(dataVariableArray[j].type(), stringArray[i][j]));
            }
            dataValues.push( dataValuesThisRow );
        }
        return dataValues;
    };

});

module.exports = ArrayData;


},{"../../lib/jermaine/src/jermaine.js":9,"./data.js":26,"./data_value.js":30}],18:[function(require,module,exports){
//var jermaine = require('../../lib/jermaine/src/jermaine.js');
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.horizontalaxis),
    Displacement = require('../math/displacement.js'),
    Point = require('../math/point.js'),
    DataMeasure = require('../core/data_measure.js'),
    RGBColor = require('../math/rgb_color.js'),
    Enum = require('../math/enum.js'),
    EventEmitter = require('./event_emitter.js'),
    Text = require('../core/text.js'),
    AxisBinding = require('./axis_binding.js'),
    AxisTitle = require('./axis_title.js'),
    DataValue = require('./data_value.js'),
    Grid = require('./grid.js'),
    Labeler = require('./labeler.js'),
    Pan = require('./pan.js'),
    Zoom = require('./zoom.js'),

    Util = require('../math/util.js'),

    Orientation = new Enum("AxisOrientation");

var Axis = new jermaine.Model("Axis", function () {

    this.isA(EventEmitter);

    this.hasA("title").which.validatesWith(function (title) {
        return title instanceof AxisTitle;
    });
    this.hasMany("labelers").eachOfWhich.validateWith(function (labelers) {
        return labelers instanceof Labeler;
    });
    this.hasA("grid").which.validatesWith(function (grid) {
        return grid instanceof Grid;
    });
    this.hasA("pan").which.validatesWith(function (pan) {
        return pan instanceof Pan;
    });
    this.hasA("zoom").which.validatesWith(function (zoom) {
        return zoom instanceof Zoom;
    });
    this.hasA("binding").which.validatesWith(function (binding) {
        return binding === null || binding instanceof AxisBinding;
    });
    this.hasAn("id").which.isA("string");
    this.hasA("type").which.isOneOf(DataValue.types());
    this.hasA("length").which.validatesWith(function (length) {
        return length instanceof Displacement;
    });
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });
    this.hasA("pregap").which.isA("number");
    this.hasA("postgap").which.isA("number");
    this.hasAn("anchor").which.isA("number");
    this.hasA("base").which.validatesWith(function (base) {
        return base instanceof Point;
    });

    this.hasA("visible").which.isA("boolean").and.which.defaultsTo(true);

    /**
     * Stores the "min" value from the mugl file as a string, if there was one.
     * This value is stored as a string, rather than as a number or a DataValue,
     * because it might have the value "auto".
     */
    this.hasA("min").which.isA("string");

    /**
     * The current min DataValue for the axis.
     *
     * @property dataMin
     * @type {DataValue}
     * @author jrfrimme
     */
    this.hasA("dataMin").which.validatesWith(DataValue.isInstance);
    /**
     * Convenience method for checking to see if dataMin has been set or not
     *
     * @method hasDataMin
     * @author jrfrimme
     * @return {Boolean}
     */
    this.respondsTo("hasDataMin", function () {
        return this.dataMin() !== undefined;
    });

    
    this.hasA("minoffset").which.isA("number");
    this.hasA("minposition").which.validatesWith(function (minposition) {
        return minposition instanceof Displacement;
    });

    /**
     * Stores the "max" value from the mugl file as a string, if there was one.
     * This value is stored as a string, rather than as a number or a DataValue,
     * because it might have the value "auto".
     */
    this.hasA("max").which.isA("string");

    /**
     * The current max DataValue for the axis.
     *
     * @property dataMax
     * @type {DataValue}
     * @author jrfrimme
     */
    this.hasA("dataMax").which.validatesWith(DataValue.isInstance);
    /**
     * Convenience method for checking to see if dataMax has been set or not.
     *
     * @method hasDataMax
     * @author jrfrimme
     * @return {Boolean}
     */
    this.respondsTo("hasDataMax", function () {
        return this.dataMax() !== undefined;
    });



    this.hasA("maxoffset").which.isA("number");
    this.hasA("maxposition").which.validatesWith(function (maxposition) {
        return maxposition instanceof Displacement;
    });


    this.hasA("positionbase").which.isA("string"); // deprecated
    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    });
    this.hasA("tickcolor").which.validatesWith(function (color) {
        return color === null || color instanceof RGBColor;
    });
    this.hasA("tickwidth").which.isA("integer");
    this.hasA("tickmin").which.isA("integer");
    this.hasA("tickmax").which.isA("integer");
    this.hasA("highlightstyle").which.validatesWith(function (highlightstyle) {
        return typeof(highlightstyle) === "string";
    });
    this.hasA("linewidth").which.isA("integer");
    this.hasA("orientation").which.validatesWith(Orientation.isInstance);
    this.isBuiltWith("orientation", function () {
        this.grid(new Grid());
        this.zoom(new Zoom());
        this.pan(new Pan());
    });

    this.hasA("pixelLength").which.isA("number");
    this.hasA("parallelOffset").which.isA("number");
    this.hasA("perpOffset").which.isA("number");

    this.hasA("axisToDataRatio").which.isA("number");

    this.respondsTo("initializeGeometry", function (graph, graphicsContext) {
        var plotBox = graph.plotBox(),
            position = this.position(),
            base     = this.base(),
            pixelLength,
            i;
        if (this.orientation() === Axis.HORIZONTAL) {
            pixelLength = this.length().calculateLength( plotBox.width() );
            this.pixelLength(pixelLength);
            this.parallelOffset( position.x() + (base.x() + 1) * plotBox.width()/2 - (this.anchor() + 1) * pixelLength / 2 );
            this.perpOffset( position.y() + (base.y() + 1) * plotBox.height() / 2 );
        } else {
            pixelLength = this.length().calculateLength( plotBox.height() );
            this.pixelLength(pixelLength);
            this.parallelOffset( position.y() + (base.y() + 1) * plotBox.height()/2 - (this.anchor() + 1) * pixelLength / 2 );
            this.perpOffset( position.x() + (base.x() + 1) * plotBox.width() / 2 );
        }
        this.minoffset(this.minposition().calculateCoordinate(pixelLength));
        this.maxoffset(pixelLength - this.maxposition().calculateCoordinate(pixelLength));
        if (this.hasDataMin() && this.hasDataMax()) {
            this.computeAxisToDataRatio();
        }
        for (i = 0; i < this.labelers().size(); ++i) {
            this.labelers().at(i).initializeGeometry(graph);
        }
        if (this.title()) {
            this.title().initializeGeometry(graph, graphicsContext);
        }
    });

    this.respondsTo("computeAxisToDataRatio", function () {
        if (this.hasDataMin() && this.hasDataMax()) {
            this.axisToDataRatio((this.pixelLength() - this.maxoffset() - this.minoffset()) / (this.dataMax().getRealValue() - this.dataMin().getRealValue()));
        }
    });

    this.respondsTo("dataValueToAxisValue", function (v) {
        return this.axisToDataRatio() * ( v.getRealValue() - this.dataMin().getRealValue() ) + this.minoffset() + this.parallelOffset();
    });

    this.respondsTo("axisValueToDataValue", function (a) {
        return DataValue.create( this.type(),
                                 ( this.dataMin().getRealValue() +
                                   ( a - this.minoffset() - this.parallelOffset() ) / this.axisToDataRatio()) );
    });

    this.hasA("currentLabeler").which.validatesWith(function (labeler) {
        return labeler===null || labeler instanceof Labeler;
    });
    this.hasA("currentLabelDensity").which.isA("number");
    this.hasA("currentLabelerIndex").which.isA("number");

    this.respondsTo("destroy", function() {
        if (this.binding()) {
            this.binding().removeAxis(this);
        }
    });

    /**
     * Decides which labeler to use: take the one with the largest density <= 0.8.
     * Unless all have density > 0.8, in which case we take the first one.  This assumes
     * that the labelers list is ordered in increasing order of label density.
     * This function sets the `currentLabeler` and `currentLabelDensity` attributes.
     *
     * @method prepareRender
     * @param {Object} graphicsContext
     * @author jrfrimme
     */
    this.respondsTo("prepareRender", function (graphicsContext) {
        if (!this.hasDataMin() || !this.hasDataMax()) {
            // if either endpoint dataMin() or dataMax() hasn't been specified yet,
            // return immediately without doing anything
            return;
        }
        var currentLabeler,
            currentLabelDensity = 0,
            storedDensity = 0,
            densityThreshold = 0.8,
            labelers  = this.labelers(),
            nlabelers = labelers.size(),
            index     = this.currentLabelerIndex(),
            storedIndex;

        if (nlabelers <= 0) {
            currentLabeler = null;
        } else {
            var flag = true,
                lastLabelerIndex = labelers.size() - 1;

            if (index === undefined) {
                index = 0;
            }
            storedIndex = index;
            currentLabelDensity = labelers.at(index).getLabelDensity(graphicsContext);

            if (currentLabelDensity > densityThreshold) {
                if (index === 0) { // use labeler at position 0
                    flag = false;
                } else { // check the prior labeler
                    storedDensity = currentLabelDensity;
                    index--;
                }
            } else if (currentLabelDensity < densityThreshold) { // check the next labeler
                storedDensity = currentLabelDensity;
                if (index === lastLabelerIndex) {
                    flag = false;
                } else {
                    index++;
                }
            } else if (currentLabelDensity === densityThreshold) { // use labeler at position 0
                flag = false;
            }

            while (flag) {
                currentLabelDensity = labelers.at(index).getLabelDensity(graphicsContext);
                if (currentLabelDensity > densityThreshold) { // labeler before current one
                    if (index === 0) { // use labeler at position 0
                        break;
                    } else if (storedIndex > index) { // going backwards through labelers
                        storedIndex = index;
                        storedDensity = currentLabelDensity;
                        index--;
                    } else { // the prior labeler had density < threshold and was checking the next labeler
                        index = storedIndex;
                        currentLabelDensity = storedDensity;
                        break;
                    }
                } else if (currentLabelDensity < densityThreshold) { // this labeler or one after it
                    if (storedIndex > index) { // going backwards through labelers so prior labeler had density > threshold
                        break;
                    } else if (index === lastLabelerIndex) {
                        break;
                    } else { // check next labeler to see if it has density < threshold
                        storedIndex = index;
                        storedDensity = currentLabelDensity;
                        index++;
                    }
                } else if (currentLabelDensity === densityThreshold) {
                    break;
                }
            }
        }
        currentLabeler = labelers.at(index);

        this.currentLabeler(currentLabeler);
        this.currentLabelerIndex(index);
        this.currentLabelDensity(currentLabelDensity);
    });

    this.respondsTo("toRealValue", function (value) {
        if (typeof(value) === "number") {
            return value;
        } else if (DataValue.isInstance(value)) {
            return value.getRealValue();
        } else {
            throw new Error("unknown value type for axis value " + value);
        }
    });

    this.respondsTo("toDataValue", function (value) {
        if (typeof(value) === "number") {
            return DataValue.create(this.type(), value);
        } else if (DataValue.isInstance(value)) {
            return value;
        } else {
            throw new Error("unknown value type for axis value " + value);
        }
    });

    this.respondsTo("setDataRangeNoBind", function(min, max, dispatch) {

        // NOTE: min and max may either be plain numbers, or
        // DataValue instances.  If they're plain numbers, they
        // get converted to DataValue instances here before being
        // passed to the dataMin()/dataMax() setters below.

        var dataValueMin = this.toDataValue(min),
            dataValueMax = this.toDataValue(max);

        this.dataMin(dataValueMin);
        this.dataMax(dataValueMax);
        // if (_graph != null) { _graph.invalidateDisplayList(); }
        if (dispatch === undefined) {
            dispatch = true;
        }

        this.emit({'type' : 'dataRangeSet',
                   'min'  : dataValueMin,
                   'max'  : dataValueMax});
        /*
         if (dispatch) {
         //dispatchEvent(new AxisEvent(AxisEvent.CHANGE,min,max));  
         }
         */
    });

    this.respondsTo("setDataRange", function (min, max, dispatch) {
        if (this.binding()) {
            this.binding().setDataRange(this, min, max, dispatch);
        } else {
            this.setDataRangeNoBind(min, max, dispatch);
        }
    });

    this.respondsTo("doPan", function (pixelBase, pixelDisplacement) {
        var pan = this.pan(),
            panMin = pan.min(),
            panMax = pan.max(),
            offset,
            newRealMin,
            newRealMax;

        if (!pan.allowed()) { return; }
        offset = pixelDisplacement / this.axisToDataRatio();
        newRealMin = this.dataMin().getRealValue() - offset;
        newRealMax = this.dataMax().getRealValue() - offset;
        
        if (panMin && newRealMin < panMin.getRealValue()) {
            newRealMax += (panMin.getRealValue() - newRealMin);
            newRealMin = panMin.getRealValue();
        }
        if (panMax && newRealMax > panMax.getRealValue()) {
            newRealMin -= (newRealMax - panMax.getRealValue());
            newRealMax = panMax.getRealValue();
        }
        this.setDataRange(DataValue.create(this.type(), newRealMin),
                          DataValue.create(this.type(), newRealMax));
    });

    this.respondsTo("doZoom", function (pixelBase, pixelDisplacement) {
        var zoom = this.zoom(),
            pan  = this.pan(),
            type = this.type(),
            dataMin = this.dataMin(),
            dataMax = this.dataMax(),
            panMin  = pan.min(),
            panMax  = pan.max(),
            zoomMin = zoom.min(),
            zoomMax = zoom.max(),
            baseRealValue,
            factor,
            newMin,
            newMax,
            d;
        if (!zoom.allowed()) {
            return;
        }
        baseRealValue = this.axisValueToDataValue(pixelBase).getRealValue();
        if (DataValue.isInstance(zoom.anchor())) {
            baseRealValue = zoom.anchor().getRealValue();
        }
        factor = 10 * Math.abs(pixelDisplacement / (this.pixelLength() - this.maxoffset() - this.minoffset()));
        /*TODO: uncomment after this.reversed() has been implemented
         if (this.reversed()) { factor = -factor; }
         */
        if (pixelDisplacement <= 0) {
            newMin = DataValue.create(type,
                                      (dataMin.getRealValue() - baseRealValue) * ( 1 + factor ) + baseRealValue);
            newMax = DataValue.create(type,
                                      (dataMax.getRealValue() - baseRealValue) * ( 1 + factor ) + baseRealValue);
        } else {
            newMin = DataValue.create(type,
                                      (dataMin.getRealValue() - baseRealValue) * ( 1 - factor ) + baseRealValue);
            newMax = DataValue.create(type,
                                      (dataMax.getRealValue() - baseRealValue) * ( 1 - factor ) + baseRealValue);
        }
        if (panMin && newMin.lt(panMin)) {
            newMin = panMin;
        }
        if (panMax && newMax.gt(panMax)) {
            newMax = panMax;
        }
        
        if ((dataMin.le(dataMax) && newMin.lt(newMax)) ||
            (dataMin.ge(dataMax) && newMin.gt(newMax))) {
            if (zoomMax && (newMax.gt(newMin.add(zoomMax)))) {
                d = (newMax.getRealValue() - newMin.getRealValue() - zoomMax.getRealValue()) / 2;
                newMax = newMax.addRealValue(-d);
                newMin = newMin.addRealValue(d);
            } else if (zoomMin && (newMax.lt(newMin.add(zoomMin)))) {
                d = (zoomMin.getRealValue() - (newMax.getRealValue() - newMin.getRealValue())) / 2;
                newMax = newMax.addRealValue(d);
                newMin = newMin.addRealValue(-d);
            }
            this.setDataRange(newMin, newMax);
        }
    });

    /**
     * Compute the distance from an axis to a point.  The point
     * (x,y) is expressed in pixel coordinates in the same
     * coordinate system as the axis.
     * 
     * We use two different kinds of computations depending on
     * whether the point lies inside or outside the region bounded
     * by the two lines perpendicular to the axis through its
     * endpoints.  If the point lies inside this region, the
     * distance is simply the difference in the perpendicular
     * coordinate of the point and the perpendicular coordinate of
     * the axis.
     * 
     * If the point lies outside the region, then the distance is
     * the L2 distance between the point and the closest endpoint
     * of the axis.
     *
     * @method distanceToPoint
     * @param {} x
     * @param {} y
     * @author jrfrimme
     */
    this.respondsTo("distanceToPoint", function (x, y) {
        var perpCoord     = (this.orientation() === Axis.HORIZONTAL) ? y : x,
            parallelCoord = (this.orientation() === Axis.HORIZONTAL) ? x : y,
            parallelOffset = this.parallelOffset(),
            perpOffset     = this.perpOffset(),
            pixelLength    = this.pixelLength(),
            l2dist         = Util.l2dist;

        if (parallelCoord < parallelOffset) {
            // point is under or left of the axis; return L2 distance to bottom or left axis endpoint
            return l2dist(parallelCoord, perpCoord, parallelOffset, perpOffset);
        }
        if (parallelCoord > parallelOffset + pixelLength) {
            // point is above or right of the axis; return L2 distance to top or right axis endpoint
            return l2dist(parallelCoord, perpCoord, parallelOffset + pixelLength, perpOffset);
        }
        // point is between the axis endpoints; return difference in perpendicular coords
        return Math.abs(perpCoord - perpOffset);
    });


    this.respondsTo("normalize", function (graph) {
        var i,
            title,
            label;

        //
        // Handles title tags
        //
        if (this.title() && this.title().content() === undefined) {
            this.title().content(new Text(this.id()));
        }

        //
        // Handles missing labelers
        //
        if (this.labelers().size() === 0) {
            var defaultValues = (utilityFunctions.getDefaultValuesFromXSD()).horizontalaxis.labels,
                defaultSpacings = this.type() === DataValue.NUMBER ?
                    defaultValues.defaultNumberSpacing :
                    defaultValues.defaultDatetimeSpacing;

            for (i = 0; i < defaultSpacings.length; i++) {
                label = new Labeler(this);
                label.spacing(DataMeasure.parse(this.type(), defaultSpacings[i]));
                this.labelers().add(label);
            }
        }

        //
        // normalizes the labelers
        //
        for (i = 0; i < this.labelers().size(); i++) {
            this.labelers().at(i).normalize();
        }

    });

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis, attributes);
});

Axis.HORIZONTAL = new Orientation("horizontal");
Axis.VERTICAL   = new Orientation("vertical");

Axis.Orientation = Orientation;

module.exports = Axis;

},{"../../lib/jermaine/src/jermaine.js":9,"../core/data_measure.js":28,"../core/text.js":64,"../math/displacement.js":101,"../math/enum.js":102,"../math/point.js":104,"../math/rgb_color.js":105,"../math/util.js":106,"../util/utilityFunctions.js":157,"./axis_binding.js":19,"./axis_title.js":20,"./data_value.js":30,"./event_emitter.js":38,"./grid.js":42,"./labeler.js":45,"./pan.js":52,"./zoom.js":71}],19:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var AxisBinding = new jermaine.Model("AxisBinding", function () {
    var AxisBinding = this;
    
    AxisBinding.instances = {};

    /**
     * 
     *
     * @property id
     * @type {String}
     * @author jrfrimme
     */
    this.hasA("id").which.isA("string");

    /**
     * 
     *
     * @property axes
     * @type {Array}
     * @author jrfrimme
     */
    this.hasA("axes"); // js array

    this.isBuiltWith("id", function() {
        AxisBinding.instances[this.id()] = this;
        this.axes([]);
    });

    /**
     * 
     *
     * @method addAxis
     * @param {Axis} axis
     * @param {number|DataValue} min
     * @param {number|DataValue} max
     * @author jrfrimme
     */
    this.respondsTo("addAxis", function(axis, min, max, multigraph/*optional*/) {
        // NOTE: min/max can be either numbers, or DataValue
        // instances, but they CANNOT be strings.

        if (axis.binding()) {
            axis.binding().removeAxis(axis);
        }
        axis.binding(this);

        // convert min/max to numbers
        min = axis.toRealValue(min);
        max = axis.toRealValue(max);

        this.axes().push({
            axis       : axis,
            multigraph : multigraph,
            factor     : 1 / (max - min),
            offset     : -min / (max - min),
            min        : min,
            max        : max
        });
    });

    /**
     * 
     *
     * @method removeAxis
     * @param {Axis} axis
     * @author jrfrimme
     */
    this.respondsTo("removeAxis", function(axis) {
        var axes = this.axes(),
            i;
        for (i=0; i<axes.length; ++i) {
            if (axes[i].axis === axis) {
                axes.splice(i,1);
                break;
            }
        }
    });

    /**
     * Force all the axes in this binding to sync up with each
     * other, if possible.
     * 
     * This is done by looking for an axis in this binding which
     * has its dataMin and dataMax values set, and then calling
     * its setDataRange() method with those values.  The main
     * purpose of this method is to facilitate the initial setting
     * of dataMin/dataMax values for axes in a binding that do not
     * already have dataMin/dataMax values set; this forces them
     * to be set based on the binding, as determined by another
     * axis in the binding.
     * 
     * Note that this method is NOT the normal way for bound axes
     * to interact with each other once initialization is
     * complete; that is done via the axes' own setDataRange()
     * method.
     * 
     * @method sync
     * 
     * @return {boolean} a value indicating whether the sync was
     *                   done; this will be true if and only if
     *                   there is at least one axis in the binding
     *                   having both its dataMin and dataMax
     *                   values set.
     */
    this.respondsTo("sync", function() {
        var i,
            axes = this.axes(),
            axis;
        for (i=0; i<axes.length; ++i) {
            axis = axes[i].axis;
            if (axis.hasDataMin() && axis.hasDataMax()) {
                axis.setDataRange(axis.dataMin(), axis.dataMax());
                return true;
            }

        }
        return false;
    });

    /**
     * 
     *
     * @method setDataRange
     * @param {Axis} initiatingAxis
     * @param {number|DataValue} min
     * @param {number|DataValue} max
     * @param {Boolean} dispatch
     * @author jrfrimme
     */
    this.respondsTo("setDataRange", function(initiatingAxis, min, max, dispatch) {

        // NOTE: min and max may either be plain numbers, or
        // DataValue instances.  If they're DataValue instances,
        // get converted to numbers here before being
        // passed to the individual axes' setDataRangeNoBind()
        // method below.

        var initiatingAxisIndex,
            i, j,
            axes = this.axes(),
            axis,
            minRealValue = initiatingAxis.toRealValue(min),
            maxRealValue = initiatingAxis.toRealValue(max),
            redrawn_multigraphs = [],
            redrawn;

        if (dispatch === undefined) {
            dispatch = true; // dispatch defaults to true
        }

        for (i=0; i<axes.length; ++i) {
            if (axes[i].axis === initiatingAxis) {
                initiatingAxisIndex = i;
                redrawn_multigraphs = [ axes[i].multigraph ];
                break;
            }
        }
        for (i=0; i<axes.length; ++i) {
            axis = axes[i];
            if (i === initiatingAxisIndex) {
                axis.axis.setDataRangeNoBind(minRealValue, maxRealValue, dispatch);
            } else {
                axis.axis.setDataRangeNoBind(
                    (minRealValue * axes[initiatingAxisIndex].factor + axes[initiatingAxisIndex].offset - axis.offset) / axis.factor,
                    (maxRealValue * axes[initiatingAxisIndex].factor + axes[initiatingAxisIndex].offset - axis.offset) / axis.factor,
                    dispatch
                );
                if (axis.multigraph !== undefined) {
                    // If this axis has a multigraph stored with it, and if that multigraph isn't already in the `redrawn_multigraphs`
                    // array, call its `redraw` method, and add it to the array.
                    redrawn = false;
                    for (j=0; j<redrawn_multigraphs.length; ++j) {
                        if (axis.multigraph === redrawn_multigraphs[j]) {
                            redrawn = true;
                            break;
                        }
                    }
                    if (!redrawn) {
                        axis.multigraph.redraw();
                        redrawn_multigraphs.push(axis.multigraph);
                    }
                }
            }
        }
    });

    /**
     * 
     *
     * @method getInstanceById
     * @static
     * @param id
     * @author jrfrimme
     */
    AxisBinding.getInstanceById = function(id) {
        return AxisBinding.instances[id];
    };

    /**
     * 
     *
     * @method findByIdOrCreateNew
     * @static
     * @param id
     * @author jrfrimme
     */
    AxisBinding.findByIdOrCreateNew = function(id) {
        var binding = AxisBinding.getInstanceById(id);
        if (!binding) {
            binding = new AxisBinding(id);
        }
        return binding;
    };

    /**
     * 
     *
     * @method syncAllBindings
     * @static
     * @author jrfrimme
     */
    AxisBinding.syncAllBindings = function() {
        var id;
        for (id in AxisBinding.instances) {
            AxisBinding.instances[id].sync();
        }
    };

    /**
     * 
     *
     * @method forgetAllBindings
     * @static
     * @author jrfrimme
     */
    AxisBinding.forgetAllBindings = function() {

        // This function is just for use in testing, so we can clear out the global list
        // of bindings to get a fresh start between tests.

        var id,j,binding;

        // loop over all bindings, all axes, setting the axis binding to null
        for (id in AxisBinding.instances) {
            binding = AxisBinding.instances[id];
            for (j=0; j<binding.axes().length; ++j) {
                binding.axes()[j].axis.binding(null);
            }
        }

        // reset the global binding list
        AxisBinding.instances = {};
    };

});

module.exports = AxisBinding;

},{"../../lib/jermaine/src/jermaine.js":9}],20:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues    = utilityFunctions.getDefaultValuesFromXSD(),
    attributes       = utilityFunctions.getKeys(defaultValues.horizontalaxis.title),
    Point            = require('../math/point.js');

/**
 * Axis Title is a Jermaine model that supports the rendering of Axis Titles.
 *
 * @class AxisTitle
 * @for AxisTitle
 * @constructor
 * @param {Axis} axis
 */
var AxisTitle = new jermaine.Model("AxisTitle", function () {
    
    /**
     * Pointer to the Title's parent Axis jermiane model.
     *
     * @property axis
     * @type {Axis}
     * @author jrfrimme
     */
    this.hasA("axis").which.validatesWith(function (axis) {
        var Axis = require('./axis.js');
        return axis instanceof Axis;
    });
    /**
     * The value which is used as the title string.
     *
     * @property content
     * @type {Text}
     * @author jrfrimme
     */
    this.hasA("content").which.validatesWith(function (content) {
        var Text = require('./text.js');
        return content instanceof Text;
    });
    /**
     * The value which gives the location of the Title's anchor point to be attached to the
     * base point.
     *
     * @property anchor
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("anchor").which.validatesWith(function (anchor) {
        return anchor instanceof Point;
    });
    /**
     * The value which gives the location of the base point relative to the Title's Axis.
     *
     * @property base
     * @type {Number}
     * @author jrfrimme
     */
    this.hasA("base").which.isA("number");
    /**
     * A coordinate pair of pixel offsets for the base point.
     *
     * @property position
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });
    /**
     * The value which determines the rotation of the Title in degrees.
     *
     * @property angle
     * @type {Number}
     * @author jrfrimme
     */
    this.hasA("angle").which.isA("number");

    this.hasA("font").which.isA("string").and.which.defaultsTo("");

    this.isBuiltWith("axis");

    /**
     * Determines values for the `position` and `anchor` attributes if they were not set; determines the
     * geometry of the `content` attribute. Called by `Axis.initializeGeometry()`.
     *
     * @method initializeGeometry
     * @param {Graph} graph
     * @param {Object} graphicsContext
     * @chainable
     * @author jrfrimme
     */
    this.respondsTo("initializeGeometry", function (graph, graphicsContext) {
        var Axis = require('./axis.js');
        var titleDefaults = defaultValues.horizontalaxis.title,
            axis     = this.axis(),
            position = this.position,
            anchor   = this.anchor,
            plotBox  = graph.plotBox(),
            axisPerpOffset   = axis.perpOffset(),
            axisIsHorizontal = (axis.orientation() === Axis.HORIZONTAL);

        var getValue = function (valueOrFunction) {
            if (typeof(valueOrFunction) === "function") {
                return valueOrFunction();
            } else {
                return valueOrFunction;
            }
        };

        if (position() === undefined) {
            if (axisIsHorizontal) {
                if (axisPerpOffset > plotBox.height()/2) {
                    position( getValue(titleDefaults["position-horizontal-top"]) );
                } else {
                    position( getValue(titleDefaults["position-horizontal-bottom"]) );
                }
            } else {
                if (axisPerpOffset > plotBox.width()/2) {
                    position( getValue(titleDefaults["position-vertical-right"]) );
                } else {
                    position( getValue(titleDefaults["position-vertical-left"]) );
                }
            }
        }

        if (anchor() === undefined) {
            if (axisIsHorizontal) {
                if (axisPerpOffset > plotBox.height()/2) {
                    anchor( getValue(titleDefaults["anchor-horizontal-top"]) );
                } else {
                    anchor( getValue(titleDefaults["anchor-horizontal-bottom"]) );
                }
            } else {
                if (axisPerpOffset > plotBox.width()/2) {
                    anchor( getValue(titleDefaults["anchor-vertical-right"]) );
                } else {
                    anchor( getValue(titleDefaults["anchor-vertical-left"]) );
                }
            }
        }

        graphicsContext.angle = this.angle();
        this.content().initializeGeometry(graphicsContext);

        return this;
    });

    /**
     * Renders the Axis Title. Overridden by implementations in graphics drivers.
     *
     * @method render
     * @private
     * @author jrfrimme
     */
    this.respondsTo("render", function () {});

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis.title, attributes);
});

module.exports = AxisTitle;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/point.js":104,"../util/utilityFunctions.js":157,"./axis.js":18,"./text.js":64}],21:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues    = utilityFunctions.getDefaultValuesFromXSD(),
    attributes       = utilityFunctions.getKeys(defaultValues.background),
    RGBColor         = require('../math/rgb_color.js'),
    Img              = require('./img.js');

var Background = new jermaine.Model("Background", function () {
    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    }).defaultsTo(RGBColor.parse(defaultValues.background.color));
    this.hasA("img").which.validatesWith(function (img) {
        return img instanceof Img;
    });
});

module.exports = Background;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/rgb_color.js":105,"../util/utilityFunctions.js":157,"./img.js":44}],22:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');
var vF = require('../util/validationFunctions.js');

var CategoryFormatter = function (formatValues) {
    if (vF.typeOf(formatValues) !== "array") {
        throw new Error("formatValues must be an array");
    }
    this.formatValues = formatValues;
    this.length = Math.max.apply(this, this.formatValues.map(function(s) { return s.length; }));
};

CategoryFormatter.prototype.format = function (value) {
    var i = Math.round(value.getRealValue());
    var k = this.formatValues.length;
    return this.formatValues[((i % k) + k) % k];
};

CategoryFormatter.prototype.getMaxLength = function () {
    return this.length;
};

CategoryFormatter.prototype.getFormatString = function () {
    return this.formatValues;
};

module.exports = CategoryFormatter;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/validationFunctions.js":158}],23:[function(require,module,exports){
var ConsecutiveDistanceFilter = function (options) {
    this.options = options;
    this.prevPx = undefined;
    this.prevPy = undefined;
    this.havePrev = false;
    this.distance = ("distance" in options) ? options.distance : 5;
};

ConsecutiveDistanceFilter.prototype.reset = function () {
    this.havePrev = false;
};

ConsecutiveDistanceFilter.prototype.filter = function (datap, pixelp) {
    var filterOut = false;
      if (this.havePrev) {
          var dx = Math.abs(pixelp[0] - this.prevPx);
          var dy = Math.abs(pixelp[1] - this.prevPy);
          filterOut = (dx + dy < this.distance);
          if (!filterOut) {
              this.prevPx = pixelp[0];
              this.prevPy = pixelp[1];
          }
      } else {
          this.prevPx = pixelp[0];
          this.prevPy = pixelp[1];
      }
    this.havePrev = true;
    return filterOut;
};

module.exports = ConsecutiveDistanceFilter;

},{}],24:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');


var ConstantPlot = new jermaine.Model("ConstantPlot", function () {
    var utilityFunctions = require('../util/utilityFunctions.js'),
        defaultValues    = utilityFunctions.getDefaultValuesFromXSD(),
        attributes       = utilityFunctions.getKeys(defaultValues.plot),
        Plot             = require('./plot.js'),
        DataValue        = require('./data_value.js');

    this.isA(Plot);
    this.hasA("constantValue").which.validatesWith(DataValue.isInstance);

    this.isBuiltWith("constantValue");

    utilityFunctions.insertDefaults(this, defaultValues.plot, attributes);

    this.respondsTo("render", function (graph, graphicsContext) {
        // graphicsContext is an optional argument passed to ConstantPlot.render() by the
        // graphics driver, and used by that driver's implementation of Renderer.begin().
        // It can be any object used by the driver -- usually some kind of graphics
        // context object.  It can also be omitted if a driver does not need it.

        if (!this.visible()) { return; }

        var haxis = this.horizontalaxis(),
            renderer = this.renderer(),
            constantValue = this.constantValue();

        if (!haxis.hasDataMin() || !haxis.hasDataMax()) {
            return;
        }

        renderer.setUpMissing(); //TODO: this is awkward -- figure out a better way!
        renderer.begin(graphicsContext);
        renderer.dataPoint([ haxis.dataMin(), constantValue ]);
        renderer.dataPoint([ haxis.dataMax(), constantValue ]);
        renderer.end();

    });

});

module.exports = ConstantPlot;


},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":157,"./data_value.js":30,"./plot.js":54}],25:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
var CSVData;
module.exports = function($) {
    if (typeof(CSVData) !== "undefined") { return CSVData; }

    var jermaine = require('../../lib/jermaine/src/jermaine.js'),
        ArrayData = require('./array_data.js');

    CSVData = new jermaine.Model(function () {

        this.isA(ArrayData);
        this.hasA("filename").which.isA("string");
        this.hasA("messageHandler");
        this.hasA("ajaxthrottle");
        this.hasA("dataIsReady").which.isA("boolean").and.defaultsTo(false);

        this.respondsTo("getIterator", function (columnIds, min, max, buffer) {
            if (this.dataIsReady()) {
                return ArrayData.getArrayDataIterator(this, columnIds, min, max, buffer);
            } else {
                return {
                    "next"    : function () {},
                    "hasNext" : function () { return false; }
                };
            }
        });

        this.respondsTo("_displayError", function (e) {
            if (this.messageHandler()) {
                this.messageHandler().error(e);
            } else {
                throw e;
            }
        });

        this.isBuiltWith("columns", "filename", "%messageHandler", "%ajaxthrottle", function () {
            var that         = this,
                ajaxthrottle = this.ajaxthrottle();

            if (ajaxthrottle === undefined) {
                ajaxthrottle = $;
            }

            this.adapter(ArrayData);
            this.init();

            if (that.filename() !== undefined) {
                that.emit({type : 'ajaxEvent', action : 'start'});
                ajaxthrottle.ajax({
                    url : that.filename(),

                    success : function (data) {
                        //parse the data
                        var dataValues = that.adapter().textToStringArray(that.getColumns(), data);
                        that.stringArray(dataValues);
                        // renormalize & populate array
                        that.ajaxNormalize();
                        that.dataIsReady(true);
                        that.emit({type : "dataReady"});
                    },

                    error : function (jqXHR, textStatus, errorThrown) {
                        var message = errorThrown;
                        if (jqXHR.statusCode().status === 404) {
                            message = "File not found: '" + that.filename() + '"';
                        } else {
                            if (textStatus) {
                                message = textStatus + ": " + message;
                            }
                        }
                        that._displayError(new Error(message));
                    },

                    // 'complete' callback gets called after either 'success' or 'error', whichever:
                    complete : function (jqXHR, textStatus) {
                        that.emit({type : 'ajaxEvent', action : 'complete'});
                    }

                });
            }
        });
    });

    return CSVData;
};

},{"../../lib/jermaine/src/jermaine.js":9,"./array_data.js":17}],26:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var EventEmitter = require('./event_emitter.js'),
    DataValue = require('../core/data_value.js'),
    DataVariable = require('./data_variable.js');

var Data = new jermaine.Model(function () {
    
    this.isA(EventEmitter);

    this.hasAn("id").which.isA("string");

    /**
     * Searches through a jermaine attr_list of DataVariables (columns) for
     * an entry having a given id or column number.
     *
     * @method find
     * @private
     * @param {String} attrName The name of the attribute to search on;
     *     should be either "id" or "column".
     * @param {String|Integer} attrValue The value to search for. If attrName
     *     is "id", this value should be a string.  If attrName is "column",
     *     this value should be an int.
     * @param {DataVariable Attr_List} columns The attr_list to search through.
     * @static
     * @return {Integer} The index (an int) of the DataVariable entry having
     *     the given attribute value, if any, or -1 if none was found
     * @author jrfrimme
     *
     * @example
     *
     *     find("id", "x", columns)
     *
     *         finds the index of the DataVariable in the columns attr_list
     *         having an id of "x"
     *
     *     find("column", 1, columns)
     *
     *         finds the index of the DataVariable in the columns attr_list
     *         having a "column" attribute of 1
     */
    var find = function (attrName, attrValue, columns) {
        var result = -1,
            i;
        for (i = 0; i < columns.size(); ++i) {
            if (columns.at(i)[attrName]() === attrValue) {
                result = i;
                break;
            }
        }
        return result;
    };

    /**
     * Set the `data` attribute of each of this data object's columns
     * to point to the data object itself.
     *
     * @method initializeColumns
     * @author jrfrimme
     */
    this.respondsTo("initializeColumns", function () {
        var i;
        for (i = 0; i < this.columns().size(); ++i) {
            this.columns().at(i).data(this);
        }
    });

    this.hasMany("columns").eachOfWhich.validateWith(function (column) {
        this.message = "Data: constructor parameter should be an array of DataVariable objects";
        return column instanceof DataVariable;
    });

    this.hasA("defaultMissingvalue").which.isA("string");
    this.hasA("defaultMissingop").which.isA("string").and.defaultsTo("eq");
    this.hasAn("adapter");

    /**
     * Initialization function --- should be called from isBuiltWith initializer.  This is split
     * off into a separate function so that it can be called from submodel's isBuiltWith initializers
     * as well, since Jermaine does not provide a way to call the parent models' isBuiltWith initializer
     * function.
     *
     * @method init
     * @author jrfrimme
     */
    this.respondsTo("init", function() {
        this.initializeColumns();
    });

    this.isBuiltWith("columns", function () {
        this.init();
    });

    this.respondsTo("columnIdToColumnNumber", function (id) {
        if (typeof(id) !== "string") {
            throw new Error("Data: columnIdToColumnNumber expects parameter to be a string");
        }

        var columnIndex = find("id", id, this.columns()),
            column = undefined;

        if (columnIndex >= 0) {
            column = this.columns().at(columnIndex);
        }

        if (column === undefined) {
            throw new Error("Data: no column with the label " + id);
        }
        
        return column.column();
    });

    this.respondsTo("columnIdToDataVariable", function (id) {
        if (typeof(id) !== "string") {
            throw new Error("Data: columnIdToDataVariable requires a string parameter");
        }
        
        var columns = this.columns(),
            dv = find("id", id, columns) !== -1 ? columns.at(find("id", id, columns)) : undefined;

        if (dv === undefined) {
            throw new Error("Data: no column with the label " + id);
        }

        return dv;
    });

    this.respondsTo("getColumnId", function (column) {
        if (typeof(column) !== "number") {
            throw new Error("Data: getColumnId method expects an integer");
        }

        var result = find("column", column, this.columns());

        if (result === -1) {
            throw new Error("Data: column " + column + " does not exist");
        }
        
        return this.columns().at(result).id();
    });

    this.respondsTo("getColumns", function () {
        var result = [],
            columns = this.columns(),
            i;

        for (i = 0; i < columns.size(); ++i) {
            result.push(columns.at(i));
        }

        return result;
    });

    this.respondsTo("getBounds", function (columnNumber) {
        // submodels must implement this
    });

    this.respondsTo("getIterator", function () {
        // submodels must implement this
    });

    /*
     * The "onReady" contract:
     * 
     * Each submodel of this Data model should do the following:
     * 
     * 1. Emit an "onReady" event whenever new data is available.
     *    The arguments to the event listener are the min and max
     *    values of the range of (newly) available data.
     * 
     * 2. Optionally, register a listener for its own "listenerAdded"
     *    events, which performs whatever actions are needed, if any,
     *    when a new "onReady" listener is registered.
     */

    this.respondsTo("pause", function() {
        //no op
    });
    this.respondsTo("resume", function() {
        //no op
    });

    this.respondsTo("isMissing", function (value, i) {
        // This method should return true if the DataValue "value" meets the "missing" criteria of
        // the i-th column
        var column;
        if (i < 0 || i >= this.columns().size()) {
            throw new Error("metadata.isMissing(): index out of range");
        }
        column = this.columns().at(i);
        if (!column.missingvalue() || !column.missingop()) {
            return false;
        }
        return value[column.missingop()](column.missingvalue());
    });

    // Sorts variables into appropriate order
    var sortVariables = function (data, sortedVariables, unsortedVariables) {
        var columns = data.columns(),
            column,
            i;
        for (i = 0; i < columns.size(); i++) {
            column = columns.at(i);
            if (column.column() !== undefined) {
                sortedVariables[column.column()] = column;
            } else {
                unsortedVariables.push(column);
            }
        }
    };

    // creates placeholder variables
    var createPlaceholderVariables = function (data, unsortedVariables) {
        var numMissingVariables = data.stringArray()[0].length - data.columns().size(),
            i;
        if (numMissingVariables > 0) {
            for (i = 0; i < numMissingVariables; i++) {
                unsortedVariables.push(null);
            }
        }
    };

    // inserts unsorted variables into the correct location
    var insertUnsortedVariables = function (sortedVariables, unsortedVariables) {
        var index, i;
        for (i = 0, index = 0; i < unsortedVariables.length; i++) {
            while (true) {
                if (sortedVariables[index] === undefined) {
                    break;
                }
                index++;
            }
            sortedVariables[index] = unsortedVariables[i];
        }
    };

    // checks that columns were correctly specified
    var checkColumnIndicies = function (data, sortedVariables) {
        var length = data.stringArray()[0].length,
            i;
        if (sortedVariables.length > length) {
            for (i = 0; i < sortedVariables.length; i++) {
                if (sortedVariables[i] instanceof DataVariable && sortedVariables[i].column() > length) {
                    throw new Error("Data Variable Error: Attempting to specify column '" + sortedVariables[i].column() + "' for a variable, while there are only " + length + " data columns available");
                }
            }                    
        }
    };

    // Handles missing attributes
    // creates the appropriate variables if missing
    var handleMissingAttributes = function (sortedVariables, defaultMissingop, defaultMissingvalue) {
        var defaultid,
            i;
        defaultMissingop = DataValue.parseComparator(defaultMissingop);
        for (i = 0; i < sortedVariables.length; i++) {
            if (!sortedVariables[i]) {
                if (i === 0) {
                    defaultid = "x";
                } else if (i === 1) {
                    defaultid = "y";
                } else {
                    defaultid = "y" + (i-1);
                }
                sortedVariables[i] = new DataVariable(defaultid, i, DataValue.NUMBER);
            } else {
                if (sortedVariables[i].column() === undefined) {
                    sortedVariables[i].column(i);
                }
                if (sortedVariables[i].type() === undefined) {
                    sortedVariables[i].type(DataValue.NUMBER);
                }
            }

            if (defaultMissingvalue !== undefined) {
                if (sortedVariables[i].missingvalue() === undefined) {
                    sortedVariables[i].missingvalue(DataValue.parse(sortedVariables[i].type(), defaultMissingvalue));
                }
            }
            if (sortedVariables[i].missingop() === undefined) {
                sortedVariables[i].missingop(defaultMissingop);
            }
        }
    };

    // Inserts the normalized variables into the data instance
    var insertNormalizedVariables = function (data, sortedVariables) {
        var columns = data.columns(),
            i;
        while (columns.size() > 0) {
            columns.pop();
        }
        for (i = 0; i < sortedVariables.length; i++) {
            columns.add(sortedVariables[i]);
        }
        data.initializeColumns();
    };


    // parses string values into the proper data types
    // If there was actual data, validate that the number of values found in stringArray
    // as large as the the number of variables declared.  ArrayData.textToStringArray(),
    // which is the function that constructed stringArray, has already guaranteed that
    // every row in stringArray is of the same length, so we can use the length of the
    // first row as the number of variables.
    var createDataValueArray = function (data, sortedVariables) {
        var ArrayData = require('./array_data.js');
        var stringArray = data.stringArray();
        if (stringArray.length > 0) {
            if (stringArray[0].length < sortedVariables.length) {
                throw new Error("data contains only " + stringArray[0].length + " column(s), but should contain " + sortedVariables.length);
            }
        }

        var dataValues = ArrayData.stringArrayToDataValuesArray(sortedVariables, stringArray);

        data.array(dataValues);
        data.stringArray([]);
    };

    this.prototype.normalize = function () {
        var ArrayData = require('./array_data.js'),
            sortedVariables   = [],
            unsortedVariables = [],
            //  mbp Tue Mar  3 10:51:40 2015:
            //    avoid requiring web_service_data.js and csv_data.js here because they have
            //    a dependency on jQuery; also avoid instanceof
            //CSVData = require('./csv_data.js'),
            //WebServiceData = require('./web_service_data.js'),
            //isCsvOrWebService = this instanceof CSVData || this instanceof WebServiceData,
            isWebServiceData = (typeof(this.serviceaddress) === "function"),
            isCSVData = (typeof(this.filename) === "function"),
            isCsvOrWebService = isWebServiceData || isCSVData;

        // Handles missing variable tags if the data tag has a 'csv' or 'service' tag
        if (isCsvOrWebService) {
            if (this.columns().size() === 0) {
                throw new Error("Data Normalization: Data gotten from csv and web service sources require variables to be specified in the mugl.");
            }
        }

        sortVariables(this, sortedVariables, unsortedVariables);

        // creates placeholder variables if the data tag has a 'values' tag
        if (this instanceof ArrayData === true && !isCsvOrWebService) {
            createPlaceholderVariables(this, unsortedVariables);
        }

        insertUnsortedVariables(sortedVariables, unsortedVariables);

        // checks that columns were correctly specified for 'values' data tags
        if (this instanceof ArrayData === true && !isCsvOrWebService) {
            checkColumnIndicies(this, sortedVariables);
        }

        handleMissingAttributes(sortedVariables, this.defaultMissingop(), this.defaultMissingvalue());
        insertNormalizedVariables(this, sortedVariables);

        // parses string values into the proper data types if the data tag has a 'values' tag
        if (this instanceof ArrayData === true && !isCsvOrWebService) {
            createDataValueArray(this, sortedVariables);
        }
    };

    this.prototype.ajaxNormalize = function () {
        var sortedVariables   = [],
            unsortedVariables = [];

        sortVariables(this, sortedVariables, unsortedVariables);
        createPlaceholderVariables(this, unsortedVariables);
        insertUnsortedVariables(sortedVariables, unsortedVariables);
        checkColumnIndicies(this, sortedVariables);
        handleMissingAttributes(sortedVariables, this.defaultMissingop(), this.defaultMissingvalue());
        insertNormalizedVariables(this, sortedVariables);
        createDataValueArray(this, sortedVariables);
    };

});

module.exports = Data;

},{"../../lib/jermaine/src/jermaine.js":9,"../core/data_value.js":30,"./array_data.js":17,"./data_variable.js":31,"./event_emitter.js":38}],27:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataValue = require('./data_value.js'),
    NumberFormatter = require('./number_formatter.js'),
    DatetimeFormatter = require('./datetime_formatter.js');

var DataFormatter = {};
/*
 * Return true or false depending on whether obj is an instance of a DataFormatter type
 */
DataFormatter.isInstance = function (obj) {
    return (obj && (typeof(obj.format) === "function") && (typeof(obj.getMaxLength) === "function"));
};

/*
 * Create a new DataFormatter subtype of a given type
 */
DataFormatter.create = function (type, format) {
    if (type === DataValue.NUMBER) {
        return new NumberFormatter(format);
    } else if (type === DataValue.DATETIME) {
        return new DatetimeFormatter(format);
    }
    throw new Error("attempt to create an unknown DataFormatter type");
};

module.exports = DataFormatter;

},{"../../lib/jermaine/src/jermaine.js":9,"./data_value.js":30,"./datetime_formatter.js":34,"./number_formatter.js":49}],28:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataValue = require('./data_value.js'),
    NumberMeasure = require('./number_measure.js'),
    DatetimeMeasure = require('./datetime_measure.js');

var DataMeasure = {};

/*
 * Return true or false depending on whether obj is an instance of a DataMeasure type
 */
DataMeasure.isInstance = function (obj) {
    return (obj && (typeof(obj.getRealValue) === "function") && (!obj.compareTo));
};

/*
 * Create a new DataMeasure subtype of a given type by parsing a string
 */
DataMeasure.parse = function (type, string) {
    if (type === DataValue.NUMBER) {
        return NumberMeasure.parse(string);
    } else if (type === DataValue.DATETIME) {
        return DatetimeMeasure.parse(string);
    }
    throw new Error("attempt to parse an unknown DataMeasure type");
};

module.exports = DataMeasure;

},{"../../lib/jermaine/src/jermaine.js":9,"./data_value.js":30,"./datetime_measure.js":35,"./number_measure.js":50}],29:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Plot = require('./plot.js'),
    DataVariable = require('./data_variable.js'),
    Filter = require('./filter.js'),
    Datatips = require('./datatips.js'),
    Data = require('./data.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot);

var graphCoordsToPixelCoords = function (graphCoords, graph, height) {
    return [
        graphCoords[0] + graph.x0(),
        height - (graphCoords[1] + graph.y0())
    ];
};

var DataPlot = new jermaine.Model("DataPlot", function () {
    this.isA(Plot);
    this.hasMany("variable").eachOfWhich.validateWith(function (variable) {
        return variable instanceof DataVariable || variable === null;
    });
    this.hasA("filter").which.validatesWith(function (filter) {
        return filter instanceof Filter;
    });
    this.hasA("datatips").which.validatesWith(function (datatips) {
        return datatips instanceof Datatips;
    });
    this.hasA("data").which.validatesWith(function (data) {
        return data instanceof Data;
    });

    utilityFunctions.insertDefaults(this, defaultValues.plot, attributes);

    this.respondsTo("render", function (graph, graphicsContext) {
        // graphicsContext is an optional argument passed to DataPlot.render() by the
        // graphics driver, and used by that driver's implementation of Renderer.begin().
        // It can be any objectded by the driver -- usually some kind of graphics
        // context object.  It can also be omitted if a driver does not need it.
        //var data = this.data().arraydata();

        if (!this.visible()) { return; }

        var data = this.data();
        if (! data) { return; }

        var haxis = this.horizontalaxis(),
            vaxis = this.verticalaxis();

        if (!haxis.hasDataMin() || !haxis.hasDataMax()) {
            // if this plot's horizontal axis does not have a min or max value yet,
            // return immediately without doing anything
            return;
        }

        var variables   = this.variable(),
            variableIds = [],
            i;
        for (i = 0; i < variables.size(); ++i) {
            variableIds.push( variables.at(i).id() );
        }

        var iter = data.getIterator(variableIds, haxis.dataMin(), haxis.dataMax(), 1),
            renderer = this.renderer();

        renderer.setUpMissing(); //TODO: this is awkward -- figure out a better way!
        renderer.begin(graphicsContext);
        while (iter.hasNext()) {
            var datap = iter.next();
            renderer.dataPoint(datap);
        }
        renderer.end();

    });


    this.respondsTo("getDatatipsData", function (loc, graphWidth, graphHeight, graph, testElem) {
        var datatips = this.datatips();
        if (!datatips) {
            return;
        }

        var data = this.data();

        if (!data) { return; }

        var haxis = this.horizontalaxis(),
            vaxis = this.verticalaxis();

        if (!haxis.hasDataMin() || !haxis.hasDataMax()) {
            // if this plot's horizontal axis does not have a min or max value yet,
            // return immediately without doing anything
            return;
        }

        var variables   = this.variable(),
            variableIds = [],
            i;

        for (i = 0; i < variables.size(); i++) {
            variableIds.push( variables.at(i).id() );
        }

        var iter        = data.getIterator(variableIds, haxis.dataMin(), haxis.dataMax(), 1),
            renderer    = this.renderer(),
            points      = [],
            x           = loc.x(),
            y           = loc.y(),
            maxDistance = 20,
            curDist,
            datap;

        while (iter.hasNext()) {
            datap = renderer.transformPoint(iter.next());
            curDist = window.multigraph.math.util.l2dist(x, y, datap[0], datap[1]);
            if (curDist < maxDistance) {
                points.push({
                    "datap"  : datap,
                    "dist"   : curDist
                });
            }
        }

        if (points.length === 0) {
            return;
        }

        var minIndex = 0,
            minDist  = points[0].dist;

        // determine index of closest point to mouse
        for (i = 1; i < points.length; i++) {
            if (points[i].dist < minDist) {
                minIndex = i;
                minDist = points[i].dist;
            }
        }

        // cache closest point to mouse
        var point      = points[minIndex],
            axisValues = [];

        // cache data for point
        datap = point.datap;

        // determine pixel location of data point
        point.pixelp = graphCoordsToPixelCoords(datap, graph, graphHeight);

        // determine real DataValues for the datapoint
        axisValues[0] = haxis.axisValueToDataValue(datap[0]);
        for (i = 1; i < datap.length; i++) {
            axisValues[i] = vaxis.axisValueToDataValue(datap[i]);
        }

        var content    = datatips.format(axisValues),
            dimensions = datatips.computeDimensions(content, testElem);

        point.content = content;
        point.dimensions = dimensions;

        // for now just use the first item in the results
        point.type = datatips.computeOrientation(point, graphWidth, graphHeight)[0];

        return point;
    });

    this.respondsTo("createDatatip", function (data) {
        var $           = window.multigraph.jQuery,
            content     = data.content,
            type        = data.type,
            dimensions  = data.dimensions,
            pixelp      = data.pixelp,
            w           = dimensions.width,
            h           = dimensions.height,
            x           = pixelp[0],
            y           = pixelp[1],
            arrowLength = data.arrow,
            offset      = determineOffsets(type, x, y, w, h, arrowLength),
            datatips    = this.datatips(),
            bordercolor = datatips.bordercolor().getHexString("#");

        var box     = $("<div>" + content + "</div>"),
            arrow   = $("<div>&nbsp</div>"),
            datatip = $("<div></div>");

        switch (type) {
        case Datatips.DOWN:
            arrow.css({
                "left"          : ((w/2) - 5) + "px",
                "border-bottom" : arrowLength + "px solid " + bordercolor,
                "border-left"   : "5px solid transparent",
                "border-right"  : "5px solid transparent",
                "border-top"    : "0px"
            });
            datatip.append(arrow);
            datatip.append(box);
            break;
        case Datatips.RIGHT:
            arrow.css({
                "top"           : ((h/2) - 5) + "px",
                "border-bottom" : "5px solid transparent",
                "border-top"    : "5px solid transparent",
                "border-right"  : arrowLength + "px solid " + bordercolor,
                "border-left"   : "0px",
                "float"         : "left"
            });
            box.css("float", "left");
            datatip.append(arrow);
            datatip.append(box);
            break;
        case Datatips.UP:
            arrow.css({
                "left"          : ((w/2) - 5) + "px",
                "border-top"    : arrowLength + "px solid " + bordercolor,
                "border-left"   : "5px solid transparent",
                "border-right"  : "5px solid transparent",
                "border-bottom" : "0px"
            });
            datatip.append(box);
            datatip.append(arrow);
            break;
        case Datatips.LEFT:
            arrow.css({
                "top"           : ((h/2) - 5) + "px",
                "border-bottom" : "5px solid transparent",
                "border-top"    : "5px solid transparent",
                "border-left"   : arrowLength + "px solid " + bordercolor,
                "border-right"  : "0px",
                "float"         : "left"
            });
            box.css("float", "left");
            datatip.append(box);
            datatip.append(arrow);
            break;
        }

        datatip.css({
            "text-align" : "left",
            "position"   : "absolute",
            "clear"      : "both",
            "left"       : offset[0] + "px",
            "top"        : offset[1] + "px",
            "margin"     : "0px",
            "padding"    : "0px"
        });

        box.css({
            "display"          : "inline-block",
            "position"         : "relative",
            "background-color" : datatips.bgcolor().toRGBA(datatips.bgalpha()),
            "text-align"       : "left",
            "margin"           : "0px",
            "padding-left"     : "5px",
            "padding-right"    : "5px",
            "padding-top"      : "1px",
            "padding-bottom"   : "1px",
            "border"           : datatips.border() + "px solid " + bordercolor,
            "border-radius"    : "5px"
        }),

        arrow.css({
            "height"     : "0px",
            "width"      : "0px",
            "position"   : "relative",
            "text-align" : "left",
            "margin"     : "0px",
            "padding"    : "0px"
        });

        return datatip;
    });

    var determineOffsets = function (type, x, y, w, h, arrowLength) {
        switch (type) {
        case Datatips.DOWN:
            return [x - w/2, y];
        case Datatips.RIGHT:
            return [x, y - h/2];
        case Datatips.UP:
            return [x - w/2, y - h - arrowLength];
        case Datatips.LEFT:
            return [x - w - arrowLength, y - h/2];
        }
    };


});

module.exports = DataPlot;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":157,"./data.js":26,"./data_variable.js":31,"./datatips.js":32,"./filter.js":39,"./plot.js":54}],30:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/*
 * DataValue is a POJSO (plain old javascript object) that simply
 * serves as an ecapsulation for several generic
 * data-value-related constants and functions.  There is no actual
 * DataValue model that can be instantiated; all data values are
 * instances of either the NumberValue or DatetimeValue model.
 */

var DataValue = {};

DataValue.NUMBER = "number";
DataValue.DATETIME = "datetime";
DataValue.UNKNOWN = "unknown";

/*
 * Return a list of the type constants above
 */
DataValue.types = function () {
    return [ DataValue.NUMBER, DataValue.DATETIME, DataValue.UNKNOWN ];
};

/*
 * Create a new DataValue subtype of a given type by parsing a string
 */
DataValue.parseType = function (string) {
    if (string.toLowerCase() === DataValue.NUMBER) { return DataValue.NUMBER; }
    if (string.toLowerCase() === DataValue.DATETIME) { return DataValue.DATETIME; }
    throw new Error("unknown DataValue type: " + string);
};

/*
 * This function converts a "type" enum object to a string.  In reality, the objects ARE
 * the strings, so we just return the object.
 */
DataValue.serializeType = function (type) {
    return type;
};

/*
 * Return true or false depending on whether obj is an instance of a DataValue type
 */
DataValue.isInstance = function (obj) {
    return (obj && (typeof(obj.getRealValue) === "function") && (typeof(obj.compareTo) === "function"));
};

/*
 * Same as DataValue.isInstance, but also allows the null value
 */
DataValue.isInstanceOrNull = function (obj) {
    return ((obj===null) || DataValue.isInstance(obj));
};

/*
 * Create a new DataValue subtype of a given type from a real value
 */
DataValue.create = function (type, realValue) {
    var NumberValue = require('./number_value.js'),
        DatetimeValue = require('./datetime_value.js');

    if (type === DataValue.NUMBER) {
        return new NumberValue(realValue);
    } else if (type === DataValue.DATETIME) {
        return new DatetimeValue(realValue);
    }
    throw new Error("attempt to parse an unknown DataValue type");
};

/*
 * Create a new DataValue subtype of a given type by parsing a string
 */
DataValue.parse = function (type, string) {
    var NumberValue = require('./number_value.js'),
        DatetimeValue = require('./datetime_value.js');

    if (type === DataValue.NUMBER) {
        return NumberValue.parse(string);
    } else if (type === DataValue.DATETIME) {
        return DatetimeValue.parse(string);
    }
    throw new Error("attempt to parse an unknown DataValue type");
};

/*
 * Enum values for comparison operators.  These should be lowercase strings --- they're used as
 * actual method names below.
 */
DataValue.LT = "lt";
DataValue.LE = "le";
DataValue.EQ = "eq";
DataValue.GE = "ge";
DataValue.GT = "gt";
DataValue.NE = "ne";

var comparatorFuncs = {};
comparatorFuncs[DataValue.LT] = function (x) { return this.compareTo(x)   < 0; };
comparatorFuncs[DataValue.LE] = function (x) { return this.compareTo(x)  <= 0; };
comparatorFuncs[DataValue.EQ] = function (x) { return this.compareTo(x) === 0; };
comparatorFuncs[DataValue.GE] = function (x) { return this.compareTo(x)  >= 0; };
comparatorFuncs[DataValue.GT] = function (x) { return this.compareTo(x)   > 0; };
comparatorFuncs[DataValue.NE] = function (x) { return this.compareTo(x) !== 0; };

/*
 * Mix the 5 comparator function into another object:
 */
DataValue.mixinComparators = function (obj) {
    obj[DataValue.LT] = comparatorFuncs[DataValue.LT];
    obj[DataValue.LE] = comparatorFuncs[DataValue.LE];
    obj[DataValue.EQ] = comparatorFuncs[DataValue.EQ];
    obj[DataValue.GE] = comparatorFuncs[DataValue.GE];
    obj[DataValue.GT] = comparatorFuncs[DataValue.GT];
    obj[DataValue.NE] = comparatorFuncs[DataValue.NE];
};

/*
 * The comparators function returns a list of the 5 comparator
 * functions, to be used like an enum type.
 */
DataValue.comparators = function () {
    return [ DataValue.LT, DataValue.LE, DataValue.EQ, DataValue.GE, DataValue.GT, DataValue.NE ];
};

/*
 * Convert a string to a comparator enum object:
 */
DataValue.parseComparator = function (string) {
    if (typeof(string) === "string") {
        switch (string.toLowerCase()) {
        case "lt": return DataValue.LT;
        case "le": return DataValue.LE;
        case "eq": return DataValue.EQ;
        case "ge": return DataValue.GE;
        case "gt": return DataValue.GT;
        case "ne": return DataValue.NE;
        }
    }
    throw new Error(string + " should be one of 'lt', 'le', 'eq', 'ge', 'gt', 'ne'.");
};

module.exports = DataValue;

},{"../../lib/jermaine/src/jermaine.js":9,"./datetime_value.js":37,"./number_value.js":51}],31:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataValue = require('./data_value.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.data.variables.variable);

var DataVariable = new jermaine.Model("DataVariable", function () {
    this.hasA("id").which.isA("string");
    this.hasA("column").which.isA("integer");
    this.hasA("type").which.isOneOf(DataValue.types()).and.defaultsTo(DataValue.NUMBER);
    this.hasA("data").which.validatesWith(function (data) {
        var Data = require('./data.js');
        return data instanceof Data;
    });
    this.hasA("missingvalue").which.validatesWith(DataValue.isInstance);

    this.hasA("missingop").which.isOneOf(DataValue.comparators());
    this.isBuiltWith("id", "%column", "%type");

    utilityFunctions.insertDefaults(this, defaultValues.data.variables.variable, attributes);
});

module.exports = DataVariable;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":157,"./data.js":26,"./data_value.js":30}],32:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DatatipsVariable = require('./datatips_variable.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    DataValue = require('./data_value.js'),
    DataFormatter = require('./data_formatter.js'),
    RGBColor = require('../math/rgb_color.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.datatips);

var Datatips = new jermaine.Model("Datatips", function () {
    this.hasMany("variables").eachOfWhich.validateWith(function (variable) {
        return variable instanceof DatatipsVariable;
    });
    this.hasA("formatString").which.isA("string");
    this.hasA("bgcolor").which.validatesWith(function (bgcolor) {
        return bgcolor instanceof RGBColor;
    });
    this.hasA("bgalpha").which.isA("number");
    this.hasA("border").which.isA("integer");
    this.hasA("bordercolor").which.validatesWith(function (bordercolor) {
        return bordercolor instanceof RGBColor;
    });
    this.hasA("pad").which.isA("integer");

    this.respondsTo("format", function (data) {
        var formattedData = [],
            replacementPatterns = [],
            output = this.formatString(),
            i, l = data.length;

        for (i = 0; i < l; i++) {
            formattedData.push(this.variables().at(i).formatter().format(data[i]));
            replacementPatterns.push(new RegExp("\\{" + i + "\\}", "g"));
        }

        for (i = 0; i < l; i++) {
            output = output.replace(replacementPatterns[i], formattedData[i]);
        }

        output = output.replace(/[\n|\r]/g, "<br/>");

        return output;
    });

    this.respondsTo("computeDimensions", function (content, elem) {
        var paddingWidth  = parseInt(elem.css("padding-left"), 10) + parseInt(elem.css("padding-right"), 10),
            paddingHeight = parseInt(elem.css("padding-top"), 10)  + parseInt(elem.css("padding-bottom"), 10),
            border        = 2 * this.border();

        elem.html(content);

        return {
            "width"  : elem.width()  + border + paddingWidth,
            "height" : elem.height() + border + paddingHeight
        };
    });

    this.respondsTo("computeOrientation", function (data, graphWidth, graphHeight) {
        var dimensions    = data.dimensions,
            pixelp        = data.pixelp,
            datatipWidth  = dimensions.width,
            datatipHeight = dimensions.height,
            baseX         = pixelp[0],
            baseY         = pixelp[1],
            offset        = 20,
            offsetWidth   = datatipWidth  + offset,
            offsetHeight  = datatipHeight + offset;

        baseY = graphHeight - baseY; // remove this line when baseY is taken from the lower left corner being the origin

        if ( // center
            baseX       - offsetWidth  >= 0 &&
                graphWidth  - baseX        >= offsetWidth &&
                baseY       - offsetHeight >= 0 &&
                graphHeight - baseY        >= offsetHeight
        ) {
            return [Datatips.UP, Datatips.DOWN, Datatips.RIGHT, Datatips.LEFT];
        } else if ( // top
            baseX       - offsetWidth  >= 0 &&
                graphWidth  - baseX        >= offsetWidth &&
                baseY                      >= graphHeight - offsetHeight &&
                graphHeight                >= baseY
        ) {
            return [Datatips.DOWN, Datatips.RIGHT, Datatips.LEFT, Datatips.UP];
        } else if ( // bottom
            baseX      - offsetWidth >= 0 &&
                graphWidth - baseX       >= offsetWidth &&
                offsetHeight             >= baseY &&
                baseY                    >= 0
        ) {
            return [Datatips.UP, Datatips.RIGHT, Datatips.LEFT, Datatips.DOWN];
        } else if ( // left
            baseX                      >= 0 &&
                offsetWidth                >= baseX &&
                baseY       - offsetHeight >= 0 &&
                graphHeight - baseY        >= offsetHeight
        ) {
            return [Datatips.RIGHT, Datatips.UP, Datatips.DOWN, Datatips.LEFT];
        } else if ( // right
            graphWidth                 >= baseX &&
                offsetWidth                >= graphWidth - baseX &&
                baseY       - offsetHeight >= 0 &&
                graphHeight - baseY        >= offsetHeight
        ) {
            return [Datatips.LEFT, Datatips.UP, Datatips.DOWN, Datatips.RIGHT];
        } else {
            var preferences = [];
            if (baseX < graphWidth / 2) { // left side of graph
                if (baseY > graphHeight / 2) { // top-left corner of graph
                    if (baseX - datatipWidth/2 < (graphHeight - baseY) - datatipHeight/2) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.RIGHT);
                        preferences.push(Datatips.DOWN);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.DOWN);
                        preferences.push(Datatips.RIGHT);
                    }
                    if (baseX - offsetWidth < (graphHeight - baseY) - offsetHeight) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.UP);
                        preferences.push(Datatips.LEFT);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.LEFT);
                        preferences.push(Datatips.UP);
                    }
                } else { // bottom-left corner of graph
                    if (baseX - datatipWidth/2 < baseY - datatipHeight/2) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.RIGHT);
                        preferences.push(Datatips.UP);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.UP);
                        preferences.push(Datatips.RIGHT);
                    }
                    if (baseX - offsetWidth < baseY - offsetHeight) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.DOWN);
                        preferences.push(Datatips.LEFT);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.LEFT);
                        preferences.push(Datatips.DOWN);
                    }
                }
            } else { // right side of graph
                if (baseY > graphHeight / 2) { // top-right corner of graph
                    if ((graphWidth - baseX) - datatipWidth/2 < (graphHeight - baseY) - datatipHeight/2) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.LEFT);
                        preferences.push(Datatips.DOWN);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.DOWN);
                        preferences.push(Datatips.LEFT);
                    }
                    if ((graphWidth - baseX) - offsetWidth < (graphHeight - baseY) - offsetHeight) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.UP);
                        preferences.push(Datatips.RIGHT);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.RIGHT);
                        preferences.push(Datatips.UP);
                    }
                } else { // bottom-right corner of graph
                    if ((graphWidth - baseX) - datatipWidth/2 < baseY - datatipHeight/2) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.LEFT);
                        preferences.push(Datatips.UP);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.UP);
                        preferences.push(Datatips.LEFT);
                    }
                    if ((graphWidth - baseX) - offsetWidth < baseY - offsetWidth) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.DOWN);
                        preferences.push(Datatips.RIGHT);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.RIGHT);
                        preferences.push(Datatips.DOWN);
                    }
                }
            }
            return preferences;
        }
    });



    this.respondsTo("normalize", function (plot) {
        var datatipsVariables = this.variables(),
            plotVariables     = plot.variable(),
            variable,
            type,
            i;

        // creates missing variables for the datatip                                                                                                 
        if (datatipsVariables.size() < plotVariables.size()) {
            for (i = datatipsVariables.size(); i < plotVariables.size(); i++) {
                datatipsVariables.add(new DatatipsVariable());
            }
        }

        // sets up formatters for datatips variables                                                                                                 
        for (i = 0; i < datatipsVariables.size(); i++) {
            variable = datatipsVariables.at(i);
            type = plotVariables.at(i).type();
            if (variable.formatString() === undefined) {
                if (type === DataValue.NUMBER) {
                    variable.formatString(defaultValues["formatString-number"]);
                } else {
                    variable.formatString(defaultValues["formatString-datetime"]);
                }
            }
            variable.formatter(DataFormatter.create(type, variable.formatString()));
        }
    });


    utilityFunctions.insertDefaults(this, defaultValues.plot.datatips, attributes);
});

Datatips.UP    = "u";
Datatips.DOWN  = "d";
Datatips.LEFT  = "l";
Datatips.RIGHT = "r";

module.exports = Datatips;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/rgb_color.js":105,"../util/utilityFunctions.js":157,"./data_formatter.js":27,"./data_value.js":30,"./datatips_variable.js":33}],33:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.datatips.variable),
    DataFormatter = require('./data_formatter.js');

var DatatipsVariable = new jermaine.Model("DatatipsVariable", function () {
    this.hasA("formatString").which.isA("string");
    this.hasA("formatter").which.validatesWith(DataFormatter.isInstance);

    utilityFunctions.insertDefaults(this, defaultValues.plot.datatips.variable, attributes);
});

module.exports = DatatipsVariable;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":157,"./data_formatter.js":27}],34:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var sprintf = require('sprintf');

var DatetimeFormatter = function (format) {
    var testString;
    if (typeof(format) !== "string") {
        throw new Error("format must be a string");
    }
    this.formatString = format;
    testString = DatetimeFormatter.formatInternally(format, new Date(0));
    this.length = testString.length;
};

DatetimeFormatter.prototype.format = function (value) {
    return DatetimeFormatter.formatInternally(this.formatString, value.value);
};

DatetimeFormatter.prototype.getMaxLength = function () {
    return this.length;
};

DatetimeFormatter.prototype.getFormatString = function () {
    return this.formatString;
};

DatetimeFormatter.formatInternally = function (formatString, date) {
    var dayNames = {
        "shortNames": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        "longNames": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
        monthNames = {
            "shortNames": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "longNames": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        },
        state = 0,
        c,
        i,
        t,
        output = "";

    for (i = 0; i < formatString.length; i++) {
        c = formatString.charAt(i);
        switch (state) {
        case 0:
            if (c === "%") {
                state = 1;
            } else {
                output += c;
            }
            break;
        case 1:
            switch (c) {
            case "Y":
                // four digit year
                output += date.getUTCFullYear().toString();
                break;
            case "y":
                // two digit year
                output += date.getUTCFullYear().toString().substr(2, 2);
                break;
            case "M":
                // 2-digit month number with leading zero
                output += sprintf("%02s", (date.getUTCMonth() + 1).toString());
                break;
            case "m":
                // month number without leading zero
                output += (date.getUTCMonth() + 1).toString();
                break;
            case "N":
                // month name, spelled out
                output += monthNames.longNames[date.getUTCMonth()];
                break;
            case "n":
                // month name, 3 letter abbreviation
                output += monthNames.shortNames[date.getUTCMonth()];
                break;
            case "D":
                // two-digit day of month with leading zero
                output += sprintf("%02s", date.getUTCDate().toString());
                break;
            case "d":
                // day of month without leading zero
                output += date.getUTCDate().toString();
                break;
            case "W":
                // weekday name, spelled out
                output += dayNames.longNames[date.getUTCDay()];
                break;
            case "w":
                // weekday name, 3-letter abbreviation
                output += dayNames.shortNames[date.getUTCDay()];
                break;
            case "H":
                // hour of day, 24 hour clock
                output += sprintf("%02s", date.getUTCHours().toString());
                break;
            case "h":
                // hour of day, 12 hour clock
                t = date.getUTCHours() % 12;
                if (t === 0) {
                    output += "12";
                } else {
                    output += t.toString();
                }
                break;
            case "i":
                // minutes
                output += sprintf("%02s", date.getUTCMinutes().toString());
                break;
            case "s":
                // seconds
                output += sprintf("%02s", date.getUTCSeconds().toString());
                break;
            case "v":
                // deciseconds (10ths of a second)
                output += sprintf("%03s", date.getUTCMilliseconds().toString()).substr(0, 1);
                break;
            case "V":
                // centiseconds (100ths of a second)
                output += sprintf("%03s", date.getUTCMilliseconds().toString()).substr(0, 2);
                break;
            case "q":
                // milliseconds (1000ths of a second)
                output += sprintf("%03s", date.getUTCMilliseconds().toString());
                break;
            case "P":
                // AM or PM
                t = date.getUTCHours();
                if (t < 12) {
                    output += "AM";
                } else {
                    output += "PM";
                }
                break;
            case "p":
                // am or pm
                t = date.getUTCHours();
                if (t < 12) {
                    output += "am";
                } else {
                    output += "pm";
                }
                break;
            case "L":
                // newline
                output += "\n";
                break;
            case "%":
                // %
                output += "%";
                break;
            default:
                throw new Error("Invalid character code for datetime formatting string");
            }
            state = 0;
            break;
        }
    }
    return output;
};

module.exports = DatetimeFormatter;

},{"../../lib/jermaine/src/jermaine.js":9,"sprintf":16}],35:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DatetimeValue = require('./datetime_value.js'),
    Enum = require('../math/enum.js');

var DatetimeUnit = require('./datetime_unit.js');

var DatetimeMeasure = function (measure, unit) {
    if (typeof(measure) !== "number" || DatetimeMeasure.isUnit(unit) !== true) {
        throw new Error("Improper input for Datetime Measure's constructor");
    } else if (arguments.length !== 2) {
        throw new Error("Datetime Measure's contructor requires exactly two arguments");
    }
    this.measure = measure;
    this.unit    = unit;
};

DatetimeMeasure.isUnit = function (unit) {
    return DatetimeUnit.isInstance(unit);
};

DatetimeMeasure.prototype.negative = function () {
    return new DatetimeMeasure(-this.measure, this.unit);
};

DatetimeMeasure.prototype.getRealValue = function () {
    var factor;
    switch (this.unit) {
    case DatetimeUnit.MILLISECOND:
        factor = 1;
        break;
    case DatetimeUnit.SECOND:
        factor = 1000;
        break;
    case DatetimeUnit.MINUTE:
        factor = 60000;
        break;
    case DatetimeUnit.HOUR:
        factor = 3600000;
        break;
    case DatetimeUnit.DAY:
        factor = 86400000;
        break;
    case DatetimeUnit.WEEK:
        factor = 604800000;
        break;
    case DatetimeUnit.MONTH:
        factor = 2592000000;
        break;
    case DatetimeUnit.YEAR:
        factor = 31536000000;
        break;
    }
    return this.measure * factor;
};

DatetimeMeasure.parse = function (s) {
    var re, measure, unit;

    if (typeof(s) !== "string" || s.match(/\s*-?(([0-9]+\.?[0-9]*)|([0-9]*\.?[0-9]+))\s*(ms|s|m|H|D|W|M|Y){1}\s*$/) === null) {
        throw new Error("Improper input for Datetime Measure's parse method");
    }

    re      = /ms|s|m|H|D|W|M|Y/;
    measure = parseFloat(s.replace(re, ""));
    unit    = s.match(re); // returns an array

    unit = DatetimeUnit.parse(unit[0]);

    return new DatetimeMeasure(measure, unit);
};

DatetimeMeasure.findTickmarkWithMillisecondSpacing = function (/*number(milliseconds)*/value, /*number(milliseconds)*/alignment, /*number(milliseconds)*/spacing) {
    var offset = value - alignment,
        d      = Math.floor( offset / spacing );
    if (offset % spacing !== 0) {
        ++d;
    }
    return new DatetimeValue(alignment + d * spacing);
};

DatetimeMeasure.findTickmarkWithMonthSpacing = function (/*DatetimeValue*/value, /*DatetimeValue*/alignment, /*number(months)*/monthSpacing) {
    var valueD = value.value,       //NOTE: ".value" property of DatetimeValue is a javascript Date object
        alignD = alignment.value,   //NOTE: ".value" property of DatetimeValue is a javascript Date object
        monthOffset = 12 * (valueD.getUTCFullYear() - alignD.getUTCFullYear()) + (valueD.getUTCMonth() - alignD.getUTCMonth()),
        d = Math.floor( monthOffset / monthSpacing );

    if (monthOffset % monthSpacing !== 0) { ++d; }
    else if (valueD.getUTCDate() > alignD.getUTCDate()) { ++d; }
    else if (valueD.getUTCDate() === alignD.getUTCDate() && valueD.getUTCHours() > alignD.getUTCHours()) { ++d; }
    else if (valueD.getUTCDate() === alignD.getUTCDate() && valueD.getUTCHours() === alignD.getUTCHours() && valueD.getUTCMinutes() > alignD.getUTCMinutes()) { ++d; }
    else if (valueD.getUTCDate() === alignD.getUTCDate() && valueD.getUTCHours() === alignD.getUTCHours() && valueD.getUTCMinutes() === alignD.getUTCMinutes() && valueD.getUTCSeconds() > alignD.getUTCSeconds()) { ++d; }
    else if (valueD.getUTCDate() === alignD.getUTCDate() && valueD.getUTCHours() === alignD.getUTCHours() && valueD.getUTCMinutes() === alignD.getUTCMinutes() && valueD.getUTCSeconds() === alignD.getUTCSeconds() && valueD.getUTCMilliseconds() > alignD.getUTCMilliseconds()) { ++d; }

    return alignment.add( DatetimeMeasure.parse((d * monthSpacing) + "M") );
};


/**
 * Consider the regular lattice of points on the Datetime line separated from each other
 * by `this` DatetimeMeasure, and aligned at the DatetimeValue `alignment`.  This function
 * return the smallest DatetimeValue in that lattice which is greater than or equal to
 * `value`.
 * 
 * return: a DatetimeValue
 */
DatetimeMeasure.prototype.firstSpacingLocationAtOrAfter = function (/*DatetimeValue*/value, /*DatetimeValue*/alignment)  {
    switch (this.unit) {
    case DatetimeUnit.MONTH:
        return DatetimeMeasure.findTickmarkWithMonthSpacing(value, alignment, this.measure);
    case DatetimeUnit.YEAR:
        return DatetimeMeasure.findTickmarkWithMonthSpacing(value, alignment, this.measure * 12);
    default:
        return DatetimeMeasure.findTickmarkWithMillisecondSpacing(value.getRealValue(), alignment.getRealValue(), this.getRealValue());
    }
};

/**
 * This function is just like `firstSpacingLocationAtOrAfter` above, but returns the
 * greatest DatetimeValue in the lattice that is less than or equal to `value`.
 * 
 * return: a DatetimeValue
 */
DatetimeMeasure.prototype.lastSpacingLocationAtOrBefore = function (/*DatetimeValue*/value, /*DatetimeValue*/alignment)  {
    var x = this.firstSpacingLocationAtOrAfter(value, alignment);
    if (x.eq(value)) {
        return x;
    }
    var y = x.add(this.negative());
    return y;
};

DatetimeMeasure.prototype.toString = function () {
    return this.measure.toString() + this.unit.toString();
};


module.exports = DatetimeMeasure;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/enum.js":102,"./datetime_unit.js":36,"./datetime_value.js":37}],36:[function(require,module,exports){
var Enum = require('../math/enum.js');

var DatetimeUnit = new Enum("DatetimeUnit");

DatetimeUnit.MILLISECOND = new DatetimeUnit("ms");
DatetimeUnit.SECOND      = new DatetimeUnit("s");
DatetimeUnit.MINUTE      = new DatetimeUnit("m");
DatetimeUnit.HOUR        = new DatetimeUnit("H");
DatetimeUnit.DAY         = new DatetimeUnit("D");
DatetimeUnit.WEEK        = new DatetimeUnit("W");
DatetimeUnit.MONTH       = new DatetimeUnit("M");
DatetimeUnit.YEAR        = new DatetimeUnit("Y");

module.exports = DatetimeUnit;

},{"../math/enum.js":102}],37:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataValue = require('./data_value.js'),
    DatetimeUnit = require('./datetime_unit.js'),
    sprintf = require('sprintf');

var DatetimeValue = function (value) {
    if (typeof(value) !== "number") {
        throw new Error("DatetimeValue requires its parameter to be a number");
    }
    this.value = new Date(value);
};

DatetimeValue.prototype.getRealValue = function () {
    return this.value.getTime();
};

DatetimeValue.prototype.type = DataValue.DATETIME;

DatetimeValue.prototype.clone = function() {
    return new DatetimeValue(this.getRealValue());
};

DatetimeValue.parse = function (string) {
    var Y = 0,
        M = 0,
        D = 1,
        H = 0,
        m = 0,
        s = 0,
        ms = 0;
    if (typeof(string) === "string") {
        string = string.replace(/[\.\-\:\s]/g, "");
        if (string.length === 4) {
            Y = parseInt(string, 10);
        } else if (string.length === 6) {
            Y = parseInt(string.substring(0,4), 10);
            M = parseInt(string.substring(4,6), 10) - 1;
        } else if (string.length === 8) {
            Y = parseInt(string.substring(0,4), 10);
            M = parseInt(string.substring(4,6), 10) - 1;
            D = parseInt(string.substring(6,8), 10);
        } else if (string.length === 10) {
            Y = parseInt(string.substring(0,4), 10);
            M = parseInt(string.substring(4,6), 10) - 1;
            D = parseInt(string.substring(6,8), 10);
            H = parseInt(string.substring(8,10), 10);
        } else if (string.length === 12) {
            Y = parseInt(string.substring(0,4), 10);
            M = parseInt(string.substring(4,6), 10) - 1;
            D = parseInt(string.substring(6,8), 10);
            H = parseInt(string.substring(8,10), 10);
            m = parseInt(string.substring(10,12), 10);
        } else if (string.length === 14) {
            Y = parseInt(string.substring(0,4), 10);
            M = parseInt(string.substring(4,6), 10) - 1;
            D = parseInt(string.substring(6,8), 10);
            H = parseInt(string.substring(8,10), 10);
            m = parseInt(string.substring(10,12), 10);
            s = parseInt(string.substring(12,14), 10);
        } else if (string.length === 15 || string.length === 16 || string.length === 17) {
            Y  = parseInt(string.substring(0,4), 10);
            M  = parseInt(string.substring(4,6), 10) - 1;
            D  = parseInt(string.substring(6,8), 10);
            H  = parseInt(string.substring(8,10), 10);
            m  = parseInt(string.substring(10,12), 10);
            s  = parseInt(string.substring(12,14), 10);
            ms = parseInt(string.substring(14,17), 10);
        } else if (string === "0") {
            // handles the case of "0", which parser should convert to the Unix epoch
            Y = 1970;
        } else {
            throw new Error("Incorrect input format for Datetime Value's parse method:" + string);
        }
    } else {
        throw new Error("Datetime Value's parse method requires its parameter to be a string");
    }
    return new DatetimeValue(Date.UTC(Y, M, D, H, m, s, ms));
};


DatetimeValue.prototype.toString = function () {
    var Y, M, D, H, m, s, ms;

    Y  = sprintf("%04s", this.value.getUTCFullYear().toString());
    M  = sprintf("%02s", (this.value.getUTCMonth() + 1).toString());
    D  = sprintf("%02s", this.value.getUTCDate().toString());
    H  = sprintf("%02s", this.value.getUTCHours().toString());
    m  = sprintf("%02s", this.value.getUTCMinutes().toString());
    s  = sprintf("%02s", this.value.getUTCSeconds().toString());
    ms = "." + sprintf("%03s", this.value.getUTCMilliseconds().toString());

    if (ms === ".000") {
        ms = "";
    }
    
    return Y + M + D + H + m + s + ms;
};


DatetimeValue.prototype.compareTo = function (x) {
    if (this.getRealValue() < x.getRealValue()) {
        return -1;
    } else if (this.getRealValue() > x.getRealValue()) {
        return 1;
    }
    return 0;
};

DatetimeValue.prototype.addRealValue = function ( realValueIncr ) {
    return new DatetimeValue(this.value.getTime() + realValueIncr);
};

DatetimeValue.prototype.add = function ( /*DataMeasure*/ measure) {
    var date = new DatetimeValue(this.getRealValue());
    switch (measure.unit) {
    case DatetimeUnit.MILLISECOND:
        date.value.setUTCMilliseconds(date.value.getUTCMilliseconds() + measure.measure);
        break;
    case DatetimeUnit.SECOND:
        date.value.setUTCSeconds(date.value.getUTCSeconds() + measure.measure);
        break;
    case DatetimeUnit.MINUTE:
        date.value.setUTCMinutes(date.value.getUTCMinutes() + measure.measure);
        break;
    case DatetimeUnit.HOUR:
        date.value.setUTCHours(date.value.getUTCHours() + measure.measure);
        break;
    case DatetimeUnit.DAY:
        date.value.setUTCDate(date.value.getUTCDate() + measure.measure);
        break;
    case DatetimeUnit.WEEK:
        date.value.setUTCDate(date.value.getUTCDate() + measure.measure * 7);
        break;
    case DatetimeUnit.MONTH:
        date.value.setUTCMonth(date.value.getUTCMonth() + measure.measure);
        break;
    case DatetimeUnit.YEAR:
        date.value.setUTCFullYear(date.value.getUTCFullYear() + measure.measure);
        break;
    }
    return date;
};

DataValue.mixinComparators(DatetimeValue.prototype);

module.exports = DatetimeValue;

},{"../../lib/jermaine/src/jermaine.js":9,"./data_value.js":30,"./datetime_unit.js":36,"sprintf":16}],38:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/**
 * EventEmitter is a Jermaine model that supports basic event emitting /
 * handling for Jermaine objects.
 *
 * Events are represented as plain old JavaScript objects with at least
 * the following two properties:
 *
 *   **type**
 *
 *   > a string giving the type of the event; this can be any
 *     arbitrary string.  The event type is not restricted to be
 *     from some predetermined list; applications are free to
 *     use whatever strings they want for their event types.
 *
 *   **target**
 *
 *   > a reference to the object that emitted the event
 *
 * Event objects may also contain arbitrary other properties that are specific to
 * a particular event type.
 *
 * Any Jermaine model can declare itself to be an event emitter by saying
 * "this.isA(EventEmitter)" in its model declaration.
 *
 * This adds three methods to the model:
 *  
 *   **addListener(eventType, listenerFunction)**
 *
 *   > Registers listenerFunction as a listener for events of type
 *     eventType (a string).  listenerFunction should be a function
 *     that accepts a single argument which will be a reference to an
 *     event object as described above.  When the object emits the
 *     event, the listener function will be invoked in the context
 *     where its "this" keyword refers to the object that emitted the
 *     event (the event target).  If listenerFunction is already
 *     registered as a listener for eventType, this function does
 *     nothing --- each listener function can be registered only once.
 *
 *   **removeListener(eventType, listenerFunction)**
 *
 *   > Removes the given listenerFunction from the list of listeners
 *     for this object for events of type eventType.
 *
 *   **emit(event)**
 *
 *   > Causes the object to emit the given event.  The argument can be
 *     either a string, in which case it is assumed to be an event type
 *     and is converted to an event object with the given 'type'
 *     property, or an event object with a 'type' property and any
 *     other desired properties.  The emit() method automatically adds
 *     a 'target' property to the event object, whose value is a
 *     reference to the object emitting the event.
 *
 * In most cases the emit() method is only called from within the
 * implementation of an EventEmitter object, and code external to the
 * object's model will use its addListener() and removeListener() methods
 * to process events that the object emits.  All three of these methods
 * are public methods, though, so it's also possible for code outside of
 * an object's implementation to cause it to emit an event, or for the
 * object's own code to listen for and process its own events.
 *
 * Two special types of events are always present for every EventEmitter
 * object: the "listenerAdded" and "listenerRemoved" events.  These
 * events make it possible to monitor the addition or removal of event
 * listeners.  The "listenerAdded" event is emitted whenever a new
 * listener function is added, and the "listenerRemoved" event is emitted
 * whenever a listener is removed.  Each of these events contain the
 * following properties:
 *
 *   **targetType**
 *
 *   > the event type associated with the listener
 *     being added or removed
 *
 *   **listener**
 *
 *   > the listener function being added or removed
 *
 * @class EventEmitter
 * @for EventEmitter
 * @constructor
 * @example
 *     var Person = new jermaine.Model(function() {
 *         this.isA(EventEmitter);
 *         this.hasA("name").which.isA("string");
 *         this.respondsTo("say", function(something) {
 *             console.log(this.name() + ' says ' + something);
 *             this.emit({type : "say", message : something});
 *         });
 *     });
 *     var person = new Person().name("Mark");
 *
 *     var sayListener = function(event) {
 *         console.log(event.target.name() + ' said ' + event.message);
 *     };
 *
 *     person.say('Hello');
 *     person.addListener("say", sayListener);
 *     person.say('Alright');
 *     person.removeListener("say", sayListener);
 *     person.say('Goodbye');
 *
 *
 *     OUTPUT:
 *
 *         Mark says Hello
 *         Mark says Alright
 *         Mark said Alright
 *         Mark said Goodbye
 */
var EventEmitter = new jermaine.Model(function () {
    // listeners is a plain old JS object whose keys are events
    // types (strings); the value associated with each key is the
    // list of registered listener functions for that event type.
    this.hasA("listeners").which.defaultsTo( function() {
        // Use a function that returns an empty object as the
        // default value, so we get a new listeners object
        // created for each EventEmitter instance.
        return {};
    });

    /**
     * Adds a listener function for events of a specific type
     * emitted by this object.
     * 
     * @method addListener
     * @param {string} eventType the type of event
     * @param {function} listener a listener function
     * @return {boolean} a value indicating whether the listener
     *         was actually added (a listener is not added if it
     *         is already registered for the eventType)
     */
    this.respondsTo("addListener", function (eventType, listener) {
        var listeners = this.listeners(),
            i;

        if (listeners[eventType] === undefined) {
            listeners[eventType] = [];
        }
        for (i=0; i<listeners[eventType].length; ++i) {
            if (listeners[eventType][i] === listener) {
                return false;
            }
        }
        listeners[eventType].push(listener);
        this.emit({ type       : "listenerAdded",
                    targetType : eventType,
                    listener   : listener});
        return true;
    });

    /**
     * Removes a listener function for events of a specific type
     * emitted by this object.
     * 
     * @method removeListener
     * @param {string} eventType the type of event
     * @param {function} listener the listener function to remove
     * @return {boolean} a value indicating whether the listener
     *         was actually removed.
     */
    this.respondsTo("removeListener", function (eventType, listener) {
        var listeners = this.listeners(),
            i;

        if (listeners[eventType] !== undefined) {
            for (i=0; i<listeners[eventType].length; ++i) {
                if (listeners[eventType][i] === listener) {
                    listeners[eventType][i] = null;
                    this.emit({ type       : "listenerRemoved",
                                targetType : eventType,
                                listener   : listener});
                    return true;
                }
            }
        }
        return false;
    });

    /**
     * Call this objects listeners for a specific event.  If the "event"
     * argument is a string, it is converted to an Object having
     * that string as the value of its "type" attribute; otherwise
     * the "event" argument should be an event Object having a
     * "type" attribute and any other attributes approriate for
     * that event type.  In either case, all (if there are any) of
     * the current listeners on this object for events of the
     * given type will be invoked, being passed an event object.
     * 
     * @method emit
     * @param {Object|string} event either a string representing an event type, or an event
     *                                 object with a 'type' attribute.
     * @return (nothing)
     */
    this.respondsTo("emit", function (event) {
        var listeners,
            i,
            nulls = [];

        if (typeof(event) === "string") {
            event = { type : event };
        }
        if (!event.target) {
            event.target = this;
        }
        if (!event.type) {
            throw new Error("Event object missing 'type' property");
        }

        listeners = this.listeners()[event.type];

        if (!listeners) {
            // no listeners registered for this event type
            return;
        }

        // call all the listeners for this event type, except for
        // nulls, which we keep track of
        for (i = 0; i < listeners.length; i++) {
            if (listeners[i] !== null) {
                listeners[i].call(this, event);
            } else {
                nulls.push(i);
            }
        }

        // remove any nulls from the listeners list; work from the end
        // of the list backwards so that removing an item doesn't change
        // the index of other items to be removed
        if (nulls.length > 0) {
            for (i=nulls.length-1; i>=0; --i) {
                listeners.splice(nulls[i],1);
            }
        }

    });


});

module.exports = EventEmitter;

},{"../../lib/jermaine/src/jermaine.js":9}],39:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var FilterOption = require('./filter_option.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.filter);

var Filter = new jermaine.Model("Filter", function () {
    this.hasMany("options").eachOfWhich.validatesWith(function (option) {
        return option instanceof FilterOption;
    });
    this.hasA("type").which.validatesWith(function (type) {
        return typeof(type) === "string";
    });

    utilityFunctions.insertDefaults(this, defaultValues.plot.filter, attributes);
});

module.exports = Filter;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":157,"./filter_option.js":40}],40:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.filter.option);

var FilterOption = new jermaine.Model("FilterOption", function () {
    this.hasA("name").which.validatesWith(function (name) {
        return typeof(name) === "string";
    });
    this.hasA("value").which.validatesWith(function (value) {
        return typeof(value) === "string";
    });

    utilityFunctions.insertDefaults(this, defaultValues.plot.filter.option, attributes);
});

module.exports = FilterOption;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":157}],41:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Axis = require('./axis.js'),
    Background = require('./background.js'),
    Data = require('./data.js'),
    Legend = require('./legend.js'),
    Plot = require('./plot.js'),
    Plotarea = require('./plotarea.js'),
    Title = require('./title.js'),
    Window = require('./window.js'),
    Box = require('../math/box.js'),
    DataPlot = require('../core/data_plot.js'),
    AxisBinding = require('../core/axis_binding.js'),
    varaible_id_regex = /^([^\.]+)\.(.+)$/;


/**
 * The Graph Jermaine model controls the properties for an individual Graph.
 *
 * @class Graph
 * @for Graph
 * @constructor
 */
var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues);

var Graph = new jermaine.Model("Graph", function () {
    /**
     * Child model which controls the properties of the Graph's Window.
     *
     * @property window
     * @type {Window}
     * @author jrfrimme
     */
    this.hasA("window").which.validatesWith(function (w) {
        return w instanceof Window;
    });
    /**
     * Child model which controls the properties of the Graph's Plotarea.
     *
     * @property plotarea
     * @type {Plotarea}
     * @author jrfrimme
     */
    this.hasA("plotarea").which.validatesWith(function (plotarea) {
        return plotarea instanceof Plotarea;
    });


    /**
     * Child model which controls the properties of the Graph's Legend.
     *
     * @property legend
     * @type {Legend}
     * @author jrfrimme
     */
    this.hasA("legend").which.validatesWith(function (legend) {
        return legend instanceof Legend;
    });
    /**
     * Child model which controls the properties of the Graph's Background.
     *
     * @property background
     * @type {Background}
     * @author jrfrimme
     */
    this.hasA("background").which.validatesWith(function (background) {
        return background instanceof Background;
    });

    /**
     * Child model which controls the properties of the Graph's Title.
     *
     * @property title
     * @type {Title}
     * @author jrfrimme
     */
    this.hasA("title").which.validatesWith(function (title) {
        return title instanceof Title;
    });
    /**
     * Jermaine Attr_List of the Graph's Axes.
     *
     * @property axes
     * @type {Axis}
     * @author jrfrimme
     */
    this.hasMany("axes").eachOfWhich.validateWith(function (axis) {
        return axis instanceof Axis;
    });
    /**
     * Jermiane Attr_List of the Graph's Plots.
     *
     * @property plots
     * @type {Plot}
     * @author jrfrimme
     */
    this.hasMany("plots").eachOfWhich.validateWith(function (plot) {
        return plot instanceof Plot;
    });
    /**
     * Jermiane Attr_List of the Graph's Data sets.
     *
     * @property data
     * @type {Data}
     * @author jrfrimme
     */
    this.hasMany("data").eachOfWhich.validateWith(function (data) {
        return data instanceof Data;
    });

    /**
     * Stores the computed width and height of the Graph's windowBox.
     *
     * @property windowBox
     * @type {}
     * @author jrfrimme
     */
    this.hasA("windowBox").which.validatesWith(function (val) {
        return val instanceof Box;
    });
    /**
     * Stores the computed width and height of the Graph's paddingBox.
     *
     * @property paddingBox
     * @type {}
     * @author jrfrimme
     */
    this.hasA("paddingBox").which.validatesWith(function (val) {
        return val instanceof Box;
    });
    /**
     * Stores the computed width and height of the Graph's plotBox.
     *
     * @property plotBox
     * @type {}
     * @author jrfrimme
     */
    this.hasA("plotBox").which.validatesWith(function (val) {
        return val instanceof Box;
    });

    /**
     * The containing Multigraph object
     *
     * @property multigraph
     * @type {}
     * @author mbp
     */
    this.hasA("multigraph").which.validatesWith(function (val) {
        //avoid using instanceof, so we don't have to require('multigraph.js') above!!!
        //return val instanceof Multigraph;
        //Just check for busySpinnerLevel function, since that's the part of the
        //multigraph that we use (duck typing).
        return (typeof(val.busySpinnerLevel) == "function");
    });

    this.hasA("x0").which.isA("number");
    this.hasA("y0").which.isA("number");

    this.hasA("filter").which.validatesWith(function(filter) {
        return ((typeof(filter) === 'undefined')
                ||
                ((typeof(filter.reset) === 'function') && (typeof(filter.filter) === 'function')));
    });

    this.isBuiltWith(function () {
        this.window( new Window() );
        this.plotarea( new Plotarea() );
        this.background( new Background() );
    });

    this.respondsTo("postParse", function () {
        var i,
            that = this,
            handleAjaxEvent = function(event) {
                if (event.action === 'start') {
                    if (that.multigraph()) {
                        that.multigraph().busySpinnerLevel(1);
                    }
                } else if (event.action === 'complete') {
                    if (that.multigraph()) {
                        that.multigraph().busySpinnerLevel(-1);
                    }
                }
            };

        for (i=0; i<this.data().size(); ++i) {
            this.data().at(i).addListener("ajaxEvent", handleAjaxEvent);
        }
    });

    /**
     * Initializes the Graph's geometry. Determines the width and height of the Graph's `windowBox`,
     * `paddingBox` and `plotBox`; calls its Axes' and Legend's implementations of
     * `initializeGeometry`.
     *
     * @method initializeGeometry
     * @param {Integer} width Width of the multigraph's div
     * @param {Integer} height Height of the multigraph's div
     * @param {Object} graphicsContext
     * @author jrfrimme
     */
    this.respondsTo("initializeGeometry", function (width, height, graphicsContext) {
        var w              = this.window(),
            windowBorder   = w.border(),
            windowMargin   = w.margin(),
            windowPadding  = w.padding(),
            plotarea       = this.plotarea(),
            plotareaBorder = plotarea.border(),
            plotareaMargin = plotarea.margin(),
            i;

        this.windowBox( new Box(width, height) );
        this.paddingBox( new Box(
            ( width -
              ( windowMargin.left()  + windowBorder + windowPadding.left() ) -
              ( windowMargin.right() + windowBorder + windowPadding.right() )
            ),
            ( height -
              ( windowMargin.top()    + windowBorder + windowPadding.top() ) -
              ( windowMargin.bottom() + windowBorder + windowPadding.bottom() )
            )
        )
                       );
        this.plotBox( new Box(
            (
                this.paddingBox().width() -
                    ( plotareaMargin.left() + plotareaMargin.right() + (2 * plotareaBorder))
            ),
            (
                this.paddingBox().height() -
                    ( plotareaMargin.top() + plotareaMargin.bottom() + (2 * plotareaBorder))
            )
        )
                    );
        for (i = 0; i < this.axes().size(); ++i) {
            this.axes().at(i).initializeGeometry(this, graphicsContext);
        }
        if (this.legend()) {
            this.legend().initializeGeometry(this, graphicsContext);
        }
        if (this.title()) {
            this.title().initializeGeometry(graphicsContext);
        }

        this.x0( windowMargin.left()   + windowBorder + windowPadding.left()   + plotareaMargin.left()   + plotareaBorder );
        this.y0( windowMargin.bottom() + windowBorder + windowPadding.bottom() + plotareaMargin.bottom() + plotareaBorder );
    });

    /**
     * Convience function for registering callback functions on the Graph's `Data` models. Adds
     * `dataReady` event listeners to each of the Graph's `Data` models.
     *
     * @method registerCommonDataCallback
     * @param {Function} callback
     * @author jrfrimme
     */
    this.respondsTo("registerCommonDataCallback", function (callback) {
        var i;
        for (i = 0; i < this.data().size(); ++i) {
            this.data().at(i).addListener("dataReady", callback);
        }
    });

    /**
     * 
     *
     * @method pauseAllData
     * @author jrfrimme
     */
    this.respondsTo("pauseAllData", function () {
        var i;
        // pause all this graph's data sources:
        for (i = 0; i < this.data().size(); ++i) {
            this.data().at(i).pause();
        }
    });

    /**
     * 
     *
     * @method resumeAllData
     * @author jrfrimme
     */
    this.respondsTo("resumeAllData", function () {
        var i;
        // resume all this graph's data sources:
        for (i = 0; i < this.data().size(); ++i) {
            this.data().at(i).resume();
        }
    });

    /**
     * @method findNearestAxis
     * @param {} x
     * @param {} y
     * @param {} orientation
     * @author jrfrimme
     */
    this.respondsTo("findNearestAxis", function (x, y, orientation) {
        var foundAxis = null,
            mindist = 9999,
            axes = this.axes(),
            naxes = this.axes().size(),
            axis,
            i,
            d;
        for (i = 0; i < naxes; ++i) {
            axis = axes.at(i);
            if (!axis.visible()) { continue; }
            if ((orientation === undefined) ||
                (orientation === null) ||
                (axis.orientation() === orientation)) {
                d = axis.distanceToPoint(x, y);
                if (foundAxis === null || d < mindist) {
                    foundAxis = axis;
                    mindist = d;
                }
            }
        }
        return foundAxis;
    });

    this.respondsTo("axisById", function (id) {
        // return a pointer to the axis for this graph that has the given id, if any
        var axes = this.axes(),
            i;
        for (i = 0; i < axes.size(); ++i) {
            if (axes.at(i).id() === id) {
                return axes.at(i);
            }
        }
        return undefined;
    });


    this.respondsTo("dataById", function(id) { // 'id' is a string id of a data object
        // Return a reference to the data object associated with the given graph having the given id
        var datas = this.data(),
            data;
        for (i = 0; i < datas.size(); ++i) {
            data = datas.at(i);
            if (data.id() === id) {
                return data;
            }
        }
        return undefined;
    });

    this.respondsTo("variableById", function (id) {
        // return a pointer to the variable for this graph that has the given id, if any
        var datas,
            re = /^([^\.]+)\.(.+)$/,
            m = id.match(re),
            data_id,
            var_id,
            data,
            columns,
            i, j;

        if (m) {
            data_id = m[1];
            var_id = m[2];
            data = this.dataById(data_id);
            return data.columnIdToDataVariable(var_id);
        } else {
            datas = this.data();
            for (i = 0; i < datas.size(); ++i) {
                columns = datas.at(i).columns();
                for (j = 0; j < columns.size(); ++j) {
                    if (columns.at(j).id() === id) {
                        return columns.at(j);
                    }
                }
            }
            return undefined;
        }
    });

    this.respondsTo("destroy", function() {
        var i;
        for (i = 0; i < this.axes().size(); ++i) {
            this.axes().at(i).destroy();
        }
    });

    this.respondsTo("normalize", function () {
        var HORIZONTAL = Axis.HORIZONTAL,
            VERTICAL   = Axis.VERTICAL,
            axes  = this.axes(),
            plots = this.plots(),
            i, j,
            haxisCount = 0,
            vaxisCount = 0,
            axis,
            axisid,
            plot;

        //
        // normalizes the data sections
        //
        for (i = 0; i < this.data().size(); i++) {
            this.data().at(i).normalize();
        }

        //
        // Handles missing horizontalaxis and vertical axis tags
        //
        for (i = 0; i < axes.size(); i++) {
            if (axes.at(i).orientation() === HORIZONTAL) {
                haxisCount++;
            } else if (axes.at(i).orientation() === VERTICAL) {
                vaxisCount++;
            }
        }

        if (haxisCount === 0) {
            axes.add(new Axis(HORIZONTAL));
        }
        if (vaxisCount === 0) {
            axes.add(new Axis(VERTICAL));
        }

        //
        // Handles missing id's for axes
        //
        haxisCount = 0;
        vaxisCount = 0;
        for (i = 0; i < axes.size(); i++) {
            axis = axes.at(i);
            if (axis.orientation() === HORIZONTAL) {
                axisid = "x";
                if (haxisCount > 0) {
                    axisid += haxisCount;
                }
                haxisCount++;
            } else if (axis.orientation() === VERTICAL) {
                axisid = "y";
                if (vaxisCount > 0) {
                    axisid += vaxisCount;
                }
                vaxisCount++;
            }

            if (axis.id() === undefined) {
                axis.id(axisid);
            }
        }

        //
        // normalizes the rest of the axis properties
        //
        for (i = 0; i < axes.size(); i++) {
            axes.at(i).normalize(this);
        }

        //
        // handles missing plot tags
        //
        if (plots.size() === 0) {
            plots.add(new DataPlot());
        }

        //
        // normalizes the plots
        //
        for (i = 0; i < plots.size(); i++) {
            plots.at(i).normalize(this);
        }

        //
        // normalizes the legend
        //
        if (this.legend()) {
            this.legend().normalize(this);
        }

        //
        // execute the setDataRange method for each axis binding, to sync up all axes
        // that participate in the binding (this takes care of setting dataMin/dataMax
        // for any axes that don't have them already but which are bound to axes that
        // do have them)
        // 
        AxisBinding.syncAllBindings();

        //
        // arrange to set missing axis min/max values when data is ready, if necessary
        // 
        for (i = 0; i < axes.size(); i++) {
            // for each axis...
            axis = axes.at(i);
            if (!axis.hasDataMin() || !axis.hasDataMax()) {
                // if this axis is mising either a dataMin() or dataMax() value...
                for (j = 0; j < plots.size(); ++j) {
                    // find a DataPlot that references this axis...
                    plot = plots.at(j);
                    if (plot instanceof DataPlot && (plot.horizontalaxis() === axis || plot.verticalaxis() === axis)) {
                        // ... and then register a dataReady listener for this plot's data section which sets the
                        // missing bound(s) on the axis once the data is ready.  Do this inside a closure so that we
                        // can refer to a pointer to our dynamically-defined listener function from inside itself,
                        // so that we can de-register it once it is called; this is done via the the local variable
                        // axisBoundsSetter.  The closure also serves to capture the current values, via arguments,
                        // of the axis pointer, a pointer to the data object, and a boolean (isHorizontal) that
                        // indicates whether the axis is the plot's horizontal or vertical axis.
                        (function (axis, data, isHorizontal) {
                            var axisBoundsSetter = function (event) {
                                var columnNumber = isHorizontal ? 0 : 1,
                                    bounds = data.getBounds(columnNumber),
                                    min = axis.dataMin(),
                                    max = axis.dataMax();
                                if (!axis.hasDataMin()) {
                                    min = bounds[0];
                                }
                                if (!axis.hasDataMax()) {
                                    max = bounds[1];
                                }
                                if (!axis.hasDataMin() || !axis.hasDataMax()) {
                                    axis.setDataRange(min, max);
                                }
                                data.removeListener('dataReady', axisBoundsSetter);
                            };
                            data.addListener('dataReady', axisBoundsSetter);
                        }(axis,                             // axis
                          plot.data(),                      // data
                          plot.horizontalaxis() === axis    // isHorizontal
                         ));
                        break; // for (j=0; j < this.plots().size(); ++j)...
                    }
                }
            }
        }



    });

    utilityFunctions.insertDefaults(this, defaultValues, attributes);
});

module.exports = Graph;

},{"../../lib/jermaine/src/jermaine.js":9,"../core/axis_binding.js":19,"../core/data_plot.js":29,"../math/box.js":100,"../util/utilityFunctions.js":157,"./axis.js":18,"./background.js":21,"./data.js":26,"./legend.js":46,"./plot.js":54,"./plotarea.js":56,"./title.js":65,"./window.js":70}],42:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var RGBColor = require('../math/rgb_color.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.horizontalaxis.grid);

var Grid = new jermaine.Model("Grid", function () {
    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    });
    this.hasA("visible").which.isA("boolean");

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis.grid, attributes);
});

module.exports = Grid;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/rgb_color.js":105,"../util/utilityFunctions.js":157}],43:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.legend.icon);

var Icon = new jermaine.Model("Icon", function () {
    this.hasA("height").which.isA("integer");
    this.hasA("width").which.isA("integer");
    this.hasA("border").which.isA("integer");

    utilityFunctions.insertDefaults(this, defaultValues.legend.icon, attributes);
});

module.exports = Icon;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":157}],44:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Point = require('../math/point.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.background.img);

var Img = new jermaine.Model("Img", function () {
    this.hasA("src").which.isA("string");
    this.hasA("anchor").which.validatesWith(function (anchor) {
        return anchor instanceof Point;
    });
    this.hasA("base").which.validatesWith(function (base) {
        return base instanceof Point;
    });
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });
    this.hasA("frame").which.validatesWith(function (frame) {
        return frame === Img.PADDING || frame === Img.PLOT;
    });
    this.isBuiltWith("src");

    utilityFunctions.insertDefaults(this, defaultValues.background.img, attributes);
});

Img.PADDING = "padding";
Img.PLOT    = "plot";

module.exports = Img;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/point.js":104,"../util/utilityFunctions.js":157}],45:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataValue = require('./data_value.js'),
    DataFormatter = require('./data_formatter.js'),
    DataMeasure = require('./data_measure.js'),
    Point = require('../math/point.js'),
    RGBColor = require('../math/rgb_color.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.horizontalaxis.labels.label);

var Labeler = new jermaine.Model("Labeler", function () {

    var getValue = function (valueOrFunction) {
        if (typeof(valueOrFunction) === "function") {
            return valueOrFunction();
        } else {
            return valueOrFunction;
        }
    };

    this.hasA("axis").which.validatesWith(function (axis) {
        var Axis = require('./axis.js');
        return axis instanceof Axis;
    });
    this.hasA("formatter").which.validatesWith(DataFormatter.isInstance);
    this.hasA("font").which.isA("string").and.which.defaultsTo("");
    this.hasA("start").which.validatesWith(DataValue.isInstance);
    this.hasA("angle").which.isA("number");
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });
    this.hasA("anchor").which.validatesWith(function (anchor) {
        return anchor instanceof Point;
    });
    this.hasA("spacing").which.validatesWith(DataMeasure.isInstance);
    this.hasA("densityfactor").which.isA("number").and.which.defaultsTo(1.0);

    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    });

    this.hasA("visible").which.isA("boolean").and.which.defaultsTo(true);

    this.isBuiltWith("axis", function () {
        var labelsDefaults = defaultValues.horizontalaxis.labels;
        if (this.axis().type() === DataValue.DATETIME) {
            this.start( getValue(labelsDefaults['start-datetime']) );
        } else {
            this.start( getValue(labelsDefaults['start-number']) );
        }
    });

    this.respondsTo("initializeGeometry", function (graph) {
        var axis    = this.axis(),
            plotBox = graph.plotBox(),
            labelDefaults = defaultValues.horizontalaxis.labels.label,
            Axis = require('./axis.js');

        if (this.position() === undefined) {
            if (axis.orientation() === Axis.HORIZONTAL) {
                if (axis.perpOffset() > plotBox.height()/2) {
                    this.position( getValue(labelDefaults["position-horizontal-top"]) );
                } else {
                    this.position( getValue(labelDefaults["position-horizontal-bottom"]) );
                }
            } else {
                if (axis.perpOffset() > plotBox.width()/2) {
                    this.position( getValue(labelDefaults["position-vertical-right"]) );
                } else {
                    this.position( getValue(labelDefaults["position-vertical-left"]) );
                }
            }
        }

        if (this.anchor() === undefined) {
            if (axis.orientation() === Axis.HORIZONTAL) {
                if (axis.perpOffset() > plotBox.height()/2) {
                    this.anchor( getValue(labelDefaults["anchor-horizontal-top"]) );
                } else {
                    this.anchor( getValue(labelDefaults["anchor-horizontal-bottom"]) );
                }
            } else {
                if (axis.perpOffset() > plotBox.width()/2) {
                    this.anchor( getValue(labelDefaults["anchor-vertical-right"]) );
                } else {
                    this.anchor( getValue(labelDefaults["anchor-vertical-left"]) );
                }
            }
        }
    });

    this.respondsTo("isEqualExceptForSpacing", function (labeler) {
        // return true iff the given labeler and this labeler are equal in every way
        // except for their spacing values
        return ((this.axis()                         ===   labeler.axis()                            ) &&
                (this.formatter().getFormatString()  ===   labeler.formatter().getFormatString()     ) &&
                (this.start()                        .eq(  labeler.start()                         ) ) &&
                (this.angle()                        ===   labeler.angle()                           ) &&
                (this.position()                     .eq(  labeler.position()                      ) ) &&
                (this.anchor()                       .eq(  labeler.anchor()                        ) ) &&
                (this.densityfactor()                ===   labeler.densityfactor()                   )
               );
    });


    this.hasA("iteratorNextValue").which.validatesWith(DataValue.isInstanceOrNull).and.which.defaultsTo(null);
    this.hasA("iteratorMinValue").which.validatesWith(DataValue.isInstance);
    this.hasA("iteratorMaxValue").which.validatesWith(DataValue.isInstance);

    this.respondsTo("prepare", function (minDataValue, maxDataValue) {
        this.iteratorMinValue(minDataValue);
        this.iteratorMaxValue(maxDataValue);
        this.iteratorNextValue( this.spacing().firstSpacingLocationAtOrAfter(minDataValue, this.start()) );
    });

    this.respondsTo("hasNext", function () {
        var value = this.iteratorNextValue();
        if (value === null || value === undefined) {
            return false;
        }
        return value.le(this.iteratorMaxValue());
    });

    this.respondsTo("peekNext", function () {
        var value    = this.iteratorNextValue(),
            maxValue = this.iteratorMaxValue();
        if (value === null || value === undefined) {
            return undefined;
        }
        if (maxValue !== undefined && value.gt(maxValue)) {
            return undefined;
        }
        return value;
    });

    this.respondsTo("next", function () {
        var value = this.iteratorNextValue(),
            maxValue = this.iteratorMaxValue();
        if (value === null || value === undefined) {
            return undefined;
        }
        if (maxValue !== undefined && value.gt(maxValue)) {
            return undefined;
        }
        this.iteratorNextValue( value.add( this.spacing() ) );
        return value;
    });

    this.respondsTo("getLabelDensity", function (graphicsContext) {
        var axis                      = this.axis(),
            pixelSpacing              = this.spacing().getRealValue() * axis.axisToDataRatio(),
            minRealValue              = axis.dataMin().getRealValue(),
            maxRealValue              = axis.dataMax().getRealValue(),
            representativeRealValue   = minRealValue + 0.51234567 * (maxRealValue - minRealValue),
            representativeValue       = DataValue.create(axis.type(), representativeRealValue ),
            representativeValueString = this.formatter().format(representativeValue),
            Axis                      = require('./axis.js');

        // length of the formatted axis representative value, in pixels
        var pixelFormattedValue = (
            (axis.orientation() === Axis.HORIZONTAL) ?
                this.measureStringWidth(graphicsContext, representativeValueString) :
                this.measureStringHeight(graphicsContext, representativeValueString)
        );
        // return the ratio -- the fraction of the spacing taken up by the formatted string
        return pixelFormattedValue / ( pixelSpacing * this.densityfactor() );
    });


    this.respondsTo("measureStringWidth", function (graphicsContext, string) {
        // Graphics drivers should replace this method with an actual implementation; this
        // is just a placeholder.  The implementation should return the width, in pixels,
        // of the given string.  Of course this is dependent on font choice, size, etc,
        // but we gloss over that at the moment.  Just return the width of the string
        // using some reasonable default font for now.  Later on, we'll modify this
        // function to use font information.
        return string.length*30;
    });
    this.respondsTo("measureStringHeight", function (graphicsContext, string) {
        // see comment for measureStringWidth() above
        return string.length*30;
    });
    this.respondsTo("renderLabel", function (graphicsContext, value) {
        // Graphics drivers should replace this method with an actual implementation; this
        // is just a placeholder.  The implementation should draw the string for the given
        // value, formatted by the labeler's DataFormatter, in the location along the axis
        // determined by the value itself, and the labeler's position, anchor, and angle
        // attributes.
    });

    this.respondsTo("normalize", function () {
        var defaultNumberFormat   = "%.1f",
            defaultDatetimeFormat = "%Y-%M-%D %H:%i",
            labelerFormat,
            type = this.axis().type();

        //
        // Determines default values of labeler attributes based on axis type
        //
        if (type === DataValue.DATETIME) {
            labelerFormat = defaultDatetimeFormat;
        } else {
            labelerFormat = defaultNumberFormat;
        }

        //
        // Inserts labeler defaults
        //
        if (this.formatter() === undefined) {
            this.formatter(DataFormatter.create(type, labelerFormat));
        }

    });

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis.labels.label, attributes);
});

module.exports = Labeler;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/point.js":104,"../math/rgb_color.js":105,"../util/utilityFunctions.js":157,"./axis.js":18,"./data_formatter.js":27,"./data_measure.js":28,"./data_value.js":30}],46:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Point = require('../math/point.js'),
    RGBColor = require('../math/rgb_color.js'),
    Icon = require('./icon.js'),
    Plot = require('./plot.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    validationFunctions = require('../util/validationFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.legend);

/**
 * Legend is a Jermaine model that supports the rendering of Multigraph Legends.
 * 
 * The methods for this object take a parameter called `graphicsContext`, which is a
 * driver-specific object that stores whatever state/configuration is needed by the
 * driver.  Each driver is responsible for creating its own graphicsContext object and
 * passing it to these methods, which in turn pass that object on to the driver-specific
 * methods that they call.
 * 
 * @class Legend
 * @for Legend
 * @constructor
 * @requires Point,RGBColor,Plot,Icon
 */
var Legend = new jermaine.Model("Legend", function () {
    /**
     * The value which determines if the legend will be rendered; a value of `true` means the Legend will
     * be drawn while `false` means that it will not.
     *
     * @property visible
     * @type {boolean}
     * @author jrfrimme
     */
    this.hasA("visible").which.validatesWith(function (visible) {
        return typeof visible === "boolean" || visible === null;
    });

    /**
     * The value which gives the location of the base point relative to the Legend's frame.
     *
     * @property base
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("base").which.validatesWith(function (base) {
        return base instanceof Point;
    });

    /**
     * The value which gives the location of the Legend's anchor point to be attached to the base point.
     *
     * @property anchor
     * @type {Point}
     * @author jrfrimme
     */
    this.hasAn("anchor").which.validatesWith(function (anchor) {
        return anchor instanceof Point;
    });

    /**
     * A coordinate pair of pixel offsets for the base point.
     *
     * @property position
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });

    /**
     * The value which determines whether the legend is positioned relative to the plot area or the padding
     * box. A value of `plot` means the Legend will be drawn relative to the plot area while `padding` means
     * that it will the padding box.
     *
     * @property frame
     * @type {String}
     * @author jrfrimme
     */
    this.hasA("frame").which.validatesWith(function (frame) {
        return frame === "plot" || frame === "padding";
    });

    /**
     * The value which determines the background color of the Legend.
     *
     * @property color
     * @type {RGBColor}
     * @author jrfrimme
     */
    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    });

    /**
     * The value which determines the bordercolor of the Legend.
     *
     * @property bordercolor
     * @type {RGBColor}
     * @author jrfrimme
     */
    this.hasA("bordercolor").which.validatesWith(function (bordercolor) {
        return bordercolor instanceof RGBColor;
    });

    /**
     * The value which determines the opacity of the Legend; depending on where the Legend is positioned it
     * may obscure parts of the plot data.
     *
     * @property opacity
     * @type {Float}
     * @author jrfrimme
     */
    this.hasA("opacity").which.validatesWith(function (opacity) {
        return validationFunctions.validateNumberRange(opacity, 0.0, 1.0);
    });

    /**
     * The value which determines the thickness of the border drawn around the Legend; a value of `0` turns
     * the border off.
     *
     * @property border
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("border").which.isA("integer");

    /**
     * The value which determines the number of rows to be used for Plot entries in the Legend. If left
     * unspecified then rows will be inserted to account for each Plot entry.
     *
     * @property rows
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("rows").which.isA("integer").and.isGreaterThan(0);

    /**
     * The value which determines the number of columns to be used for Plot entries in the Legend. If rows
     * is set while columns is left unspecified then columns will be inserted to account for each Plot
     * entry.
     *
     * @property columns
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("columns").which.isA("integer").and.isGreaterThan(0);

    /**
     * The value which determines whether the corners of the legend box are rounded when drawn. A value of
     * `0` means that the corners will be drawn square while values greater than `0` mean that the corners
     * are rounded off with circles whose radius in pixels is this value.
     *
     * @property cornerradius
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("cornerradius").which.isA("integer");

    /**
     * The value which determines the pixel width of the padding between the Legend border and its entries.
     *
     * @property padding
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("padding").which.isA("integer");

    /**
     * A optional sub-model which determines the appearance of the Icons for the Plot entries.
     *
     * @property icon
     * @type {Icon}
     * @author jrfrimme
     */
    this.hasAn("icon").which.validatesWith(function (icon) {
        return icon instanceof Icon;
    });

    this.isBuiltWith(function () {
        this.icon( new Icon() );
    });

    /**
     * Pointers to Plot models that have entries in the Legend.
     *
     * @property plots
     * @type {Plot}
     * @author jrfrimme
     */
    this.hasMany("plots").eachOfWhich.validateWith(function (plot) {
        return plot instanceof Plot;
    });

    /**
     * Internal value which determines the number of pixels between an entries icon and its border.
     *
     * @property iconOffset
     * @type {Integer}
     * @default 5
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("iconOffset").which.isAn("integer").and.defaultsTo(5);

    /**
     * Internal value which determines the number of pixels between an entries label and its icon.
     *
     * @property labelOffset
     * @type {Integer}
     * @default 5
     * @private
     * @final
     * @type {}
     * @author jrfrimme
     */
    this.hasA("labelOffset").which.isAn("integer").and.defaultsTo(5);

    /**
     * Internal value which determines the number of pixels between the right end of an entries label and
     * its border
     *
     * @property labelEnding
     * @type {Integer}
     * @default 15
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("labelEnding").which.isAn("integer").defaultsTo(15);

    /**
     * Computed value of the width of the Legend.
     *
     * @property width
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("width").which.isA("number");

    /**
     * Computed value of the height of the Legend.
     *
     * @property height
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("height").which.isA("number");

    /**
     * Computed `x` value of the Legend's lower left corner relative to its frame.
     *
     * @property x
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("x").which.isA("number");

    /**
     * Computed `y` value of the Legend's lower left corner relative to its frame.
     *
     * @property y
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("y").which.isA("number");

    /**
     * Computed width of an individual plot entry.
     *
     * @property blockWidth
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("blockWidth").which.isA("number");

    /**
     * Computed height of an individual plot entry.
     *
     * @property blockHeight
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("blockHeight").which.isA("number");

    /**
     * Computed width of the longest label of all plot entries.
     *
     * @property maxLabelWidth
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("maxLabelWidth").which.isA("number");

    /**
     * Maximum value of the Icon's height and the computed height of the tallest label of all plot entries.
     *
     * @property maxLabelHeight
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("maxLabelHeight").which.isA("number");

    this.respondsTo("determineVisibility", function () {
        switch (this.visible()) {
        case true:
            return true;
        case false:
            return false;
        case null:
            if (this.plots().size() > 1) {
                return true;
            } else {
                return false;
            }
        }
    });

    /**
     * Initializes the Legend's geometry. Determines values for the internal attributes `maxLabelWidth`,
     * `maxLabelHeight`, `blockWidth`, `blockHeight`, `width`, `height`, `x` and `y`; these values
     * determine the size and position of the legend and its various internal components, and need
     * to be recomputed whenever the geometry of the containing graph changes;  this method is
     * called by Graph.initializeGeometry().
     * 
     * @method initializeGeometry
     * @chainable
     * @param {Graph} graph Jermaine Graph model
     * @param {Object} graphicsContext driver-specific graphics context object
     * @author jrfrimme
     * @todo Find out whether or not padding needs to be taken into consideration.
     */
    this.respondsTo("initializeGeometry", function (graph, graphicsContext) {
        var anchor     = this.anchor(),
            base       = this.base(),
            position   = this.position(),
            iconOffset = this.iconOffset(),
            widths  = [],
            heights = [],
            label,
            i;

        if (this.determineVisibility() === false) {
            return this;
        }

        for (i = 0; i < this.plots().size(); i++) {
            label = this.plots().at(i).legend().label();
            if (label !== undefined) {
                label.initializeGeometry(graphicsContext);
                widths.push(label.origWidth());
                heights.push(label.origHeight());
            }
        }

        widths.sort(function (a, b) {
            return b - a;
        });
        heights.sort(function (a, b) {
            return b - a;
        });
        this.maxLabelWidth(widths[0]);
        this.maxLabelHeight(Math.max(heights[0], this.icon().height()));

        this.blockWidth(iconOffset + this.icon().width() + this.labelOffset() + this.maxLabelWidth() + this.labelEnding());
        this.blockHeight(iconOffset + this.maxLabelHeight());

        // TODO: find out whether or not padding needs to be taken into consideration
        this.width((2 * this.border()) + (this.columns() * this.blockWidth()));
        this.height((2 * this.border()) + (this.rows() * this.blockHeight()) + iconOffset);

        if (this.frame() === "padding") {
            this.x(((base.x() + 1) * graph.paddingBox().width()/2)  - ((anchor.x() + 1) * this.width()/2)  + position.x());
            this.y(((base.y() + 1) * graph.paddingBox().height()/2) - ((anchor.y() + 1) * this.height()/2) + position.y());
        } else {
            this.x(((base.x() + 1) * graph.plotBox().width()/2)     - ((anchor.x() + 1) * this.width()/2)  + position.x());
            this.y(((base.y() + 1) * graph.plotBox().height()/2)    - ((anchor.y() + 1) * this.height()/2) + position.y());
        }

        return this;
    });

    /**
     * Renders the legend; calls various driver-specific graphics functions to do the
     * actual drawing of the various parts of the legend (background, borders, icons,
     * text).
     * 
     * @method render
     * @chainable
     * 
     * @param {Object} graphicsContext driver-specific graphics context object
     * 
     * @author jrfrimme
     */
    this.respondsTo("render", function (graphicsContext) {
        var plots = this.plots(),
            icon  = this.icon(),
            blockx, blocky,
            iconx, icony,
            labelx, labely,
            plotCount = 0,
            r, c;

        if (this.determineVisibility() === false) {
            return this;
        }

        // perform any neccesary setup
        this.begin(graphicsContext);

        // Draw the legend box
        this.renderLegend(graphicsContext);

        for (r = 0; r < this.rows(); r++) {
            if (plotCount >= plots.size()) {
                break;
            }
            blocky = this.border() + ((this.rows() - r - 1) * this.blockHeight());
            icony  = blocky + this.iconOffset();
            labely = icony;
            for (c = 0; c < this.columns(); c++) {
                if (plotCount >= plots.size()) {
                    break;
                }
                blockx = this.border() + (c * this.blockWidth());
                iconx  = blockx + this.iconOffset();
                labelx = iconx + icon.width() + this.labelOffset();

                // Draw the icon
                plots.at(plotCount).renderer().renderLegendIcon(graphicsContext, iconx, icony, icon, this.opacity());
                
                // Draw the icon border
                if (icon.border() > 0) {
                    icon.renderBorder(graphicsContext, iconx, icony, this.opacity());
                }
                
                // Write the text
                this.renderLabel(plots.at(plotCount).legend().label(), graphicsContext, labelx, labely);

                plotCount++;
            }
        }

        // preform any neccesary steps at the end of rendering
        this.end(graphicsContext);

        return this;
    });

    this.respondsTo("normalize", function (graph) {
        var legendPlots = this.plots(),
            graphPlots  = graph.plots(),
            columns = this.columns,
            rows    = this.rows,
            i, j,
            flag;

        //
        // stores pointers to plots with legends in the Legend object
        //
        for (i = 0; i < graphPlots.size(); i++) {
            // doesn't add a plot if it doesn't have a visible legend
            if (!graphPlots.at(i).legend() || graphPlots.at(i).legend().visible() !== true) {
                continue;
            }

            // doesn't add a plot if it has already been added
            flag = false;
            for (j = 0; j < legendPlots.size(); j++) {
                if (graphPlots.at(i) === legendPlots.at(j)) {
                    flag = true;
                    break;
                }
            }
            if (flag === true) {
                continue;
            }

            legendPlots.add(graphPlots.at(i));
        }

        //
        // If there are no plots in the legend default to 1 row and column if they aren't specified
        //
        if (legendPlots.size() === 0) {
            if (columns() === undefined) {
                columns(1);
            }
            if (rows() === undefined) {
                rows(1);
            }
        }

        //
        // if neither rows nor cols is specified, default to 1 col
        //
        if (rows() === undefined && columns() === undefined) {
            columns(1);
        }

        //
        // if only one of rows/cols is specified, compute the other
        //
        if (columns() === undefined) {
            columns(parseInt(legendPlots.size() / rows() + ( (legendPlots.size() % rows()) > 0 ? 1 : 0 ), 10));
        } else if (rows() === undefined) {
            rows(parseInt(legendPlots.size() / columns() + ( (legendPlots.size() % columns()) > 0 ? 1 : 0 ), 10));
        }

        return this;
    });

    utilityFunctions.insertDefaults(this, defaultValues.legend, attributes);
});

module.exports = Legend;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/point.js":104,"../math/rgb_color.js":105,"../util/utilityFunctions.js":157,"../util/validationFunctions.js":158,"./icon.js":43,"./plot.js":54}],47:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/**
 * The Mixin model provides a convenient way for Jermaine
 * applications to "mix in" additional functionality to a model,
 * from outside the model's initial definition.
 * 
 * The ability to add features (methods and/or attributes) to a
 * Jermaine model outside its initial definition already exists in
 * Jermaine -- this Mixin model does not actually add new
 * functionality to Jermaine; it just provides a convenient
 * pattern for grouping additional features together and applying
 * them to a model as a group.
 * 
 * The Mixin model maintains an internal list of functions, called
 * mixin functions, and provides an add() method for adding a
 * function to that list.
 * 
 * The apply() method calls all of the mixinfunctions that have been
 * added to the list, passing each one the same arguments
 * that were passed to the apply() function itself.
 * 
 * That's it.  That's all the Mixin class does.  It's up to you to
 * put whatever jermaine-model-extending code you want in the
 * mixin functions you add to the Mixin; the Mixin simply serves
 * as a place to hold them all, and a convenient way to execute
 * them all at once.
 *
 * @class Mixin
 * @for Mixin
 * @author mbp
 */
var Mixin = new jermaine.Model("Mixin", function () {

    /**
     * The internal list of functions to be applied.
     *
     * @property mixinfuncs
     * @private
     * @type {}
     * @author mbp
     */
    this.hasMany("mixinfuncs");

    /**
     * Internal value for tracking whether apply() has been called
     * for this Mixin.
     *
     * @property applied
     * @type {}
     * @private
     * @author mbp
     */
    this.hasA("applied").which.isA("boolean").defaultsTo(false);

    /**
     * Adds a function to this Mixin's mixin list.  Does not check
     * to see if the function is already on the list -- just blindly
     * appends the given function to the list.
     *
     * @method add
     * @param {} func
     * @author mbp
     */
    this.respondsTo("add", function (mixinfunc) {
        this.mixinfuncs().add(mixinfunc);
    });

    /**
     * Call each of this Mixin's mixin functions.  Any
     * arguments passed to apply() will be passed through to each
     * mixin function called.
     * 
     * apply() checks to see whether it has ever been called
     * before for this Mixin, and only executes the mixin
     * functions if this is the first call to apply(); calls to
     * apply() after the first one will have no effect.  (This is
     * true even if additional mixin functions are added after
     * apply() is called; the Mixin maintains a single internal
     * Boolean value that tracks whether apply() has been called.)
     *
     * @method apply
     * @author mbp
     */
    this.respondsTo("apply", function () {
        if (! this.applied()) {
            var i;
            for (i=0; i<this.mixinfuncs().size(); ++i) {
                this.mixinfuncs().at(i).apply(this, arguments);
            }
        }
        this.applied(true);
    });


    /**
     * Just like apply(), but forces the mixin functions to be called
     * regardless of whether apply() was previously called for this
     * Mixin.
     *
     * @method reapply
     * @author mbp
     */
    this.respondsTo("reapply", function () {
        this.applied(false);
        this.apply.apply(this,arguments);
    });


});

module.exports = Mixin;

},{"../../lib/jermaine/src/jermaine.js":9}],48:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
var Multigraph;
module.exports = function($) {
    if (typeof(Multigraph) !== "undefined") { return Multigraph; }

    var jermaine = require('../../lib/jermaine/src/jermaine.js');

    /**
     * The Multigraph Jermaine model is the root class for the js-multigraph project.
     *
     * @class Multigraph
     * @for Multigraph
     * @constructor
     */
    Multigraph = new jermaine.Model("Multigraph", function () {

        /**
         * Jermiane Attr_List of all the graphs in a Multigraph.
         *
         * @property graphs
         * @type {Graph}
         * @author jrfrimme
         */
        this.hasMany("graphs").eachOfWhich.validateWith(function (graph) {
            var Graph = require('./graph.js');
            return graph instanceof Graph;
        });

        /**
         * The div the multigraph is rendered in.
         *
         * @property div
         * @type {HTML Element}
         * @author jrfrimme
         */
        this.hasA("div"); // the actual div element

        /**
         * The url for the mugl file this graph was created from, if any
         *
         * @property mugl
         * @type {string}
         * @author mbp
         */
        this.hasA("mugl");

        /**
         * JavaScript array of ajax throttles; each entry in this array is an
         * object with the following properties:
         *    regex        : regular expression for matching URLs
         *    ajaxthrottle : instance of $.ajaxthrottle
         * 
         * @property ajaxthrottles
         * @type {Array}
         * @author mbp
         */
        this.hasA("ajaxthrottles");

        this.isBuiltWith(function() {
            this.ajaxthrottles([]);
        });

        this.respondsTo("addAjaxThrottle", function (pattern, requests, period, concurrent) {
            this.ajaxthrottles().push({
                regex        : pattern ? new RegExp(pattern) : undefined,
                ajaxthrottle : $.ajaxthrottle({
                    numRequestsPerTimePeriod : parseInt(requests,10),
                    timePeriod               : parseInt(period, 10),
                    maxConcurrent            : parseInt(concurrent, 10)
                })
            });
        });

        this.respondsTo("getAjaxThrottle", function (url) {
            var throttle = undefined;
            $.each(this.ajaxthrottles(), function() {
                if (!this.regex || this.regex.test(url)) {
                    throttle = this.ajaxthrottle;
                    return false;
                }
                return true;
            });
            return throttle;
        });

        /*
         * This function transforms a given URL so that it
         * is relative to the same base as the URL from which the MUGL
         * file was loaded.  If this graph was not created from a MUGL
         * file (either it came from a MUGL string, or was created programmatically),
         * the URL is returned unchanged.
         * 
         * If the URL to be rebased is absolute (contains '://')
         * or root-relative (starts with a '/'), it is returned unchanged.
         * 
         * Otherise, the given URL is relative, and whhat is returned is a
         * new URL obtained by interpreting it relative to the URL
         * from which the MUGL was loaded. 
         */
        this.respondsTo("rebaseUrl", function(url) {
            var baseurl = this.mugl();
            if (! baseurl) {
                return url;
            }
            if (/^\//.test(url)) {
                // url is root-relative (starts with a '/'); return it unmodified
                return url;
            }
            if (/:\/\//.test(url)) {
                // url contains '://', so assume it's a full url, return it unmodified
                return url;
            }
            // convert baseurl to a real base path, by eliminating any url args and
            // everything after the final '/'
            if (!/^\//.test(baseurl)  && !/:\/\//.test(baseurl) && !/^\.\//.test(baseurl)) {
                // first make sure that if baseurl is relative, it starts with './'
                baseurl = './' + baseurl; 
            }
            baseurl = baseurl.replace(/\?.*$/, ''); // remove everything after the first '?'
            baseurl = baseurl.replace(/\/[^\/]*$/, '/'); // remove everything after the last '/'
            return baseurl + url;
        });

        /**
         * The busy spinner
         *
         * @property busySpinner
         * @type {HTML Element}
         * @author mbp
         */
        this.hasA("busySpinner"); // the busy_spinner div

        this.respondsTo("busySpinnerLevel", function (delta) {
            if (this.busySpinner()) {
                $(this.busySpinner()).busy_spinner('level', delta);
            }
        });


        /**
         * Initializes the Multigraph's geometry by calling the `initializeGeometry` function of
         * each of its graph children.
         *
         * @method initializeGeometry
         * @param {Integer} width Width of the multigraph's div.
         * @param {Integer} height Height of the multigraph's div.
         * @param {Object} graphicsContext
         * @author jrfrimme
         */
        this.respondsTo("initializeGeometry", function (width, height, graphicsContext) {
            var i;
            for (i = 0; i < this.graphs().size(); ++i) {
                this.graphs().at(i).initializeGeometry(width, height, graphicsContext);
            }
        });

        /**
         * Convience function for registering callback functions for data becoming ready.
         *
         * @method registerCommonDataCallback
         * @param {Function} callback Callback function to be registered.
         * @author jrfrimme
         */
        this.respondsTo("registerCommonDataCallback", function (callback) {
            var i;
            for (i = 0; i < this.graphs().size(); ++i) {
                this.graphs().at(i).registerCommonDataCallback(callback);
            }
        });

        this.respondsTo("normalize", function () {
            var i;
            for (i = 0; i < this.graphs().size(); ++i) {
                this.graphs().at(i).normalize();
            }
        });

        this.respondsTo("destroy", function() {
            var i;
            for (i = 0; i < this.graphs().size(); ++i) {
                this.graphs().at(i).destroy();
            }
        });


    });

    /**
     * Determines if the browser supports canvas elements.
     *
     * @method browserHasCanvasSupport
     * @private
     * @static
     * @author jrfrimme
     */
    Multigraph.browserHasCanvasSupport = function () {
        // Warning: this function uses the global variables `window` and `document`
        // --- it does not rely on these variables being passed in as is the
        // case with '$' above.
        return (
                (!!window.HTMLCanvasElement) &&
                (!!window.CanvasRenderingContext2D) &&
                (function (elem) {
                    return !!(elem.getContext && elem.getContext('2d'));
                }(document.createElement('canvas')))
            );
    };
    
    Multigraph.browserHasSVGSupport = function () {
        // Warning: this function uses the global variable `document`
        // --- it does not rely on this variable being passed in as is the
        // case with '$' above.
        return !!document.createElementNS &&
            !!document.createElementNS('http://www.w3.org/2000/svg', "svg").createSVGRect;
    };

    /**
     * Creates a Multigraph according to specified options. Returns a
     * jQuery `promise` which interacts with the multigraph through its
     * `done` function.
     *
     * @method createGraph
     * @param {Object} options
     *
     * @param {String|HTML Element|jQuery Object} options.div (REQUIRED)
     *      The DOM element div into which the multigraph should be
     *      placed; this value may be either (a) a string which is taken
     *      to be the id attribute of a div in the page, (b) a reference
     *      to the div DOM element itself, or (c) a jQuery object
     *      corresponding to the div DOM element.
     * 
     * @param {URI} options.mugl (REQUIRED, unless muglString is present)
     *       the URL from which the MUGL
     *       file for the Multigraph can be loaded
     * 
     * @param {String} options.muglString (REQUIRED, unless mugl is present)
     *       a string containing the MUGL XML for the graph
     * 
     * @param {String} options.driver (OPTIONAL) Indicates which
     *       graphics driver to use; should be one of the strings
     *       "canvas", "raphael", or "auto".  The default (which is
     *       used if the 'driver' tag is absent) is "auto", which
     *       causes Multigraph to check the features of the browser
     *       it is running in and choose the most appropriate driver.
     * 
     * @param {Function} options.error (OPTIONAL) A function for
     *       displaying error messages to the user.  Multigraph will
     *       call this function if and when it encounters an error.  The
     *       function should receive a single argument which is an
     *       instance of the JavaScript Error object.  The default is to
     *       use Multigraph's own internal mechanism for displaying user
     *       messages.
     *
     * @param {Function} options.warning (OPTIONAL) A function for
     *       displaying warning messages to the user.  Multigraph will
     *       call this function if and when it needs to display a
     *       warning message. The function should receive a single
     *       argument which is an instance of the JavaScript Error
     *       object.  The default is to use Multigraph's own internal
     *       mechanism for displaying user messages.
     * @return {Promise} jQuery promise which provides interaction with
     *     the graph through its `done` function.
     * @author mbp
     */
    Multigraph.createGraph = function (options) {
        var div = options.div,
            messageHandler,
            defaultMessageHandler;

        // // if driver wasn't specified, choose the best based on browser capability
        // if (!options.driver) {
        //     if (ns.browserHasCanvasSupport()) {
        //         options.driver = "canvas";
        //     } else {
        //         options.driver = "raphael";
        //     }
        // }
        // Force canvas driver from now on:
        options.driver = "canvas";

        // if div is a string, assume it's an id, and convert it to the div element itself
        if (typeof(div) === "string") {
            div = $("#" + div)[0];
        }

        // Force the div to have the specific width or height given in the options, if any.
        // I'm adding this code to resolve a problem with the div size sometimes not being
        // available when src/graphics/canvas/multigraph.js:createCanvasGraphFromString()
        // is used; see the notes in that file.
        if (options.width !== undefined && options.width > 0) {
            $(div).width(options.width);
        }
        if (options.height !== undefined && options.height > 0) {
            $(div).height(options.height);
        }

        //
        // NOTE: each of the Multigraph.create{DRIVER}Graph functions below takes an
        // "options" object argument just like Multigraph.createGraph does.  In general this
        // "options" object is the same as the one passed to this Multigraph.createGraph
        // function, but it differs in one way: Instead of containing separate "error" and
        // "warning" properties which are optional, the "options" object passed to the
        // Multigraph.create{DRIVER}Graph functions requires a single (non-optional!)
        // "messageHandler" property, which in turn contains "error" and "warning" properties
        // which are functions for handling errors and warnings, respectively.  Both the
        // "error" and a "warning" properties must be present in the "messageHandler" object
        // and must point to valid functions.
        // 
        // The rationale behind this is to allow convenience for callers of the more "public"
        // Multigraph.createGraph function, so that they don't have to specify an error or
        // warning handler function unless they want to use custom ones.  The internal
        // Multigraph.create{DRIVER}Graph functions, however, always need access to error and
        // warning functions, and often need to pass both of them on to other functions, so
        // they're encapsulated together into a single messageHandler object to make this
        // easier.
        //
        // Build the messageHandler object:
        messageHandler = {};
        if (typeof(options.error) === "function") {
            messageHandler.error = options.error;
        }
        if (typeof(options.warning) === "function") {
            messageHandler.warning = options.warning;
        }

        if (! messageHandler.error  || ! messageHandler.warning) {
            defaultMessageHandler = Multigraph.createDefaultMessageHandlers(div);
            if (! messageHandler.error) {
                messageHandler.error = defaultMessageHandler.error;
            }
            if (! messageHandler.warning) {
                messageHandler.warning = defaultMessageHandler.warning;
            }
        }
        options.messageHandler = messageHandler;

        if (options.muglString !== undefined) {
            // delegate to the driver-specific create function
            if (options.driver === "canvas") {
                return Multigraph.createCanvasGraphFromString(options);
            } else if (options.driver === "raphael") {
                return Multigraph.createRaphaelGraphFromString(options);
            } else {
                options.messageHanlder.error(new Error("invalid graphic driver '" + options.driver + "' specified to Multigraph.createGraph"));
                return undefined;
            }
        }

        // delegate to the driver-specific create function
        if (options.driver === "canvas") {
            return Multigraph.createCanvasGraph(options);
        } else if (options.driver === "raphael") {
            return Multigraph.createRaphaelGraph(options);
        } else {
            options.messageHanlder.error(new Error("invalid graphic driver '" + options.driver + "' specified to Multigraph.createGraph"));
            return undefined;
        }
    };

    /**
     * `window.multigraph.create` is an alias for `window.multigraph.core.Multigraph.createGraph`.
     *
     * @method window.multigraph.create
     * @param {Object} options
     *
     * @param {String|HTML Element|jQuery Object} options.div (REQUIRED)
     *      The DOM element div into which the multigraph should be
     *      placed; this value may be either (a) a string which is taken
     *      to be the id attribute of a div in the page, (b) a reference
     *      to the div DOM element itself, or (c) a jQuery object
     *      corresponding to the div DOM element.
     * 
     * @param {URI} options.mugl (REQUIRED) the URL from which the MUGL
     *       file for the Multigraph can be loaded
     * 
     * @param {String} options.driver (OPTIONAL) Indicates which
     *       graphics driver to use; should be one of the strings
     *       "canvas", "raphael", or "auto".  The default (which is
     *       used if the 'driver' tag is absent) is "auto", which
     *       causes Multigraph to check the features of the browser
     *       it is running in and choose the most appropriate driver.
     * 
     * @param {Function} options.error (OPTIONAL) A function for
     *       displaying error messages to the user.  Multigraph will
     *       call this function if and when it encounters an error.  The
     *       function should receive a single argument which is an
     *       instance of the JavaScrip Error object.  The default is to
     *       use Multigraph's own internal mechanism for displaying user
     *       messages.
     *
     * @param {Function} options.warning (OPTIONAL) A function for
     *       displaying warning messages to the user.  Multigraph will
     *       call this function if and when it needs to display a
     *       warning message. The function should receive a single
     *       argument which is an instance of the JavaScript Error
     *       object.  The default is to use Multigraph's own internal
     *       mechanism for displaying user messages.
     * @return {Promise} jQuery promise which provides interaction with
     *     the graph through its `done` function.
     * @static
     * @author jrfrimme
     */
    Multigraph.create = Multigraph.createGraph;

    /**
     * Creates default error and warning functions for multigraph.
     *
     * @method createDefaultMessageHandlers
     * @param {HTML Element} div
     * @static
     * @return {Object} Object keyed by `error` and `warning` which respectively point to
     *     the generated default error and warning functions.
     * @author jrfrimme
     */
    Multigraph.createDefaultMessageHandlers = function (div) {

        $(div).css('position', 'relative');
        $(div).errorDisplay({});

        return {
            error : function(e) {
                var stackTrace = (e.stack && typeof(e.stack) === "string") ? e.stack.replace(/\n/g, "</li><li>") : e.message;
                $(div).errorDisplay("displayError", stackTrace, e.message, {
                    fontColor       : '#000000',
                    backgroundColor : '#ff0000',
                    indicatorColor  : '#ff0000'
                });
            },

            warning : function (w) {
                // w can be either a string, or a Warning instance
                var message    = "Warning: " + ((typeof(w) === "string") ? w : w.message),
                    stackTrace = (typeof(w) !== "string" && w.stack && typeof(w.stack) === "string") ? w.stack.replace(/\n/g, "</li><li>") : message;
                $(div).errorDisplay("displayError", stackTrace, message, {
                    fontColor       : '#000000',
                    backgroundColor : '#e06a1b',
                    indicatorColor  : '#e06a1b'
                });
            }
        };
    };

    // define empty object for holding data adpaters
    Multigraph._dataAdapters = {};

    Multigraph.installDataAdapter = function(name, adapter) {
        Multigraph._dataAdapters[name] = adapter;
    };

    Multigraph.getDataAdapter = function(name) {
        return Multigraph._dataAdapters[name];
    };

    // so that data adpaters, or other JS code interacting with Multigraph,
    // may have access to sprintf:
    Multigraph.sprintf = require('sprintf');

    return Multigraph;
};

},{"../../lib/jermaine/src/jermaine.js":9,"./graph.js":41,"sprintf":16}],49:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var sprintf = require('sprintf');

var NumberFormatter = function (format) {
    var testString;
    if (typeof(format) !== "string") {
        throw new Error("format must be a string");
    }
    this.formatString = format;
    testString = sprintf(format, 0);
    this.length = testString.length;
};

NumberFormatter.prototype.format = function (value) {
    return sprintf(this.formatString, value.getRealValue());
};

NumberFormatter.prototype.getMaxLength = function () {
    return this.length;
};

NumberFormatter.prototype.getFormatString = function () {
    return this.formatString;
};

module.exports = NumberFormatter;

},{"../../lib/jermaine/src/jermaine.js":9,"sprintf":16}],50:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

NumberValue = require('./number_value.js');

// Fudge factor for floating point comparisons:
var epsilon = 1E-12;

var NumberMeasure = function (measure) {
    this.measure = measure;
};

NumberMeasure.prototype.getRealValue = function () {
    return this.measure;
};

NumberMeasure.prototype.toString = function () {
    return this.measure.toString();
};

NumberMeasure.prototype.firstSpacingLocationAtOrAfter = function (value, alignment)  {
    var f,
        n,
        m,
        a = alignment.value,
        v = value.value,
        s = Math.abs(this.measure);
    f = (v - a) / s;
    n = Math.floor(f);
    m = n + 1;
    //if ((Math.abs(n - f) < epsilon) || (Math.abs(m - f) < epsilon)) {
    //NOTE: by definition of n=floor(f), we know f >= n, so Math.abs(n - f) is the same as (f - n)
    //Also by definition, floor(f)+1 >= f, so Math.abs(m - f) is the same as (m - f)
    if ((f - n < epsilon) || (m - f < epsilon)) {
        return new NumberValue(v);
    }
    return new NumberValue(a + s * m);
};

// Consider a lattice of values spaced `s` apart, aligned with `a`
//    i.e. all values a + z*s, where z is any integer
// Return the largest value in this lattice that is <= `v`
function lastSpacingLocationAtOrBefore(s, v, a) {
    var n, n, f;
    v = v - a;
    if (v >= 0) {
        f = v / s;
        n = Math.floor(f);
        if (f - n < epsilon) { return v; }
        return a + n*s;
    } else {
        f = -v / s;
        n = Math.ceil(f);
        if (n - f < epsilon) { return v; }
        return a - n*s;
    }
}

/**
 * This function is just like `firstSpacingLocationAtOrAfter` above, but returns the
 * greatest NumberValue in the lattice that is less than or equal to `value`.
 * 
 * return: a NumberValue
 */
NumberMeasure.prototype.lastSpacingLocationAtOrBefore = function (/*NumberValue*/value, /*NumberValue*/alignment)  {
    return new NumberValue(lastSpacingLocationAtOrBefore(this.measure, value.value, alignment.value));
};

//    var f,
//        n,
//        m,
//        a = alignment.value,
//        v = value.value,
//        s = Math.abs(this.measure);
//    f = (v - a) / s;
//    if (f > 0) {
//        n = Math.floor(f);
//    } else {
//        n = Math.ceil(f);
//    }
//    m = n + 1;
//    if ((f - n < epsilon) || (m - f < epsilon)) {
//        console.log('at 1');
//        console.log(f);
//        console.log(f-n);
//        console.log(m-f);
//        console.log(epsilon);
//        return new NumberValue(v);
//    }
//    console.log('at 2');
//    return new NumberValue(a + s * n);
//};

NumberMeasure.parse = function (s) {
    return new NumberMeasure(parseFloat(s));
};

module.exports = NumberMeasure;

},{"../../lib/jermaine/src/jermaine.js":9,"./number_value.js":51}],51:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

DataValue = require('./data_value.js');

var NumberValue = function (value) {
    this.value = value;
};

NumberValue.prototype.getRealValue = function () {
    return this.value;
};

NumberValue.prototype.toString = function () {
    return this.value.toString();
};

NumberValue.prototype.compareTo = function (x) {
    if (this.value < x.value) {
        return -1;
    } else if (this.value > x.value) {
        return 1;
    }
    return 0;
};

NumberValue.prototype.addRealValue = function ( realValueIncr ) {
    return new NumberValue(this.value + realValueIncr);
};

NumberValue.prototype.add = function (/*DataMeasure*/ measure) {
    // NOTE: deliberately accessing the 'measure' property of a NumberMeasure here, rather
    // than calling its getRealValue() method, for convenience and efficiency:
    return new NumberValue(this.value + measure.measure);
};

NumberValue.prototype.type = DataValue.NUMBER;

NumberValue.prototype.clone = function() {
    return new NumberValue(this.value);
};

NumberValue.parse = function (s) {
    return new NumberValue(parseFloat(s));
};

DataValue.mixinComparators(NumberValue.prototype);

module.exports = NumberValue;

},{"../../lib/jermaine/src/jermaine.js":9,"./data_value.js":30}],52:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

DataValue = require('./data_value.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.horizontalaxis.pan);

var Pan = new jermaine.Model("Pan", function () {
    this.hasA("allowed").which.isA("boolean");
    this.hasA("min").which.validatesWith(DataValue.isInstanceOrNull);
    this.hasA("max").which.validatesWith(DataValue.isInstanceOrNull);

    //NOTE: the distinction between DataValue and DataMeasure for the zoom & pan model
    //      attributes might seem confusing, so here's a table to clarify it:
    //
    //              Boolean      DataValue      DataMeasure
    //              -------      ---------      -----------
    //  zoom:       allowed      anchor         min,max
    //   pan:       allowed      min,max

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis.pan, attributes);
});

module.exports = Pan;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":157,"./data_value.js":30}],53:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var ArrayData = require('./array_data.js'),
    DataMeasure = require('./data_measure.js'),
    DataValue = require('./data_value.js');

var PeriodicArrayData = new jermaine.Model(function () {
    var PeriodicArrayData = this,
        emptyIterator = {
            "next"    : function () {},
            "hasNext" : function () { return false; }
        };

    this.isA(ArrayData);
    this.hasA("period").which.validatesWith(DataMeasure.isInstance);
    //this.hasA("column0RelativeRealValues").which.defaultsTo(null);
    this.isBuiltWith("columns", "stringArray", "period", function () {
        this.init();
        this.addListener("listenerAdded", function (event) {
            var data = this.array();
            if (event.targetType === "dataReady") {
                event.listener(data[0][0], data[data.length-1][0]);
            }
        });
    });

    /*
     this.respondsTo("initializeColumn0RelativeRealValues", function() {
     var array = this.array(),
     column0RelativeRealValues = [],
     i;
     for (i=0; i<array.length; ++i) {
     column0RelativeRealValues[i] = array[i][0] - array[0][0];
     }
     this.column0RelativeRealValues(column0RelativeRealValues);
     });
     */

    /**
     * @method getIterator
     * @param {string array} columnIDs
     * @param {DataValue} min
     * @param {DataValue} max
     * @param {Integer} buffer
     * @author jrfrimme
     */
    this.respondsTo("getIterator", function (columnIds, min, max, buffer) {
        return PeriodicArrayData.getArrayDataIterator(this, columnIds, min, max, buffer);
    });

    /**
     * @method getArrayDataIterator
     * @static
     * @param {ArrayData} arrayData
     * @param {string array} columnIDs
     * @param {DataValue} min
     * @param {DataValue} max
     * @param {Integer} buffer
     * @return iter
     * @author jrfrimme
     */
    PeriodicArrayData.getArrayDataIterator = function (periodicArrayData, columnIds, min, max, buffer) {
        var iter = {},
            arraySlice = [],
            curr = 0,
            i, j,
            currentIndex,
            columnIndices,
            array = periodicArrayData.array();

        buffer = buffer || 0;

        // columnIds argument should be an array of strings
        if (Object.prototype.toString.apply(columnIds) !== "[object Array]") {
            throw new Error("ArrayData: getIterator method requires that the first parameter be an array of strings");
        } else {
            for (i = 0; i < columnIds.length; ++i) {
                if (typeof(columnIds[i]) !== "string") {
                    throw new Error("ArrayData: getIterator method requires that the first parameter be an array of strings");
                }
            }
        }

        //min,max arguments should be data values
        if (!DataValue.isInstance(min) || !DataValue.isInstance(max)) {
            throw new Error("ArrayData: getIterator method requires the second and third argument to be number values");
        }

        //buffer argument should be an integer
        if (typeof(buffer) !== "number") {
            throw new Error("ArrayData: getIterator method requires last argument to be an integer");
        }

        // if we have no data, return an empty iterator
        if (array.length === 0) {
            return emptyIterator;
        }

        /*
         // populate the column0RelativeRealValues array if it hasn't yet been populated
         if (this.column0RelativeRealValues() === null) {
         this.initializeColumn0RelativeRealValues();
         }
         */

        // Let `baseValue` be the location of the first data point in the array
        var baseValue = array[0][0];

        // In the regular lattice of spacing `period` aligned with baseValue,
        // find the last point that is less than or equal to `min`.  Call this point `b`.
        var b = periodicArrayData.period().lastSpacingLocationAtOrBefore(min, baseValue);

        // Let `offsetRealValue` be the difference between b and baseValue, as a real value:
        var offsetRealValue = b.getRealValue() - baseValue.getRealValue();

        // Let `baseMin` be `min` shifted 'backward' by offsetRealValue; this is `min`
        // relative to the same period cycle as baseValue:
        var baseMin = DataValue.create(min.type, min.getRealValue() - offsetRealValue);

        // find the index of the first row in the array whose column0 value is >= baseMin;
        // this is the data point we start with
        for (currentIndex = 0; currentIndex < array.length; ++currentIndex) {
            if (array[currentIndex][0].ge(baseMin)) {
                break;
            }
        }
        if (currentIndex === array.length) {
            currentIndex = 0;
        }

        //
        //TODO later: back up 'buffer' steps
        //

        // set the current value to be the column0 value at this first index, shifted
        // 'forward' by offsetRealValue
        var currentValue = DataValue.create(array[currentIndex][0].type, array[currentIndex][0].getRealValue() + offsetRealValue);

        columnIndices = [];
        for (j = 0; j < columnIds.length; ++j) {
            var k = periodicArrayData.columnIdToColumnNumber(columnIds[j]);
            columnIndices.push( k );
        }

        return {
            next : function () {
                var projection = [],
                    i, x;
                if (currentIndex < 0) {
                    return null;
                }
                for (i = 0; i < columnIndices.length; ++i) {
                    if (columnIndices[i] === 0) {
                        projection.push(currentValue);
                    } else {
                        projection.push(array[currentIndex][columnIndices[i]]);
                    }
                }
                ++currentIndex;
                if (currentIndex >= array.length) {
                    currentIndex = 0;
                    b = b.add(periodicArrayData.period());
                    offsetRealValue = b.getRealValue() - baseValue.getRealValue();
                }
                currentValue = DataValue.create(array[currentIndex][0].type, array[currentIndex][0].getRealValue() + offsetRealValue);
                if (currentValue.gt(max)) {
                    //TODO: actually need to figure out how to move forward `buffer` steps, but for
                    // now skip that part.
                    currentIndex = -1;
                }
                return projection;
            },
            hasNext : function () {
                return (currentIndex >= 0);
            }
        };
        
    };

});


module.exports = PeriodicArrayData;

},{"../../lib/jermaine/src/jermaine.js":9,"./array_data.js":17,"./data_measure.js":28,"./data_value.js":30}],54:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var PlotLegend = require('./plot_legend.js'),
    Axis = require('./axis.js'),
    Renderer = require('./renderer.js');

var Plot = new jermaine.Model("Plot", function () {
    this.hasA("legend").which.validatesWith(function (legend) {
        return legend instanceof PlotLegend;
    });
    this.hasA("horizontalaxis").which.validatesWith(function (axis) {
        return axis instanceof Axis;
    });
    this.hasA("verticalaxis").which.validatesWith(function (axis) {
        return axis instanceof Axis;
    });
    this.hasA("renderer").which.validatesWith(function (renderer) {
        return renderer instanceof Renderer;
    });
    this.hasA("visible").which.isA("boolean").and.defaultsTo(true);

    this.respondsTo("normalize", function(graph) {
        var graphAxes = graph.axes(),
            rendererType,
            numberOfVariables,
            findNextVariableAtOrAfter,
            i,
            DataPlot = require('../core/data_plot.js');

        //
        // Handles missing variables
        //
        findNextVariableAtOrAfter = function (plot, data, index) {
            var overlapFlag = false,
                variableInPlotFlag,
                i = index,
                j,
                variable;

            while (true) {
                if (i === index && overlapFlag === true) {
                    throw new Error("Plot Normalizer: There does not exist an unused variable");
                }

                if (i === data.columns().size()) {
                    i = 0;
                    overlapFlag = true;
                }

                variableInPlotFlag = false;
                variable = data.columns().at(i);

                for (j = 0; j < plot.variable().size(); j++) {
                    if (plot.variable().at(j) === variable) {
                        variableInPlotFlag = true;
                        break;
                    }
                }

                if (variableInPlotFlag === false) {
                    return variable;
                }

                i++;
            }
            
        };

        //
        // Handles missing horizontalaxis tags
        //
        if (this.horizontalaxis() === undefined) {
            for (i = 0; i < graphAxes.size(); i++) {
                if (graphAxes.at(i).orientation() === Axis.HORIZONTAL) {
                    this.horizontalaxis(graphAxes.at(i));
                    break;
                }
            }
        }

        //
        // Handles missing verticalaxis tags
        //
        if (this.verticalaxis() === undefined) {
            for (i = 0; i < graphAxes.size(); i++) {
                if (graphAxes.at(i).orientation() === Axis.VERTICAL) {
                    this.verticalaxis(graphAxes.at(i));
                    break;
                }
            }
        }

        //
        // Handles missing renderer tags
        //
        if (this.renderer() === undefined) {
            require('./renderers/all_renderers.js');
            rendererType = Renderer.Type.parse("line");
            this.renderer(Renderer.create(rendererType));
            this.renderer().plot(this);
        }

        numberOfVariables = this.renderer().numberOfVariables();

        if (this instanceof DataPlot) {
            var plotData = this.data,
                plotVariables = this.variable();
            
            if (plotData() === undefined) {
                plotData(graph.data().at(0));
            }

            if (plotVariables.size() === 0) {
                plotVariables.add(findNextVariableAtOrAfter(this, plotData(), 0));
            }

            if (plotVariables.at(0) === null) {
                plotVariables.replace(0, findNextVariableAtOrAfter(this, plotData(), 0));
            }

            while (plotVariables.size() < numberOfVariables) {
                plotVariables.add(findNextVariableAtOrAfter(this, plotData(), 1));
            }

            // 1. get variables from a data section, some will be used, others won't be.
            // 2. check if horizontal axis needs a variable
            //       if it does - find first unused variable, starting at position 0
            //                  - if no unused variables exist - throw error
            //                  - CONTINUE
            //       if it does not - CONTINUE
            // 3. check if vertical axis needs variable(s)
            //       if it does - find first unused variable, starting at the position of
            //                    the x variable
            //                  - if no unused variables exist - throw error
            //                  - check if vertical axis needs another variable
            //                        if it does - Repeat step 3

            if (this.datatips()) {
                this.datatips().normalize(this);
            }
        }

    });

});

module.exports = Plot;

},{"../../lib/jermaine/src/jermaine.js":9,"../core/data_plot.js":29,"./axis.js":18,"./plot_legend.js":55,"./renderer.js":57,"./renderers/all_renderers.js":58}],55:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Text = require('./text.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.legend);

var PlotLegend = new jermaine.Model("PlotLegend", function () {
    this.hasA("visible").which.isA("boolean");
    this.hasA("label").which.validatesWith(function (label) {
        return label instanceof Text;
    });

    utilityFunctions.insertDefaults(this, defaultValues.plot.legend, attributes);
});

module.exports = PlotLegend;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":157,"./text.js":64}],56:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var RGBColor = require('../math/rgb_color.js'),
    Insets = require('../math/insets.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plotarea);

var Plotarea = new jermaine.Model("Plotarea", function () {

    this.hasA("margin").which.validatesWith(function (margin) {
        return margin instanceof Insets;
    });

    this.hasA("border").which.isA("integer");

    this.hasA("color").which.validatesWith(function (color) {
        return color === null || color instanceof RGBColor;
    });

    this.hasA("bordercolor").which.validatesWith(function (bordercolor) {
        return bordercolor instanceof RGBColor;
    });

    utilityFunctions.insertDefaults(this, defaultValues.plotarea, attributes);
});

module.exports = Plotarea;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/insets.js":103,"../math/rgb_color.js":105,"../util/utilityFunctions.js":157}],57:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Warning = require('./warning.js'),
    Enum = require('../math/enum.js'),
    rendererList,
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer),
    Type = new Enum("RendererType"),
    RGBColor = require('../math/rgb_color.js');

var Renderer = new jermaine.Model("Renderer", function () {
    this.hasA("type").which.validatesWith(Type.isInstance);
    this.hasA("plot").which.validatesWith(function (plot) {
        var Plot = require('./plot.js');
        return plot instanceof Plot;
    });
    this.hasA("numberOfVariables").which.isA("number");

    this.hasA("filter").which.validatesWith(function(filter) {
        return ((typeof(filter) === 'undefined')
                ||
                ((typeof(filter.reset) === 'function') && (typeof(filter.filter) === 'function')));
    });

    this.respondsTo("setUpMissing", function () {
        // A call to this method results in the addition (or replacement) of a method called "isMissing()"
        // that can be used to test whether a value meets the "missing" criteria of one of this renderer's
        // plot's data columns.  The point of having this "setUpMissing()" method create the "isMissing()"
        // method, rather than just coding the "isMissing()" method directly here, is so that we can capture
        // a pointer to the plot's data object via a closure, for faster access, rather than coding
        // this.plot().data() in "isMissing()", which adds the overhead of 2 getter calls to each invocation.
        //
        // NOTE: This is awkward.  What we really want is for this stuff to happen automatically when
        // the renderer's "plot" attribute is set.  Can Jermaine be modified to allow us to write
        // a custom setter, so that we can execute this code automatically when the render's "plot"
        // attribute is set ???
        var plot = this.plot(),
            data;
        if (!plot) {
            console.log("Warning: renderer.setUpMissing() called for renderer that has no plot ref");
            // this should really eventually throw an error
            return;
        }

        // for ConstantPlot, create function that always returns false, since it has no data
        var ConstantPlot = require('./constant_plot.js');
        if (plot instanceof ConstantPlot) {
            this.isMissing = function (p) {
                return false;
            };
            return;
        }


        if (!plot.data()) {
            // this should eventually throw an error
            console.log("Warning: renderer.setUpMissing() called for renderer whose plot has no data ref");
            return;
        }
        data = plot.data();
        this.isMissing = function (p) {
            var i;
            for (i = 1; i < p.length; ++i) {
                if (data.isMissing(p[i], i)) {
                    return true;
                }
            }
            return false;
        };
    });

    this.isBuiltWith("type");

    utilityFunctions.insertDefaults(this, defaultValues.plot.renderer, attributes);

    this.respondsTo("transformPoint", function (input) {
        var output = [],
            haxis = this.plot().horizontalaxis(),
            vaxis = this.plot().verticalaxis(),
            i;

        output[0] = haxis.dataValueToAxisValue(input[0]);
        for (i = 1; i < input.length; ++i) {
            output[i] = vaxis.dataValueToAxisValue(input[i]);
        }
        return output;
    });

    var equalOrUndefined = function (a, b) {
        return ((a===b) || ((a===undefined) && (b===undefined)));
    };

    this.respondsTo("setOption", function (name, value, min, max) {
        var rendererOpt,
            rendererOpts,
            i;
        if (!this.optionsMetadata[name]) {
            throw new Error("attempt to set unknown renderer option '"+name+"'");
        }
        rendererOpts = this.options()[name]();
        for (i = 0; i < rendererOpts.size(); ++i) {
            if (equalOrUndefined(rendererOpts.at(i).min(), min) &&
                equalOrUndefined(rendererOpts.at(i).max(), max)) {
                rendererOpts.at(i).value(value);
                return;
            }
        }
        // If we get this far, it means we didn't find an existing option in the list with matching min/max
        // settings, so we create a new one and append it to the end of the list:
        rendererOpt = new (this.optionsMetadata[name].type)();
        rendererOpt.value(value);
        rendererOpt.min(min);
        rendererOpt.max(max);
        rendererOpts.add(rendererOpt);
    });

    this.respondsTo("setOptionFromString", function (name, stringValue, stringMin, stringMax) {
        var plot = this.plot(),
            type = this.type(),
            DataValue = require('./data_value.js');

        //
        // Two blocks of code below provides support for the deprecated "dotsize" and "dotcolor"
        // options, which have been replaced by "pointsize" and "pointcolor".  Delete these blocks
        // when removing support for this.
        // 

        // 
        // First block in support of deprecated dotsize/dotcolor options:
        //
        var warning = undefined;
        if (name === "dotsize") {
            name = "pointsize";
            warning = new Warning('deprecated "dotsize" option used for "' + type + '" renderer; use "pointsize" instead');
        } else if (name === "dotcolor") {
            name = "pointcolor";
            warning = new Warning('deprecated "dotcolor" option used for "' + type + '" renderer; use "pointcolor" instead');
        }
        // 
        // End of first block in support of deprecated dotsize/dotcolor options
        //

        var rendererOpt;
        if (!this.optionsMetadata[name]) {
            // If this renderer has no option named "name", bail out immediately.  This should eventually
            // throw an error, but for now we just quietly ignore it, to eliminate error conditions coming
            // from unimplemented options.
            //console.log("WARNING: renderer has no option named '" + name + "'");
            throw new Warning('"' + type + '"' + ' renderer has no option named "' + name + '"');
        }
        rendererOpt = new (this.optionsMetadata[name].type)();
        rendererOpt.parseValue(stringValue, this);
        if (plot && plot.verticalaxis()) {
            if (stringMin !== undefined) {
                rendererOpt.min( DataValue.parse( plot.verticalaxis().type(), stringMin ));
            }
            if (stringMax !== undefined) {
                rendererOpt.max( DataValue.parse( plot.verticalaxis().type(), stringMax ));
            }
        }
        this.setOption(name, rendererOpt.value(), rendererOpt.min(), rendererOpt.max());

        // 
        // Second block in support of deprecated dotsize/dotcolor options:
        //
        if (warning) {
            throw warning;
        }
        // 
        // End of second block in support of deprecated dotsize/dotcolor options:
        //
    });


    this.respondsTo("getOptionValue", function (optionName, /*optional:*/value) {
        var i,
            options,
            optionList;

        options = this.options();
        if (typeof(options[optionName]) !== "function") {
            throw new Error('unknown option "'+optionName+'"');
        }
        optionList = options[optionName]();
        if (!optionList) {
            throw new Error('unknown option "'+optionName+'"');
        }
        //NOTE: options are stored in reverse order; default one is always in the '0' position.
        //  Search through them starting at the END of the list, going backwards!
        for (i = optionList.size()-1; i >= 0; --i) {
            var option = optionList.at(i);
            if (((option.min()===undefined) || (value===undefined) || option.min().le(value)) &&
                ((option.max()===undefined) || (value===undefined) || option.max().gt(value))) {
                return option.value();
            }
        }
        
    });

    // method must be overridden by subclass:
    this.respondsTo("begin", function () {
    });
    // method must be overridden by subclass:
    this.respondsTo("dataPoint", function (point) {
    });
    // method must be overridden by subclass:
    this.respondsTo("end", function () {
    });

});

/*
 * Private list of known renderers.  This list is populated from within individual
 * renderer submodel implementations by calls to Renderer.addType.
 */
rendererList = [];

/*
 * Add a renderer submodel to the list of known renders.  rendererObj should be
 * an object with two properties:
 *    'type'  : the type of the renderer -- a string, which is the value expected
 *              for the type attribute of the mugl <renderer> tag.
 *    'model' : the renderer submodel
 */
Renderer.addType = function (rendererObj) {
    rendererList.push(rendererObj);
};

/*
 * Factory method: create an instance of a renderer submodel based on its type (a string).
 */
Renderer.create = function (type) {
    var i,
        renderer;
    for (i = 0; i < rendererList.length; ++i) {
        if (rendererList[i].type === type) {
            renderer = new (rendererList[i].model)();
            renderer.type(type);
            return renderer;
        }
    }
    throw new Error("Renderer.create: '" + type + "' is not a known renderer type");
    //        throw new Error('Renderer.create: attempt to create a renderer of unknown type');
};

Renderer.declareOptions = function (renderer, OptionsModelName, options) {
    var i,
        OptionsModel,
        optionsMetadata,
        declareOption = function(optionName, optionType) {
            // NOTE: this call to hasMany() has to be in a function here, rather than just
            // being written inline where it is used below, because we need a closure to
            // capture value of options[i].type as optionType, for use in the validation
            // function.  Otherwise, the validator captures the 'options' array and the
            // local loop variable i instead, and evaluates options[i].type when validation
            // is performed!
            OptionsModel.hasMany(optionName).eachOfWhich.validateWith(function (v) {
                return v instanceof optionType;
            });
        };

    OptionsModel    = new jermaine.Model(OptionsModelName, function () {});
    optionsMetadata = {};
    for (i = 0; i < options.length; ++i) {
        declareOption(options[i].name, options[i].type);
        optionsMetadata[options[i].name] = {
            "type"    : options[i].type,
            "default" : options[i]["default"]
        };
    }
    renderer.hasA("options").isImmutable().defaultsTo(function () { return new OptionsModel(); });
    renderer.prototype.optionsMetadata = optionsMetadata;

    renderer.isBuiltWith(function () {
        // populate options with default values stored in options metadata (which was populated by declareOptions):
        var optionsMetadata = this.optionsMetadata,
            opt, ropt;
        for (opt in optionsMetadata) {
            if (optionsMetadata.hasOwnProperty(opt)) {
                ropt = new (optionsMetadata[opt].type)(optionsMetadata[opt]["default"]);
                this.options()[opt]().add( ropt );
            }
        }
    });

};


Renderer.Option = new jermaine.Model("Renderer.Option", function () {
    var DataValue = require('./data_value.js');
    this.hasA("min").which.validatesWith(DataValue.isInstance);
    this.hasA("max").which.validatesWith(DataValue.isInstance);
});


Renderer.RGBColorOption = new jermaine.Model("Renderer.RGBColorOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.validatesWith(function (v) {
        return v instanceof RGBColor || v === null;
    });
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return this.value().getHexString();
    });
    this.respondsTo("parseValue", function (string) {
        this.value( RGBColor.parse(string) );
    });
    this.respondsTo("valueEq", function (value) {
        return this.value().eq(value);
    });

});

Renderer.NumberOption = new jermaine.Model("Renderer.NumberOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.isA("number");
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return this.value().toString();
    });
    this.respondsTo("parseValue", function (string) {
        this.value( parseFloat(string) );
    });
    this.respondsTo("valueEq", function (value) {
        return (this.value()===value);
    });
});

Renderer.DataValueOption = new jermaine.Model("Renderer.DataValueOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.validatesWith(function (value) {
        var DataValue = require('./data_value.js');
        return DataValue.isInstance(value) || value === null;
    });
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return this.value();
    });
    this.respondsTo("valueEq", function (value) {
        return this.value().eq(value);
    });
});

Renderer.VerticalDataValueOption = new jermaine.Model("Renderer.DataValueOption", function () {
    this.isA(Renderer.DataValueOption);
    this.isBuiltWith("value");
    this.respondsTo("parseValue", function (string, renderer) {
        var DataValue = require('./data_value.js');
        this.value( DataValue.parse(renderer.plot().verticalaxis().type(), string) );
    });
    
});

Renderer.HorizontalDataValueOption = new jermaine.Model("Renderer.DataValueOption", function () {
    this.isA(Renderer.DataValueOption);
    this.isBuiltWith("value");
    this.respondsTo("parseValue", function (string, renderer) {
        var DataValue = require('./data_value.js');
        this.value( DataValue.parse(renderer.plot().horizontalaxis().type(), string) );
    });
    
});

Renderer.DataMeasureOption = new jermaine.Model("Renderer.DataMeasureOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.validatesWith(function (value) {
        var DataMeasure = require('./data_measure.js');
        return DataMeasure.isInstance(value) || value === null;
    });
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return this.value();
    });
    this.respondsTo("valueEq", function (value) {
        return this.value().eq(value);
    });
});

Renderer.VerticalDataMeasureOption = new jermaine.Model("Renderer.DataMeasureOption", function () {
    this.isA(Renderer.DataMeasureOption);
    this.respondsTo("parseValue", function (string, renderer) {
        var DataMeasure = require('./data_measure.js');
        this.value( DataMeasure.parse(renderer.plot().verticalaxis().type(), string) );
    });
    
});

Renderer.HorizontalDataMeasureOption = new jermaine.Model("Renderer.DataMeasureOption", function () {
    this.isA(Renderer.DataMeasureOption);
    this.isBuiltWith("value");
    this.respondsTo("parseValue", function (string, renderer) {
        var DataMeasure = require('./data_measure.js');
        this.value( DataMeasure.parse(renderer.plot().horizontalaxis().type(), string) );
    });
    
});

Renderer.Type = Type;

module.exports = Renderer;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/enum.js":102,"../math/rgb_color.js":105,"../util/utilityFunctions.js":157,"./constant_plot.js":24,"./data_measure.js":28,"./data_value.js":30,"./plot.js":54,"./warning.js":66}],58:[function(require,module,exports){
require('./band_renderer.js');
require('./bar_renderer.js');
require('./fill_renderer.js');
require('./pointline_renderer.js');
require('./rangebar_renderer.js');

},{"./band_renderer.js":59,"./bar_renderer.js":60,"./fill_renderer.js":61,"./pointline_renderer.js":62,"./rangebar_renderer.js":63}],59:[function(require,module,exports){
var jermaine = require('../../../lib/jermaine/src/jermaine.js');

// The Band renderer is a 2-variable renderer which fills the region
// between two data lines with a solid color, and draws a line segment
// between consecutive data points in each line.
// 
// It is very similar to the fill renderer except that the filled region
// extends between the two (vertical axis) data values at each data point, instead
// of between a single (vertical axis) value and a horizontal base line.
// 
// The line segements should occlude the solid fill.
// 
// This renderer accepts the following options:
// 
//     OPTION NAME:          linecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          Color used for line segments.
// 
//     OPTION NAME:          linewidth
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Width, in pixels, of line segments.  A
//                           value of 0 means do not draw line segments.
// 
//     OPTION NAME:          line1color
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        none (linecolor is used)
//     DESCRIPTION:          Color used for line segments connecting the
//                           values of variable 1.   If both linecolor and
//                           line1color are specified, line1color is used.
// 
//     OPTION NAME:          line1width
//     DATA TYPE:            number
//     DEFAULT VALUE:        -1 (linewidth is used)
//     DESCRIPTION:          Width, in pixels, of line segments connecting the
//                           values of variable 1.  A value of 0 means do not
//                           draw line segments.   If both linewidth and
//                           line1width are specified, line1width is used.
// 
//     OPTION NAME:          line2color
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        none (linecolor is used)
//     DESCRIPTION:          Color used for line segments connecting the
//                           values of variable 2.   If both linecolor and
//                           line2color are specified, line2color is used.
// 
//     OPTION NAME:          line2width
//     DATA TYPE:            number
//     DEFAULT VALUE:        -1 (linewidth is used)
//     DESCRIPTION:          Width, in pixels, of line segments connecting the
//                           values of variable 2.  A value of 0 means do not
//                           draw line segments.   If both linewidth and
//                           line2width are specified, line2width is used.
// 
//     OPTION NAME:          fillcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x808080 (dark gray)
//     DESCRIPTION:          Color used for the fill area.
// 
//     OPTION NAME:          fillopacity
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Opacity used for the fill area.
//

var Renderer = require('../renderer.js'),
    RGBColor = require('../../math/rgb_color.js');

var BandRenderer = new jermaine.Model("BandRenderer", function () {
    this.isA(Renderer);
    this.hasA("numberOfVariables").which.defaultsTo(3);
});

BandRenderer.GRAY = parseInt("80", 16) / 255;

Renderer.declareOptions(BandRenderer, "BandRendererOptions", [
    {
        "name"          : "linecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "linewidth",
        "type"          : Renderer.NumberOption,
        "default"       : 1
    },
    {
        "name"          : "line1color",
        "type"          : Renderer.RGBColorOption,
        "default"       : null
    },
    {
        "name"          : "line1width",
        "type"          : Renderer.NumberOption,
        "default"       : -1
    },
    {
        "name"          : "line2color",
        "type"          : Renderer.RGBColorOption,
        "default"       : null
    },
    {
        "name"          : "line2width",
        "type"          : Renderer.NumberOption,
        "default"       : -1
    },
    {
        "name"          : "fillcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(BandRenderer.GRAY,BandRenderer.GRAY,BandRenderer.GRAY)
    },
    {
        "name"          : "fillopacity",
        "type"          : Renderer.NumberOption,
        "default"       : 1.0
    }
]);

Renderer.BAND = new Renderer.Type("band");

Renderer.addType({"type"  : Renderer.Type.parse("band"),
                  "model" : BandRenderer});

module.exports = BandRenderer;

},{"../../../lib/jermaine/src/jermaine.js":9,"../../math/rgb_color.js":105,"../renderer.js":57}],60:[function(require,module,exports){
var jermaine = require('../../../lib/jermaine/src/jermaine.js');

// The Bar renderer is a 1-variable renderer which draws a bar at each
// non-missing data point with an outline around the bar and a solid
// fill between the bar and the horizontal axis.
// 
// This renderer accepts the following options:
// 
//     OPTION NAME:          barwidth
//     DATA TYPE:            DataMeasure
//     DEFAULT VALUE:        ???
//     DESCRIPTION:          Width, in relative terms to the type of the
//                           axis the plot is on, of the bars.
//                           
//     OPTION NAME:          baroffset
//     DATA TYPE:            number
//     DEFAULT VALUE:        0
//     DESCRIPTION:          The offset, in pixels, of the left edge of
//                           each bar from the corresponding data value.
//                           
//     OPTION NAME:          barbase
//     DATA TYPE:            DataValue
//     DEFAULT VALUE:        null
//     DESCRIPTION:          The location, relative to the plot's
//                           vertical axis, of the bottom of the bar; if
//                           no barbase is specified, the bars will
//                           extend down to the bottom of the plot area.
//                           
//     OPTION NAME:          linecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          The color to be used for the outline around
//                           each bar.
// 
//     OPTION NAME:          fillcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          The color to be used for the fill inside
//                           each bar; if barbase is specified, this
//                           color is used only for bars that extend
//                           above the base.
// 
//     OPTION NAME:          fillopacity
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Opacity used for the fill inside each bar.
// 
//     OPTION NAME:          hidelines
//     DATA TYPE:            number
//     DEFAULT VALUE:        2
//     DESCRIPTION:          Bars which are less wide, in pixels, than
//                           this number do not render their outlines.
//                           
var Renderer = require('../renderer.js'),
    RGBColor = require('../../math/rgb_color.js'),
    DataMeasure = require('../data_measure.js'),
    utilityFunctions = require('../../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer);

var BarRenderer = new jermaine.Model("BarRenderer", function () {
    this.isA(Renderer);
    this.hasA("numberOfVariables").which.defaultsTo(2);
});

Renderer.declareOptions(BarRenderer, "BarRendererOptions", [
    {
        "name"          : "barwidth",
        "type"          : Renderer.HorizontalDataMeasureOption,
        "default"       : new DataMeasure.parse("number", 0)
    },
    {
        "name"          : "baroffset",
        "type"          : Renderer.NumberOption,
        "default"       : 0
    },
    {
        "name"          : "barbase",
        "type"          : Renderer.VerticalDataValueOption,
        "default"       : null
    },
    {
        "name"          : "fillcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "fillopacity",
        "type"          : Renderer.NumberOption,
        "default"       : 1.0
    },
    {
        "name"          : "linecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "hidelines",
        "type"          : Renderer.NumberOption,
        "default"       : 2
    }
]);

Renderer.BAR = new Renderer.Type("bar");

Renderer.addType({"type"  : Renderer.Type.parse("bar"),
                  "model" : BarRenderer});

module.exports = BarRenderer;

},{"../../../lib/jermaine/src/jermaine.js":9,"../../math/rgb_color.js":105,"../../util/utilityFunctions.js":157,"../data_measure.js":28,"../renderer.js":57}],61:[function(require,module,exports){
var jermaine = require('../../../lib/jermaine/src/jermaine.js');

// The Fill renderer is a 1-variable renderer which connects consecutive
// non-missing data points with line segments with a solid fill between
// the lines and the horizontal axis.
// 
// The line segements should occlude the solid fill.
// 
// This renderer accepts the following options:
// 
//     OPTION NAME:          linecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          Color used for line segments
// 
//     OPTION NAME:          linewidth
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Width, in pixels, of line segments.  A
//                           value of 0 means do not draw line segments.
// 
//     OPTION NAME:          fillcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x808080 (dark gray)
//     DESCRIPTION:          Color used for the fill area.
// 
//     OPTION NAME:          downfillcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        null
//     DESCRIPTION:          Color used for fill area that is below the
//                           fillbase, if a fillbase is specified. If no
//                           downfillcolor is specifed, fillcolor will
//                           be used for all fill areas.
// 
//     OPTION NAME:          fillopacity
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Opacity used for the fill area.
// 
//     OPTION NAME:          fillbase
//     DATA TYPE:            DataValue
//     DEFAULT VALUE:        null
//     DESCRIPTION:          The location along the plot's vertical axis
//                           of the horizontal line that defines the
//                           bottom (or top) of the filled region; if no
//                           fillbase is specified, the fill will extend
//                           down to the bottom of the plot area.
// 
var Renderer = require('../renderer.js'),
    RGBColor = require('../../math/rgb_color.js'),
    utilityFunctions = require('../../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer);

var FillRenderer = new jermaine.Model("FillRenderer", function () {
    this.isA(Renderer);
    this.hasA("numberOfVariables").which.defaultsTo(2);
});

FillRenderer.GRAY = parseInt("80", 16) / 255;

Renderer.declareOptions(FillRenderer, "FillRendererOptions", [
    {
        "name"          : "linecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "linewidth",
        "type"          : Renderer.NumberOption,
        "default"       : 1
    },
    {
        "name"          : "fillcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(FillRenderer.GRAY,FillRenderer.GRAY,FillRenderer.GRAY)
    },
    {
        "name"          : "downfillcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : null
    },
    {
        "name"          : "fillopacity",
        "type"          : Renderer.NumberOption,
        "default"       : 1.0
    },
    {
        "name"          : "fillbase",
        "type"          : Renderer.VerticalDataValueOption,
        "default"       : null
    }
]);

Renderer.FILL = new Renderer.Type("fill");

Renderer.addType({"type"  : Renderer.Type.parse("fill"),
                  "model" : FillRenderer});

module.exports = FillRenderer;

},{"../../../lib/jermaine/src/jermaine.js":9,"../../math/rgb_color.js":105,"../../util/utilityFunctions.js":157,"../renderer.js":57}],62:[function(require,module,exports){
var jermaine = require('../../../lib/jermaine/src/jermaine.js');

// The Pointline renderer is a 1-variable renderer which draws a shape
// at each non-missing data point, and connects consecutive
// non-missing data points with line segments.  The drawing of both
// the points, and the lines, is optional, so this renderer can be
// used to draw just points, just line segments, or both.
// 
// When both points and line segments are drawn, the points should
// be drawn on "top of" the line segments.
// 
// This renderer accepts the following options:
// 
//     OPTION NAME:          linewidth
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Width, in pixels, of line segments.  A
//                           value of 0 means do not draw line segments.
// 
//     OPTION NAME:          linecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          Color used for line segments
// 
//     OPTION NAME:          pointsize
//     DATA TYPE:            number
//     DEFAULT VALUE:        0
//     DESCRIPTION:          The radius of drawn points.  A value
//                           of 0 means do not draw points.
// 
//     OPTION NAME:          pointcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          Color used for drawing points
// 
//     OPTION NAME:          pointshape
//     DATA TYPE:            One of the constants PointlineRenderer.CIRCLE,
//                           PointlineRenderer.SQUARE, PointlineRenderer.TRIANGLE,
//                           PointlineRenderer.DIAMOND, PointlineRenderer.STAR,
//                           PointlineRenderer.PLUS, or PointlineRenderer.X.  These
//                           correspond to the strings "circle", "square", "triangle",
//                           "diamond", "star", "plus", and "x" in MUGL files.
//     DEFAULT VALUE:        PointlineRenderer.CIRCLE
//     DESCRIPTION:          The shape to use for drawing points.
// 
//     OPTION NAME:          linestroke
//     DATA TYPE:            One of the constants PointlineRenderer.SOLID,
//                           PointlineRenderer.DASHED.  These
//                           correspond to the strings "solid", "dashed" in MUGL files.
//     DEFAULT VALUE:        PointlineRenderer.SOLID
//     DESCRIPTION:          Whether to draw solid or dashed lines
// 
//     OPTION NAME:          pointopacity
//     DATA TYPE:            number
//     DEFAULT VALUE:        1.0
//     DESCRIPTION:          The opactiy of the drawn points, in the range 0-1.
//                           A value of 1 means completely opaque; a value of 0
//                           means completely invisible.
// 
//     OPTION NAME:          pointoutlinewidth
//     DATA TYPE:            number
//     DEFAULT VALUE:        0
//     DESCRIPTION:          The width, in pixels, of the outline to be drawn
//                           around each point.  A value of 0 means draw no
//                           outline.
// 
//     OPTION NAME:          pointoutlinecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          The color to use for the outline around each point.
//
var Renderer = require('../renderer.js'),
    RGBColor = require('../../math/rgb_color.js'),
    utilityFunctions = require('../../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer);

var PointlineRenderer = new jermaine.Model("PointlineRenderer", function () {
    this.isA(Renderer);
    this.hasA("numberOfVariables").which.defaultsTo(2);
    //
    //this.isBuiltWith(...)  NO NO NO!!!
    //
    // DO NOT CALL isBuiltWith for a renderer subclass; Renderer.declareOptions calls isBuiltWith(), and it
    // will break if you also call it here!!!
});


PointlineRenderer.CIRCLE   = "circle";
PointlineRenderer.SQUARE   = "square";
PointlineRenderer.TRIANGLE = "triangle";
PointlineRenderer.DIAMOND  = "diamond";
PointlineRenderer.STAR     = "star";
PointlineRenderer.PLUS     = "plus";
PointlineRenderer.X        = "x";

PointlineRenderer.shapes = [ 
    PointlineRenderer.CIRCLE,
    PointlineRenderer.SQUARE,
    PointlineRenderer.TRIANGLE,
    PointlineRenderer.DIAMOND,
    PointlineRenderer.STAR,
    PointlineRenderer.PLUS,
    PointlineRenderer.X
];

PointlineRenderer.isShape = function (shape) {
    var i;
    for (i=0; i<PointlineRenderer.shapes.length; ++i) {
        if (PointlineRenderer.shapes[i] === shape) { return true; }
    }
    return false;
};

PointlineRenderer.parseShape = function (string) {
    if (string.toLowerCase() === PointlineRenderer.CIRCLE)   { return PointlineRenderer.CIRCLE;   }
    if (string.toLowerCase() === PointlineRenderer.SQUARE)   { return PointlineRenderer.SQUARE;   }
    if (string.toLowerCase() === PointlineRenderer.TRIANGLE) { return PointlineRenderer.TRIANGLE; }
    if (string.toLowerCase() === PointlineRenderer.DIAMOND)  { return PointlineRenderer.DIAMOND;  }
    if (string.toLowerCase() === PointlineRenderer.STAR)     { return PointlineRenderer.STAR;     }
    if (string.toLowerCase() === PointlineRenderer.PLUS)     { return PointlineRenderer.PLUS;     }
    if (string.toLowerCase() === PointlineRenderer.X)        { return PointlineRenderer.X;        }
    throw new Error("unknown point shape: " + string);
};

/*
 * This function converts a "shape" enum object to a string.  In reality, the objects ARE
 * the strings, so we just return the object.
 */
PointlineRenderer.serializeShape = function (shape) {
    return shape;
};

PointlineRenderer.ShapeOption = new jermaine.Model("PointlineRenderer.ShapeOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.validatesWith(PointlineRenderer.isShape);
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return PointlineRenderer.serializeShape(this.value());
    });
    this.respondsTo("parseValue", function (string) {
        this.value( PointlineRenderer.parseShape(string) );
    });
    this.respondsTo("valueEq", function (value) {
        return (this.value()===value);
    });
});

///////////////////////////////////////////////////////////////////////

PointlineRenderer.SOLID   = "solid";
PointlineRenderer.DASHED  = "dashed";

PointlineRenderer.strokes = [ 
    PointlineRenderer.SOLID,
    PointlineRenderer.DASHED
];

PointlineRenderer.isStroke = function (stroke) {
    var i;
    for (i=0; i<PointlineRenderer.strokes.length; ++i) {
        if (PointlineRenderer.strokes[i] === stroke) { return true; }
    }
    return false;
};

PointlineRenderer.parseStroke = function (string) {
    if (string.toLowerCase() === PointlineRenderer.SOLID)   { return PointlineRenderer.SOLID;   }
    if (string.toLowerCase() === PointlineRenderer.DASHED)  { return PointlineRenderer.DASHED;   }
    throw new Error("unknown line stroke: " + string);
};

/*
 * This function converts a "stroke" enum object to a string.  In reality, the objects ARE
 * the strings, so we just return the object.
 */
PointlineRenderer.serializeStroke = function (stroke) {
    return stroke;
};

PointlineRenderer.StrokeOption = new jermaine.Model("PointlineRenderer.StrokeOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.validatesWith(PointlineRenderer.isStroke);
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return PointlineRenderer.serializeStroke(this.value());
    });
    this.respondsTo("parseValue", function (string) {
        this.value( PointlineRenderer.parseStroke(string) );
    });
    this.respondsTo("valueEq", function (value) {
        return (this.value()===value);
    });
});

///////////////////////////////////////////////////////////////////////

Renderer.declareOptions(PointlineRenderer, "PointlineRendererOptions", [
    {
        "name"          : "linecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "linewidth",
        "type"          : Renderer.NumberOption,
        "default"       : 1
    },
    {
        "name"          : "pointshape",
        "type"          : PointlineRenderer.ShapeOption,
        "default"       : PointlineRenderer.CIRCLE
    },
    {
        "name"          : "linestroke",
        "type"          : PointlineRenderer.StrokeOption,
        "default"       : PointlineRenderer.SOLID
    },
    {
        "name"          : "pointsize",
        "type"          : Renderer.NumberOption,
        "default"       : 0
    },
    {
        "name"          : "pointcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "pointopacity",
        "type"          : Renderer.NumberOption,
        "default"       : 1.0
    },
    {
        "name"          : "pointoutlinewidth",
        "type"          : Renderer.NumberOption,
        "default"       : 0
    },
    {
        "name"          : "pointoutlinecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    }
]);

Renderer.POINTLINE = new Renderer.Type("pointline");
Renderer.POINT     = new Renderer.Type("point");
Renderer.LINE      = new Renderer.Type("line");

Renderer.addType({"type"  : Renderer.Type.parse("pointline"),
                  "model" : PointlineRenderer});
Renderer.addType({"type"  : Renderer.Type.parse("line"),
                  "model" : PointlineRenderer});
Renderer.addType({"type"  : Renderer.Type.parse("point"),
                  "model" : PointlineRenderer});

module.exports = PointlineRenderer;


},{"../../../lib/jermaine/src/jermaine.js":9,"../../math/rgb_color.js":105,"../../util/utilityFunctions.js":157,"../renderer.js":57}],63:[function(require,module,exports){
var jermaine = require('../../../lib/jermaine/src/jermaine.js');

// The RangeBar renderer is a 2-variable renderer which draws a
// vertical bar between two data values, and optionally outlines
// around the bars.  It is very similar to the Bar renderer except
// that the bar is drawn between two data values, instead of between a
// single data value and a base line.
// 
// The line segements should occlude the solid fill.
// 
// This renderer accepts the following options:
// 
//     OPTION NAME:          barwidth
//     DATA TYPE:            DataMeasure
//     DEFAULT VALUE:        ???
//     DESCRIPTION:          Width, in relative terms to the type of the
//                           axis the plot is on, of the bars.
//                           
//     OPTION NAME:          baroffset
//     DATA TYPE:            number
//     DEFAULT VALUE:        0
//     DESCRIPTION:          The offset of the left edge of each bar
//                           from the corresponding data value, as a
//                           fraction (0-1) of the barwidth.
// 
//     OPTION NAME:          fillcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x808080 (dark gray)
//     DESCRIPTION:          Color used for filling the bars.
// 
//     OPTION NAME:          fillopacity
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Opacity used for the fill area.
// 
//     OPTION NAME:          linecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          Color used for outlines around the bars.
// 
//     OPTION NAME:          linewidth
//     DATA TYPE:            number
//     DEFAULT VALUE:        0
//     DESCRIPTION:          Width, in pixels, of outlines around
//                           the bars.  A value of 0 (which is the
//                           default) means don't draw outlines.
// 
//     OPTION NAME:          hidelines
//     DATA TYPE:            number
//     DEFAULT VALUE:        2
//     DESCRIPTION:          Bars which are less wide, in pixels, than
//                           this number do not render their outlines.
// 
var Renderer = require('../renderer.js'),
    RGBColor = require('../../math/rgb_color.js'),
    DataMeasure = require('../data_measure.js'),
    utilityFunctions = require('../../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer);

var RangeBarRenderer = new jermaine.Model("RangeBarRenderer", function () {
    this.isA(Renderer);
    this.hasA("numberOfVariables").which.defaultsTo(3);
});

Renderer.declareOptions(RangeBarRenderer, "RangeBarRendererOptions", [
    {
        "name"          : "barwidth",
        "type"          : Renderer.HorizontalDataMeasureOption,
        "default"       : new DataMeasure.parse("number", 0)
    },
    {
        "name"          : "baroffset",
        "type"          : Renderer.NumberOption,
        "default"       : 0
    },
    {
        "name"          : "fillcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : RGBColor.parse("0x808080")
    },
    {
        "name"          : "fillopacity",
        "type"          : Renderer.NumberOption,
        "default"       : 1.0
    },
    {
        "name"          : "linecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "linewidth",
        "type"          : Renderer.NumberOption,
        "default"       : 1
    },
    {
        "name"          : "hidelines",
        "type"          : Renderer.NumberOption,
        "default"       : 2
    }
]);

Renderer.RANGEBAR = new Renderer.Type("rangebar");

Renderer.addType({"type"  : Renderer.Type.parse("rangebar"),
                  "model" : RangeBarRenderer});

module.exports = RangeBarRenderer;

},{"../../../lib/jermaine/src/jermaine.js":9,"../../math/rgb_color.js":105,"../../util/utilityFunctions.js":157,"../data_measure.js":28,"../renderer.js":57}],64:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/**
 * Text is a Jermaine model that supports storing and determining metrics of
 * strings in different graphics contexts.
 *
 * @class Text
 * @for Text
 * @constructor
 * @param string {String} The string stored in the Text model
 */
var Text = new jermaine.Model("Text", function () {
    this.isBuiltWith("string");

    /**
     * The string stored in the Text model
     *
     * @property string
     * @type {String}
     */
    this.hasA("string").which.isA("string");

    /**
     * The unrotated width of the string
     *
     * @property origWidth
     * @type {float}
     * @final
     */
    this.hasA("origWidth").which.isA("number");

    /**
     * The unrotated height of the string
     *
     * @property origHeight
     * @type {float}
     * @final
     */
    this.hasA("origHeight").which.isA("number");

    /**
     * The rotated width of the string
     *
     * @property rotatedWidth
     * @type {float}
     * @final
     */
    this.hasA("rotatedWidth").which.isA("number");

    /**
     * The rotated height of the string
     *
     * @property rotatedHeight
     * @type {float}
     * @final
     */
    this.hasA("rotatedHeight").which.isA("number");

    this.hasA("font").which.isA("string").and.which.defaultsTo("");

    /**
     * Determines unrotated and rotated widths and heights for the stored string. Overridden by
     * implementations in graphics drivers.
     *
     * @method initializeGeometry
     * @chainable
     * @param {Object} graphicsContext
     *   @param {Float} graphicsContext.angle
     */
    this.respondsTo("initializeGeometry", function (graphicsContext) {
        var origWidth,
            origHeight,
            rotatedWidth,
            rotatedHeight;

        origWidth  = this.measureStringWidth(graphicsContext);
        origHeight = this.measureStringHeight(graphicsContext);
        rotatedWidth = origWidth;
        rotatedHeight = origHeight;

        if (graphicsContext && graphicsContext.angle !== undefined) {
            var angle = graphicsContext.angle/180 * Math.PI;
            rotatedWidth = Math.abs(Math.cos(angle)) * origWidth + Math.abs(Math.sin(angle)) * origHeight;
            rotatedHeight = Math.abs(Math.sin(angle)) * origWidth + Math.abs(Math.cos(angle)) * origHeight;
        }

        this.origWidth(origWidth);
        this.origHeight(origHeight);
        this.rotatedWidth(rotatedWidth);
        this.rotatedHeight(rotatedHeight);

        return this;
    });

    /**
     * Determines unrotated width for the stored string. Overridden by implementations in graphics
     * drivers.
     *
     * @method measureStringWidth
     * @private
     * @return {Float} Unrotated width of string.
     * @param {Object} graphicsContext
     */
    this.respondsTo("measureStringWidth", function (graphicsContext) {
        // Graphics drivers should replace this method with an actual implementation; this
        // is just a placeholder.  The implementation should return the width, in pixels,
        // of the given string.  Of course this is dependent on font choice, size, etc,
        // but we gloss over that at the moment.  Just return the width of the string
        // using some reasonable default font for now.  Later on, we'll modify this
        // function to use font information.
        var lines,
            maxLength = 1,
            testLength,
            i;

        if (this.string() === undefined) {
            throw new Error("measureStringWidth requires the string attr to be set.");
        }

        lines = this.string().split(/\n/);
        for (i = 0; i < lines.length; i++) {
            testLength = lines[i].length;
            if (testLength > maxLength) {
                maxLength = testLength;
            }
        }
        
        return maxLength * 15;
    });

    /**
     * Determines unrotated height for the stored string. Overridden by implementations in graphics
     * drivers.
     *
     * @method measureStringHeight
     * @private
     * @return {Float} Unrotated height of string.
     * @param {Object} graphicsContext
     */
    this.respondsTo("measureStringHeight", function (graphicsContext) {
        // Graphics drivers should replace this method with an actual implementation; this
        // is just a placeholder.  The implementation should return the height, in pixels,
        // of the given string.  Of course this is dependent on font choice, size, etc,
        // but we gloss over that at the moment.  Just return the height of the string
        // using some reasonable default font for now.  Later on, we'll modify this
        // function to use font information.
        if (this.string() === undefined) {
            throw new Error("measureStringHeight requires the string attr to be set.");
        }
        var newlineCount = this.string().match(/\n/g);
        return (newlineCount !== null ? (newlineCount.length + 1) : 1) * 12;
    });
});

module.exports = Text;

},{"../../lib/jermaine/src/jermaine.js":9}],65:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Text = require('./text.js'),
    RGBColor = require('../math/rgb_color.js'),
    Point = require('../math/point.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.title);

/**
 * Title is a Jermiane model that controls Graph Titles.
 *
 * @class Title
 * @for Title
 * @constructor
 * @param {Text} text
 * @param {Graph} graph
 * @author jrfrimme
 */
var Title = new jermaine.Model("GraphTitle", function () {
    /**
     * Pointer to the Title's parent Graph Jermaine model.
     *
     * @property graph
     * @type {Graph}
     * @author jrfrimme
     */
    this.hasA("graph").which.validatesWith(function (graph) {
        var Graph = require('./graph.js');
        return graph instanceof Graph;
    });
    /**
     * The text of the title.
     *
     * @property text
     * @type {Text}
     * @author jrfrimme
     */
    this.hasA("text").which.validatesWith(function (text) {
        return text instanceof Text;
    });
    /**
     * Determines if the Title is positioned relative to the Graphs `plot` or `padding`
     * box.
     *
     * @property frame
     * @type {String}
     * @author jrfrimme
     */
    this.hasA("frame").which.isA("string");
    /**
     * The width of the border to be drawn around the title in pixel; use a value of `0`
     * to not draw a border.
     *
     * @property border
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("border").which.isAn("integer");
    /**
     * Background color for the Title's region.
     *
     * @property color
     * @type {RGBColor}
     * @author jrfrimme
     */
    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    });
    /**
     * Color for the Title's border.
     *
     * @property bordercolor
     * @type {RGBColor}
     * @author jrfrimme
     */
    this.hasA("bordercolor").which.validatesWith(function (bordercolor) {
        return bordercolor instanceof RGBColor;
    });
    /**
     * Opacity of the Title's region.
     *
     * @property opacity
     * @type {Number}
     * @author jrfrimme
     */
    this.hasA("opacity").which.isA("number");
    /**
     * The width of the padding between the Title's text and its border in pixels; use a
     * value of `0` to not draw the padding.
     *
     * @property padding
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("padding").which.isAn("integer");
    /**
     * Determines whether the corners of the title appear rounded. If cornerradius is 0,
     * which is the default, the corners are drawn square. If cornerradius > 0, then the
     * corners are rounded off using circles whose radius is cornerradius pixels.
     *
     * @property cornerradius
     * @deprecated
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("cornerradius").which.isAn("integer");
    /**
     * A coordinate pair which gives the relative location of the Title's anchor point.
     *
     * @property anchor
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("anchor").which.validatesWith(function (anchor) {
        return anchor instanceof Point;
    });
    /**
     * A coordinate pair which gives the location of the Title's base point, relative to
     * its Graph's plot or padding box - determined by the `frame` attribute.
     *
     * @property base
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("base").which.validatesWith(function (base) {
        return base instanceof Point;
    });
    /**
     * A coordinate pair of pixel offsets for the base point.
     *
     * @property position
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });
    /**
     * The font-size of the title. Currently is a constant.
     *
     * @property font-size
     * @type {String}
     * @author jrfrimme
     */
    this.hasA("fontSize").which.isA("string").and.defaultsTo("18px");

    /**
     * Determines the geometry of the Title's text.
     *
     * @method initializeGeometry
     * @chainable
     * @param {Object} graphicsContext
     * @author jrfrimme
     */
    this.respondsTo("initializeGeometry", function (graphicsContext) {
        graphicsContext.fontSize = this.fontSize();
        this.text().initializeGeometry(graphicsContext);
        return this;
    });

    /**
     * Renders the Graph Title. Overridden by implementations in graphics drivers.
     *
     * @method render
     * @private
     * @author jrfrimme
     */
    this.respondsTo("render", function () {});

    this.isBuiltWith("text", "graph");

    utilityFunctions.insertDefaults(this, defaultValues.title, attributes);

});

module.exports = Title;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/point.js":104,"../math/rgb_color.js":105,"../util/utilityFunctions.js":157,"./graph.js":41,"./text.js":64}],66:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Warning = function(message) {
    this.message = message;
};

Warning.prototype = new Error();

module.exports  = Warning;

},{"../../lib/jermaine/src/jermaine.js":9}],67:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
var WebServiceData;
module.exports = function($) {
    if (typeof(WebServiceData) !== "undefined") { return WebServiceData; }

    var jermaine = require('../../lib/jermaine/src/jermaine.js');

    var Data = require('./data.js'),
        DataValue = require('./data_value.js'),
        DataFormatter = require('./data_formatter.js'),
        ArrayData = require('./array_data.js'),
        WebServiceDataCacheNode = require('./web_service_data_cache_node.js'),
        WebServiceDataIterator = require('./web_service_data_iterator.js');

    WebServiceData = new jermaine.Model(function () {
        this.isA(Data);
        this.hasA("serviceaddress").which.isA("string");
        this.hasA("serviceaddresspattern").which.isA("string");
        this.hasA("format").which.isA("string");
        this.hasA("formatter").which.validatesWith(DataFormatter.isInstance);
        this.hasA("messageHandler");
        this.hasA("ajaxthrottle");
        this.isBuiltWith("columns", "serviceaddress", "%messageHandler", "%ajaxthrottle", function () {
            this.init();
            if (this.columns().size() > 0) {
                var column0Type = this.columns().at(0).type();
                if (this.format() === undefined) {
                    this.format(column0Type===DataValue.NUMBER ? "%f" : "%Y%M%D%H%i%s");
                }
                this.formatter(DataFormatter.create(column0Type, this.format()));
            }
            if (this.ajaxthrottle() === undefined) {
                this.ajaxthrottle($);
            }
        });

        this.respondsTo("_displayError", function (e) {
            if (this.messageHandler()) {
                this.messageHandler().error(e);
            } else {
                throw e;
            }
        });

        this.respondsTo("getBounds", function (columnNumber) {
            // TODO: replace this kludge
            return [0, 10];
        });

        this.hasA("arraydata").which.defaultsTo(null).and.validatesWith(function (arraydata) {
            return arraydata instanceof ArrayData || arraydata === null;
        });

        /**
         * A pointer to the head WebServiceDataCacheNode in this WebServieData's cache.
         *
         * @property cacheHead
         * @type {null|WebServiceDataCacheNode}
         * @author jrfrimme
         */
        this.hasA("cacheHead").which.defaultsTo(null).and.validatesWith(function (x) {
            return x === null || x instanceof WebServiceDataCacheNode;
        });

        /**
         * A pointer to the tail WebServiceDataCacheNode in this WebServieData's cache.
         *
         * @property cacheTail
         * @type {null|WebServiceDataCacheNode}
         * @author jrfrimme
         */
        this.hasA("cacheTail").which.defaultsTo(null).and.validatesWith(function (x) {
            return x === null || x instanceof WebServiceDataCacheNode;
        });

        /**
         * Return a pointer to the first WebServiceDataCacheNode in this WebServieData's cache
         * that actually contains data, if any.  If the cache doesn't contain any data, return null.
         *
         * @method dataHead
         * @author jrfrimme
         * @return {null|WebServiceDataCacheNode}
         */
        this.respondsTo("dataHead", function () {
            var head = this.cacheHead();
            if (head === null) { return null; }
            if (head.hasData()) { return head; }
            return head.dataNext();
        });

        /**
         * Return a pointer to the last WebServiceDataCacheNode in this WebServieData's cache
         * that actually contains data, if any.  If the cache doesn't contain any data, return null.
         *
         * @method dataTail
         * @author jrfrimme
         * @return {null|WebServiceDataCacheNode}
         */
        this.respondsTo("dataTail", function () {
            var tail = this.cacheTail();
            if (tail === null) { return null; }
            if (tail.hasData()) { return tail; }
            return tail.dataPrev();
        });

        /**
         * Insert a WebServiceCacheNode into this WebService's cache.
         * If this node's coveredMin is less than the cache head's
         * coveredMin, insert it at the head; otherwise insert it at
         * the tail.  Note that nodes are only inserted either at the
         * head or at the tail of the cache --- not in the middle.
         *
         * @method insertCacheNode
         * @param {WebServiceCacheNode} node
         * @author jrfrimme
         */
        this.respondsTo("insertCacheNode", function (node) {
            var head = this.cacheHead(),
                tail = this.cacheTail();
            if (head === null) {
                this.cacheHead(node);
                this.cacheTail(node);
            } else {
                if (node.coveredMin().lt(head.coveredMin())) {
                    node.next(head);
                    head.prev(node);
                    this.cacheHead(node);
                } else {
                    node.prev(tail);
                    tail.next(node);
                    this.cacheTail(node);
                }
            }
        });

        this.respondsTo("constructRequestURL", function (min, max) {
            var serviceaddress = this.serviceaddress(),
                formatter = this.formatter();

            if (serviceaddress === undefined) {
                throw new Error("WebServiceData.constructRequestURL: undefined service address");
            }
            if (formatter === undefined) {
                throw new Error("WebServiceData.constructRequestURL: undefined formatter for column 0");
            }
            if (this.serviceaddresspattern() === undefined) {
                if ((serviceaddress.indexOf("$min") < 0) &&
                    (serviceaddress.indexOf("$max") < 0)) {
                    this.serviceaddresspattern(serviceaddress + "$min,$max");
                } else {
                    this.serviceaddresspattern(serviceaddress);
                }
            }
            return (this.serviceaddresspattern()
                    .replace("$min", formatter.format(min))
                    .replace("$max", formatter.format(max)));
        });

        this.hasA("coveredMin").which.defaultsTo(null).and.validatesWith(function (x) {
            return x === null || DataValue.isInstance(x);
        });
        this.hasA("coveredMax").which.defaultsTo(null).and.validatesWith(function (x) {
            return x === null || DataValue.isInstance(x);
        });

        /**
         * Initiate requests needed to fetch data between coveredMin and coveredMax, if any.
         *
         * @method insureCoveredRange
         * @author jrfrimme
         */
        this.respondsTo("insureCoveredRange", function () {
            var head = this.cacheHead(),
                tail = this.cacheTail(),
                coveredMin = this.coveredMin(),
                coveredMax = this.coveredMax();

            if (coveredMin === null || coveredMax === null) {
                return;
            }
            if (head === null || tail === null) {
                this.requestSingleRange(coveredMin, coveredMax);
            } else {
                if (coveredMin.lt(head.coveredMin())) {
                    //                     head's min              tail's max
                    //  -----|-------------|-----------------------|----------------
                    //       coveredMin
                    this.requestSingleRange(coveredMin, head.coveredMin());
                }
                if (coveredMax.gt(tail.coveredMax())) {
                    //                     head's min              tail's max
                    //  -------------------|-----------------------|-----------|----
                    //                                                         coveredMax
                    this.requestSingleRange(tail.coveredMax(), coveredMax);
                }
            }
        });

        this.respondsTo("requestSingleRange", function (min, max) {
            var node,
                requestURL,
                that = this,
                JQueryXMLParser = require('../parser/xml/jquery_xml_parser.js')($);

            // create the cache node that will hold the data in this range
            node = new WebServiceDataCacheNode(min, max);

            // insert it into the cache linked list
            this.insertCacheNode(node);

            // construct the URL for fetching the data in this range
            requestURL = this.constructRequestURL(min, max);

            // initiate the fetch request
            this.emit({type : 'ajaxEvent', action : 'start'});
            this.ajaxthrottle().ajax({
                url      : requestURL,
                dataType : "text",
                success  : function (data, textStatus, jqXHR) {
                    // if data contains a <values> tag, extract its text string value
                    if (data.indexOf("<values>") > 0) {
                        data = JQueryXMLParser.stringToJQueryXMLObj(data).find("values").text();
                    }
                    node.parseData(that.getColumns(), data);

                    that.emit({type : 'ajaxEvent', action : 'success'});
                    that.emit({type : 'dataReady'});
                },

                error : function (jqXHR, textStatus, errorThrown) {
                    var message = errorThrown;
                    if (jqXHR.statusCode().status === 404) {
                        message = "URL not found: '" + requestURL + '"';
                    } else {
                        if (textStatus) {
                            message = textStatus + ": " + message;
                        }
                    }
                    that._displayError(new Error(message));
                },

                // 'complete' callback gets called after either 'success' or 'error', whichever:
                complete : function (jqXHR, textStatus) {
                    that.emit({type : 'ajaxEvent', action : 'complete'});
                }

            });
        });

        this.respondsTo("getIterator", function (columnIds, min, max, buffer) {
            var initialNode,
                initialIndex,
                n, b, i, tmp,
                finalNode,
                finalIndex,
                columnIndices;

            // if min > max, swap them
            if (min.gt(max)) {
                tmp = min;
                min = max;
                max = tmp;
            }

            if (this.coveredMin() === null || min.lt(this.coveredMin())) {
                this.coveredMin(min.clone());
            }
            if (this.coveredMax() === null || max.gt(this.coveredMax())) {
                this.coveredMax(max.clone());
            }

            if (!this.paused()) {
                this.insureCoveredRange();
            }

            if (this.dataHead() === null) {
                // cache is empty, return empty iterator:
                return {
                    "next"    : function () {},
                    "hasNext" : function () { return false; }
                };
            }
            // convert columnIds to columnIndices
            columnIndices = [];
            for (i = 0; i < columnIds.length; ++i) {
                columnIndices.push( this.columnIdToColumnNumber(columnIds[i]) );
            }

            // find the data node containing the 'min' value
            initialNode = this.dataHead();
            while ((initialNode !== null) &&
                   (initialNode.dataNext() !== null) &&
                   (min.gt(initialNode.dataMax()))) {
                initialNode = initialNode.dataNext();
            }
            
            if (initialNode === null || !initialNode.hasData()) {
                initialIndex = -1;
            } else {
                initialIndex = 0;
                // find the index within the initial node corresponding to the 'min' value
                while ((initialIndex < initialNode.data().length-1) &&
                       (initialNode.data()[initialIndex][columnIndices[0]].lt(min))) {
                    ++initialIndex;
                }
                
                // back up 'buffer' steps, being careful not to go further back than the first element of the head node
                n = 0;
                while (n<buffer) {
                    --initialIndex;
                    if (initialIndex<0) {
                        b = initialNode.dataPrev();
                        if (b !== null) {
                            initialNode = b;
                            initialIndex = initialNode.data().length-1;
                        } else {
                            initialIndex = 0;
                            break;
                        }
                    }
                    ++n;
                }
                
                // find the data node containing the 'max' value
                finalNode = initialNode;
                while ( (max.gt(finalNode.dataMax())) &&
                        (finalNode.dataNext() !== null) ) {
                    finalNode = finalNode.dataNext();
                }
                
                // find the index within the final node corresponding to the 'max' value
                finalIndex = 0;
                if (finalNode === initialNode) {
                    finalIndex = initialIndex;
                }
                while ((finalIndex < finalNode.data().length-1) &&
                       (finalNode.data()[finalIndex][columnIndices[0]].lt(max))) {
                    ++finalIndex;
                }
                
                // go forward 'buffer' more steps, being careful not to go further than the last element of the tail
                n = 0;
                //while (n<buffer && !(finalNode===_tail && finalIndex<finalNode.data.length)) {
                while (n < buffer) {
                    ++finalIndex;
                    if (finalIndex >= finalNode.data().length) {
                        b = finalNode.dataNext();
                        if (b !== null) {
                            finalNode = b;
                            finalIndex = 0;
                        } else {
                            finalIndex = finalNode.data().length-1;
                            break;
                        }
                    }
                    ++n;
                }
                
            }
            
            return new WebServiceDataIterator(columnIndices, initialNode, initialIndex, finalNode, finalIndex);
        });

        this.hasA("paused").which.isA("boolean").and.defaultsTo(false);
        this.respondsTo("pause", function() {
            this.paused(true);
        });
        this.respondsTo("resume", function() {
            this.paused(false);
            this.emit({type : 'dataReady',
                       min : this.coveredMin(),
                       max : this.coveredMax()});
        });

    });

    return WebServiceData;
};

},{"../../lib/jermaine/src/jermaine.js":9,"../parser/xml/jquery_xml_parser.js":144,"./array_data.js":17,"./data.js":26,"./data_formatter.js":27,"./data_value.js":30,"./web_service_data_cache_node.js":68,"./web_service_data_iterator.js":69}],68:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/**
 * A WebServiceDataCacheNode represents a single node in the
 * doubly-linked list holding the data for a WebServiceDataCache.
 * The WebServiceDataCacheNode has an array of data (which may
 * actually be null, if the node's data has not yet been loaded),
 * next and prev pointers to the next and previous nodes in the
 * linked list, and coveredMin and coveredMax values that indicate
 * the min and max values of the "covered" range of data for this
 * node.
 * 
 * The "covered" range is the interval of the data number line for
 * which this node is responsible for storing data; Multigraph
 * uses range this to avoid requesting the same data twice --- it
 * never requests data for a range already covered by an existing
 * cache node.
 * 
 * Initially, when the WebServiceDataCacheNode is created, the
 * limits of the covered range are specified in the constructor.
 * Later on, when the node's data is actually populated, the
 * limits are potentially adjusted outward, if the range of data
 * received is larger than the initially specified covered range.
 * So in all cases, the covered range indicates the range for
 * which no more data is needed, because it's covered by this
 * node.
 * 
 * Note that the covered range is never adjusted to be smaller.
 * 
 * The WebServiceDataCacheNode does not actually fetch any data
 * --- it is simply a storage container for fetched data; it's up
 * to other code outside of this object to fetch and populate the
 * data.
 *
 * @class WebServiceDataCacheNode
 * @for WebServiceDataCacheNode
 * @constructor
 * @param {DataValue} coveredMin
 * @param {DataValue} coveredMax
 */
var DataValue = require('./data_value.js'),
    ArrayData = require('./array_data.js');

var WebServiceDataCacheNode = new jermaine.Model(function () {

    /**
     * The actual data for this node.
     *
     * @property data
     * @type {Array|null}
     * @author jrfrimme
     */
    this.hasA("data").which.defaultsTo(null).and.validatesWith(function (data) {
        var validationFunctions = require('../util/validationFunctions.js');
        // accept null
        if (data === null) { return true; }
        // only accept arrays
        if (validationFunctions.typeOf(data) !== "array") {
            this.message = "WebServiceDataCacheNode's data attribute is not an Array";
            return false;
        }
        // if the array contains anything, do a cursory check that it looks
        // like an array of DataValue arrays (just check the first row)
        if (data.length > 0) {
            var firstRow = data[0],
                i;
            if (validationFunctions.typeOf(firstRow) !== "array") {
                this.message = "WebServiceDataCacheNode's data attribute is not an Array of Arrays";
                return false;
            }
            for (i = 0; i < firstRow.length; ++i) {
                if (!DataValue.isInstance(firstRow[i])) {
                    this.message = "WebServiceDataCacheNode's data attribute is not an Array of Arrays of DataValues (bad value in position " + i + " of first row";
                    return false;
                }
            }
        }
        return true;
    });

    /**
     * The next node in the cache's linked list
     *
     * @property next
     * @type {WebServiceDataCacheNode|null}
     * @author jrfrimme
     */
    this.hasA("next").which.defaultsTo(null).and.validatesWith(function (x) {
        return x === null || x instanceof WebServiceDataCacheNode;
    });

    /**
     * The previous node in the cache's linked list
     *
     * @property prev
     * @type {WebServiceDataCacheNode|null}
     * @author jrfrimme
     */
    this.hasA("prev").which.defaultsTo(null).and.validatesWith(function (x) {
        return x === null || x instanceof WebServiceDataCacheNode;
    });

    /**
     * The min of the covered value range
     *
     * @property coveredMin
     * @type {DataValue}
     * @author jrfrimme
     */
    this.hasA("coveredMin").which.validatesWith(DataValue.isInstance);

    /**
     * The max of the covered value range
     *
     * @property coveredMax
     * @type {DataValue}
     * @author jrfrimme
     */
    this.hasA("coveredMax").which.validatesWith(DataValue.isInstance);

    /**
     * Return the next node in the cache that actually has data,
     * or null if none exists.
     *
     * @method dataNext
     * @author jrfrimme
     * @return {WebServiceDataCacheNode|null}
     */
    this.respondsTo("dataNext", function () {
        var node = this.next();
        while (node !== null && !node.hasData()) {
            node = node.next();
        }
        return node;
    });

    /**
     * Return the previous node in the cache that actually has data,
     * or null if none exists.
     *
     * @method dataPrev
     * @author jrfrimme
     * @return {WebServiceDataCacheNode|null}
     */
    this.respondsTo("dataPrev", function () {
        var node = this.prev();
        while (node !== null && !node.hasData()) {
            node = node.prev();
        }
        return node;
    });

    /**
     * Return the minimum (column 0) data value for this node.  Returns null
     * if the node has no data yet.
     *
     * @method dataMin
     * @author jrfrimme
     * @return {DataValue|null}
     */
    this.respondsTo("dataMin", function () {
        var data = this.data();
        if (data === null) { return null; }
        if (data.length === 0) { return null; }
        if (data[0] === null) { return null; }
        if (data[0].length === 0) { return null; }
        return data[0][0];
    });

    /**
     * Return the maximum (column 0) data value for this node.    Returns null
     * if the node has no data yet.
     *
     * @method dataMax
     * @author jrfrimme
     * @return {DataValue|null}
     */
    this.respondsTo("dataMax", function() {
        var data = this.data();
        if (data === null) { return null; }
        if (data.length === 0) { return null; }
        if (data[data.length-1] === null) { return null; }
        if (data[data.length-1].length === 0) { return null; }
        return data[data.length-1][0];
    });

    /**
     * Return true if this node has data; false if not.
     *
     * @method hasData
     * @author jrfrimme
     * @return Boolean
     */
    this.respondsTo("hasData", function() {
        return this.data() !== null;
    });

    this.isBuiltWith("coveredMin", "coveredMax");

    /**
     * Populate this node's data array by parsing the values
     * contained in the 'dataText' string, which should be a
     * string of comma-separated values of the same sort expected
     * by ArrayData and CSVData.  The first argument, `columns`,
     * should be a plain javascript array of DataVariable instances,
     * of the sort returned by `Data.getColumns()`.
     * 
     * This method examines other nodes in the cache in order
     * insure that values included in this node's data array
     * are (a) strictly greater than the maximum value present in the
     * cache prior to this node, and (b) strictly less than the
     * minimum value present in the cache after this node.
     * This guarantees that there is no overlap between the
     * data in this node and other nodes in the cache.
     *
     * @method parseData
     * @param {DataVariable Attr_List} columns
     * @param {String} dataText
     * @author jrfrimme
     */
    this.respondsTo("parseData", function (columns, dataText) {
        var i, b,
            maxPrevValue = null,
            minNextValue = null,
            arrayDataArray,
            data,
            row;

        // set maxPrevValue to the max value in column0 in the cache prior to this block, if any:
        b = this.dataPrev();
        if (b !== null) {
            maxPrevValue = b.dataMax();
        }

        // set minNextValue to the min value in column0 in the cache after this block, if any:
        b = this.dataNext();
        if (b !== null) {
            minNextValue = b.dataMin();
        }

        // convert the csv dataText string to an array
        arrayDataArray = ArrayData.textToDataValuesArray(columns, dataText);

        // populate the data array by copying values from the converted array, skipping any
        // values that are already within the range covered by the rest of the cache
        data = [];
        for (i = 0; i < arrayDataArray.length; ++i) {
            row = arrayDataArray[i];
            if ((maxPrevValue === null || row[0].gt(maxPrevValue)) &&
                (minNextValue === null || row[0].lt(minNextValue))) {
                data.push( row );
            }
        }

        // if we didn't get any new values, we're done
        if (data.length === 0) {
            return;
        }
        
        // lower the coveredMin value if the actual data received is lower than the current coveredMin value
        if (data[0][0].lt(this.coveredMin())) {
            this.coveredMin(data[0][0]);
        }

        // raise the coveredMax value if the actual data received is higher than the current coveredMax value
        if (data[data.length-1][0].gt(this.coveredMax())) {
            this.coveredMax(data[data.length-1][0]);
        }

        // load the data
        this.data( data );
    });
});

module.exports = WebServiceDataCacheNode;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/validationFunctions.js":158,"./array_data.js":17,"./data_value.js":30}],69:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/**
 * An iterator for stepping through data values stored in a linked list of
 * WebServiceDataCacheNodes.  The constructor takes 5 arguments:
 * 
 * @class WebServiceDataIterator
 * @for WebServiceDataIterator
 * @constructor
 *
 * @param {Array} columnIndices
 *     JavaScript array of the indices of the columns
 *     of data to return
 * @param {WebServiceDataCacheNode} initialNode
 *     Pointer to the WebServiceDataCacheNode containing the first
 *     value to iterate over
 * @param {integer} initialIndex
 *     Index, within initialNode, of the first value to iterate over
 * @param {WebServiceDataCacheNode} finalNode
 *     Pointer to the WebServiceDataCacheNode containing the last
 *     value to iterate over
 * @param {integer} finalIndex
 *     Index, within finalNode, of the last value to iterate over
 */
var WebServiceDataCacheNode = require('./web_service_data_cache_node.js'),
    ValidationFunctions = require('../util/validationFunctions.js');

var WebServiceDataIterator = new jermaine.Model(function () {
    var WebServiceDataIterator = this;

    this.hasA("currentNode").which.validatesWith(function(x) {
        return x instanceof WebServiceDataCacheNode;
    });
    this.hasA("currentIndex").which.isA("integer");
    this.hasA("columnIndices").which.validatesWith(function(x) {
        return ValidationFunctions.typeOf(x) === "array";
    });
    
    this.hasA("initialNode").which.validatesWith(function(x) {
        return x instanceof WebServiceDataCacheNode;
    });
    this.hasA("finalNode").which.validatesWith(function(x) {
        return x instanceof WebServiceDataCacheNode;
    });
    this.hasA("initialIndex").which.isA("integer");
    this.hasA("finalIndex").which.isA("integer");

    this.isBuiltWith("columnIndices", "initialNode", "initialIndex", "finalNode", "finalIndex", function() {
        this.currentNode(this.initialNode());
        this.currentIndex(this.initialIndex());
    });

    this.respondsTo("hasNext", function() {
        if (this.currentNode() === null || this.currentIndex() < 0) { return false; }
        if (this.currentNode() !== this.finalNode()) {
            return true;
        }
        return this.currentIndex() <= this.finalIndex();
    });

    this.respondsTo("next", function() {
        var vals = [],
            columnIndices = this.columnIndices(),
            currentIndex = this.currentIndex(),
            finalIndex = this.finalIndex(),
            currentNode = this.currentNode(),
            i;

        if (currentNode === this.finalNode()) {
            if (currentIndex > finalIndex) { return null; }
            for (i=0; i<columnIndices.length; ++i) {
                vals.push(currentNode.data()[currentIndex][columnIndices[i]]);
            }
            this.currentIndex(++currentIndex);
            return vals;
        } else {
            for (i=0; i<columnIndices.length; ++i) {
                vals.push(currentNode.data()[currentIndex][columnIndices[i]]);
            }
            this.currentIndex(++currentIndex);
            if (currentIndex >= currentNode.data().length) {
                this.currentNode(currentNode.dataNext());
                this.currentIndex(0);
            }
            return vals;
        }
    });

});

module.exports = WebServiceDataIterator;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/validationFunctions.js":158,"./web_service_data_cache_node.js":68}],70:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Insets = require('../math/insets.js'),
    RGBColor = require('../math/rgb_color.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.window);

var Window = new jermaine.Model("Window", function () {

    this.hasA("width").which.isA("integer");

    this.hasA("height").which.isA("integer");

    this.hasA("border").which.isA("integer");

    this.hasA("margin").which.validatesWith(function (margin) {
        return margin instanceof Insets;
    });

    this.hasA("padding").which.validatesWith(function (padding) {
        return padding instanceof Insets;
    });

    this.hasA("bordercolor").which.validatesWith(function (bordercolor) {
        return bordercolor instanceof RGBColor;
    });

    utilityFunctions.insertDefaults(this, defaultValues.window, attributes);
});

module.exports = Window;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/insets.js":103,"../math/rgb_color.js":105,"../util/utilityFunctions.js":157}],71:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataMeasure = require('./data_measure.js'),
    DataValue = require('./data_value.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.horizontalaxis.zoom);

var Zoom = new jermaine.Model("Zoom", function () {

    this.hasA("allowed").which.isA("boolean");
    this.hasA("min").which.validatesWith(function (min) {
        return DataMeasure.isInstance(min);
    });
    this.hasA("max").which.validatesWith(function (max) {
        return DataMeasure.isInstance(max);
    });
    this.hasA("anchor").which.validatesWith(function (anchor) {
        return DataValue.isInstance(anchor) || anchor === null;
    });

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis.zoom, attributes);
});

module.exports = Zoom;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":157,"./data_measure.js":28,"./data_value.js":30}],72:[function(require,module,exports){
var _INCLUDED = false;

module.exports = function($, window, errorHandler) {
    if (!_INCLUDED) {
        require('./draggable/graph.js')($, window, errorHandler);
        require('./touch/graph.js')($, window, errorHandler);
        require('./touch/multigraph.js')($, window, errorHandler);
        require('./mouse/graph.js')($, window, errorHandler);
        require('./mouse/multigraph.js')($, window, errorHandler);
        require('./multigraph.js')($, window, errorHandler);
        require('./resize/multigraph.js')($, window, errorHandler);
        _INCLUDED = true;
    }
};

},{"./draggable/graph.js":73,"./mouse/graph.js":74,"./mouse/multigraph.js":75,"./multigraph.js":76,"./resize/multigraph.js":77,"./touch/graph.js":78,"./touch/multigraph.js":79}],73:[function(require,module,exports){
module.exports = function($, window, errorHandler) {
    var Graph = require('../../core/graph.js'),
        Axis = require('../../core/axis.js');

    if (typeof(Graph.dragStarted)==="function") { return Graph; }

    Graph.hasA("dragStarted").which.isA("boolean");
    Graph.hasA("dragOrientation").which.validatesWith(Axis.Orientation.isInstance);
    Graph.hasA("dragAxis").which.validatesWith(function (a) {
        return a instanceof Axis;
    });

    Graph.respondsTo("doDragReset", function () {
        this.dragStarted(false);
        this.pauseAllData();
    });

    Graph.respondsTo("doDragDone", function () {
        this.resumeAllData();
    });

    Graph.respondsTo("doDrag", function (multigraph, bx, by, dx, dy, shiftKey) {
        var dragAxis        = this.dragAxis,
            dragOrientation = this.dragOrientation,
            HORIZONTAL = Axis.HORIZONTAL,
            VERTICAL   = Axis.VERTICAL;
        // TODO: this try...catch is just to remind myself how to apply, make sure this is correct later
        try {
            if (!this.dragStarted()) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    dragOrientation(HORIZONTAL);
                } else {
                    dragOrientation(VERTICAL);
                }
                dragAxis(this.findNearestAxis(bx, by, dragOrientation()));
                if (dragAxis() === null) {
                    dragOrientation( (dragOrientation() === HORIZONTAL) ? VERTICAL : HORIZONTAL );
                    dragAxis( this.findNearestAxis(bx, by, dragOrientation()) );
                }
                this.dragStarted(true);
            }

            // do the action
            if (shiftKey) {
                if (dragOrientation() === HORIZONTAL) {
                    dragAxis().doZoom(bx, dx);
                } else {
                    dragAxis().doZoom(by, dy);
                }
            } else {
                if (dragOrientation() === HORIZONTAL) {
                    dragAxis().doPan(bx, dx);
                } else {
                    dragAxis().doPan(by, dy);
                }
            }

            // draw everything
            multigraph.redraw();
        } catch (e) {
            errorHandler(e);
        }
    });

    return Graph;
};

},{"../../core/axis.js":18,"../../core/graph.js":41}],74:[function(require,module,exports){
module.exports = function($, window, errorHandler) {
    var Graph = require('../../core/graph.js'),
        ConstantPlot = require('../../core/constant_plot.js'),
        Axis = require('../../core/axis.js');

    if (typeof(Graph.mouseWheelTimer)==="function") { return Graph; }

    Graph.hasA("mouseWheelTimer").which.defaultsTo(null);

    Graph.respondsTo("doWheelZoom", function (multigraph, x, y, delta) {
        var that = this;
        try {
            this.pauseAllData();
            var axis = this.findNearestAxis(x, y);
            if (axis.orientation() === Axis.HORIZONTAL) {
                axis.doZoom(x, 4*delta);
            } else {
                axis.doZoom(y, 4*delta);
            }
            multigraph.redraw();

            // resume data fetching after .5 seconds of no mouse wheel motion:
            var mouseWheelTimer = this.mouseWheelTimer;
            if (mouseWheelTimer() !== null) {
                window.clearTimeout(mouseWheelTimer());
                mouseWheelTimer(null);
            }
            mouseWheelTimer(window.setTimeout(function () {
                that.resumeAllData();
            }, 500)); 
        } catch (e) {
            errorHandler(e);
        }
    });


    Graph.hasA("existingDatatips").which.defaultsTo(function () { return []; });
    Graph.respondsTo("handleDatatips", function (loc, width, height, $target, div) {
        var existingDatatips = this.existingDatatips(),
            plots            = this.plots(),
            plot,
            datatipsData,
            datatipIndex,
            i;

        var temp = $("<span></span>")
                .css({
                    "display"          : "hidden",
                    "margin"           : "0px",
                    "padding-left"     : "5px",
                    "padding-right"    : "5px",
                    "padding-top"      : "1px",
                    "padding-bottom"   : "1px"
                })
                .appendTo(div);

        // find first available bit of data
        for (i = 0; i < plots.size(); i++) {
            plot = plots.at(i);
            if (plot instanceof ConstantPlot) {
                continue;
            }
            datatipsData = plot.getDatatipsData(loc, width, height, this, temp);
            if (datatipsData !== undefined) {
                datatipIndex = i;
                break;
            }
        }

        temp.remove();

        // don't do anything if there is no data
        if (datatipsData === undefined) {
            this.removeDatatips();
            return;
        }

        // flag all datatips for removal
        for (i = 0; i < existingDatatips.length; i++) {
            existingDatatips[i].flag = true;
        }

        // remove flags from datatips that don't need to be redrawn
        checkDatatipExistence(datatipsData, existingDatatips);

        this.removeFlaggedDatatips();

        // don't do anything if datatip already exists
        if (datatipsData.flag === false) {
            return;
        }

        var arrowLength = 10;
        datatipsData.arrow = arrowLength;

        var datatip = plots.at(datatipIndex).createDatatip(datatipsData);

        datatip.appendTo(div);

        datatip.mousedown(function (event) {
            $target.trigger("mousedown", event);
        });

        datatipsData.elem = datatip;
        existingDatatips.push(datatipsData);
    });

    var checkDatatipExistence = function (datatipData, existingData) {
        var i, l;
        for (i = 0, l = existingData.length; i < l; i++) {
            if (
                datatipData.content   === existingData[i].content   &&
                    datatipData.type      === existingData[i].type      &&
                    datatipData.pixelp[0] === existingData[i].pixelp[0] &&
                    datatipData.pixelp[1] === existingData[i].pixelp[1]
            ) {
                existingData[i].flag = false;
                datatipData.flag = false; // do not redraw
                return;
            }
        }
        datatipData.flag = true; // needs to be drawn
    };

    Graph.respondsTo("removeDatatips", function () {
        var existingDatatips = this.existingDatatips(),
            i;
        if (existingDatatips.length > 0) {
            for (i = 0; i < existingDatatips.length; i++) {
                existingDatatips[i].elem.remove();
            }
            existingDatatips = [];
        }
    });

    Graph.respondsTo("removeFlaggedDatatips", function () {
        var existingDatatips = this.existingDatatips(),
            i;
        if (existingDatatips.length > 0) {
            for (i = 0; i < existingDatatips.length; i++) {
                if (existingDatatips[i].flag === true) {
                    existingDatatips[i].elem.remove();
                    existingDatatips.splice(i, 1);
                }
            }
        }
    });


    return Graph;
};

},{"../../core/axis.js":18,"../../core/constant_plot.js":24,"../../core/graph.js":41}],75:[function(require,module,exports){
module.exports = function($, window, errorHandler) {

    var Multigraph = require('../../core/multigraph.js')($),
        Point = require('../../math/point.js');

    if (typeof(Multigraph.registerMouseEvents)==="function") { return Multigraph; }

    Multigraph.respondsTo("registerMouseEvents", function (target, options) {
        var base,
            mouseLast,
            mouseIsDown = false,
            dragStarted = false,
            multigraph = this,
            $target = $(target);

        var eventLocationToGraphCoords = function (event) {
            return new Point((event.pageX - $target.offset().left) - multigraph.graphs().at(0).x0(),
                             $target.height() - (event.pageY - $target.offset().top) - multigraph.graphs().at(0).y0());
        };

        $target.mousedown(function (event, datatipsEvent) {
            if (datatipsEvent) {
                // if the datatips mousedown handler is triggered through the datatips handler
                // then the default event does not contain pageX or pageY. So the datatips handler
                // passes its event, which does contain pageX and pageY.
                event = datatipsEvent;
            }
            event.preventDefault();
            var i;
            for (i = 0; i < multigraph.graphs().size(); i++) {
                multigraph.graphs().at(i).removeDatatips();
            }

            mouseLast = base = eventLocationToGraphCoords(event);
            mouseIsDown = true;
            dragStarted = false;
        });

        $target.mouseup(function (event) {
            mouseIsDown = false;
            multigraph.graphs().at(0).doDragDone();
        });

        $target.mousemove(function (event) {
            var eventLoc = eventLocationToGraphCoords(event),
                graphs   = multigraph.graphs();
            if (mouseIsDown) {
                var dx = eventLoc.x() - mouseLast.x(),
                    dy = eventLoc.y() - mouseLast.y();
                if (multigraph.graphs().size() > 0) {
                    if (!dragStarted ) {
                        graphs.at(0).doDragReset();
                    }
                    graphs.at(0).doDrag(multigraph, base.x(), base.y(), dx, dy, event.shiftKey);
                }
                dragStarted = true;
            } else { // datatips handling
                var i;
                for (i = 0; i < graphs.size(); i++) {
                    graphs.at(i).handleDatatips(eventLoc, multigraph.width(), multigraph.height(), $target, multigraph.div());
                }
            }
            mouseLast = eventLoc;
        });

        if (!options.noscroll) {
            $target.mousewheel(function (event, delta) {
                var eventLoc = eventLocationToGraphCoords(event);
                if (multigraph.graphs().size() > 0) {
                    multigraph.graphs().at(0).doWheelZoom(multigraph, eventLoc.x(), eventLoc.y(), delta);
                }
                event.preventDefault();
            });
        }

        $target.mouseleave(function (event) {
            mouseIsDown = false;
            multigraph.graphs().at(0).doDragDone();
        });

        $(multigraph.div()).mouseleave(function (event) {
            var graphs = multigraph.graphs(),
                i;
            for (i = 0; i < graphs.size(); i++) {
                graphs.at(i).removeDatatips();
            }
        });

    });

    return Multigraph;
};

},{"../../core/multigraph.js":48,"../../math/point.js":104}],76:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
var _INCLUDED = false;
module.exports = function($, window, errorHandler) {

    if (_INCLUDED) { return; } else { _INCLUDED = true; }
    
    var Multigraph = require('../core/multigraph.js')($);

    var methods = {
        multigraph : function () {
            return this.data('multigraph').multigraph;
        },

        done : function (func) {
            return this.each(function () {
                return $(this).data('multigraph').multigraph.done(func);
            });
        },

        destroy : function () {
            return this.each(function() {
                var $this = $(this);
                $this.data('multigraph').multigraph.done(function(m) {
                    m.destroy();
                });
                $this.removeData("multigraph");
            });
        },

        init : function (options) {
            return this.each(function () {
                var $this = $(this),
                    data = $this.data('multigraph');
                if (!("mugl" in options) && !("muglString" in options)) {
                    // if options contains neigther "mugl" nor "muglString",
                    // assume it's a JSON mugl object, so pass it on as
                    // the value of "muglString":
                    options = {
                        muglString: options
                    };
                }
                options.div = this;
                if ( ! data ) {
                    $this.data('multigraph', {
                        multigraph : Multigraph.createGraph(options)
                    });
                }
                return this;
            });
        }
    };

    $.fn.multigraph = function (method) {
        if ( methods[method] ) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.multigraph' );
            return null;
        }    
    };

    /*
     * Inclusion of this file allows markup like the following to be
     * used in HTML:
     * 
     *     <div class="multigraph"
     *        data-src="MUGL_FILE"
     *        data-width="WIDTH"
     *        data-height="HEIGHT"
     *        data-driver="DRIVER">
     *     </div>
     * 
     * The data-driver tag is optional; if not specified, it currently
     * defaults to "canvas", but that will be changed in the future to
     * make a smart choice based on browser capabilities.
     * 
     * The data-width and data-height tags are also optional; if they
     * are not specified, Multigraph will use the div size as determined
     * by the browser (which may be set by css rules, for example).  If
     * data-width or data-height is present, it will override any css
     * width or height.
     * 
     */
    $(document).ready(function () {

        $("div.multigraph").each(function () {

            var width  = $(this).attr("data-width"),
                height = $(this).attr("data-height"),
                src    = $(this).attr("data-src"),
                driver = $(this).attr("data-driver"),
                options;

            if (width !== undefined) {
                $(this).css('width', width + 'px');
            }
            if (height !== undefined) {
                $(this).css('height', height + 'px');
            }

            /*
             // don't default to canvas here any more; Multigraph.createGraph now does
             // browser detection and will default to canvas if possible, otherwise
             // to raphael
             if (driver === undefined) {
             driver = "canvas";
             }
             */

            options = {
                'div'    : this,
                'mugl'   : src,
                'driver' : driver
            };

            $(this).multigraph(options);
            $(this).lightbox({
                scale : true,
                postopen : function () {
                    var lightboxData = this.data("lightbox");
                    lightboxData.originalDiv = this;
                    this.data("multigraph").multigraph.done(function (m) {
                        m.div(lightboxData.contents);
                        m.initializeSurface();
                        m.resizeSurface(lightboxData.contentWidth, lightboxData.contentHeight);
                        m.width(lightboxData.contentWidth)
                            .height(lightboxData.contentHeight);
                        m.busySpinner().remove();
                        m.busySpinner($('<div style="position: absolute; left:5px; top:5px;"></div>')
                                      .appendTo($(m.div()))
                                      .busy_spinner());
                        m.render();
                    });
                    var timeout= window.setTimeout(function () {
                        lightboxData.contents.lightbox("resize");
                        window.clearTimeout(timeout);
                    }, 50);
                },
                postclose : function () {
                    var lightboxData = this.data("lightbox");
                    this.data("multigraph").multigraph.done(function (m) {
                        m.div(lightboxData.originalDiv)
                            .width($(m.div()).width())
                            .height($(m.div()).height())
                            .busySpinner($('<div style="position: absolute; left:5px; top:5px;"></div>')
                                         .appendTo($(m.div()))
                                         .busy_spinner()
                                        );

                        m.initializeSurface();
                        m.render();
                    });
                },
                postresize : function () {
                    var lightboxData = this.data("lightbox");
                    this.data("multigraph").multigraph.done(function (m) {
                        m.resizeSurface(lightboxData.contentWidth, lightboxData.contentHeight);
                        m.width(lightboxData.contentWidth)
                            .height(lightboxData.contentHeight);
                        m.render();
                    });
                }
            });

        });

    });

};

},{"../core/multigraph.js":48}],77:[function(require,module,exports){
module.exports = function($, window, errorHandler) {
    var Multigraph = require('../../core/multigraph.js')($),
        Point = require('../../math/point.js');

    if (typeof(Multigraph.registerResizeEvents)==="function") { return Multigraph; }

    Multigraph.respondsTo("registerResizeEvents", function (target) {
        var multigraph = this;
        var container = $(this.div());
        var c = $(target); // select canvas in multigraph div
        $(window).resize(respondGraph);

        function respondGraph()
        {
            c.attr("width", container.width() * window.devicePixelRatio);
            c.attr("height", container.height() * window.devicePixelRatio);
            c.css("width", container.width());
            c.css("height", container.height());
            multigraph.init();
        }
    });

    return Multigraph;
};

},{"../../core/multigraph.js":48,"../../math/point.js":104}],78:[function(require,module,exports){
module.exports = function($, window, errorHandler) {
    var Graph = require('../../core/graph.js'),
        Axis = require('../../core/axis.js');

    if (typeof(Graph.doFirstPinchZoom)==="function") { return Graph; }

    Graph.respondsTo("doFirstPinchZoom", function (multigraph, bx, by, dx, dy, totalx, totaly) {
        var dragAxis = this.dragAxis,
            dragOrientation = this.dragOrientation,
            HORIZONTAL = Axis.HORIZONTAL,
            VERTICAL   = Axis.VERTICAL;

        // TODO: this try...catch is just to remind myself how to apply, make sure this is correct later
        try {
            if (!this.dragStarted()) {
                if (totalx > totaly) {
                    dragOrientation(HORIZONTAL);
                } else {
                    dragOrientation(VERTICAL);
                }
                dragAxis(this.findNearestAxis(bx, by, dragOrientation()));
                if (dragAxis() === null) {
                    dragOrientation( (dragOrientation() === HORIZONTAL) ? VERTICAL : HORIZONTAL );
                    dragAxis( this.findNearestAxis(bx, by, dragOrientation()) );
                }
                this.dragStarted(true);
            }

            // do the action
            if (dragOrientation() === HORIZONTAL) {
                dragAxis().doZoom(bx, dx);
            } else {
                dragAxis().doZoom(by, dy);
            }

            // draw everything
            multigraph.redraw();
        } catch (e) {
            errorHandler(e);
        }
    });

    return Graph;
};

},{"../../core/axis.js":18,"../../core/graph.js":41}],79:[function(require,module,exports){
module.exports = function($, window, errorHandler) {
    var Multigraph = require('../../core/multigraph.js')($),
        Point = require('../../math/point.js');

    if (typeof(Multigraph.registerTouchEvents)==="function") { return Multigraph; }

    Multigraph.respondsTo("registerTouchEvents", function (target) {
        var touchStarted           = false,
            dragStarted            = false,
            pinchZoomStarted       = false,
            pinchZoomDetermined    = false,
            pinchZoomInitialDeltas = {},
            pinchZoomDeterminedTimeout,
            previoustoucha, previoustouchb,
            base,
            multigraph = this,
            $target = $(target);

        var touchLocationToGraphCoords = function (touch) {
            return new Point((touch.pageX - $target.offset().left) - multigraph.graphs().at(0).x0(),
                             $target.height() - (touch.pageY - $target.offset().top) - multigraph.graphs().at(0).y0());
        };

        var handleTouchStart = function (jqueryEvent) {
            var e = jqueryEvent.originalEvent;
            e.preventDefault();

            if (e.touches.length === 1) {
                base = touchLocationToGraphCoords(e.touches[0]);
            }
            previoustoucha = touchLocationToGraphCoords(e.touches[0]);

            // one finger drag
            if (e.touches.length === 1) {
                dragStarted = true;
            } else {
                dragStarted = false;
            }

            // pinch zoom
            if (e.touches.length === 2) {
                pinchZoomStarted = true;
                pinchZoomDetermined = false;
                previoustouchb = touchLocationToGraphCoords(e.touches[1]);
            } else {
                pinchZoomStarted = false;
                pinchZoomDetermined = false;
            }

            touchStarted = false;
            multigraph.graphs().at(0).doDragDone();
        };

        var handleTouchMove = function (jqueryEvent) {
            var e = jqueryEvent.originalEvent;
            e.preventDefault();

            // one finger drag
            if (e.touches.length === 1 && dragStarted === true) {
                handleDrag(e);
            }
            // pinch zoom
            if (e.touches.length === 2 && pinchZoomStarted === true) {
                handlePinchZoom(e);
            }
        };

        var handleTouchEnd = function (jqueryEvent) {
            var e = jqueryEvent.originalEvent;
            e.preventDefault();
            
            // one finger drag
            if (e.touches.length === 1) {
                dragStarted = true;
            } else {
                dragStarted = false;
            }
            
            // pinch zoom
            if (e.touches.length === 2) {
                pinchZoomStarted = true;
                pinchZoomDetermined = false;
            } else {
                pinchZoomStarted = false;
                pinchZoomDetermined = false;
            }

            touchStarted = false;
            multigraph.graphs().at(0).doDragDone();
        };

        var handleTouchLeave = function (jqueryEvent) {
            jqueryEvent.originalEvent.preventDefault();

            dragStarted = false;
            pinchZoomStarted = false;
            pinchZoomDetermined = false;
            touchStarted = false;

            multigraph.graphs().at(0).doDragDone();
        };

        var handleDrag = function (e) {
            var touchLoc = touchLocationToGraphCoords(e.touches[0]),
                dx = touchLoc.x() - previoustoucha.x(),
                dy = touchLoc.y() - previoustoucha.y();
            if (multigraph.graphs().size() > 0) {
                if (!touchStarted) {
                    multigraph.graphs().at(0).doDragReset();
                }
                multigraph.graphs().at(0).doDrag(multigraph, base.x(), base.y(), dx, dy, false);
            }
            touchStarted = true;
            previoustoucha = touchLoc;
        };

        var handlePinchZoom = function (e) {
            var a = touchLocationToGraphCoords(e.touches[0]),
                b = touchLocationToGraphCoords(e.touches[1]),
                basex = (a.x() + b.x()) / 2,
                basey = (a.y() + b.y()) / 2,
                dx = calculateAbsoluteDistance(a.x(), b.x()) - calculateAbsoluteDistance(previoustoucha.x(), previoustouchb.x()),
                dy = calculateAbsoluteDistance(a.y(), b.y()) - calculateAbsoluteDistance(previoustoucha.y(), previoustouchb.y());

            if (multigraph.graphs().size() > 0) {
                if (!touchStarted) {
                    multigraph.graphs().at(0).doDragReset();
                }
                if (pinchZoomDetermined === true) {
                    multigraph.graphs().at(0).doDrag(multigraph, basex, basey, dx, dy, true);
                }
            }
            touchStarted = true;

            // two finger scroll
            var cx = ((a.x() - previoustoucha.x()) + (b.x() - previoustouchb.x())) / 2,
                cy = ((a.y() - previoustoucha.y()) + (b.y() - previoustouchb.y())) / 2;
            if (pinchZoomDetermined === true) {
                multigraph.graphs().at(0).doDrag(multigraph, basex, basey, cx, cy, false);
            }

            if (pinchZoomDetermined === false) {
                if (pinchZoomInitialDeltas.base === undefined) {
                    pinchZoomInitialDeltas.base = {};
                    pinchZoomInitialDeltas.base.x = basex;
                    pinchZoomInitialDeltas.base.y = basey;
                } 
                if (pinchZoomInitialDeltas.zoomDeltas === undefined) {
                    pinchZoomInitialDeltas.zoomDeltas = {
                        "dx"     : 0,
                        "dy"     : 0,
                        "totalx" : 0,
                        "totaly" : 0
                    };
                }
                if (pinchZoomInitialDeltas.panDeltas === undefined) {
                    pinchZoomInitialDeltas.panDeltas = {
                        "dx" : 0,
                        "dy" : 0
                    };
                }

                pinchZoomInitialDeltas.zoomDeltas.dx += dx;
                pinchZoomInitialDeltas.zoomDeltas.dy += dy;
                pinchZoomInitialDeltas.panDeltas.dx += cx;
                pinchZoomInitialDeltas.panDeltas.dy += cy;

                pinchZoomInitialDeltas.zoomDeltas.totalx += Math.abs(dx);
                pinchZoomInitialDeltas.zoomDeltas.totaly += Math.abs(dy);

                if (pinchZoomDeterminedTimeout === undefined) {
                    pinchZoomDeterminedTimeout = setTimeout(function () {
                        var basex = pinchZoomInitialDeltas.base.x,
                            basey = pinchZoomInitialDeltas.base.y,
                            dx = pinchZoomInitialDeltas.zoomDeltas.dx,
                            dy = pinchZoomInitialDeltas.zoomDeltas.dy,
                            cx = pinchZoomInitialDeltas.panDeltas.dx,
                            cy = pinchZoomInitialDeltas.panDeltas.dy;

                        multigraph.graphs().at(0).doDragReset();

                        multigraph.graphs().at(0).doFirstPinchZoom(multigraph, basex, basey, dx, dy, pinchZoomInitialDeltas.zoomDeltas.totalx, pinchZoomInitialDeltas.zoomDeltas.totaly);
                        multigraph.graphs().at(0).doDrag(multigraph, basex, basey, cx, cy, false);

                        pinchZoomInitialDeltas = {};
                        pinchZoomDetermined = true;
                        clearTimeout(pinchZoomDeterminedTimeout);
                        pinchZoomDeterminedTimeout = undefined;
                    }, 60);
                }
            }

            previoustoucha = a;
            previoustouchb = b;

        };

        var calculateAbsoluteDistance = function (a, b) {
            return Math.abs(a - b);
        };

        $target.on("touchstart", handleTouchStart);
        $target.on("touchmove", handleTouchMove);
        $target.on("touchend", handleTouchEnd);
        $target.on("touchleave", handleTouchLeave);

    });

    return Multigraph;
};

},{"../../core/multigraph.js":48,"../../math/point.js":104}],80:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function($, window) {
    if (_INCLUDED) { return; }
    _INCLUDED = true;

    require('./multigraph.js')($, window);

    require('./axis.js')();
    require('./axis_title.js')();
    require('./background.js')();
    require('./graph.js')();
    require('./graph_title.js')();
    require('./icon.js')();
    require('./img.js')();
    require('./labeler.js')();
    require('./legend.js')();
    require('./plotarea.js')();
    require('./renderers/band_renderer.js')();
    require('./renderers/bar_renderer.js')();
    require('./renderers/fill_renderer.js')();
    require('./renderers/pointline_renderer.js')();
    require('./renderers/rangebar_renderer.js')();
    require('./text.js')();
    require('./window.js')();
};

},{"./axis.js":81,"./axis_title.js":82,"./background.js":83,"./graph.js":84,"./graph_title.js":85,"./icon.js":86,"./img.js":87,"./labeler.js":88,"./legend.js":89,"./multigraph.js":90,"./plotarea.js":91,"./renderers/band_renderer.js":92,"./renderers/bar_renderer.js":93,"./renderers/fill_renderer.js":94,"./renderers/pointline_renderer.js":95,"./renderers/rangebar_renderer.js":96,"./text.js":97,"./window.js":98}],81:[function(require,module,exports){
module.exports = function() {
    var Axis = require('../../core/axis.js');

    if (typeof(Axis.renderGrid)==="function") { return Axis; }

    Axis.respondsTo("renderGrid", function (graph, context) {
        if (!this.visible()) { return; }
        this.prepareRender(context);

        // draw the grid lines
        if (this.hasDataMin() && this.hasDataMax()) { // skip if we don't yet have data values
            if (this.grid().visible()) { // skip if grid lines aren't turned on
                if (this.labelers().size() > 0 && this.currentLabelDensity() <= 1.5) {
                    var currentLabeler = this.currentLabeler(),
                        perpOffset     = this.perpOffset(),
                        plotBox        = graph.plotBox();
                    currentLabeler.prepare(this.dataMin(), this.dataMax());
                    context.beginPath();
                    while (currentLabeler.hasNext()) {
                        var v = currentLabeler.next(),
                            a = this.dataValueToAxisValue(v);
                        if (this.orientation() === Axis.HORIZONTAL) {
                            context.moveTo(a, perpOffset);
                            context.lineTo(a, plotBox.height() - perpOffset);
                        } else {
                            context.moveTo(perpOffset, a);
                            context.lineTo(plotBox.width() - perpOffset, a);
                        }
                    }
                    context.strokeStyle = this.grid().color().getHexString("#");
                    context.stroke();
                }
            }
        }
    });

    Axis.respondsTo("render", function (graph, context) {
        if (!this.visible()) { return; }
        var parallelOffset = this.parallelOffset(),
            perpOffset     = this.perpOffset(),
            pixelLength    = this.pixelLength(),
            currentLabeler = this.currentLabeler(),
            axisIsHorizontal = (this.orientation() === Axis.HORIZONTAL);
        //NOTE: axes are drawn relative to the graph's plot area (plotBox); the coordinates
        //      below are relative to the coordinate system of that box.

        //
        // Render the axis line itself, unless its linewidth() property is 0.
        // TODO: modify this so that it correctly draws a line with the given
        // linewidth().  At the moment, it only makes a distinction between
        // lines of width 0, which aren't drawn at all, and lines with width > 0,
        // which are drawn with width 1.
        if (this.linewidth() > 0) {
            context.beginPath();
            if (axisIsHorizontal) {
                context.moveTo(parallelOffset, perpOffset);
                context.lineTo(parallelOffset + pixelLength, perpOffset);
            } else {
                context.moveTo(perpOffset, parallelOffset);
                context.lineTo(perpOffset, parallelOffset + pixelLength);
            }

            context.strokeStyle = this.color().getHexString("#");
            context.stroke();
        }

        //
        // Render the tick marks and labels
        //
        if (this.hasDataMin() && this.hasDataMax()) { // but skip if we don't yet have data values
            if (currentLabeler && currentLabeler.visible()) { // also skip if we have no current labeler, or
                var tickwidth = this.tickwidth(),             //   if we do but its `visible` property is false
                    tickmin   = this.tickmin(),
                    tickmax   = this.tickmax(),
                    tickcolor = this.tickcolor();
                context.beginPath();
                context.fillStyle = '#000000';
                currentLabeler.prepare(this.dataMin(), this.dataMax());
                while (currentLabeler.hasNext()) {
                    var v = currentLabeler.next(),
                        a = this.dataValueToAxisValue(v);
                    if (tickwidth > 0) {
                        if (tickcolor !== undefined && tickcolor !== null) {
                            context.strokeStyle = tickcolor.getHexString('#');
                        }
                        if (axisIsHorizontal) {
                            context.moveTo(a, perpOffset+tickmax);
                            context.lineTo(a, perpOffset+tickmin);
                        } else {
                            context.moveTo(perpOffset+tickmin, a);
                            context.lineTo(perpOffset+tickmax, a);
                        }
                        if (tickcolor !== undefined && tickcolor !== null) {
                            context.restore();
                        }
                    }
                    currentLabeler.renderLabel(context, v);
                }
                context.stroke();
            }
        }

        //
        // Render the title
        //
        if (this.title()) {
            this.title().render(context);
        }

    });

    return Axis;
};

},{"../../core/axis.js":18}],82:[function(require,module,exports){
module.exports = function() {
    var AxisTitle = require('../../core/axis_title.js'),
        Axis = require('../../core/axis.js'),
        Point = require('../../math/point.js');

    if (typeof(AxisTitle.render)==="function") { return AxisTitle; }

    AxisTitle.respondsTo("render", function (context) {
        var axis        = this.axis(),
            title       = this.content(),
            anchor      = this.anchor(),
            perpOffset  = axis.perpOffset(),
            h           = title.origHeight(),
            w           = title.origWidth(),
            pixelAnchor = new Point(
                0.5 * w * (anchor.x() + 1),
                0.5 * h * (anchor.y() + 1)
            ),
            storedBase  = (this.base() + 1) * (axis.pixelLength() / 2) + axis.minoffset() + axis.parallelOffset(),
            pixelBase;

        if (axis.orientation() === Axis.HORIZONTAL) {
            pixelBase = new Point(storedBase, perpOffset);
        } else {
            pixelBase = new Point(perpOffset, storedBase);
        }

        context.save();
        context.fillStyle = "rgba(0, 0, 0, 1)";
        title.font(this.font());
        title.drawText(context, pixelAnchor, pixelBase, this.position(), this.angle());
        context.restore();
    });

    return AxisTitle;
};

},{"../../core/axis.js":18,"../../core/axis_title.js":20,"../../math/point.js":104}],83:[function(require,module,exports){
module.exports = function() {
    var Background = require('../../core/background.js');

    if (typeof(Background.render)==="function") { return Background; }

    Background.respondsTo("render", function (graph, context, width, height) {
        var mb = graph.window().margin().left() + graph.window().border(),
            img = this.img();

        context.save();
        context.fillStyle = this.color().getHexString("#");
        context.fillRect(mb, mb, width - 2*mb, height - 2*mb);
        context.restore();
        
        if (img && img.src() !== undefined) {
            img.render(graph, context, width, height);
        }
    });

    return Background;
};

},{"../../core/background.js":21}],84:[function(require,module,exports){
module.exports = function() {
    var Graph = require('../../core/graph.js');

    if (typeof(Graph.render)==="function") { return Graph; }

    Graph.respondsTo("render", function (context, width, height) {
        var i;

        this.window().render(context, width, height);

        this.background().render(this, context, width, height);

        context.transform(1,0,0,1,this.x0(),this.y0());

        this.plotarea().render(this, context);

        for (i = 0; i < this.axes().size(); ++i) {
            this.axes().at(i).renderGrid(this, context);
        }


        context.save();
        context.rect(0, 0, this.plotBox().width(), this.plotBox().height());
        context.clip();


        for (i = 0; i < this.plots().size(); ++i) {
            this.plots().at(i).render(this, context);
        }

        context.restore();

        for (i = 0; i < this.axes().size(); ++i) {
            this.axes().at(i).render(this, context);
        }

        this.legend().render(context);

        if (this.title()) {
            this.title().render(context);
        }
    });

    return Graph;
};

},{"../../core/graph.js":41}],85:[function(require,module,exports){
module.exports = function() {
    var Title = require('../../core/title.js'),
        Point = require('../../math/point.js');

    if (typeof(Title.render)==="function") { return Title; }

    Title.respondsTo("render", function (context) {
        var graph           = this.graph(),
            border          = this.border(),
            padding         = this.padding(),
            storedAnchor    = this.anchor(),
            storedBase      = this.base(),
            position        = this.position(),
            title           = this.text(),
            backgroundColor = this.color().toRGBA(this.opacity()),
            paddingBox      = graph.paddingBox(),
            plotBox         = graph.plotBox(),
            plotareaMargin  = graph.plotarea().margin(),
            h = title.origHeight(),
            w = title.origWidth(),
            pixelAnchor = new Point(
                (0.5 * w + padding + border) * (storedAnchor.x() + 1),
                (0.5 * h + padding + border) * (storedAnchor.y() + 1)
            ),
            pixelBase;

        if (this.frame() === "padding") {
            pixelBase = new Point(
                (storedBase.x() + 1) * (paddingBox.width() / 2)  - plotareaMargin.left(),
                (storedBase.y() + 1) * (paddingBox.height() / 2) - plotareaMargin.bottom()
            );
        } else {
            pixelBase = new Point(
                (storedBase.x() + 1) * (plotBox.width() / 2),
                (storedBase.y() + 1) * (plotBox.height() / 2)
            );
        }

        context.save();
        title.setTransform(context, pixelAnchor, pixelBase, position, 0);
        context.transform(1, 0, 0, -1, 0, 0);

        // border
        if (border > 0) {
            context.strokeStyle = this.bordercolor().toRGBA();
            context.lineWidth = border;
            context.strokeRect(
                border / 2,
                border / 2,
                w + (2 * padding) + border,
                h + (2 * padding) + border
            );
        }

        // background
        context.fillStyle = backgroundColor;
        context.fillRect(
            border,
            border,
            w + (2 * padding),
            h + (2 * padding)
        );
        context.restore();

        // text
        context.save();
        var textPosition = new Point(
            position.x() + border + padding,
            position.y() + border + padding
        );
        context.font = this.fontSize() + " sans-serif";
        context.fillStyle = "rgba(0, 0, 0, 1)";
        title.drawText(context, pixelAnchor, pixelBase, textPosition, 0);
        context.restore();
    });

    return Title;
};

},{"../../core/title.js":65,"../../math/point.js":104}],86:[function(require,module,exports){
module.exports = function() {
    var Icon = require('../../core/icon.js'),
        Point = require('../../math/point.js');

    if (typeof(Icon.renderBorder)==="function") { return Icon; }

    Icon.respondsTo("renderBorder", function (context, x, y) {
        context.save();
        context.strokeStyle = "rgba(0, 0, 0, 1)";
        context.strokeRect(x, y, this.width(), this.height());
        context.restore();
    });
    return Icon;
};

},{"../../core/icon.js":43,"../../math/point.js":104}],87:[function(require,module,exports){
module.exports = function() {
    var Img = require('../../core/img.js'),
        Util = require('../../math/util.js');

    if (typeof(Img.render)==="function") { return Img; }

    Img.hasA("image").which.defaultsTo(function () {return new Image();});
    Img.hasA("fetched").which.defaultsTo(false);

    Img.respondsTo("render", function (graph, context, width, height) {
        if (this.fetched()) {
            var interp      = Util.interp,
                image       = this.image(),
                graphWindow = graph.window(),
                plotarea    = graph.plotarea(),
                base = this.base(),
                ax = interp(this.anchor().x(), -1, 1, 0, image.width),
                ay = interp(this.anchor().y(), 1, -1, 0, image.height),
                paddingLeft = graphWindow.margin().left() + graphWindow.border(),
                paddingTop  = graphWindow.margin().top() + graphWindow.border(),
                plotLeft = paddingLeft + graphWindow.padding().left() + plotarea.margin().left() + plotarea.border(),
                plotTop  = paddingTop + graphWindow.padding().top() + plotarea.margin().top() + plotarea.border(),
                bx, by,
                x, y;
            if (this.frame() === Img.PLOT) {
                bx = plotLeft + interp(base.x(), -1, 1, 0, graph.plotBox().width());
                by = plotTop + interp(base.y(), 1, -1, 0, graph.plotBox().height());
            } else {
                bx = paddingLeft + interp(base.x(), -1, 1, 0, graph.paddingBox().width());
                by = paddingTop + interp(base.y(), 1, -1, 0, graph.paddingBox().height());
            }
            x = bx + this.position().x() - ax;
            y = by + this.position().y() - ay;
            context.save();
            context.transform(1, 0, 0, -1, 0, height);
            context.drawImage(image, x, y, image.width, image.height);
            context.restore();
        } else {
            var that = this;
            this.image().onload = function () {
                that.fetched(true);
                context.save();
                context.setTransform(1, 0, 0, -1, 0, height);
                graph.render(context, width, height);
                context.restore();
            };
            this.image().src = this.src();
        }
    });

    return Img;
};

},{"../../core/img.js":44,"../../math/util.js":106}],88:[function(require,module,exports){
module.exports = function() {
    var Labeler = require('../../core/labeler.js'),
        Text = require('../../core/text.js'),
        Axis = require('../../core/axis.js'),
        Point = require('../../math/point.js');

    if (typeof(Labeler.renderLabel)==="function") { return Labeler; }

    Labeler.respondsTo("measureStringWidth", function (context, string) {
        var t = new Text(string);
        t.font(this.font());
        return t.initializeGeometry({
            "context" : context,
            "angle"   : this.angle()
        }).rotatedWidth();
    });

    Labeler.respondsTo("measureStringHeight", function (context, string) {
        var t = new Text(string);
        t.font(this.font());
        return t.initializeGeometry({
            "context" : context,
            "angle"   : this.angle()
        }).rotatedHeight();
    });

    Labeler.respondsTo("renderLabel", function (context, value) {
        var axis            = this.axis(),
            storedAnchor    = this.anchor(),
            angle           = this.angle(),
            perpOffset      = axis.perpOffset(),
            a               = axis.dataValueToAxisValue(value),
            formattedString = new Text(this.formatter().format(value)),
            pixelAnchor,
            base;

        formattedString.font(this.font());
        formattedString.initializeGeometry({
            "context" : context,
            "angle"   : angle
        });

        pixelAnchor = new Point(
            0.5 * formattedString.origWidth() * (storedAnchor.x() + 1),
            0.5 * formattedString.origHeight() * (storedAnchor.y() + 1)
        );

        if (axis.orientation() === Axis.HORIZONTAL) {
            base = new Point(a, perpOffset);
        } else {
            base = new Point(perpOffset, a);
        }


        context.save();
        context.fillStyle = this.color().getHexString("#");
        formattedString.drawText(context, pixelAnchor, base, this.position(), angle);
        context.restore();
    });

    return Labeler;
};

},{"../../core/axis.js":18,"../../core/labeler.js":45,"../../core/text.js":64,"../../math/point.js":104}],89:[function(require,module,exports){
module.exports = function() {
    var Legend = require('../../core/legend.js'),
        Point = require('../../math/point.js');

    if (typeof(Legend.renderLegend)==="function") { return Legend; }

    Legend.respondsTo("begin", function (context) {
        context.save();
        context.transform(1, 0, 0, 1, this.x(), this.y());
    });

    Legend.respondsTo("end", function (context) {
        context.restore();
    });

    Legend.respondsTo("renderLegend", function (context) {
        var border = this.border();
        context.save();
        if (border > 0) {
            context.strokeStyle = this.bordercolor().toRGBA();
            context.strokeRect(border/2, border/2, this.width() - border/2, this.height() - border/2);
        }

        context.fillStyle = this.color().toRGBA(this.opacity());
        context.fillRect(border, border, this.width() - (2 * border), this.height() - (2 * border));
        context.restore();
    });

    Legend.respondsTo("renderLabel", function (label, context, x, y) {
        context.save();
        context.fillStyle = "rgba(0, 0, 0, 1)";
        context.transform(1, 0, 0, -1, 0, y + this.maxLabelHeight()/2 - label.origHeight()/2);
        context.fillText(label.string(), x, 0);
        context.restore();
    });

    return Legend;
};

},{"../../core/legend.js":46,"../../math/point.js":104}],90:[function(require,module,exports){
module.exports = function($, window) {
    var Multigraph = require('../../core/multigraph.js')($),
        Point = require('../../math/point.js'),
        vF = require('../../util/validationFunctions.js');

    if (typeof(Multigraph.render)==="function") { return Multigraph; }

    Multigraph.hasA("canvas");  // canvas object itself (the '<canvas>' tag itself)
    Multigraph.hasA("context"); // canvas context object
    Multigraph.hasA("width").which.isA("number");
    Multigraph.hasA("height").which.isA("number");

    Multigraph.respondsTo("redraw", function () {
        var that = this;
        window.requestAnimationFrame(function () {
            that.render();
        });
    });

    Multigraph.respondsTo("popout", function (popdiv) {
        // Popout takes a single arg which is a jQuery selector, and temporarily moves the
        // multigraph to that element.  It turns a function that can be called to pop the
        // graph back "in" to its original place.  Note that the original canvas is actually
        // not removed -- the popout function just adds a new canvas to the popout diff and
        // swithces the multigraph to render in that canvas.  The returned popin function
        // removes the new canvas from the popout div, and switches the multigraph back
        // to its original canvas.
        var origDiv = this.div();
        $(popdiv).empty();
        this.div($('<div style="width: 100%; height: 100%;"></div>').appendTo($(popdiv)));
        this.init();
        this.registerEvents();
        var that = this;
        return function() {
            $(that.div()).remove();
            that.div(origDiv);
            that.width($(that.div()).width());
            that.height($(that.div()).height());
            that.initializeSurface();
            that.render();
        };
    });

    Multigraph.respondsTo("resize", function () {
        // Call this function whenever the multigraph's containing div has changed size;
        // this causes the multigraph to adjust to match the new size, and to re-render
        // once at that size.
        //
        // Note that the containing application has to call this to tell multigraph
        // that the div has changed size -- multigraph does not attempt to monitor
        // and respond to size changes itself.
        var $div = $(this.div());
        this.width($div.width());
        this.height($div.height());
        this.resizeSurface(this.width()*window.devicePixelRatio, this.height()*window.devicePixelRatio);
        $div.find("canvas").css({
            width: this.width() + "px",
            height: this.height() + "px"
        });
        this.render();
    });

    Multigraph.respondsTo("init", function () {
        var $div = $(this.div());
        this.width($div.width());
        this.height($div.height());
        if (this.width() > 0 && this.height() > 0) {
            // create the canvas
            $("<canvas width=\""+this.width()*window.devicePixelRatio+"\" height=\""+this.height()*window.devicePixelRatio+"\" style=\"width:"+this.width()+"px; height:"+this.height()+"px;\"/>")
                .appendTo($div);

            this.initializeSurface();

            this.busySpinner($('<div style="position:absolute;top:50%;left:50%;margin-top:-16px;margin-left:-16px"></div>') .
                             appendTo($div) .
                             busy_spinner());
        }
        this.render();
    });

    Multigraph.respondsTo("render", function () {
        var context = this.context(),
            width   = this.width(),
            height  = this.height(),
            i;

        context.setTransform(1, 0, 0, 1, 0, 0);
        context.scale(window.devicePixelRatio, window.devicePixelRatio);
        context.transform(1, 0, 0, -1, 0, height);
        context.clearRect(0, 0, width, height);
        this.initializeGeometry(width, height, {"context" : context});
        for (i = 0; i < this.graphs().size(); ++i) {
            this.graphs().at(i).render(context, width, height);
        }
    });

    Multigraph.respondsTo("registerEvents", function (options) {
        var canvas = this.canvas();
        this.registerMouseEvents(canvas, options);
        if (!options.noscroll) {
            this.registerTouchEvents(canvas, options);
        }
        //this.registerResizeEvents(canvas);
    });

    Multigraph.respondsTo("resizeSurface", function (width, height) {
        var canvas = this.context().canvas;
        canvas.width  = width;
        canvas.height = height;
    });

    Multigraph.respondsTo("initializeSurface", function () {
        this.canvas($(this.div()).children("canvas")[0]);
        this.context(this.canvas().getContext("2d"));
    });

    //    var applyMixins = function (options) {
    //        var errorHandler = options.messageHandler.error;
    //        window.multigraph.parser.mixin.apply(window.multigraph, "parseXML");
    //        ns.mixin.apply(window.multigraph.core);
    //        window.multigraph.events.draggable.mixin.apply(window.multigraph, errorHandler);
    //        window.multigraph.events.mouse.mixin.apply(window.multigraph, errorHandler);
    //        window.multigraph.events.touch.mixin.apply(window.multigraph, errorHandler);
    //        window.multigraph.normalizer.mixin.apply(window.multigraph.core);
    //    };

    // Return true iff the string `s` looks like a json object.
    // This simply checks to see if the first non-whitespace char is a '{' or '['.
    function looks_like_json(s) {
        return /^\s*[{\[]/.test(s);
    }

    var generateInitialGraph = function (mugl, options) {
        var JQueryXMLParser = require('../../parser/xml/jquery_xml_parser.js')($);
        require('../../parser/json/json_parser.js')($);
        var multigraph;
        if (vF.typeOf(mugl) === 'string') {
            if (looks_like_json(mugl)) {
                //http://stackoverflow.com/questions/4935632/parse-json-in-javascript
                var obj = JSON && JSON.parse(mugl) || $.parseJSON(mugl);
                multigraph = Multigraph.parseJSON( obj, options.mugl, options.messageHandler );
            } else {
                var xmlObj = JQueryXMLParser.stringToJQueryXMLObj(mugl);
                multigraph = Multigraph.parseXML( xmlObj, options.mugl, options.messageHandler );
            }
        } else {
            multigraph = Multigraph.parseJSON( mugl, options.mugl, options.messageHandler );
        }


        multigraph.normalize();
        multigraph.div(options.div);
        $(options.div).css("cursor" , "pointer");
        multigraph.init();
        multigraph.registerEvents(options);
        multigraph.registerCommonDataCallback(function (event) {
            multigraph.redraw();
        });
        return multigraph;
    };

    Multigraph.createCanvasGraph = function (options) {
        var muglPromise,
            deferred;

        try {
            //applyMixins(options);
            require('../../events/all.js')($, window, options.messageHandler.error);
            muglPromise = $.ajax({
                "url"      : options.mugl,
                "dataType" : "text"
            });

            deferred = $.Deferred();
        } catch (e) {
//console.log('at c 1');
throw e;
//            options.messageHandler.error(e);
        }

        muglPromise.done(function (data) {
            try {
                // TODO: div size IS available here; see below.  What's going on???!!!
                var multigraph = generateInitialGraph(data, options);
                deferred.resolve(multigraph);
            } catch (e) {
//console.log('at c 2');
throw e;
//                options.messageHandler.error(e);
            }
        });

        return deferred.promise();
    };

    Multigraph.createCanvasGraphFromString = function (options) {
        var deferred;

        try {
            //applyMixins(options);
            require('../../events/all.js')($, window, options.messageHandler.error);
            deferred = $.Deferred();
            // TODO: figure this out!  div size is not available here?  Apparently, at this point in
            // code execution, the browser hasn't laid things out enough for the div to have been
            // assigned a size, at least sometimes???  But it IS available at the corresponding place in
            // createCanvasGraph above?  This is worked around by the code in
            // src/core/multigraph.js:createGraph() that forces the div to have the size specified in
            // the options --- so we can work around the problem by passing an explicit size in the
            // options.  But we need to really figure out what's going on and resolve it.
            var multigraph = generateInitialGraph(options.muglString, options);
            deferred.resolve(multigraph);
        } catch (e) {
//console.log('at c 3');
throw e;
//            options.messageHandler.error(e);
        }

        return deferred.promise();
    };

    return Multigraph;
};

},{"../../core/multigraph.js":48,"../../events/all.js":72,"../../math/point.js":104,"../../parser/json/json_parser.js":119,"../../parser/xml/jquery_xml_parser.js":144,"../../util/validationFunctions.js":158}],91:[function(require,module,exports){
module.exports = function() {
    var Plotarea = require('../../core/plotarea.js');

    if (typeof(Plotarea.render)==="function") { return Plotarea; }

    Plotarea.respondsTo("render", function (graph, context) {
        var plotBox = graph.plotBox(),
            border = this.border();

        if (this.color() !== null) {
            context.save();
            context.fillStyle = this.color().getHexString("#");
            context.fillRect(0, 0, plotBox.width(), plotBox.height());
            context.restore();
        }

        if (border > 0) {
            context.save();
            context.lineWidth = border;
            context.strokeStyle = this.bordercolor().getHexString("#");
            context.strokeRect(-border/2, -border/2, plotBox.width() + border, plotBox.height() + border);
            context.restore();
        }
    });

    return Plotarea;
};

},{"../../core/plotarea.js":56}],92:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function() {
    var BandRenderer = require('../../../core/renderers/band_renderer.js');

    if (_INCLUDED) { return BandRenderer; }
    _INCLUDED = true;

    // cached state object, for quick access during rendering, populated in begin() method:
    BandRenderer.hasA("state");

    BandRenderer.respondsTo("begin", function (context) {
        var state = {
            "context"            : context,
            "run"                : [],
            "linecolor"          : this.getOptionValue("linecolor"),
            "line1color"         : this.getOptionValue("line1color"),
            "line2color"         : this.getOptionValue("line2color"),
            "linewidth"          : this.getOptionValue("linewidth"),
            "line1width"         : this.getOptionValue("line1width"),
            "line2width"         : this.getOptionValue("line2width"),
            "fillcolor"          : this.getOptionValue("fillcolor"),
            "fillopacity"        : this.getOptionValue("fillopacity")
        };
        this.state(state);
    });

    // This renderer's dataPoint() method works by accumulating
    // and drawing one "run" of data points at a time.  A "run" of
    // points consists of a consecutive sequence of non-missing
    // data points which have the same fill color.  (The fill
    // color can change if the data line crosses the fill base
    // line, if the downfillcolor is different from the
    // fillcolor.)
    BandRenderer.respondsTo("dataPoint", function (datap) {
        var state = this.state();

        if (this.isMissing(datap)) {
            // if this is a missing point, render and reset the current run, if any
            if (state.run.length > 0) {
                this.renderRun();
                state.run = [];
            }
        } else {
            // otherwise, transform point to pixel coords
            var p = this.transformPoint(datap);
            // and add it to the current run
            state.run.push(p);
        }
    });

    BandRenderer.respondsTo("end", function () {
        var state = this.state();
        // render the current run, if any
        if (state.run.length > 0) {
            this.renderRun();
        }
    });

    /*
     * Private utility function to stroke line segments connecting the points of a run
     */
    var strokeRunLine = function(context, run, whichLine, color, defaultColor, width, defaultWidth) {
        var i;

        width = (width >= 0) ? width : defaultWidth;
        if (width > 0) {
            color = (color !== null) ? color : defaultColor;
            context.save();
            context.strokeStyle = color.getHexString("#");
            context.lineWidth = width;
            context.beginPath();
            context.moveTo(run[0][0], run[0][whichLine]);
            for (i = 1; i < run.length; ++i) {
                context.lineTo(run[i][0], run[i][whichLine]);
            }
            context.stroke();
            context.restore();
        }
    };

    // Render the current run of data points.  This consists of drawing the fill region
    // in the band between the two data lines, and connecting the points of each data line
    // with lines of the appropriate color.
    BandRenderer.respondsTo("renderRun", function () {
        var state   = this.state(),
            context = state.context,
            run     = state.run,
            i;

        // fill the run
        context.save();
        context.globalAlpha = state.fillopacity;
        context.fillStyle = state.fillcolor.getHexString("#");
        context.beginPath();
        // trace to the right along line 1
        context.moveTo(run[0][0], run[0][1]);
        for (i = 1; i < run.length; ++i) {
            context.lineTo(run[i][0], run[i][1]);
        }
        // trace back to the left along line 2
        context.lineTo(run[run.length-1][0], run[run.length-1][2]);
        for (i = run.length-1; i >= 0; --i) {
            context.lineTo(run[i][0], run[i][2]);
        }
        context.fill();
        context.restore();

        // stroke line1
        strokeRunLine(context, run, 1, state.line1color, state.linecolor, state.line1width, state.linewidth);

        // stroke line2
        strokeRunLine(context, run, 2, state.line2color, state.linecolor, state.line2width, state.linewidth);
    });

    BandRenderer.respondsTo("renderLegendIcon", function (context, x, y, icon) {
        var state = this.state(),
            iconWidth  = icon.width(),
            iconHeight = icon.height();

        context.save();
        context.transform(1, 0, 0, 1, x, y);

        context.save();
        // Draw icon background (with opacity)
        if (iconWidth < 10 || iconHeight < 10) {
            context.fillStyle = state.fillcolor.toRGBA();
        } else {
            context.fillStyle = "#FFFFFF";
        }
        context.fillRect(0, 0, iconWidth, iconHeight);
        context.restore();

        // Draw icon graphics
        context.strokeStyle = (state.line2color !== null) ? state.line2color : state.linecolor;
        context.lineWidth   = (state.line2width >= 0) ? state.line2width : state.linewidth;
        context.fillStyle   = state.fillcolor.toRGBA(state.fillopacity);

        context.beginPath();

        context.moveTo(0,         2*iconHeight/8);
        context.lineTo(0,         6*iconHeight/8);
        context.lineTo(iconWidth, 7*iconHeight/8);
        context.lineTo(iconWidth, 3*iconHeight/8);
        context.lineTo(0,         2*iconHeight/8);
        
        context.fill();
        context.stroke();

        context.restore();
    });

    return BandRenderer;
};

},{"../../../core/renderers/band_renderer.js":59}],93:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function() {
    var BarRenderer = require('../../../core/renderers/bar_renderer.js');

    if (_INCLUDED) { return BarRenderer; }
    _INCLUDED = true;

    // cached settings object, for quick access during rendering, populated in begin() method:
    BarRenderer.hasA("settings");

    BarRenderer.respondsTo("begin", function (context) {
        var settings = {
            "context"            : context,
            "barpixelwidth"      : this.getOptionValue("barwidth").getRealValue() * this.plot().horizontalaxis().axisToDataRatio(),
            "baroffset"          : this.getOptionValue("baroffset"),
            "barpixelbase"       : (this.getOptionValue("barbase") !== null)?this.plot().verticalaxis().dataValueToAxisValue(this.getOptionValue("barbase")):0,
            "fillcolor"          : this.getOptionValue("fillcolor"),
            "linecolor"          : this.getOptionValue("linecolor"),
            "hidelines"          : this.getOptionValue("hidelines"),
            "barGroups"          : [],
            "currentBarGroup"    : null,
            "prevCorner"         : null,
            "pixelEdgeTolerance" : 1
        };

        this.settings(settings);
    });

    // This bar renderer uses a somewhat sophisticated technique when drawing
    // the outlines around the bars, in order to make sure that it only draws
    // one vertical line between two bars that share an edge.  If a complete
    // outline were drawn around each bar separately, the common edge between
    // adjacent bars would get drawn twice, once for each bar, possibly in
    // slightly different locations on the screen due to roundoff error,
    // thereby making some of the outline lines appear thicker than others.
    // 
    // In order to avoid this roundoff artifact, this render only draws the
    // bars (the filled region of the bar, that is) in its dataPoint() method,
    // and keeps a record of the bar locations and heights so that it can draw all
    // of the bar outlines at once, in its end() method.  The bar locations and
    // heights are stored in an array called _barGroups, which is an array of
    // "bar group" objects.  Each "bar group" corresponds to a sequence of adjacent
    // bars --- two bars are considered to be adjacent if the right edge of the left
    // bar is within _pixelEdgeTolerance pixels of the left edge of the right bar.
    // A "bar group" is represented by an array of points representing the pixel
    // coordinates of the upper left corners of all the bars in the group, followed by
    // the pixel coordinates of the upper right corner of the right-most bar in the group.
    // (The last, right-most, bar is the only one whose upper right corner is included
    // in the list).  So, for example, the following bar group
    // 
    //        *--*
    //        |  |--*
    //     *--*  |  |
    //     |  |  |  |
    //     |  |  |  |
    //   ---------------
    //     1  2  3  4
    // 
    // would be represented by the array
    //
    //    [ [1,2], [2,3], [3,3], [4,3] ]
    //
    
    BarRenderer.respondsTo("dataPoint", function (datap) {
        if (this.isMissing(datap)) {
            return;
        }

        var settings = this.settings(),
            context  = settings.context,
            p  = this.transformPoint(datap),
            x0 = p[0] + settings.baroffset,
            x1 = p[0] + settings.baroffset + settings.barpixelwidth;

        context.save();
        context.fillStyle = this.getOptionValue("fillcolor", datap[1]).getHexString("#");
        context.fillRect(x0, settings.barpixelbase, settings.barpixelwidth, p[1] - settings.barpixelbase);
        context.restore();

        if (settings.barpixelwidth > settings.hidelines) {
            if (settings.prevCorner === null) {
                settings.currentBarGroup = [ [x0,p[1]] ];
            } else {
                if (Math.abs(x0 - settings.prevCorner[0]) <= settings.pixelEdgeTolerance) {
                    settings.currentBarGroup.push( [x0,p[1]] );
                } else {
                    settings.currentBarGroup.push( settings.prevCorner );
                    settings.barGroups.push( settings.currentBarGroup );
                    settings.currentBarGroup = [ [x0,p[1]] ];
                }
            }
            settings.prevCorner = [x1,p[1]];
        }
    });
    
    BarRenderer.respondsTo("end", function () {
        var settings     = this.settings(),
            context      = settings.context,
            barpixelbase = settings.barpixelbase,
            max = Math.max,
            min = Math.min,
            p,
            barGroup,
            i, j, n;

        if (settings.prevCorner !== null && settings.currentBarGroup !== null) {
            settings.currentBarGroup.push( settings.prevCorner );
            settings.barGroups.push( settings.currentBarGroup );
        }        

        context.save();
        context.strokeStyle = settings.linecolor.getHexString("#");
        context.beginPath();
        for (i = 0; i < settings.barGroups.length; i++) {
            barGroup = settings.barGroups[i];
            n = barGroup.length;
            if (n < 2) { return; } // this should never happen
            
            // For the first point, draw 3 lines:
            //
            //       y |------
            //         |
            //         |
            //    base |------
            //         ^     ^
            //         x     x(next)
            //
            
            //   horizontal line @ y from x(next) to x
            context.moveTo(barGroup[1][0], barGroup[0][1]);
            context.lineTo(barGroup[0][0], barGroup[0][1]);
            //   vertical line @ x from y to base
            context.lineTo(barGroup[0][0], barpixelbase);
            //   horizontal line @ base from x to x(next)
            context.lineTo(barGroup[1][0], barpixelbase);
            
            for (j = 1; j < n - 1; ++j) {
                // For intermediate points, draw 3 lines:
                //
                //       y |
                //         |
                //         |
                //         |------ y(next)
                //         |
                //         |
                //         |------ base
                //         ^     ^
                //         x     x(next)
                //
                //   vertical line @ x from min to max of (y, y(next), base)
                context.moveTo(barGroup[j][0], min(barGroup[j-1][1], barGroup[j][1], barpixelbase));
                context.lineTo(barGroup[j][0], max(barGroup[j-1][1], barGroup[j][1], barpixelbase));
                //   horizontal line @ y(next) from x to x(next)
                context.moveTo(barGroup[j][0],   barGroup[j][1]);
                context.lineTo(barGroup[j+1][0], barGroup[j][1]);
                //   horizontal line @ base from x to x(next)
                context.moveTo(barGroup[j][0],   barpixelbase);
                context.lineTo(barGroup[j+1][0], barpixelbase);
            }
            // For last point, draw one line:
            //
            //       y |
            //         |
            //         |
            //    base |
            //         ^     ^
            //         x     x(next)
            //
            //   vertical line @ x from base to y
            context.moveTo(barGroup[n-1][0], barGroup[n-1][1]);
            context.lineTo(barGroup[n-1][0], barpixelbase);
        }
        context.stroke();
        context.restore();
    });

    BarRenderer.respondsTo("renderLegendIcon", function (context, x, y, icon) {
        var settings          = this.settings(),
            rendererFillColor = this.getOptionValue("fillcolor", 0).toRGBA(this.getOptionValue("fillopacity", 0));

        context.save();
        context.transform(1, 0, 0, 1, x, y);

        // Draw icon background (with opacity)
        context.fillStyle = "rgba(255, 255, 255, 1)";
        context.fillRect(0, 0, icon.width(), icon.height());

        context.lineWidth = 1;
        context.fillStyle = rendererFillColor;

        if (settings.barpixelwidth < settings.hidelines) {
            context.strokeStyle = rendererFillColor;
        } else {
            context.strokeStyle = this.getOptionValue("linecolor", 0).toRGBA();
        }

        // Adjust the width of the icons bars based upon the width and height of the icon Ranges: {20, 10, 0}
        var iconWidth = icon.width(),
            iconHeight = icon.height(),
            barwidth;
        if (iconWidth > 20 || iconHeight > 20) {
            barwidth = iconWidth / 6;
        } else if (iconWidth > 10 || iconHeight > 10) {
            barwidth = iconWidth / 4;
        } else {
            barwidth = iconWidth / 4;
        }

        // If the icon is large enough draw extra bars
        if (iconWidth > 20 && iconHeight > 20) {
            context.fillRect(   (iconWidth / 4) - (barwidth / 2),             0, barwidth, iconHeight / 2);
            context.strokeRect( (iconWidth / 4) - (barwidth / 2),             0, barwidth, iconHeight / 2);

            context.fillRect(   iconWidth - (iconWidth / 4) - (barwidth / 2), 0, barwidth, iconHeight / 3);
            context.strokeRect( iconWidth - (iconWidth / 4) - (barwidth / 2), 0, barwidth, iconHeight / 3);
        }

        context.fillRect(       (iconWidth / 2) - (barwidth / 2),             0, barwidth, iconHeight - (iconHeight / 4));
        context.strokeRect(     (iconWidth / 2) - (barwidth / 2),             0, barwidth, iconHeight - (iconHeight / 4));

        context.restore();
    });
    
    return BarRenderer;
};


},{"../../../core/renderers/bar_renderer.js":60}],94:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function() {
    var FillRenderer = require('../../../core/renderers/fill_renderer.js'),
        mathUtil = require('../../../math/util.js');

    if (_INCLUDED) { return FillRenderer; }
    _INCLUDED = true;

    // cached state object, for quick access during rendering, populated in begin() method:
    FillRenderer.hasA("state");

    FillRenderer.respondsTo("begin", function (context) {
        var state = {
            "context"            : context,
            "run"                : [],
            "previouspoint"      : null,
            "linecolor"          : this.getOptionValue("linecolor"),
            "linewidth"          : this.getOptionValue("linewidth"),
            "fillcolor"          : this.getOptionValue("fillcolor"),
            "downfillcolor"      : this.getOptionValue("downfillcolor"),
            "fillopacity"        : this.getOptionValue("fillopacity"),
            "fillbase"           : this.getOptionValue("fillbase"),
            "currentfillcolor"   : null
        };
        if (state.downfillcolor === null) {
            state.downfillcolor = state.fillcolor;
        }
        if (state.fillbase !== null) {
            state.fillpixelbase = this.plot().verticalaxis().dataValueToAxisValue(state.fillbase);
        } else {
            state.fillpixelbase = 0;
        }

        this.state(state);

        context.save();
        context.fillStyle = state.fillcolor.getHexString("#");
    });

    // This renderer's dataPoint() method works by accumulating
    // and drawing one "run" of data points at a time.  A "run" of
    // points consists of a consecutive sequence of non-missing
    // data points which have the same fill color.  (The fill
    // color can change if the data line crosses the fill base
    // line, if the downfillcolor is different from the
    // fillcolor.)
    FillRenderer.respondsTo("dataPoint", function (datap) {
        var state = this.state(),
            fillpixelbase = state.fillpixelbase,
            fillcolor,
            linecolor,
            p;

        // if this is a missing point, and if it's not the first point, end the current run and render it
        if (this.isMissing(datap)) {
            if (state.previouspoint !== null) {
                state.run.push( [state.previouspoint[0], fillpixelbase] );
                this.renderRun();
                state.run = [];
                state.previouspoint = null;
            }
            return;
        }

        // transform point to pixel coords
        p = this.transformPoint(datap);

        // set the fillcolor and linecolor for this data point, based on whether it's above
        // or below the base line
        if (p[1] >= fillpixelbase) {
            fillcolor = state.fillcolor;
        } else {
            fillcolor = state.downfillcolor;
        }

        // if we're starting a new run, start with this data point's base line projection
        if (state.run.length === 0) {
            state.run.push( [p[0], fillpixelbase] );
        } else {
            // if we're not starting a new run, but the fill color
            // has changed, interpolate to find the exact base
            // line crossing point, end the current run with that
            // point, render it, and start a new run with the
            // crossing point.
            if (!fillcolor.eq(state.currentfillcolor)) {
                var x = mathUtil.safe_interp(fillpixelbase, state.previouspoint[1], p[1], state.previouspoint[0], p[0]);
                // base line crossing point is [x, state.fillpixelbase]
                // These points are pushed twice so the outline of the fill will be drawn properly,
                // otherwise the outline would not be drawn around the segments that cross the baseline.
                state.run.push( [x, fillpixelbase] );
                state.run.push( [x, fillpixelbase] );
                this.renderRun();
                state.run = [];
                state.run.push( [x, fillpixelbase] );
                state.run.push( [x, fillpixelbase] );
            }
        }

        // add this point to the current run, and remember it and the current colors for next time
        state.run.push(p);
        state.previouspoint = p;
        state.currentfillcolor = fillcolor;
    });

    FillRenderer.respondsTo("end", function () {
        var state = this.state(),
            context = state.context;
        if (state.run.length > 0) {
            state.run.push( [state.run[state.run.length-1][0], state.fillpixelbase] );
            this.renderRun();
        }
        context.restore();
    });

    // Render the current run of data points.  This consists of drawing the fill region
    // under the points, and the lines connecting the points.  The first and last points
    // in the run array are always on the base line; the points in between these two
    // are the actual data points.
    FillRenderer.respondsTo("renderRun", function () {
        var state = this.state(),
            context = state.context,
            i;

        // fill the run
        context.save();
        context.globalAlpha = state.fillopacity;
        context.fillStyle = state.currentfillcolor.getHexString("#");
        context.beginPath();
        context.moveTo(state.run[0][0], state.run[0][1]);
        for (i = 1; i < state.run.length; ++i) {
            context.lineTo(state.run[i][0], state.run[i][1]);
        }
        context.fill();
        context.restore();

        // stroke the run
        context.save();
        context.strokeStyle = state.linecolor.getHexString("#");
        context.lineWidth = state.linewidth;
        context.beginPath();
        context.moveTo(state.run[1][0], state.run[1][1]);
        for (i = 2; i < state.run.length-1; ++i) {
            context.lineTo(state.run[i][0], state.run[i][1]);
        }
        context.stroke();
        context.restore();
    });

    FillRenderer.respondsTo("renderLegendIcon", function (context, x, y, icon) {
        var state = this.state(),
            iconWidth = icon.width(),
            iconHeight = icon.height();
        
        context.save();
        context.transform(1, 0, 0, 1, x, y);

        context.save();
        // Draw icon background (with opacity)
        if (iconWidth < 10 || iconHeight < 10) {
            context.fillStyle = state.fillcolor.toRGBA();
        } else {
            context.fillStyle = "rgba(255, 255, 255, 1)";
        }
        context.fillRect(0, 0, iconWidth, iconHeight);
        context.restore();

        context.strokeStyle = state.linecolor.toRGBA();
        context.lineWidth   = state.linewidth;
        context.fillStyle   = state.fillcolor.toRGBA(state.fillopacity);

        context.beginPath();
        context.moveTo(0, 0);
        // Draw the middle range icon or the large range icon if the width and height allow it
        if (iconWidth > 10 || iconHeight > 10) {
            // Draw a more complex icon if the icons width and height are large enough
            if (iconWidth > 20 || iconHeight > 20) {
                context.lineTo(iconWidth / 6, iconHeight / 2);
                context.lineTo(iconWidth / 3, iconHeight / 4);
            }
            context.lineTo(iconWidth / 2, iconHeight - iconHeight / 4);

            if (iconWidth > 20 || iconHeight > 20) {
                context.lineTo(iconWidth - iconWidth / 3, iconHeight / 4);
                context.lineTo(iconWidth - iconWidth / 6, iconHeight / 2);
            }
        }
        context.lineTo(iconWidth, 0);
        context.stroke();
        context.fill();

        context.restore();
    });

    return FillRenderer;
};

},{"../../../core/renderers/fill_renderer.js":61,"../../../math/util.js":106}],95:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function() {
    var PointlineRenderer = require('../../../core/renderers/pointline_renderer.js'),
        Renderer = require('../../../core/renderer.js');

    if (_INCLUDED) { return PointlineRenderer; }
    _INCLUDED = true;

    // cached settings object, for quick access during rendering, populated in begin() method:
    PointlineRenderer.hasA("settings");

    PointlineRenderer.respondsTo("begin", function (context) {
        var settings = {
            "context"            : context,
            "points"             : [],
            "first"              : true,
            "pointshape"         : this.getOptionValue("pointshape"),
            "pointcolor"         : this.getOptionValue("pointcolor"),
            "pointopacity"       : this.getOptionValue("pointopacity"),
            "pointsize"          : this.getOptionValue("pointsize"),
            "pointoutlinewidth"  : this.getOptionValue("pointoutlinewidth"),
            "pointoutlinecolor"  : this.getOptionValue("pointoutlinecolor"),
            "linestroke"         : this.getOptionValue("linestroke"),
            "linecolor"          : this.getOptionValue("linecolor"),
            "linewidth"          : this.getOptionValue("linewidth")
        };

        // turns off points for line renderers
        if (this.type() === Renderer.LINE) {
            settings.pointsize = 0;
        }
        // turns off lines for point renderers
        if (this.type() === Renderer.POINT) {
            settings.linewidth = 0;
        }
        this.settings(settings);

        if (settings.linewidth > 0) {
            context.save();
            context.beginPath();
            if (settings.linestroke === PointlineRenderer.DASHED) {
                context.setLineDash([5,5]);
            }
            context.lineWidth = settings.linewidth;
            context.strokeStyle = settings.linecolor.getHexString("#");
        }

        if (this.filter()) {
            this.filter().reset();
        }
    });
    PointlineRenderer.respondsTo("dataPoint", function (datap) {
        var settings = this.settings(),
            context  = settings.context,
            p;
        if (this.isMissing(datap)) {
            settings.first = true;
            return;
        }
        p = this.transformPoint(datap);
        if (this.filter()) {
            if (this.filter().filter(datap, p)) {
                return;
            }
        }
        if (settings.linewidth > 0) {
            if (settings.first) {
                context.moveTo(p[0], p[1]);
                settings.first = false;
            } else {
                context.lineTo(p[0], p[1]);
            }
        }
        if (settings.pointsize > 0) {
            settings.points.push(p);
        }
    });

    PointlineRenderer.respondsTo("end", function () {
        var settings = this.settings(),
            context  = settings.context;
        if (settings.linewidth > 0) {
            context.stroke();
            context.restore();
        }
        if (settings.pointsize > 0) {
            this.drawPoints();
        }
    });


    PointlineRenderer.respondsTo("drawPoints", function (p) {
        var settings   = this.settings(),
            context    = settings.context,
            points     = settings.points,
            pointshape = settings.pointshape,
            i;

        context.save();
        context.beginPath();
        if ((pointshape === PointlineRenderer.PLUS) || (pointshape === PointlineRenderer.X)) {
            context.strokeStyle = settings.pointcolor.getHexString("#");
            context.lineWidth = settings.pointoutlinewidth;
        } else {
            context.fillStyle = settings.pointcolor.toRGBA(settings.pointopacity);
            context.strokeStyle = settings.pointoutlinecolor.getHexString("#");
            context.lineWidth = settings.pointoutlinewidth;
        }

        for (i=0; i<points.length; ++i) {
            this.drawPoint(context, settings, points[i]);
        }

        if (!((pointshape === PointlineRenderer.PLUS) || (pointshape === PointlineRenderer.X))) {
            context.fill();
        }
        context.stroke();
        context.restore();
    });

    PointlineRenderer.respondsTo("drawPoint", function (context, settings, p) {
        var pointsize = settings.pointsize,
            p0 = p[0],
            p1 = p[1],
            a,b,d;

        switch (settings.pointshape) {
        case PointlineRenderer.PLUS:
            context.moveTo(p0,             p1 - pointsize);
            context.lineTo(p0,             p1 + pointsize);
            context.moveTo(p0 - pointsize, p1);
            context.lineTo(p0 + pointsize, p1);
            return;
        case PointlineRenderer.X:
            d = 0.70710 * pointsize;
            context.moveTo(p0-d, p1-d);
            context.lineTo(p0+d, p1+d);
            context.moveTo(p0-d, p1+d);
            context.lineTo(p0+d, p1-d);
            return;
        case PointlineRenderer.SQUARE:
            context.moveTo(p0 - pointsize, p1 - pointsize);
            context.lineTo(p0 + pointsize, p1 - pointsize);
            context.lineTo(p0 + pointsize, p1 + pointsize);
            context.lineTo(p0 - pointsize, p1 + pointsize);
            return;
        case PointlineRenderer.TRIANGLE:
            d = 1.5 * pointsize;
            a = 0.866025 * d;
            b = 0.5 * d;
            context.moveTo(p0,     p1 + d);
            context.lineTo(p0 + a, p1 - b);
            context.lineTo(p0 - a, p1 - b);
            return;
        case PointlineRenderer.DIAMOND:
            d = 1.5 * pointsize;
            context.moveTo(p0 - pointsize, p1);
            context.lineTo(p0,             p1 + d);
            context.lineTo(p0 + pointsize, p1);
            context.lineTo(p0,             p1 - d);
            return;
        case PointlineRenderer.STAR:
            d = 1.5 * pointsize;
            context.moveTo(p0 - d*0.0000, p1 + d*1.0000);
            context.lineTo(p0 + d*0.3536, p1 + d*0.3536);
            context.lineTo(p0 + d*0.9511, p1 + d*0.3090);
            context.lineTo(p0 + d*0.4455, p1 - d*0.2270);
            context.lineTo(p0 + d*0.5878, p1 - d*0.8090);
            context.lineTo(p0 - d*0.0782, p1 - d*0.4938);
            context.lineTo(p0 - d*0.5878, p1 - d*0.8090);
            context.lineTo(p0 - d*0.4938, p1 - d*0.0782);
            context.lineTo(p0 - d*0.9511, p1 + d*0.3090);
            context.lineTo(p0 - d*0.2270, p1 + d*0.4455);
            return;
        case PointlineRenderer.CIRCLE:
            context.moveTo(p0 + pointsize, p1);
            context.arc(p0, p1, pointsize, 0, 2*Math.PI, false);
            return;
        }
    });

    PointlineRenderer.respondsTo("renderLegendIcon", function (context, x, y, icon) {
        var settings   = this.settings(),
            pointshape = settings.pointshape,
            iconWidth  = icon.width(),
            iconHeight = icon.height();

        context.save();
        // Draw icon background (with opacity)
        context.fillStyle = "rgba(255, 255, 255, 1)";
        context.fillRect(x, y, iconWidth, iconHeight);

        if (settings.linewidth > 0) {
            context.strokeStyle = settings.linecolor.toRGBA();
            context.lineWidth   = settings.linewidth;
            context.beginPath();
            context.moveTo(x, y + iconHeight/2);
            context.lineTo(x + iconWidth, y + iconHeight/2);
            context.stroke();
        }
        if (settings.pointsize > 0) {
            context.beginPath();
            if ((pointshape === PointlineRenderer.PLUS) || (pointshape === PointlineRenderer.X)) {
                context.strokeStyle = settings.pointcolor.toRGBA();
                context.lineWidth   = settings.pointoutlinewidth;
            } else {
                context.fillStyle   = settings.pointcolor.toRGBA(settings.pointopacity);
                context.strokeStyle = settings.pointoutlinecolor.toRGBA();
                context.lineWidth   = settings.pointoutlinewidth;
            }

            this.drawPoint(context, settings, [(x + iconWidth/2), (y + iconHeight/2)]);

            if (!((pointshape === PointlineRenderer.PLUS) || (pointshape === PointlineRenderer.X))) {
                context.fill();
            }
            context.stroke();
        }
        context.restore();
    });

    return PointlineRenderer;
};

},{"../../../core/renderer.js":57,"../../../core/renderers/pointline_renderer.js":62}],96:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function() {
    var RangeBarRenderer = require('../../../core/renderers/rangebar_renderer.js');

    if (_INCLUDED) { return RangeBarRenderer; }
    _INCLUDED = true;

    // cached state object, for quick access during rendering, populated in begin() method:
    RangeBarRenderer.hasA("state");

    RangeBarRenderer.respondsTo("begin", function (context) {
        var state = {
            "context"            : context,
            "run"                : [],
            "barpixelwidth"      : this.getOptionValue("barwidth").getRealValue() * this.plot().horizontalaxis().axisToDataRatio(),
            "barpixeloffset"     : 0,
            "baroffset"          : this.getOptionValue("baroffset"),
            "fillcolor"          : this.getOptionValue("fillcolor"),
            "fillopacity"        : this.getOptionValue("fillopacity"),
            "linecolor"          : this.getOptionValue("linecolor"),
            "linewidth"          : this.getOptionValue("linewidth"),
            "hidelines"          : this.getOptionValue("hidelines")
        };
        state.barpixeloffset = state.barpixelwidth * state.baroffset;
        this.state(state);
        context.save();
        context.beginPath();
    });

    RangeBarRenderer.respondsTo("dataPoint", function (datap) {
        if (this.isMissing(datap)) {
            return;
        }

        var state = this.state(),
            context = state.context,
            p = this.transformPoint(datap),
            x0 = p[0] - state.barpixeloffset,
            x1 = x0 + state.barpixelwidth;

        context.moveTo(x0, p[1]);
        context.lineTo(x0, p[2]);
        context.lineTo(x1, p[2]);
        context.lineTo(x1, p[1]);
        context.lineTo(x0, p[1]);
    });

    RangeBarRenderer.respondsTo("end", function () {
        var state = this.state(),
            context = state.context;

        context.globalAlpha = state.fillopacity;
        context.fillStyle = state.fillcolor.getHexString("#");
        context.fill();
        if (state.linewidth > 0 && state.barpixelwidth > state.hidelines) {
            context.strokeStyle = state.linecolor.getHexString("#");
            context.lineWidth = state.linewidth;
            context.stroke();
        }
        context.restore();
    });

    RangeBarRenderer.respondsTo("renderLegendIcon", function (context, x, y, icon) {
        var state = this.state(),
            iconWidth  = icon.width(),
            iconHeight = icon.height(),
            barwidth;

        context.save();
        context.transform(1, 0, 0, 1, x, y);

        // Draw icon background (with opacity)
        context.save();
        context.strokeStyle = "#FFFFFF";
        context.fillStyle = "#FFFFFF";
        context.fillRect(0, 0, iconWidth, iconHeight);
        context.restore();

        // Draw icon graphics
        context.fillStyle = state.fillcolor.toRGBA(state.fillopacity);
        context.lineWidth = state.linewidth;
        if (state.barpixelwidth < 10) {
            context.strokeStyle = state.fillcolor.toRGBA(state.fillopacity);
        } else {
            context.strokeStyle = state.linecolor.getHexString("#");
        }

        // Adjust the width of the icons bars based upon the width and height of the icon Ranges: {20, 10, 0}
        if (iconWidth > 20 || iconHeight > 20) {
            barwidth = iconWidth / 6;
        } else if(iconWidth > 10 || iconHeight > 10) {
            barwidth = iconWidth / 4;
        } else {
            barwidth = iconWidth / 4;
        }

        // If the icon is large enough draw extra bars
        if (iconWidth > 20 && iconHeight > 20) {
            context.fillRect(  iconWidth/4 - barwidth/2,             iconHeight/8, barwidth, iconHeight/2);
            context.strokeRect(iconWidth/4 - barwidth/2,             iconHeight/8, barwidth, iconHeight/2);

            context.fillRect(  iconWidth - iconWidth/4 - barwidth/2, iconHeight/4, barwidth, iconHeight/3);
            context.strokeRect(iconWidth - iconWidth/4 - barwidth/2, iconHeight/4, barwidth, iconHeight/3);
        }

        context.fillRect(  iconWidth/2 - barwidth/2, 0, barwidth, iconHeight-iconHeight/4);
        context.strokeRect(iconWidth/2 - barwidth/2, 0, barwidth, iconHeight-iconHeight/4);

        context.restore();
    });

    return RangeBarRenderer;
};

},{"../../../core/renderers/rangebar_renderer.js":63}],97:[function(require,module,exports){
module.exports = function() {
    var Text = require('../../core/text.js');

    if (typeof(Text.drawText)==="function") { return Text; }

    Text.respondsTo("initializeGeometry", function (graphicsContext) {
        var origWidth,
            origHeight,
            rotatedWidth,
            rotatedHeight;

        graphicsContext.context.save();
        if (this.font() !== "") {
            // the new way: use the "font" property
            graphicsContext.context.font = this.font();
        } else if (graphicsContext.fontSize !== undefined) {
            // the old way, for backward compatibility ("fontSize" property of graphics context object):
            graphicsContext.context.font = graphicsContext.fontSize + " sans-serif";
        }

        origWidth  = this.measureStringWidth(graphicsContext.context);
        origHeight = this.measureStringHeight(graphicsContext.context);

        graphicsContext.context.restore();

        if (graphicsContext.angle !== undefined) {
            var angle = graphicsContext.angle/180 * Math.PI;
            rotatedWidth = Math.abs(Math.cos(angle)) * origWidth + Math.abs(Math.sin(angle)) * origHeight;
            rotatedHeight = Math.abs(Math.sin(angle)) * origWidth + Math.abs(Math.cos(angle)) * origHeight;
        } else {
            rotatedWidth = origWidth;
            rotatedHeight = origHeight;
        }

        this.origWidth(origWidth);
        this.origHeight(origHeight);
        this.rotatedWidth(rotatedWidth);
        this.rotatedHeight(rotatedHeight);

        return this;
    });

    /**
     * Determines unrotated width for the stored string in the canvas environment.
     *
     * @method measureStringWidth
     * @for Text
     * @private
     * @return {Float} Unrotated width of string.
     * @param {Context} context
     */
    Text.respondsTo("measureStringWidth", function (context) {
        if (this.string() === undefined) {
            throw new Error("measureStringWidth requires the string attr to be set.");
        }

        var metrics = context.measureText(this.string());
        return metrics.width;
    });

    /**
     * Determines unrotated height for the stored string in the canvas environment.
     *
     * @method measureStringHeight
     * @for Text
     * @private
     * @return {Float} Unrotated height of string.
     * @param {Context} context
     */
    Text.respondsTo("measureStringHeight", function (context) {
        if (this.string() === undefined) {
            throw new Error("measureStringHeight requires the string attr to be set.");
        }

        //NOTE: kludge: canvas cannot exactly measure text height, so we just return a value
        //      estimated by using the width of an "M" as a substitute.  Maybe improve this
        //      later by using a better workaround.
        var metrics = context.measureText("M"),
            newlineCount = this.string().match(/\n/g);
        return (newlineCount !== null ? (newlineCount.length + 1) : 1) * metrics.width;
    });

    Text.respondsTo("setTransform", function (context, anchor, base, position, angle) {
        context.transform(1, 0, 0, -1, 0, 2 * base.y());
        context.transform(1, 0, 0, 1, base.x(), base.y());
        context.transform(1, 0, 0, 1, position.x(), -position.y());
        context.rotate(-angle * Math.PI/180.0);
        context.transform(1, 0, 0, 1, -anchor.x(), anchor.y());
    });

    Text.respondsTo("drawText", function (context, anchor, base, position, angle) {
        context.save();
        this.setTransform(context, anchor, base, position, angle);
        if (this.font() !== "") {
            context.font = this.font();
        }
        context.fillText(this.string(), 0, 0);
        context.restore();
    });

    return Text;
};

},{"../../core/text.js":64}],98:[function(require,module,exports){
module.exports = function() {
    var Window = require('../../core/window.js');

    if (typeof(Window.render)==="function") { return Window; }

    Window.respondsTo("render", function (context, width, height) {
        var m = this.margin().left();

        context.save();
        context.fillStyle = this.bordercolor().getHexString("#");
        context.fillRect(m, m, width - 2*m, height - 2*m);
        context.restore();
    });

    return Window;
};

},{"../../core/window.js":70}],99:[function(require,module,exports){
require('../lib/ajaxthrottle/src/ajaxthrottle.js');
require('../lib/lightbox/lightbox.js');
require('../lib/jquery/jquery.mousewheel.js');
require('../lib/busy-spinner/busy_spinner.js');
require('../lib/error-display/build/errorDisplay.js');
require('../lib/requestanimationframe/requestanimationframe.js');

require('./parser/xml/jquery_xml_parser.js')($);
require('./parser/json/json_parser.js')($);
require('./graphics/canvas/all.js')($, window);

// This forces ./events/multigraph.js to load, which is where the 'main' program
// really lives --- i.e. installation of the Multigraph jQuery plugin, and the
// $(document).ready(...) stuff that springs into action once the page has loaded.
// Note that the 3rd arg to require('./events/multigraph.js') is unused.
require('./events/multigraph.js')($, window, undefined);

// For JS applications that want to use the bundled multigraph file, instead of
// referencing Multigraph through npm-style require statements, and for backward
// compatibility with pre-npm versions of Multigraph, create the globael
// window.multigraph object which exposes a bunch of objects/functions from the
// Multigraph code.
var Multigraph = require('./core/multigraph.js')($);
var utilityFunctions = require('./util/utilityFunctions.js');
var parsingFunctions = require('./util/parsingFunctions.js');
var validationFunctions = require('./util/validationFunctions.js');

window.multigraph = {
    'core' : {
        'Multigraph':                	Multigraph,
        'CSVData':                		require('./core/csv_data.js')($),
        'WebServiceData':             	require('./core/web_service_data.js')($),

        'ArrayData':                    require('./core/array_data.js'),
        'Axis':                         require('./core/axis.js'),
        'AxisBinding':                  require('./core/axis_binding.js'),
        'AxisTitle':                    require('./core/axis_title.js'),
        'Background':                   require('./core/background.js'),
        'ConstantPlot':                 require('./core/constant_plot.js'),
        'Data':                         require('./core/data.js'),
        'DataFormatter':                require('./core/data_formatter.js'),
        'DataMeasure':                  require('./core/data_measure.js'),
        'DataPlot':                     require('./core/data_plot.js'),
        'DataValue':                    require('./core/data_value.js'),
        'DataVariable':                 require('./core/data_variable.js'),
        'Datatips':                     require('./core/datatips.js'),
        'DatatipsVariable':             require('./core/datatips_variable.js'),
        'DatetimeFormatter':            require('./core/datetime_formatter.js'),
        'DatetimeMeasure':              require('./core/datetime_measure.js'),
        'DatetimeValue':                require('./core/datetime_value.js'),
        'EventEmitter':                 require('./core/event_emitter.js'),
        'FilterOption':                 require('./core/filter_option.js'),
        'Filter':                       require('./core/filter.js'),
        'Graph':                        require('./core/graph.js'),
        'Grid':                         require('./core/grid.js'),
        'Icon':                         require('./core/icon.js'),
        'Img':                          require('./core/img.js'),
        'Labeler':                      require('./core/labeler.js'),
        'Legend':                       require('./core/legend.js'),
        'Mixin':                        require('./core/mixin.js'),
        'NumberFormatter':              require('./core/number_formatter.js'),
        'NumberMeasure':                require('./core/number_measure.js'),
        'NumberValue':                  require('./core/number_value.js'),
        'Pan':                          require('./core/pan.js'),
        'PeriodicArrayData':            require('./core/periodic_array_data.js'),
        'Plot':                         require('./core/plot.js'),
        'PlotLegend':                   require('./core/plot_legend.js'),
        'Plotarea':                     require('./core/plotarea.js'),
        'Renderer':                     require('./core/renderer.js'),
        'BandRenderer':                 require('./core/renderers/band_renderer.js'),
        'BarRenderer':                  require('./core/renderers/bar_renderer.js'),
        'FillRenderer':                 require('./core/renderers/fill_renderer.js'),
        'PointlineRenderer':            require('./core/renderers/pointline_renderer.js'),
        'RangeBarRenderer':             require('./core/renderers/rangebar_renderer.js'),
        'Text':                         require('./core/text.js'),
        'Title':                        require('./core/title.js'),
        'Warning':                      require('./core/warning.js'),
        'WebServiceDataCacheNode':      require('./core/web_service_data_cache_node.js'),
        'WebServiceDataIterator':       require('./core/web_service_data_iterator.js'),
        'Window':                       require('./core/window.js'),
        'Zoom':                         require('./core/zoom.js'),

        'browserHasCanvasSupport' : Multigraph.browserHasCanvasSupport,
        'browserHasSVGSupport'    : Multigraph.browserHasSVGSupport
    },

    'create': Multigraph.create,

    'math': {
        'Box': 				require('./math/box.js'),
        'Displacement': 	require('./math/displacement.js'),
        'Enum': 			require('./math/enum.js'),
        'Insets': 			require('./math/insets.js'),
        'Point': 			require('./math/point.js'),
        'RGBColor': 		require('./math/rgb_color.js'),
        'util': 			require('./math/util.js')
    },
    'parser' : {
        'jquery' : {
            'stringToJQueryXMLObj' : (require('./parser/xml/jquery_xml_parser.js')($)).stringToJQueryXMLObj
        }
    },

    'utilityFunctions' : {
        'getKeys' 					: utilityFunctions.getKeys,
        'insertDefaults' 			: utilityFunctions.insertDefaults,
        'getDefaultValuesFromXSD' 	: utilityFunctions.getDefaultValuesFromXSD,
        
        'parseAttribute' 			: parsingFunctions.parseAttribute,
        'parseInteger' 				: parsingFunctions.parseInteger,
        'parseBoolean' 				: parsingFunctions.parseBoolean,
        'getXMLAttr' 				: parsingFunctions.getXMLAttr,
        
        'validateNumberRange' 		: validationFunctions.validateNumberRange,
        'typeOf' 					: validationFunctions.typeOf
    },

    'jermaine': require('../lib/jermaine/src/jermaine.js'),

    'jQuery' : $
};
window.sprintf = require('sprintf');

},{"../lib/ajaxthrottle/src/ajaxthrottle.js":1,"../lib/busy-spinner/busy_spinner.js":2,"../lib/error-display/build/errorDisplay.js":3,"../lib/jermaine/src/jermaine.js":9,"../lib/jquery/jquery.mousewheel.js":13,"../lib/lightbox/lightbox.js":14,"../lib/requestanimationframe/requestanimationframe.js":15,"./core/array_data.js":17,"./core/axis.js":18,"./core/axis_binding.js":19,"./core/axis_title.js":20,"./core/background.js":21,"./core/constant_plot.js":24,"./core/csv_data.js":25,"./core/data.js":26,"./core/data_formatter.js":27,"./core/data_measure.js":28,"./core/data_plot.js":29,"./core/data_value.js":30,"./core/data_variable.js":31,"./core/datatips.js":32,"./core/datatips_variable.js":33,"./core/datetime_formatter.js":34,"./core/datetime_measure.js":35,"./core/datetime_value.js":37,"./core/event_emitter.js":38,"./core/filter.js":39,"./core/filter_option.js":40,"./core/graph.js":41,"./core/grid.js":42,"./core/icon.js":43,"./core/img.js":44,"./core/labeler.js":45,"./core/legend.js":46,"./core/mixin.js":47,"./core/multigraph.js":48,"./core/number_formatter.js":49,"./core/number_measure.js":50,"./core/number_value.js":51,"./core/pan.js":52,"./core/periodic_array_data.js":53,"./core/plot.js":54,"./core/plot_legend.js":55,"./core/plotarea.js":56,"./core/renderer.js":57,"./core/renderers/band_renderer.js":59,"./core/renderers/bar_renderer.js":60,"./core/renderers/fill_renderer.js":61,"./core/renderers/pointline_renderer.js":62,"./core/renderers/rangebar_renderer.js":63,"./core/text.js":64,"./core/title.js":65,"./core/warning.js":66,"./core/web_service_data.js":67,"./core/web_service_data_cache_node.js":68,"./core/web_service_data_iterator.js":69,"./core/window.js":70,"./core/zoom.js":71,"./events/multigraph.js":76,"./graphics/canvas/all.js":80,"./math/box.js":100,"./math/displacement.js":101,"./math/enum.js":102,"./math/insets.js":103,"./math/point.js":104,"./math/rgb_color.js":105,"./math/util.js":106,"./parser/json/json_parser.js":119,"./parser/xml/jquery_xml_parser.js":144,"./util/parsingFunctions.js":156,"./util/utilityFunctions.js":157,"./util/validationFunctions.js":158,"sprintf":16}],100:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Box = new jermaine.Model("Box", function () {
    this.hasA("width").which.isA("number");
    this.hasA("height").which.isA("number");
    this.isBuiltWith("width", "height");
});
    
module.exports = Box;

},{"../../lib/jermaine/src/jermaine.js":9}],101:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js'),
    validationFunctions = require('../util/validationFunctions.js');

var Displacement = {};
/**
 * A Displacement represents a geometric position along a line
 * segment, expressed in terms of two quantities: a relative
 * position called `a`, and an absolute offset called `b`.  The
 * length of the line segment is not known in advance --- the idea
 * is that the Displacement object encapsulates a rule for
 * determining a location along ANY line segment.  The Displacement
 * has methods which take the line segment length as an argument
 * and return the computed final position.
 *
 * There are two different position-calcuating methods,
 * corresponding to two different interpretations of the relative
 * value `a`:
 *
 * **relative length**:
 *     `a` is a number between 0 and 1, representing a fraction of
 *       the total length of the line segment; the relative
 *       position determined by `a` is the fraction `a` of the
 *       total length of the segment.
 *     In this case, the position-calculating method
 *       `calculateLength(L)` returns the number `a * L + b`, which
 *       corresponds to moving `a` of the way along the length L,
 *       then adding `b`:
 *
 *             [--------------------------------X------------]
 *             |<---- a * L --->|<---- b ------>|
 *             |<------------------  L  -------------------->|
 *
 * **relative coordinate**:
 *     `a` is a number between -1 and 1, representing a coordinate
 *       value in a [-1,1] coordinate system along the line
 *       segment.
 *     In this case, the position-calculating method
 *       `calculateCoordinate(L)` returns the number `(a+1) * L/2 +
 *       b`.  which corresponds to moving to the position
 *       determined by the `a` coordinate, then adding `b`:
 *
 *             [------------------------------------X--------]
 *             |<--- (a+1) * L/2 --->|<---- b ----->|
 *             |<------------------  L  -------------------->|
 *
 * @class Displacement
 * @for Displacement
 * @constructor
 * @param {Number} a
 * @param {Integer} b (OPTIONAL)
 */
Displacement = new jermaine.Model("Displacement", function () {
    
    this.hasA("a").which.validatesWith(function (a) {
        return validationFunctions.validateNumberRange(a, -1.0, 1.0);
    });
    this.hasA("b").which.isA("integer").and.defaultsTo(0);
    this.isBuiltWith("a", "%b");

    this.respondsTo("calculateLength", function (totalLength) {
        return this.a() * totalLength + this.b();
    });

    this.respondsTo("calculateCoordinate", function (totalLength) {
        return (this.a() + 1) * totalLength/2.0 + this.b();
    });

});

Displacement.regExp = /^([\+\-]?[0-9\.]+)([+\-])([0-9\.+\-]+)$/;

/**
 * Parses a string into a Displacement.  The string should be of one of the following forms:
 *
 *     "A+B"  ==>  a=A  b=B
 *     "A-B"  ==>  a=A  b=-B
 *     "A"    ==>  a=A  b=0
 *     "+A"   ==>  a=A  b=0
 *     "-A"   ==>  a=-A b=0
 * 
 * If the input argument is not a string, it is coerced into one.
 */
Displacement.parse = function (string) {
    if (typeof(string) !== "string") {
        string = String(string);
    }
    var ar = Displacement.regExp.exec(string),
        d,
        a,
        b,
        sign;
    if (string === undefined) {
        d = new Displacement(1);
    } else if (ar !== null) {
        a = parseFloat(ar[1]);
        b = parseFloat(ar[3]);
        switch (ar[2]) {
        case "+":
            sign = 1;
            break;
        case "-":
            sign = -1;
            break;
        default:
            sign = 0;
            break;
        }
        /*
         if (isNaN(a) || sign == 0 || isNaN(b)) {
         throw new ParseError('parse error');
         }
         */
        d = new Displacement(a, sign * b);
    } else {
        a = parseFloat(string);
        /*n
         if (isNaN(a)) {
         throw new ParseError('parse error');
         }
         */
        d = new Displacement(a);
    }
    return d;
};

module.exports = Displacement;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/validationFunctions.js":158}],102:[function(require,module,exports){
// Use Enum to create objects that act like enumerations in other languages (such as Java).
// 
// Usage is like this:
// 
//   var Suit = Enum("Suit");
//   var clubs = new Suit("clubs");
//   var diamonds = new Suit("diamonds");
//   var spades = new Suit("spades");
//   var hearts = new Suit("hearts");
// 
//   var c = Suit.parse("clubs");  # c is guaranteed to equal the clubs variable from above
// 
var Enum = function (name) {

    var instances = {};

    var Enum = function (key) {
        if (instances[key] !== undefined) {
            throw new Error("attempt to redefine "+name+" Enum with key '"+key+"'");
        }
        this.enumType = name;
        this.key = key;
        instances[key] = this;
    };

    Enum.parse = function (key) {
        return instances[key];
    };

    Enum.prototype.toString = function () {
        return this.key;
    };

    Enum.isInstance = function (obj) {
        return (obj !== undefined && obj !== null && obj.enumType === name);
    };

    return Enum;
};

module.exports = Enum;

},{}],103:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Insets = new jermaine.Model("Insets", function () {
    this.hasA("top").which.isA("number");
    this.hasA("left").which.isA("number");
    this.hasA("bottom").which.isA("number");
    this.hasA("right").which.isA("number");
    this.respondsTo("set", function (top, left, bottom, right) {
        this.top(top);
        this.left(left);
        this.bottom(bottom);
        this.right(right);
    });
    this.isBuiltWith("top", "left", "bottom", "right");
});

module.exports = Insets;

},{"../../lib/jermaine/src/jermaine.js":9}],104:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Point = new jermaine.Model("Point", function () {
    this.hasA("x").which.isA("number");
    this.hasA("y").which.isA("number");
    this.isBuiltWith("x", "y");
    this.respondsTo("eq", function (p) {
        return ((this.x()===p.x()) && (this.y()===p.y()));
    });
});

var regExp = /^\s*([0-9\-\+\.eE]+)(,|\s+|\s*,\s+|\s+,\s*)([0-9\-\+\.eE]+)\s*$/;

Point.parse = function (string) {
    var ar = regExp.exec(string),
        p;
    // ar[1] is x value
    // ar[2] is separator between x and y
    // ar[3] is y value
    
    if (!ar || (ar.length !== 4)) {
        throw new Error("cannot parse string '"+string+"' as a Point");
    }
    return new Point(parseFloat(ar[1]), parseFloat(ar[3]));
};

module.exports = Point;


},{"../../lib/jermaine/src/jermaine.js":9}],105:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var validationFunctions = require('../util/validationFunctions.js');

var RGBColor = new jermaine.Model("RGBColor", function () {
    
    this.hasA("r").which.validatesWith(function (r) {
        return validationFunctions.validateNumberRange(r, 0, 1.0);
    });
    this.hasA("g").which.validatesWith(function (g) {
        return validationFunctions.validateNumberRange(g, 0, 1.0);
    });
    this.hasA("b").which.validatesWith(function (b) {
        return validationFunctions.validateNumberRange(b, 0, 1.0);
    });
    
    var numberToHex = function (number) {
        number = parseInt(number * 255, 10).toString(16);
        if (number.length === 1) {
            number = "0" + number;
        }
        return number;
    };
    
    this.respondsTo("getHexString", function (prefix) {
        if (!prefix) {
            prefix = "0x";
        }
        return prefix + numberToHex(this.r()) + numberToHex(this.g()) + numberToHex(this.b());
    });
    
    this.respondsTo("toRGBA", function (alpha) {
        if (alpha === undefined) {
            alpha = 1.0;
        }
        if (typeof(alpha) !== "number") {
            throw new Error("RGBColor.toRGBA: The argument, if present, must be a number");
        }
        return "rgba(" + (255*this.r()) + ", " + (255*this.g()) + ", " + (255*this.b()) + ", " + alpha + ")";
    });
    
    this.respondsTo("eq", function (color) {
        return ((this.r()===color.r()) && (this.g()===color.g()) && (this.b()===color.b()));
    });
    
    this.isBuiltWith("r", "g", "b");
    
});


/*
 * To remove support for deprecated color names, remove the following function,
 * and find all references to it elsewhere in the source code, and remove them,
 * along with accompanying code that generates warning message.  Also remove
 * support for these 9 color names from RGBColor.parse below.
 */
RGBColor.colorNameIsDeprecated = function (colorName) {
    switch (colorName) {
    case "grey": return "0xeeeeee";
    case "skyblue": return "0x87ceeb";
    case "khaki": return "0xf0e68c";
    case "orange": return "0xffa500";
    case "salmon": return "0xfa8072";
    case "olive": return "0x9acd32";
    case "sienna": return "0xa0522d";
    case "pink": return "0xffb5c5";
    case "violet": return "0xee82ee";
    }
    return false;
};

RGBColor.parse = function (input) {
    var red,
        green,
        blue,
        grey,
        parsedInput,
        colorObj;
    
    if (input === undefined) {
        return undefined;
    } else if (typeof(input) === "string") {
        parsedInput = input.toLowerCase();
        
        switch (parsedInput) {
        case "black":
            red = 0;
            green = 0;
            blue = 0;
            break;
        case "red":
            red = 1;
            green = 0;
            blue = 0;
            break;
        case "green":
            red = 0;
            green = 1;
            blue = 0;
            break;
        case "blue":
            red = 0;
            green = 0;
            blue = 1;
            break;
        case "yellow":
            red = 1;
            green = 1;
            blue = 0;
            break;
        case "magenta":
            red = 1;
            green = 0;
            blue = 1;
            break;
        case "cyan":
            red = 0;
            green = 1;
            blue = 1;
            break;
        case "white":
            red = 1;
            green = 1;
            blue = 1;
            break;
        case "grey":
            grey = parseInt("ee", 16) / 255;
            red = grey;
            green = grey;
            blue = grey;
            break;
        case "skyblue":
            red = parseInt("87", 16) / 255;
            green = parseInt("ce", 16) / 255;
            blue = parseInt("eb", 16) / 255;
            break;
        case "khaki":
            red = parseInt("f0", 16) / 255;
            green = parseInt("e6", 16) / 255;
            blue = parseInt("8c", 16) / 255;
            break;
        case "orange":
            red = parseInt("ff", 16) / 255;
            green = parseInt("a5", 16) / 255;
            blue = parseInt("00", 16) / 255;
            break;
        case "salmon":
            red = parseInt("fa", 16) / 255;
            green = parseInt("80", 16) / 255;
            blue = parseInt("72", 16) / 255;
            break;
        case "olive":
            red = parseInt("9a", 16) / 255;
            green = parseInt("cd", 16) / 255;
            blue = parseInt("32", 16) / 255;
            break;
        case "sienna":
            red = parseInt("a0", 16) / 255;
            green = parseInt("52", 16) / 255;
            blue = parseInt("2d", 16) / 255;
            break;
        case "pink":
            red = parseInt("ff", 16) / 255;
            green = parseInt("b5", 16) / 255;
            blue = parseInt("c5", 16) / 255;
            break;
        case "violet":
            red = parseInt("ee", 16) / 255;
            green = parseInt("82", 16) / 255;
            blue = parseInt("ee", 16) / 255;
            break;
        default:
            parsedInput = parsedInput.replace(/(0(x|X)|#)/, "");
            if (parsedInput.search(new RegExp(/([^0-9a-f])/)) !== -1) {
                throw new Error("'" + input + "' is not a valid color");
            }
            
            if (parsedInput.length === 6) {
                red = parseInt(parsedInput.substring(0,2), 16) / 255;
                green = parseInt(parsedInput.substring(2,4), 16) / 255;
                blue = parseInt(parsedInput.substring(4,6), 16) / 255;
            } else if (parsedInput.length === 3) {
                red = parseInt(parsedInput.charAt(0), 16) / 15;
                green = parseInt(parsedInput.charAt(1), 16) / 15;
                blue = parseInt(parsedInput.charAt(2), 16) / 15;
            } else {
                throw new Error("'" + input + "' is not a valid color");
            }
            break;
        }
        colorObj = new RGBColor(red, green, blue);
        return colorObj;
    }
    throw new Error("'" + input + "' is not a valid color");
};

module.exports = RGBColor;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/validationFunctions.js":158}],106:[function(require,module,exports){
Util = {};

Util.interp = function (x, x0, x1, y0, y1) {
    // return the 'y' coordinate of the point on the line segment
    // connecting the two points (x0,y0) and (x1,y1) whose 'x'
    // coordinate is x
    return y0 + ((y1 - y0) * (x - x0)) / (x1 - x0);
};

Util.safe_interp = function (x, x0, x1, y0, y1) {
    // same as "interp", but if the line is vertical (x0 === x1), return
    // the average of the two y values, rather than NaN
    if (x0 === x1) { return (y0 + y1) / 2; }
    return Util.interp(x, x0, x1, y0, y1);
};

Util.l2dist = function (x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx*dx + dy*dy);
};

module.exports = Util;

},{}],107:[function(require,module,exports){

//  "horizontalaxis" : {
//    "id" : STRING, "type" : DATATYPE(number), "length" : RELLEN(1.0), "base" : POINT(-1,1), "anchor" : DOUBLE(-1), "position" : POINT(0,0),
//    "min" : DATAVALUEORAUTO(auto), "max" : DATAVALUEORAUTO(auto), "minposition" : RELPOS(-1.0), "maxposition" : RELPOS(1.0), "color" : COLOR(black), "linewidth" : INTEGER(1),
//    "tickmin" : INTEGER(-3), "tickmax" : INTEGER(3), "tickcolor" : COLOR(black),
//    "labels" : {
//       "format" : STRING, "start" : DATAVALUE(0), "angle" : DOUBLE(0), "position" : POINT,
//       "anchor" : POINT, "color" : COLOR(black), "spacing" : STRING, "densityfactor" : DOUBLE(1.0),
//       "label" : [
//           { "format" : STRING, "start" : STRING, "angle" : DOUBLE, "position" : POINT, "anchor" : POINT, "spacing" : STRING, "densityfactor" : DOUBLE },
//           { "format" : STRING, "start" : STRING, "angle" : DOUBLE, "position" : POINT, "anchor" : POINT, "spacing" : STRING, "densityfactor" : DOUBLE },
//           ...
//        ]
//    }
//    "title" : { "base" : DOUBLE(0), "anchor" : POINT, "position" : POINT, "angle" : DOUBLE(0), "text" : "TITLETEXT", "font": STRING },
//    "grid" : { "color" : COLOR(0xeeeeee), "visible" : BOOLEAN(false) },
//    "pan" : { "allowed" : BOOLEAN(yes), "min" : DATAVALUE, "max" : DATAVALUE },
//    "zoom" : { "allowed" : BOOLEAN(yes), "min" : DATAMEASURE, "max" : DATAMEASURE, "anchor" : DATAVALUE },
//    "binding" : { "id" : STRING!, "min" : DATAVALUE!, "max" : DATAVALUE! }
//    "visible" : BOOLEAN(true)
//  }


// these are needed so that their .parseJSON methods will be defined when called below:
require('./labeler.js');
require('./axis_title.js');
require('./grid.js');
require('./pan.js');
require('./zoom.js');

var Axis = require('../../core/axis.js'),
    pF = require('../../util/parsingFunctions.js'),
    vF = require('../../util/validationFunctions.js'),
    uF = require('../../util/utilityFunctions.js');

var parseLabels = function (json, axis) {
    var spacings,
        labelers  = axis.labelers(),
        Labeler = require('../../core/labeler.js'),
        DataValue = require('../../core/data_value.js'),
        i;

    spacings = [];
    if (json !== undefined) {
        if (json.spacing !== undefined) {
            spacings = vF.typeOf(json.spacing) === 'array' ? json.spacing : [ json.spacing ];
        }
    }
    if (spacings.length > 0) {
        // If there was a spacing attr on the <labels> tag, create a new labeler for
        // each spacing present in it, using the other values from the <labels> tag
        for (i = 0; i < spacings.length; ++i) {
            labelers.add(Labeler.parseJSON(json, axis, undefined, spacings[i]));
        }
    } else if (json !== undefined && json.label !== undefined && json.label.length > 0) {
        // If there are <label> tags, parse the <labels> tag to get default values
        var defaults = Labeler.parseJSON(json, axis, undefined, null);
        // And loop over each <label> tag, creating labelers for each, splitting multiple
        // spacings on the same <label> tag into multiple labelers:
        json.label.forEach(function(e) {
            var spacing = [];
            if (e.spacing !== undefined) {
                spacing = vF.typeOf(e.spacing) === 'array' ? e.spacing : [ e.spacing ];
            }
            spacing.forEach(function(s) {
                labelers.add( Labeler.parseJSON(e, axis, defaults, s) );
            });
        });
    } else {
        // Otherwise create labelers using the default spacing, with the other values
        // from the <labels> tag
        var defaultValues = (uF.getDefaultValuesFromXSD()).horizontalaxis.labels;
        var defaultSpacings = axis.type() === DataValue.NUMBER ?
                defaultValues.defaultNumberSpacing :
                defaultValues.defaultDatetimeSpacing;
        for (i = 0; i < defaultSpacings.length; ++i) {
            labelers.add(Labeler.parseJSON(json, axis, undefined, defaultSpacings[i]));
        }
    }
};


Axis.parseJSON = function (json, orientation, messageHandler, multigraph) {

    var DataValue = require('../../core/data_value.js'),
        Point = require('../../math/point.js'),
        RGBColor = require('../../math/rgb_color.js'),
        Displacement = require('../../math/displacement.js'),
        AxisTitle = require('../../core/axis_title.js'),
        Grid = require('../../core/grid.js'),
        Pan = require('../../core/pan.js'),
        Zoom = require('../../core/zoom.js'),
        AxisBinding = require('../../core/axis_binding.js'),

        axis              = new Axis(orientation),
        parseAttribute    = pF.parseAttribute,
        parseDisplacement = Displacement.parse,
        parseJSONPoint    = function(p) { return new Point(p[0], p[1]); },
        parseRGBColor     = RGBColor.parse,
        attr, child,
        value;

    if (json) {

        parseAttribute(json.id,     axis.id);
        parseAttribute(json.type,   axis.type,   DataValue.parseType);
        parseAttribute(json.length, axis.length, parseDisplacement);

        //
        // The following provides support for the deprecated "positionbase" axis attribute;
        // MUGL files should use the "base" attribute instead.  When we're ready to remove
        // support for the deprecated attribute, delete this block of code:
        //
        (function () {
            var positionbase = json.positionbase;
            if (positionbase) {
                messageHandler.warning('Use of deprecated axis attribute "positionbase"; use "base" attribute instead');
                if ((positionbase === "left") || (positionbase === "bottom")) {
                    axis.base(new Point(-1, -1));
                } else if (positionbase === "right") {
                    axis.base(new Point(1, -1));
                } else if (positionbase === "top") {
                    axis.base(new Point(-1, 1));
                }
            }
        }());
        //
        // End of code to delete when removing support for deprecated "positionbase"
        // attribute.
        //

        attr = json.position;
        if (attr !== undefined) {
            if (vF.typeOf(attr) === 'array') {
                axis.position(parseJSONPoint(attr));
            } else {
                // If position is not an array, and if it can be interpreted
                // as a number, construct the position point by interpreting that
                // number as an offset from the 0 location along the perpendicular
                // direction.
                if (vF.isNumberNotNaN(attr)) {
                    if (orientation === Axis.HORIZONTAL) {
                        axis.position(new Point(0, attr));
                    } else {
                        axis.position(new Point(attr, 0));
                    }
                } else {
                    throw new Error("axis position '"+attr+"' is of the wrong type; it should be a number or a point");
                }
            }
        }

        // Note: we coerce the min and max values to strings here, because the "min" and "max" attrs
        // of the Axis object require strings.  See the comments about these properties in src/core/axis.js
        // for a discussion of why this is the case.
        if ("min" in json) {
            axis.min(uF.coerceToString(json.min));
        }
        if (axis.min() !== "auto") {
            axis.dataMin(DataValue.parse(axis.type(), axis.min()));
        }
        if ("max" in json) {
            axis.max(uF.coerceToString(json.max));
        }
        if (axis.max() !== "auto") {
            axis.dataMax(DataValue.parse(axis.type(), axis.max()));
        }

        parseAttribute(json.pregap,         axis.pregap);
        parseAttribute(json.postgap,        axis.postgap);
        parseAttribute(json.anchor,         axis.anchor);
        parseAttribute(json.base,           axis.base,           parseJSONPoint);
        parseAttribute(json.minposition,    axis.minposition,    parseDisplacement);
        parseAttribute(json.maxposition,    axis.maxposition,    parseDisplacement);
        parseAttribute(json.minoffset,      axis.minoffset);
        parseAttribute(json.maxoffset,      axis.maxoffset);
        parseAttribute(json.color,          axis.color,          parseRGBColor);
        parseAttribute(json.tickcolor,      axis.tickcolor,      parseRGBColor);
        parseAttribute(json.tickwidth,      axis.tickwidth);
        parseAttribute(json.tickmin,        axis.tickmin);
        parseAttribute(json.tickmax,        axis.tickmax);
        parseAttribute(json.highlightstyle, axis.highlightstyle);
        parseAttribute(json.linewidth,      axis.linewidth);
        
        if ("title" in json) {
            if (typeof(json.title) === 'boolean') {
                if (json.title) {
                    axis.title(new AxisTitle(axis));
                    } else {
                        axis.title(AxisTitle.parseJSON({}, axis));
                    }
            } else {
                axis.title(AxisTitle.parseJSON(json.title, axis));
            }
        } else {
            axis.title(new AxisTitle(axis));
        }

        if (json.grid) {
            axis.grid(Grid.parseJSON(json.grid));
        }

        if (json.visible !== undefined) {
            axis.visible(json.visible);
        }

        if ("pan" in json) {
            axis.pan(Pan.parseJSON(json.pan, axis.type()));
        }

        if ("zoom" in json) {
            axis.zoom(Zoom.parseJSON(json.zoom, axis.type()));
        }

        if (json.labels) {
            parseLabels(json.labels, axis);
        }

        if (json.binding) {
            var bindingMinDataValue = DataValue.parse(axis.type(), json.binding.min),
                bindingMaxDataValue = DataValue.parse(axis.type(), json.binding.max);
            if (typeof(json.binding.id) !== "string") {
                throw new Error("invalid axis binding id: '" + json.binding.id + "'");
            }
            if (! DataValue.isInstance(bindingMinDataValue)) {
                throw new Error("invalid axis binding min: '" + json.binding.min + "'");
            }
            if (! DataValue.isInstance(bindingMaxDataValue)) {
                throw new Error("invalid axis binding max: '" + json.binding.max + "'");
            }
            AxisBinding.findByIdOrCreateNew(json.binding.id).addAxis(axis, bindingMinDataValue, bindingMaxDataValue, multigraph);
        }

    }
    return axis;
};

module.exports = Axis;

},{"../../core/axis.js":18,"../../core/axis_binding.js":19,"../../core/axis_title.js":20,"../../core/data_value.js":30,"../../core/grid.js":42,"../../core/labeler.js":45,"../../core/pan.js":52,"../../core/zoom.js":71,"../../math/displacement.js":101,"../../math/point.js":104,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156,"../../util/utilityFunctions.js":157,"../../util/validationFunctions.js":158,"./axis_title.js":108,"./grid.js":116,"./labeler.js":120,"./pan.js":123,"./zoom.js":130}],108:[function(require,module,exports){
var AxisTitle = require('../../core/axis_title.js');

// "title" { "base": 23.2, "anchor": [12, 4], "position": [3, 7], "angle": 45, "text" : "temperature", "font" : "Roboto" }
// empty title:
//   "title" {}
//   "title" {"text" : "" }
AxisTitle.parseJSON = function (json, axis) {
    var title = new AxisTitle(axis),
        Text = require('../../core/text.js'),
        Point = require('../../math/point.js'),
        parseAttribute = require('../../util/parsingFunctions.js').parseAttribute,
        nonEmptyTitle = false,
        parseJSONPoint = function(p) { return new Point(p[0], p[1]); },
        text;

    if (json) {
        text = json.text;
        if (text !== "" && text !== undefined) {
            title.content(new Text(text));
            nonEmptyTitle = true;
        }
        parseAttribute(json.anchor,   title.anchor,   parseJSONPoint);
        parseAttribute(json.base,     title.base);
        parseAttribute(json.position, title.position, parseJSONPoint);
        parseAttribute(json.angle,    title.angle);
        parseAttribute(json.font,    title.font);
    }

    if (nonEmptyTitle === true) { 
        return title;
    }
    return undefined;
};

module.exports = AxisTitle;

},{"../../core/axis_title.js":20,"../../core/text.js":64,"../../math/point.js":104,"../../util/parsingFunctions.js":156}],109:[function(require,module,exports){
var Background = require('../../core/background.js');

// "background" : {
//   "color": "#ffff00",
//   "img" : { "src": "foo.png", "anchor": [-1, 5], "base": [3, 12], "position": [-2, 3], "frame": "padding" }
// }
Background.parseJSON = function (json, multigraph) {
    var background       = new Background(),
        parseAttribute   = require('../../util/parsingFunctions.js').parseAttribute,
        RGBColor         = require('../../math/rgb_color.js'),
        Img              = require('../../core/img.js'),
        child;

    if (json) {
        parseAttribute(json.color, background.color, RGBColor.parse);
        if (json.img) {
            background.img(Img.parseJSON(json.img, multigraph));
        }
    }
    return background;
};

module.exports = Background;

},{"../../core/background.js":21,"../../core/img.js":44,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],110:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Data = require('../../core/data.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Data.parseJSON)==="function") { return Data; };

    // "data" : {
    //   "adapter"      : STRING,
    //   "missingvalue" : "DATAVALUE",
    //   "missingop"    : "COMPARATOR">,
    //   "variables" : [
    //         { "id" : STRING!, "column" : INTEGER, "type" : DATATYPE(number), "missingvalue" : STRING, "missingop" : COMPARATOR }
    //         { "id" : STRING!, "column" : INTEGER, "type" : DATATYPE(number), "missingvalue" : STRING, "missingop" : COMPARATOR }
    //         ...
    //   ],
    //   "repeat" : { "period" : STRING },
    //   "repeat" : STRING,
    //   "values" : [
    //      [ 3.2, 1.4, ...],
    //      [ 5.1, 7.8, ...],
    //      ...
    //   ],
    //   "csv" : STRING,
    //   "csv" : { "location" : STRING },
    //   "service" : STRING,
    //   "service" : {
    //       "location" : STRING!
    //       "format"   : STRING
    //   }
    // }
    Data.parseJSON = function (json, multigraph, messageHandler) {
        var ArrayData = require('../../core/array_data.js'),
            DataVariable = require('../../core/data_variable.js'),
            DataMeasure = require('../../core/data_measure.js'),
            PeriodicArrayData = require('../../core/periodic_array_data.js'),
            CSVData = require('../../core/csv_data.js')($),
            WebServiceData = require('../../core/web_service_data.js')($),
            Multigraph = require('../../core/multigraph.js')($),
            pF = require('../../util/parsingFunctions.js'),
            vF = require('../../util/validationFunctions.js'),
            uF = require('../../util/utilityFunctions.js'),
            defaultMissingvalueString,
            defaultMissingopString,
            dataVariables = [],
            data,
            adap, adapter = ArrayData;

        require('./data_variable.js'); // so that DataVariable.parseJSON method is defined when needed below

        if (json) {

            adap = json.adapter;
            if (adap !== undefined && adap !== "") {
                adapter = Multigraph.getDataAdapter(adap);
                if (adapter === undefined) {
                    throw new Error("Missing data adapater: " + adap);
                }
            }

            // be sure to leave defaultMissingvalueString undefined if
            // json.missingvalue is undefined, otherwise the String cast
            // here will result in the string "undefined", which wreaks havoc!
            if (json.missingvalue) {
                defaultMissingvalueString = uF.coerceToString(json.missingvalue);
            }
            defaultMissingopString    = json.missingop;

            if (json.variables) {
                json.variables.forEach(function(variable) {
                    dataVariables.push(DataVariable.parseJSON(variable));
                });
            }

            // check to see if we have a <repeat> section, and if so, grab the period from it
            var haveRepeat = false,
                period;
            if ("repeat" in json) {
                var periodProp = (vF.typeOf(json.repeat) === 'object') ? json.repeat.period : json.repeat;
                if (periodProp === undefined || periodProp === "") {
                    messageHandler.warning("repeat requires a period; data treated as non-repeating");
                } else {
                    period = DataMeasure.parse(dataVariables[0].type(), periodProp);
                    haveRepeat = true;
                }
            }

            // if we have a <values> section, parse it and return an ArrayData instance:
            if (json.values) {
                // Note this does not use the data adapter -- not supported for inline json data
                var stringValues = json.values;
                if (haveRepeat) {
                    data = new PeriodicArrayData(dataVariables, stringValues, period);
                } else {
                    data = new ArrayData(dataVariables, stringValues);
                }
            }

            // if we have a <csv> section, parse it and return a CSVData instance:
            if (json.csv) {
                var filename = (vF.typeOf(json.csv) === 'object') ? json.csv.location : json.csv;
                data = new CSVData(dataVariables,
                                   multigraph ? multigraph.rebaseUrl(filename) : filename,
                                   messageHandler,
                                   multigraph ? multigraph.getAjaxThrottle(filename) : undefined);
            }

            // if we have a <service> section, parse it and return a WebServiceData instance:
            if (json.service) {
                var location = (vF.typeOf(json.service) === 'object') ? json.service.location : json.service;
                data = new WebServiceData(dataVariables,
                                          multigraph ? multigraph.rebaseUrl(location) : location,
                                          messageHandler,
                                          multigraph ? multigraph.getAjaxThrottle(location) : undefined);
                if (vF.typeOf(json.service) === 'object' && ("format" in json.service)) {
                    data.format(json.service.format);
                }
            }

            // if the json contains an "id" property, pass it on to our data object:
            if ("id" in json) {
                data.id(json.id);
            }
        }

        if (data) {
            if (defaultMissingvalueString !== undefined) {
                data.defaultMissingvalue(defaultMissingvalueString);
            }
            if (defaultMissingopString !== undefined) {
                data.defaultMissingop(defaultMissingopString);
            }
            data.adapter(adapter);
        }
        
        return data;
    };

    return Data;
};



},{"../../core/array_data.js":17,"../../core/csv_data.js":25,"../../core/data.js":26,"../../core/data_measure.js":28,"../../core/data_variable.js":31,"../../core/multigraph.js":48,"../../core/periodic_array_data.js":53,"../../core/web_service_data.js":67,"../../util/parsingFunctions.js":156,"../../util/utilityFunctions.js":157,"../../util/validationFunctions.js":158,"./data_variable.js":111}],111:[function(require,module,exports){
var DataVariable = require('../../core/data_variable.js');

//  "variable" : {
//      "id"           : STRING!,
//      "column"       : INTEGER,
//      "type"         : DATATYPE(number),
//      "missingvalue" : STRING,
//      "missingop"    : COMPARATOR,
//  }
DataVariable.parseJSON = function (json, data) {
    var variable,
        pF             = require('../../util/parsingFunctions.js'),
        parseAttribute = pF.parseAttribute,
        DataValue      = require('../../core/data_value.js'),
        attr;

    if (json && json.id) {
        variable = new DataVariable(json.id);
        parseAttribute(json.column,       variable.column);
        parseAttribute(json.type,         variable.type,         DataValue.parseType);
        parseAttribute(json.missingvalue, variable.missingvalue, function(v) { return DataValue.parse(variable.type(), v); });
        parseAttribute(json.missingop,    variable.missingop,    DataValue.parseComparator);
    }
    return variable;
};

module.exports = DataVariable;

},{"../../core/data_value.js":30,"../../core/data_variable.js":31,"../../util/parsingFunctions.js":156}],112:[function(require,module,exports){
var Datatips = require('../../core/datatips.js');

// "datatips" : {
//   "format"           : "STRING!",
//   "bgcolor"          : "COLOR",
//   "bgalpha"          : "DOUBLE",
//   "border"           : "INTEGER",
//   "bordercolor"      : "COLOR",
//   "pad"              : "INTEGER",
//   "variable-formats" : [ "STRING!", ... ]
// }
Datatips.parseJSON = function (json) {
    var datatips         = new Datatips(),
        RGBColor         = require('../../math/rgb_color.js'),
        DatatipsVariable = require('../../core/datatips_variable.js'),
        pF               = require('../../util/parsingFunctions.js'),
        uF               = require('../../util/utilityFunctions.js'),
        parseRGBColor    = RGBColor.parse,
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger,
        child;
    if (json) {
        if (json["variable-formats"]) {
            json["variable-formats"].forEach(function(fmt) {
                var dtv = new DatatipsVariable();
                dtv.formatString(fmt);
                datatips.variables().add(dtv);
            });
        }
        
        parseAttribute(json.format,      datatips.formatString);
        parseAttribute(json.bgcolor,     datatips.bgcolor,     parseRGBColor);
        parseAttribute(json.bgalpha,     datatips.bgalpha);
        parseAttribute(json.border,      datatips.border);
        parseAttribute(json.bordercolor, datatips.bordercolor, parseRGBColor);
        parseAttribute(json.pad,         datatips.pad);
    }
    return datatips;
};

module.exports = Datatips;

},{"../../core/datatips.js":32,"../../core/datatips_variable.js":33,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156,"../../util/utilityFunctions.js":157}],113:[function(require,module,exports){
var Filter = require('../../core/filter.js');

// "filter" : {
//   "type": "STRING"
//   "options" : [
//     { "name" : "STRING!", "value" : "STRING!" },
//     { "name" : "STRING!", "value" : "STRING!" }
//     ...
//   }
// }
Filter.parseJSON = function (json) {
    var filter = new Filter(),
        FilterOption = require('../../core/filter_option.js'),
        pF = require('../../util/parsingFunctions.js'),
        uF = require('../../util/utilityFunctions.js'),
        o;

    require('./filter_option.js'); // so that FilterOption.parseJSON will exist below

    if (json) {
        if (json.options) {
            for (opt in json.options) {
                if (json.options.hasOwnProperty(opt)) {
                    o = new FilterOption();
                    o.name(opt);
                    o.value(uF.coerceToString(json.options[opt]));
                    filter.options().add( o );
                }
            }
        }

        pF.parseAttribute(json.type, filter.type);
        return filter;
    };

    return Filter;
};

module.exports = Filter;

},{"../../core/filter.js":39,"../../core/filter_option.js":40,"../../util/parsingFunctions.js":156,"../../util/utilityFunctions.js":157,"./filter_option.js":114}],114:[function(require,module,exports){
var FilterOption = require('../../core/filter_option.js');

// "option" : { "name" : "STRING!",  "value" : "STRING!" }
FilterOption.parseJSON = function (json) {
    var pF     = require('../../util/parsingFunctions.js'),
        uF     = require('../../util/utilityFunctions.js'),
        option = new FilterOption();
    if (json) {
        option.name(json.name);
        if ("value" in json && json.value !== "") {
            // coerce to string since "value" attr of filter_option is of type string
            option.value(uF.coerceToString(json.value));
        }
    }
    return option;
};

module.exports = FilterOption;

},{"../../core/filter_option.js":40,"../../util/parsingFunctions.js":156,"../../util/utilityFunctions.js":157}],115:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Graph = require('../../core/graph.js'),
        pF = require('../../util/parsingFunctions.js');

    // if parseJSON method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Graph.parseJSON)==="function") { return Graph; };

    Graph.parseJSON = function (json, multigraph, messageHandler) {
        var graph = new Graph(),
            Axis  = require('../../core/axis.js'),
            Window = require('../../core/window.js'),
            Legend = require('../../core/legend.js'),
            Background = require('../../core/background.js'),
            Plotarea = require('../../core/plotarea.js'),
            ConsecutiveDistanceFilter = require('../../core/consecutive_distance_filter.js'),
            Title = require('../../core/title.js'),
            Data = require('../../core/data.js'),
            Plot = require('../../core/plot.js'),
            uF = require('../../util/utilityFunctions.js'),
            vF = require('../../util/validationFunctions.js'),
            defaults = uF.getDefaultValuesFromXSD(),
            child;

        // so that these objects' .parseJSON methods will exist when needed below:
        require('./window.js');
        require('./legend.js');
        require('./background.js');
        require('./plotarea.js');
        require('./title.js');
        require('./axis.js');
        require('./data.js')($);
        require('./plot.js');

        graph.multigraph(multigraph);
        if (json) {

            if (json.window) {
                graph.window( Window.parseJSON(json.window) );
            }

            if ("legend" in json) {
                graph.legend( Legend.parseJSON(json.legend) );
            } else {
                graph.legend( Legend.parseJSON() );
            }

            if (json.background) {
                graph.background( Background.parseJSON(json.background, graph.multigraph()) );
            }

            if (json.plotarea) {
                graph.plotarea( Plotarea.parseJSON(json.plotarea) );
            }

            if (json.title) {
                graph.title( Title.parseJSON(json.title, graph) );
            }

            if ("filter" in json) {
                    if (vF.typeOf(json.filter) === 'object') {
                        if ((typeof(json.filter.type) !== 'undefined') && (json.filter.type !== 'consecutivedistance')) {
                            throw new Error('unknown filter type: ' + json.filter.type);
                        }
                        graph.filter(new ConsecutiveDistanceFilter(json.filter));
                    } else {
                        if (vF.typeOf(json.filter) !== 'boolean') {
                            throw new Error('invalid filter property: ' + json.filter);
                        } else if (json.filter) {
                            graph.filter(new ConsecutiveDistanceFilter({}));
                        }
                    }
            }

            var haxes = json.horizontalaxis ? json.horizontalaxis : json.horizontalaxes;
            if (json.horizontalaxis && json.horizontalaxes) {
                throw new Error("graph may not have both 'horizontalaxis' and 'horizontalaxes'");
            }
            if (haxes) {
                if (vF.typeOf(haxes) === 'array') {
                    haxes.forEach(function(axis) {
                        graph.axes().add( Axis.parseJSON(axis, Axis.HORIZONTAL, messageHandler, graph.multigraph()) );
                    });
                } else {
                    graph.axes().add( Axis.parseJSON(haxes, Axis.HORIZONTAL, messageHandler, graph.multigraph()) );
                }
            }

            var vaxes = json.verticalaxis ? json.verticalaxis : json.verticalaxes;
            if (json.verticalaxis && json.verticalaxes) {
                throw new Error("graph may not have both 'verticalaxis' and 'verticalaxes'");
            }
            if (vaxes) {
                if (vF.typeOf(vaxes) === 'array') {
                    vaxes.forEach(function(axis) {
                        graph.axes().add( Axis.parseJSON(axis, Axis.VERTICAL, messageHandler, graph.multigraph()) );
                    });
                } else {
                    graph.axes().add( Axis.parseJSON(vaxes, Axis.VERTICAL, messageHandler, graph.multigraph()) );
                }
            }


            function addAjaxThrottle(t) {
                var pattern    = t.pattern    ? t.pattern    : defaults.throttle.pattern,
                    requests   = t.requests   ? t.requests   : defaults.throttle.requests,
                    period     = t.period     ? t.period     : defaults.throttle.period,
                    concurrent = t.concurrent ? t.concurrent : defaults.throttle.concurrent;
                multigraph.addAjaxThrottle(pattern, requests, period, concurrent);
            }
            var throttles = json.throttle ? json.throttle : json.throttles;
            if (json.throttle && json.throttles) {
                throw new Error("graph may not have both 'throttle' and 'throttles'");
            }
            if (throttles) {
                if (vF.typeOf(throttles) === 'array') {
                    throttles.forEach(addAjaxThrottle);
                } else {
                    addAjaxThrottle(throttles);
                }
            }

            if (json.data) {
                if (vF.typeOf(json.data) === 'array') {
                    json.data.forEach(function(data) {
                        graph.data().add( Data.parseJSON(data, graph.multigraph(), messageHandler) );
                    });
                } else {
                    graph.data().add( Data.parseJSON(json.data, graph.multigraph(), messageHandler) );
                }
            }

            var plots = json.plot ? json.plot : json.plots;
            if (json.plot && json.plots) {
                throw new Error("graph may not have both 'plot' and 'plots'");
            }
            if (plots) {
                if (vF.typeOf(plots) === 'array') {
                    plots.forEach(function(plot) {
                        graph.plots().add( Plot.parseJSON(plot, graph, messageHandler) );
                    });
                } else {
                    graph.plots().add( Plot.parseJSON(plots, graph, messageHandler) );
                }
            }

            graph.postParse();
        }
        return graph;
    };

    return Graph;
};

},{"../../core/axis.js":18,"../../core/background.js":21,"../../core/consecutive_distance_filter.js":23,"../../core/data.js":26,"../../core/graph.js":41,"../../core/legend.js":46,"../../core/plot.js":54,"../../core/plotarea.js":56,"../../core/title.js":65,"../../core/window.js":70,"../../util/parsingFunctions.js":156,"../../util/utilityFunctions.js":157,"../../util/validationFunctions.js":158,"./axis.js":107,"./background.js":109,"./data.js":110,"./legend.js":121,"./plot.js":124,"./plotarea.js":126,"./title.js":128,"./window.js":129}],116:[function(require,module,exports){
var Grid = require('../../core/grid.js');

// "grid": { "color": "#ff00ff", visible: true }
Grid.parseJSON = function (json) {
    var grid             = new Grid(),
        RGBColor         = require('../../math/rgb_color.js'),
        parseAttribute   = require('../../util/parsingFunctions.js').parseAttribute,
        attr;
    if (json) {
        parseAttribute(json.color, grid.color, RGBColor.parse);
        //NOTE: visible attribute should default to true when parsing, so that
        //      the presence of a "grid" property at all will turn on a grid.  In
        //      the Grid object itself, though, the default for the visible
        //      attribute is false, so that when we create a default grid object
        //      in code (as opposed to parsing), it defaults to not visible.
        attr = json.visible;
        if (attr !== undefined) {
            grid.visible(attr);
        } else {
            grid.visible(true);
        }
    }
    return grid;
};

module.exports = Grid;

},{"../../core/grid.js":42,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],117:[function(require,module,exports){
var Icon = require('../../core/icon.js');

// "icon" : { "border": 2, "width": 30, "height": 20 }
Icon.parseJSON = function (json) {
    var icon = new Icon(),
        parseAttribute = require('../../util/parsingFunctions.js').parseAttribute;
    if (json) {
        parseAttribute(json.height, icon.height);
        parseAttribute(json.width,  icon.width);
        parseAttribute(json.border, icon.border);
    }
    return icon;
};

module.exports = Icon;

},{"../../core/icon.js":43,"../../util/parsingFunctions.js":156}],118:[function(require,module,exports){
var Img = require('../../core/img.js');

// "img" : { "src": "foo.png", "anchor": [-1, 5], "base": [3, 12], "position": [-2, 3], "frame": "padding" }
Img.parseJSON = function (json, multigraph) {
    var img,
        parseAttribute = require('../../util/parsingFunctions.js').parseAttribute,
        Point          = require('../../math/point.js'),
        parseJSONPoint = function(p) { return new Point(p[0], p[1]); };
    if (json && json.src !== undefined) {
        var src = json.src;
        if (!src) {
            throw new Error('img requires a "src" property');
        }
        if (multigraph) {
            src = multigraph.rebaseUrl(src);
        }
        img = new Img(src);
        parseAttribute(json.anchor,   img.anchor,   parseJSONPoint);
        parseAttribute(json.base,     img.base,     parseJSONPoint);
        parseAttribute(json.position, img.position, parseJSONPoint);
        parseAttribute(json.frame,    img.frame,    function (value) { return value.toLowerCase(); });
    }
    return img;
};

module.exports = Img;

},{"../../core/img.js":44,"../../math/point.js":104,"../../util/parsingFunctions.js":156}],119:[function(require,module,exports){
// usage:
// 
//   A valid jQuery object must be passed to the function returned by requiring this file.
//
//      require('.../src/parser/json/json_parser.js')($);
//      var Multigraph = require('.../src/core/multigraph.js')($);
//      var m = Multigraph.parseJSON( {...} };
// 
//   where {...} is the JSON object to be parsed.
//
var included = false;
module.exports = function($) {
    if (included) { return; }
    included = true;

    require('./data.js')($);
    require('./graph.js')($);
    require('./multigraph.js')($);

    require('./axis.js');
    require('./axis_title.js');
    require('./background.js');
    require('./datatips.js');
    require('./data_variable.js');
    require('./filter.js');
    require('./filter_option.js');
    require('./grid.js');
    require('./icon.js');
    require('./img.js');
    require('./json_parser.js');
    require('./labeler.js');
    require('./legend.js');
    require('./pan.js');
    require('./plotarea.js');
    require('./plot.js');
    require('./plot_legend.js');
    require('./renderer.js');
    require('./title.js');
    require('./window.js');
    require('./zoom.js');
};

},{"./axis.js":107,"./axis_title.js":108,"./background.js":109,"./data.js":110,"./data_variable.js":111,"./datatips.js":112,"./filter.js":113,"./filter_option.js":114,"./graph.js":115,"./grid.js":116,"./icon.js":117,"./img.js":118,"./json_parser.js":119,"./labeler.js":120,"./legend.js":121,"./multigraph.js":122,"./pan.js":123,"./plot.js":124,"./plot_legend.js":125,"./plotarea.js":126,"./renderer.js":127,"./title.js":128,"./window.js":129,"./zoom.js":130}],120:[function(require,module,exports){
var Labeler = require('../../core/labeler.js');

// "labels" : {
//   "format: STRING,
//   "start" : DATAVALUE(0),
//   "angle" : DOUBLE(0),
//   "position" : POINT,
//   "anchor" : POINT,
//   "color" : COLOR(black),
//   "spacing" : STRING,
//   "font": STRING,
//   "densityfactor" : DOUBLE(1.0),
//   "label" : [
//     { "format": "%Y", "start": STRING, "angle": 45, "position": [2,3],
//       "anchor": [1,1], "spacing": "1Y", "densityfactor": 0.2 },
//     { "format": "%M", "start": STRING, "angle": 45, "position": [2,3],
//       "anchor": [1,1], "spacing": ["1M", "1D"], "densityfactor": 9.0 }
//   ]
// }
//
// Feature added 2015-12-16:
//   The "format" attribute (for an axis of type number only) can be an
//   array of strings to be displayed for the values 0..L-1 where L is the
//   number of strings in the array.  For example:
//        "format": ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov"]
//   would cause "Jan" to be rendered as the label for value 0, "Feb" for value 1,
//   and so on.  There is currently no way to customize the association between numerical
//   values and strings -- it's hardcoded to be the integers starting with 0.

Labeler.parseJSON = function (json, axis, defaults, spacing) {
    // This parser takes an optional final argument, spacing, which is a string representing
    // the spacing to be parsed for the labeler.  If that argument is not present, the spacing
    // value is taken from the json object.  If a spacing argument is present, it is parsed
    // and used to set the spacing attribute of the Labeler object, and in this case, any
    // spacing value present in the json is ignored.
    //
    // If the spacing argument has the value null, the resulting labeler will have no spacing
    // attribute set at all.
    var labeler,
        Point = require('../../math/point.js'),
        RGBColor = require('../../math/rgb_color.js'),
        DataMeasure = require('../../core/data_measure.js'),
        DataValue = require('../../core/data_value.js'),
        DataFormatter = require('../../core/data_formatter.js'),
        CategoryFormatter = require('../../core/category_formatter.js'),
        pF = require('../../util/parsingFunctions.js'),
        vF = require('../../util/validationFunctions.js'),
        parseJSONPoint = function(p) { return new Point(p[0], p[1]); };

    // `parseAttribute` returns true or false depending on whether or not it set the attribute.
    // If it did not and if the `defaults` object exists then the attribute is set to the
    // appropriate default value.
    var parseLabelerAttribute = function (value, attribute, preprocessor, defaultName) {
        if (!pF.parseAttribute(value, attribute, preprocessor) && defaults !== undefined) {
            attribute(defaults[defaultName]());
        }
    };
    var parseDataFormatter = function (type) {
        return function (value) {
            return DataFormatter.create(type, value);
        };
    };
    var parseDataValue = function (type) {
        return function (value) {
            return DataValue.parse(type, value);
        };
    };

    if (json) {
        labeler = new Labeler(axis);
        if (spacing !== null) {
            if (spacing === undefined) {
                spacing = json.spacing;
            }
            //NOTE: spacing might still === undefined at this point
            parseLabelerAttribute(spacing, labeler.spacing,
                                  function(v) { return DataMeasure.parse(axis.type(), v); }, //pF.parseDataMeasure(),
                                  "spacing");
        }

        if (vF.typeOf(json.format) === "array") {
            parseLabelerAttribute(json.format,    labeler.formatter,     function(format) {
                return new CategoryFormatter(json.format);
            }, undefined);
        } else {
            parseLabelerAttribute(json.format,        labeler.formatter,     parseDataFormatter(axis.type()),          "formatter");
        }

        parseLabelerAttribute(json.start,         labeler.start,         parseDataValue(axis.type()),                  "start");
        parseLabelerAttribute(json.angle,         labeler.angle,         undefined,                                    "angle");
        parseLabelerAttribute(json.position,      labeler.position,      parseJSONPoint,                               "position");
        parseLabelerAttribute(json.anchor,        labeler.anchor,        parseJSONPoint,                               "anchor");
        parseLabelerAttribute(json.densityfactor, labeler.densityfactor, undefined,                                    "densityfactor");
        parseLabelerAttribute(json.color,         labeler.color,         RGBColor.parse,                               "color");
        parseLabelerAttribute(json.font,          labeler.font,          undefined,                                    "font");
        parseLabelerAttribute(json.visible,       labeler.visible,       pF.parseBoolean,                              "visible");

    }
    return labeler;
};

module.exports = Labeler;

},{"../../core/category_formatter.js":22,"../../core/data_formatter.js":27,"../../core/data_measure.js":28,"../../core/data_value.js":30,"../../core/labeler.js":45,"../../math/point.js":104,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156,"../../util/validationFunctions.js":158}],121:[function(require,module,exports){
var Legend = require('../../core/legend.js');

// "legend" : {
//     "visible"      : "BOOLEAN",
//     "base"         : "POINT(1,1)",
//     "anchor"       : "POINT(1,1)",
//     "position"     : "POINT(0,0)",
//     "frame"        : "FRAME(padding)",
//     "color"        : "COLOR(white)",
//     "opacity"      : "DOUBLE(1.0)",
//     "border"       : "INTEGER(1)",
//     "bordercolor"  : "COLOR(black)",
//     "rows"         : "INTEGER",
//     "columns"      : "INTEGER",
//     "cornerradius" : "INTEGER(0)",
//     "padding"      : "INTEGER(0)",
//     "icon" : {
//       "width"  : "INTEGER(40)",
//       "height" : "INTEGER(30)",
//       "border" : "INTEGER(1)"
//     }
// }
Legend.parseJSON = function (json) {
    var legend           = new Legend(),
        pF               = require('../../util/parsingFunctions.js'),
        Point            = require('../../math/point.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        Point            = require('../../math/point.js'),
        Icon             = require('../../core/icon.js'),
        parseAttribute   = pF.parseAttribute,
        parseJSONPoint   = function(p) { return new Point(p[0], p[1]); };

    require('./icon.js'); // for Icon.parseJSON below

    if (typeof(json) === "boolean") {
        parseAttribute(json, legend.visible);
    } else if (json) {
        parseAttribute(json.visible,      legend.visible,      pF.parseBoolean);
        parseAttribute(json.base,         legend.base,         parseJSONPoint);
        parseAttribute(json.anchor,       legend.anchor,       parseJSONPoint);
        parseAttribute(json.position,     legend.position,     parseJSONPoint);
        parseAttribute(json.frame,        legend.frame);
        parseAttribute(json.color,        legend.color,        RGBColor.parse);
        parseAttribute(json.bordercolor,  legend.bordercolor,  RGBColor.parse);
        parseAttribute(json.opacity,      legend.opacity);
        parseAttribute(json.border,       legend.border);
        parseAttribute(json.rows,         legend.rows);
        parseAttribute(json.columns,      legend.columns);
        parseAttribute(json.cornerradius, legend.cornerradius);
        parseAttribute(json.padding,      legend.padding);

        if (json.icon) {
            legend.icon(Icon.parseJSON(json.icon));
        }
    }
    return legend;
};

module.exports = Legend;

},{"../../core/icon.js":43,"../../core/legend.js":46,"../../math/point.js":104,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156,"./icon.js":117}],122:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Multigraph = require('../../core/multigraph.js')($);

    // if parseJSON method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Multigraph.parseJSON)==="function") { return Multigraph; };

    Multigraph.parseJSON = function (json, mugl, messageHandler) {
        var multigraph = new Multigraph(),
            graphs     = multigraph.graphs(),
            Graph      = require('../../core/graph.js'),
            vF         = require('../../util/validationFunctions.js');

        require('./graph.js')($); // for Graph.parseJSON below

        multigraph.mugl(mugl); // set the mugl url
        if (json) {
            if (vF.typeOf(json) === 'array') {
                json.forEach(function(graph) {
                    graphs.add( Graph.parseJSON(graph, multigraph, messageHandler) );
                });
            } else {
                graphs.add( Graph.parseJSON(json, multigraph, messageHandler) );
            }
        }
        return multigraph;
    };

    return Multigraph;
};

},{"../../core/graph.js":41,"../../core/multigraph.js":48,"../../util/validationFunctions.js":158,"./graph.js":115}],123:[function(require,module,exports){
var Pan = require('../../core/pan.js');

Pan.parseJSON = function (json, type) {
    var pan            = new Pan(),
        pF             = require('../../util/parsingFunctions.js'),
        vF             = require('../../util/validationFunctions.js'),
        parseAttribute = pF.parseAttribute,
        parseBoolean   = pF.parseBoolean,
        DataValue      = require('../../core/data_value.js'),
        parseDataValue = function(v) { return DataValue.parse(type, v); };
    if (vF.typeOf(json) === 'boolean') {
        parseAttribute(json,         pan.allowed, parseBoolean);
    } else if (json) {
        parseAttribute(json.allowed, pan.allowed, parseBoolean);
        parseAttribute(json.min,     pan.min,     parseDataValue);
        parseAttribute(json.max,     pan.max,     parseDataValue);
    }
    return pan;
};

module.exports = Pan;

},{"../../core/data_value.js":30,"../../core/pan.js":52,"../../util/parsingFunctions.js":156,"../../util/validationFunctions.js":158}],124:[function(require,module,exports){
var Plot = require('../../core/plot.js');

// "plot" : {
//   "legend" : { "visible": "BOOLEAN", "label": "STRING" }, 
//   "legend" : BOOLEAN,
//                 //NO:  "horizontalaxis" : {
//                 //NO:    "ref" : STRING!,
//                 //NO:    "variables" [ STRING, ... ]
//                 //NO:  },
//                 //NO:  "verticalaxis" : {
//                 //NO:    "ref" : STRING!,
//                 //NO:    "variables" [ STRING, ... ],
//                 //NO:    "constant" : DATAVALUE
//                 //NO:  },
// 
//   "horizontalaxis" : AXIS-ID(string)
//   "horizontalaxis" : [ VARIABLE-ID(string), ... ]
//   "horizontalaxis" : { AXIS-ID(string): [ VARIABLE-ID(string), ... ] }
// 
//   "verticalaxis" : [ VARIABLE-ID(string), ... ]
//   "verticalaxis" : { AXIS-ID(string): DATA-VALUE(number or string) }     <-- ConstantPlot
//   "verticalaxis" : { AXIS-ID(string): VARIABLE-ID(string) }
//   "verticalaxis" : { AXIS-ID(string): [ VARIABLE-ID(string), ... ] }
//   "verticalaxis" : DATA-VALUE(number or string)                          <-- ConstantPlot
//   "verticalaxis" : AXIS-ID(string)
//   "visible" : BOOLEAN(true)
//   "renderer" : {
//     "type" : RENDERERTYPE(line),
//     "options" : {
//         "option1": value1,
//         "option2": value2,
//         "option3": [ { "value": value3, "min": DATAVALUE, "max" : DATAVALUE }, .. ]
//         ...
//     },
//   },
//   "datatips" : {
//     "format"           : STRING!,
//     "bgcolor"          : COLOR,
//     "bgalpha"          : DOUBLE,
//     "border"           : INTEGER,
//     "bordercolor"      : COLOR,
//     "pad"              : INTEGER,
//     "variable-formats" : [ STRING!, ... ]
//   }
// }
//
// Alternately, instead of the "renderer" section, the "plot" section may instead contain
// the following (at the top level of the "plot" object):
// 
//   "style" : RENDERERTYPE(line),
//   "options" : {
//       "option1": value1,
//       "option2": value2,
//       "option3": [ { "value": value3, "min": DATAVALUE, "max" : DATAVALUE }, .. ]
//       ...
//   },
// 
Plot.parseJSON = function (json, graph, messageHandler) {
    var DataPlot                  = require('../../core/data_plot.js'),
        PlotLegend                = require('../../core/plot_legend.js'),
        ConstantPlot              = require('../../core/constant_plot.js'),
        DataValue                 = require('../../core/data_value.js'),
        DateTimeValue             = require('../../core/datetime_value.js'),
        Renderer                  = require('../../core/renderer.js'),
        Filter                    = require('../../core/filter.js'),
        ConsecutiveDistanceFilter = require('../../core/consecutive_distance_filter.js'),
        Datatips                  = require('../../core/datatips.js'),
        pF                        = require('../../util/parsingFunctions.js'),
        vF                        = require('../../util/validationFunctions.js'),
        plot,
        haxis,
        vaxis,
        variable,
        attr;

    // so that PlotLegend,Renderer,Filter,Datatips will have .parseJSON when called below:
    require('./plot_legend.js');
    require('./renderer.js');
    require('./filter.js');
    require('./datatips.js');

    // return the (first) key of an object; intended for convenient fetching of the
    // key name of an object (verticalaxis or horizontalaxis) that contains only one key
    function key(obj) {
        return (Object.keys(obj))[0];
    }

    // return the number of keys in an object
    function keyCount(obj) {
        return Object.keys(obj).length;
    }

    // Return true iff the value v looks like a data_value -- i.e. it's either a number,
    // or a string that looks like it could be parsed into either a number or a datetime value.
    function looks_like_data_value(v) {
        if (vF.typeOf(v) === 'number') {
            return true;
        } else if (vF.typeOf(v) === 'string') {
            // !isNaN is the recommended way to test whether a string represents a valid number
            // http://stackoverflow.com/questions/175739/is-there-a-built-in-way-in-javascript-to-check-if-a-string-is-a-valid-number
            if (!isNaN(v)) {  
                return true;
            } else {
                // if the string isn't a valid number, try to parse it as a DatetimeValue
                try { DatetimeValue.parse(v); }
                catch (e) { return false; }
                return true;
            }
        } else {
            return false;
        }
    }

    if (json) {
        var vars = {
            "horizontal" : [],
            "vertical"   : []
        };
        var axisid = {
            "horizontal" : undefined,
            "vertical"   : undefined
        };

//   "verticalaxis" : [ VARIABLE-ID(string), ... ]
//   "verticalaxis" : { AXIS-ID(string): DATA-VALUE(number or string) }     <-- ConstantPlot
//   "verticalaxis" : { AXIS-ID(string): VARIABLE-ID(string) }
//   "verticalaxis" : { AXIS-ID(string): [ VARIABLE-ID(string), ... ] }
//   "verticalaxis" : DATA-VALUE(number or string)                          <-- ConstantPlot
//   "verticalaxis" : AXIS-ID(string)

        // deal with vertical axis first, because it determines whether we have
        // a ConstantPlot or a DataPlot
        var constant_value = undefined;
        if (json.verticalaxis) {
            if (vF.typeOf(json.verticalaxis) === 'array') {
                // if it's an array, it's a list of variable ids for the plot,
                // and the axisid is unspecified
                vars.vertical = json.verticalaxis;
            } else if (vF.typeOf(json.verticalaxis) === 'number') {
                // in theory we'd like to validate here that the vertical axis type is NUMBER, but
                // we can't do that because we don't actually have the axis yet -- its id is implied
                // so it will be determined later.  So we set a numeric constant value and hope
                // for the best.
                constant_value = DataValue.parse(DataValue.NUMBER, json.verticalaxis);
            } else if (vF.typeOf(json.verticalaxis) === 'string') {
                // It's a string that is either an axis id, or a DatetimeValue constant (we
                // know it's not a number constant, because that would have been caught by
                // the 'number' case above).
                if (looks_like_data_value(json.verticalaxis)) {
                    // Again, in theory, we'd like to validate that the axis type is DateTime,
                    // but we can't because we don't have the axis yet.
                    constant_value = DataValue.parse(DataValue.DATETIME, json.verticalaxis);
                } else {
                    axisid.vertical = json.verticalaxis;
                    vaxis = graph.axisById(axisid.vertical);
                    if (typeof(vaxis) === 'undefined') {
                        throw new Error("plot refers to unknown vertical axis id: " + axisid.vertical);
                    }
                }
            } else if (vF.typeOf(json.verticalaxis) === 'object') {
                // if it's an object, the key is the axis id, and the value
                // is either:
                //    case 1: an array of variable ids, or
                //    case 2: a single value that is either an axis id, or
                //            a constant value for a constant plot
                if (keyCount(json.verticalaxis) !== 1) {
                    throw new Error("plot.verticalaxis object must contain exactly one key/value pair");
                }
                axisid.vertical = key(json.verticalaxis);
                vaxis = graph.axisById(axisid.vertical);
                if (typeof(vaxis) === 'undefined') {
                    throw new Error("plot refers to unknown vertical axis id: " + axisid.vertical);
                }
                if (vF.typeOf(json.verticalaxis[axisid.vertical]) !== "undefined") {
                    if (vF.typeOf(json.verticalaxis[axisid.vertical]) === 'array') {
                        // case 1: array of variable ids.
                        vars.vertical = json.verticalaxis[axisid.vertical];
                    } else {
                        // case 2: single value, either axis id, or constant value.
                        //   if it's a number, it must be a constant value
                        if (vF.typeOf(json.verticalaxis[axisid.vertical]) === 'number') {
                            if (vaxis.type() !== DataValue.NUMBER) {
                                throw new Error("constant value of '" + json.verticalaxis[axisid.vertical]
                                                + "' not appropriate for axis of type '" + vaxis.type() + "'");
                            }
                            constant_value = DataValue.parse(DataValue.NUMBER, json.verticalaxis[axisid.vertical]);
                        } else {
                            // it's not a number, so it must be a string that is either
                            // a constant DatetimeValue, or an axis id.
                            if (vF.typeOf(json.verticalaxis[axisid.vertical]) !== 'string') {
                                throw new Error("value for key '" + axisid.vertical + "' for verticalaxis is of wrong type");
                            }
                            if (looks_like_data_value(json.verticalaxis[axisid.vertical])) {
                                constant_value = DataValue.parse(vaxis.type(), json.verticalaxis[axisid.vertical]);
                            } else {
                                vars.vertical = [ json.verticalaxis[axisid.vertical] ];
                            }
                        }
                    }
                }
            }
        }

        if (constant_value !== undefined) {
            plot = new ConstantPlot(constant_value);
        } else {
            plot = new DataPlot();
        }

        plot.verticalaxis(vaxis);

        //   "horizontalaxis" : AXIS-ID(string)
        //   "horizontalaxis" : [ VARIABLE-ID(string), ... ]
        //   "horizontalaxis" : { AXIS-ID(string): [ VARIABLE-ID(string), ... ] }
        if (json.horizontalaxis) {
            if (vF.typeOf(json.horizontalaxis) === 'array') {
                // if it's an array, it's a list of variable ids for the plot,
                // and the axisid is unspecified
                vars.horizontal = json.horizontalaxis;
            } else if (vF.typeOf(json.horizontalaxis) === 'string') {
                axisid.horizontal = json.horizontalaxis;
                haxis = graph.axisById(axisid.horizontal);
                if (haxis !== undefined) {
                    plot.horizontalaxis(haxis);
                } else {
                    throw new Error("Plot Horizontal Axis Error: The graph does not contain an axis with an id of '" + axisid.horizontal + "'");
                }
            } else if (vF.typeOf(json.horizontalaxis) === 'object') {
                // if it's an object, the key is the axis id, and the value
                // is either:
                //    case 1: an array of variable ids, or
                //    case 2: an axis id
                if (keyCount(json.horizontalaxis) !== 1) {
                    throw new Error("plot.horizontalaxis object must contain exactly one key/value pair");
                }
                axisid.horizontal = key(json.horizontalaxis);
                haxis = graph.axisById(axisid.horizontal);
                if (haxis !== undefined) {
                    plot.horizontalaxis(haxis);
                } else {
                    throw new Error("Plot Horizontal Axis Error: The graph does not contain an axis with an id of '" + axisid.horizontal + "'");
                }
                if (vF.typeOf(json.horizontalaxis[axisid.horizontal]) !== "undefined") {
                    if (vF.typeOf(json.horizontalaxis[axisid.horizontal]) === 'array') {
                        // case 1: array of variable ids.
                        vars.horizontal = json.horizontalaxis[axisid.horizontal];
                    } else {
                        // case 2: an axis id
                            // must be a string that is an axis id.
                            if (vF.typeOf(json.horizontalaxis[axisid.horizontal]) !== 'string') {
                                throw new Error("value for key '" + axisid.horizontal + "' for horizontalaxis is of wrong type");
                            }
                        vars.horizontal = [ json.horizontalaxis[axisid.horizontal] ];
                    }
                }
            }
        }

        // if this is a DataPlot, parse variables
        if (plot instanceof DataPlot) {

            // provide default horizontalaxis variable if none present
            if (vars.horizontal.length == 0) {
                plot.variable().add(null);
            }

            //TODO: defer population of variables until normalizer has executed
            // populate axis variables
            if (graph) {
                var allvars = [].concat(vars.horizontal, vars.vertical);
                allvars.forEach(function(vid) {
                    variable = graph.variableById(vid);
                    if (variable !== undefined) {
                        plot.data( variable.data() );
                        plot.variable().add(variable);
                    } else {
                        throw new Error("Plot Variable Error: No Data tag contains a variable with an id of '" + vid + "'");
                    }
                });
            }
        }





//xxx        // populate verticalaxis
//xxx        if (json.verticalaxis) {
//xxx            if (vF.typeOf(json.verticalaxis) === 'string') {
//xxx                axisid.vertical = json.verticalaxis;
//xxx            } else {
//xxx                if (keyCount(json.verticalaxis) !== 1) {
//xxx                    throw new Error("plot.verticalaxis must contain exactly one key/value pair");
//xxx                }
//xxx                axisid.vertical = key(json.verticalaxis);
//xxx                if (vF.typeOf(json.verticalaxis[axisid.vertical]) !== "undefined") {
//xxx                    if (vF.typeOf(json.verticalaxis[axisid.vertical]) === 'array') {
//xxx                        vars.vertical = json.verticalaxis[axisid.vertical];
//xxx                    } else {
//xxx                        vars.vertical = [ json.verticalaxis[axisid.vertical] ];
//xxx                    }
//xxx                }
//xxx            }
//xxx            vaxis = graph.axisById(axisid.vertical);
//xxx            if (vaxis === undefined) {
//xxx                throw new Error("Plot Vertical Axis Error: The graph does not contain an axis with an id of '" + axisid.vertical + "'");
//xxx            }
//xxx        }
//xxx
//xxx
//xxx//        // populate verticalaxis
//xxx//        if (json.verticalaxis && json.verticalaxis.ref) {
//xxx//            vaxis = graph.axisById(json.verticalaxis.ref);
//xxx//            if (vaxis === undefined) {
//xxx//                throw new Error("Plot Vertical Axis Error: The graph does not contain an axis with an id of '" + json.verticalaxis.ref + "'");
//xxx//            }
//xxx//        }
//xxx
//xxx        // If there is a verticalaxis object, and if the value it contains looks like a
//xxx        // number or datetime value, assume it's a Constant Plot.  Otherwise assume the
//xxx        // value is either a variable id, or a list of variable ids, so we have a Data Plot.
//xxx        if ((vF.typeOf(json.verticalaxis) === 'object') && looks_like_data_value(json.verticalaxis[axisid.vertical])) {
//xxx            plot = new ConstantPlot(DataValue.parse(vaxis.type(), json.verticalaxis[axisid.vertical]));
//xxx        } else {
//xxx            plot = new DataPlot();
//xxx        }
//xxx
//xxx//        if (json.verticalaxis && json.verticalaxis.constant) {
//xxx//            plot = new ConstantPlot(DataValue.parse(vaxis.type(), json.verticalaxis.constant));
//xxx//        } else {
//xxx//            plot = new DataPlot();
//xxx//        }
//xxx
//xxx        plot.verticalaxis(vaxis);
//xxx
//xxx        // populate horizontalaxis
//xxx        if (json.horizontalaxis) {
//xxx            if (vF.typeOf(json.horizontalaxis) === 'string') {
//xxx                axisid.horizontal = json.horizontalaxis;
//xxx            } else {
//xxx                if (keyCount(json.horizontalaxis) !== 1) {
//xxx                    throw new Error("plot.horizontalaxis must contain exactly one key/value pair");
//xxx                }
//xxx                axisid.horizontal = key(json.horizontalaxis);
//xxx                if (vF.typeOf(json.horizontalaxis[axisid.horizontal]) !== "undefined") {
//xxx                    if (vF.typeOf(json.horizontalaxis[axisid.horizontal]) === 'array') {
//xxx                        vars.horizontal = json.horizontalaxis[axisid.horizontal];
//xxx                    } else {
//xxx                        vars.horizontal = [ json.horizontalaxis[axisid.horizontal] ];
//xxx                    }
//xxx                }
//xxx                haxis = graph.axisById(axisid.horizontal);
//xxx                if (haxis !== undefined) {
//xxx                    plot.horizontalaxis(haxis);
//xxx                } else {
//xxx                    throw new Error("Plot Horizontal Axis Error: The graph does not contain an axis with an id of '" + axisid.horizontal + "'");
//xxx                }
//xxx            }
//xxx        }
//xxx
//xxx//        if (json.horizontalaxis && json.horizontalaxis.ref) {
//xxx//            haxis = graph.axisById(json.horizontalaxis.ref);
//xxx//            if (haxis !== undefined) {
//xxx//                plot.horizontalaxis(haxis);
//xxx//            } else {
//xxx//                throw new Error("Plot Horizontal Axis Error: The graph does not contain an axis with an id of '" + json.horizontalaxis.ref + "'");
//xxx//            }
//xxx//        }
//xxx
//xxx        // if this is a DataPlot, parse variables
//xxx        if (plot instanceof DataPlot) {
//xxx
//xxx            // provide default horizontalaxis variable if none present
//xxx            if (vars.horizontal.length == 0) {
//xxx                plot.variable().add(null);
//xxx            }
//xxx
//xxx            //TODO: defer population of variables until normalizer has executed
//xxx            // populate axis variables
//xxx            if (graph) {
//xxx                var allvars = [].concat(vars.horizontal, vars.vertical);
//xxx                allvars.forEach(function(vid) {
//xxx                    variable = graph.variableById(vid);
//xxx                    if (variable !== undefined) {
//xxx                        plot.data( variable.data() );
//xxx                        plot.variable().add(variable);
//xxx                    } else {
//xxx                        throw new Error("Plot Variable Error: No Data tag contains a variable with an id of '" + vid + "'");
//xxx                    }
//xxx                });
//xxx            }
//xxx        }



//        // if this is a DataPlot, parse variables
//        if (plot instanceof DataPlot) {
//            // provide default horizontalaxis variable if not present
//            if (!json.horizontalaxis || !json.horizontalaxis.variables || json.horizontalaxis.variables.length === 0) {
//                plot.variable().add(null);
//            }
//
//            //TODO: defer population of variables until normalizer has executed
//            // populate axis variables
//            var vars = [];
//            if (graph) {
//                if (json.horizontalaxis && json.horizontalaxis.variables) {
//                    vars = vars.concat(json.horizontalaxis.variables);
//                }
//                if (json.verticalaxis && json.verticalaxis.variables) {
//                    vars = vars.concat(json.verticalaxis.variables);
//                }
//                vars.forEach(function(vid) {
//                    variable = graph.variableById(vid);
//                    if (variable !== undefined) {
//                        plot.data( variable.data() );
//                        plot.variable().add(variable);
//                    } else {
//                        throw new Error("Plot Variable Error: No Data tag contains a variable with an id of '" + vid + "'");
//                    }
//                });
//            }
//        }

        if ("legend" in json) {
            plot.legend(PlotLegend.parseJSON(json.legend, plot));
        } else {
            plot.legend(PlotLegend.parseJSON(undefined, plot));
        }

        if (("renderer" in json) && (("style" in json) || ("options" in json))) {
            throw new Error("plot may not contain both 'renderer' and 'style', or 'renderer' and 'options'");
        }

        if (json.visible !== undefined) {
            plot.visible(json.visible);
        }

        if ("renderer" in json) {
            plot.renderer(Renderer.parseJSON(json.renderer, plot, messageHandler));
        } else if ("style" in json) {
            // json.options may or may not be present here
            plot.renderer(Renderer.parseJSON(
                { "type" : json.style, "options" : json.options },
                plot, messageHandler));
        } else if ("options" in json) {
            // json.options is present, but json.style is not here
            // json.options may or may not be present here
            plot.renderer(Renderer.parseJSON(
                { "type" : "line", "options" : json.options },
                plot, messageHandler));
        }

        if ("filter" in json) {
            if (vF.typeOf(json.filter) === 'object') {
                if ((typeof(json.filter.type) !== 'undefined') && (json.filter.type !== 'consecutivedistance')) {
                    throw new Error('unknown filter type: ' + json.filter.type);
                }
                plot.renderer().filter(new ConsecutiveDistanceFilter(json.filter));
            } else if (vF.typeOf(json.filter) === 'boolean') {
                if (json.filter) {
                    if (graph && graph.filter()) {
                        plot.renderer().filter(graph.filter());
                    } else {
                        plot.renderer().filter(new ConsecutiveDistanceFilter({}));
                    }
                }
            } else {
                throw new Error('invalid filter property: ' + json.filter);
            }
        } else if (graph && graph.filter()) {
            plot.renderer().filter(graph.filter());
        }

        if ("datatips" in json) {
            plot.datatips(Datatips.parseJSON(json.datatips));
        }

    }
    return plot;
};

module.exports = Plot;

},{"../../core/consecutive_distance_filter.js":23,"../../core/constant_plot.js":24,"../../core/data_plot.js":29,"../../core/data_value.js":30,"../../core/datatips.js":32,"../../core/datetime_value.js":37,"../../core/filter.js":39,"../../core/plot.js":54,"../../core/plot_legend.js":55,"../../core/renderer.js":57,"../../util/parsingFunctions.js":156,"../../util/validationFunctions.js":158,"./datatips.js":112,"./filter.js":113,"./plot_legend.js":125,"./renderer.js":127}],125:[function(require,module,exports){
var PlotLegend = require('../../core/plot_legend.js');

// "legend" : { "visible" : BOOLEAN,  "label" : "STRING" }
// BOOLEAN
PlotLegend.parseJSON = function (json, plot) {
    var legend           = new PlotLegend(),
        pF               = require('../../util/parsingFunctions.js'),
        Text             = require('../../core/text.js'),
        parseAttribute   = pF.parseAttribute,
        child;
    if (typeof(json) === "boolean") {
        legend.visible(json);
    } else {
        if (json) {
            parseAttribute(json.visible, legend.visible, pF.parseBoolean);
            parseAttribute(json.label,   legend.label,   function (value) { return new Text(value); });
        }
    }
    if (legend.label() === undefined) {
        // TODO: remove this ugly patch with something that works properly
        if (typeof(plot.variable)==="function" && plot.variable().size() >= 2) { 
            legend.label(new Text(plot.variable().at(1).id()));
        } else {
            legend.label(new Text("plot"));
        }
    }

    return legend;
};

module.exports = PlotLegend;

},{"../../core/plot_legend.js":55,"../../core/text.js":64,"../../util/parsingFunctions.js":156}],126:[function(require,module,exports){
var Plotarea = require('../../core/plotarea.js');

//  "plotarea" : {
//     "marginbottom": INTEGER(35),
//     "marginleft": INTEGER(38),
//     "margintop": INTEGER(10),
//     "marginright": INTEGER(35),
//     "border": INTEGER(0),
//     "bordercolor": COLOR(0xeeeeee),
//     "color": COLOR,
//  }
Plotarea.parseJSON = function (json) {
    var plotarea = new Plotarea(),
        margin = plotarea.margin(),
        pF               = require('../../util/parsingFunctions.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        parseRGBColor    = RGBColor.parse,
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger;
    if (json) {
        parseAttribute(json.marginbottom, margin.bottom);
        parseAttribute(json.marginleft,   margin.left);
        parseAttribute(json.margintop,    margin.top);
        parseAttribute(json.marginright,  margin.right);
        parseAttribute(json.border,       plotarea.border);
        parseAttribute(json.color,        plotarea.color,       parseRGBColor);
        parseAttribute(json.bordercolor,  plotarea.bordercolor, parseRGBColor);
    }
    return plotarea;
};

module.exports = Plotarea;

},{"../../core/plotarea.js":56,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],127:[function(require,module,exports){
var Renderer = require('../../core/renderer.js');

// "renderer" : {
//     "type" : RENDERERTYPE(line)
//     "options" : [
//       { "name" : "STRING!", "value" : "STRING!", "min" : "DATAVALUE", "max" : "DATAVALUE" },
//       { "name" : "STRING!", "value" : "STRING!", "min" : "DATAVALUE", "max" : "DATAVALUE" },
//       ...
//     ]
//   }
Renderer.parseJSON = function (json, plot, messageHandler) {
    var DataValue   = require('../../core/data_value.js'),
        NumberValue = require('../../core/number_value.js'),
        Warning     = require('../../core/warning.js'),
        pF          = require('../../util/parsingFunctions.js'),
        vF          = require('../../util/validationFunctions.js'),
        rendererType,
        renderer,
        opt;

    require('../../core/renderers/all_renderers.js');

    function setOption(name, value, min, max) {
        try {
            renderer.setOptionFromString(name, value, min, max);
        } catch (e) {
            if (e instanceof Warning) {
                messageHandler.warning(e);
            } else {
                throw e;
            }
        }
    }

    if (json && json.type !== undefined) {
        rendererType = Renderer.Type.parse(json.type);
        if (!Renderer.Type.isInstance(rendererType)) {
            throw new Error("unknown renderer type '" + json.type + "'");
        }
        renderer = Renderer.create(rendererType);
        renderer.plot(plot);

        if (json.options) {
            for (opt in json.options) {
                if (json.options.hasOwnProperty(opt)) {
                    if (vF.typeOf(json.options[opt]) === 'array') {
                        json.options[opt].forEach(function(subopt) {
                            setOption(opt, subopt.value, subopt.min, subopt.max);
                        });
                    } else {
                        setOption(opt, json.options[opt]);
                    }
                }
            }
        }

    }
    return renderer;
};

module.exports = Renderer;

},{"../../core/data_value.js":30,"../../core/number_value.js":51,"../../core/renderer.js":57,"../../core/renderers/all_renderers.js":58,"../../core/warning.js":66,"../../util/parsingFunctions.js":156,"../../util/validationFunctions.js":158}],128:[function(require,module,exports){
var Title = require('../../core/title.js');

//  "title" : {
//      "base" : POINT(0,1),
//      "anchor" : POINT(0,1),
//      "position" : POINT(0,0),
//      "frame" : FRAME(padding),
//      "color" : COLOR(white),
//      "opacity" : DOUBLE(1.0),
//      "border" : INTEGER(0),
//      "bordercolor" : COLOR(black),
//      "padding" : INTEGER(0),
//      "cornerradius" : INTEGER(15),
//      "fontsize" : INTEGER,
//      "text" : STRING
//  }
Title.parseJSON = function (json, graph) {
    var Point            = require('../../math/point.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        Text             = require('../../core/text.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parseJSONPoint   = function(p) { return new Point(p[0], p[1]); },
        parseRGBColor    = RGBColor.parse,
        parseAttribute   = pF.parseAttribute,
        title;

    if (json) {
        var text = json.text;
        if (text !== "") {
            title = new Title(new Text(text), graph);
        } else {
            return undefined;
        }                
        parseAttribute(json.frame,        title.frame,        function (value) { return value.toLowerCase(); });
        parseAttribute(json.border,       title.border);
        parseAttribute(json.color,        title.color,        parseRGBColor);
        parseAttribute(json.bordercolor,  title.bordercolor,  parseRGBColor);
        parseAttribute(json.opacity,      title.opacity);
        parseAttribute(json.padding,      title.padding);
        parseAttribute(json.cornerradius, title.cornerradius);
        parseAttribute(json.anchor,       title.anchor,       parseJSONPoint);
        parseAttribute(json.base,         title.base,         parseJSONPoint);
        parseAttribute(json.position,     title.position,     parseJSONPoint);
    }
    return title;
};

module.exports = Title;

},{"../../core/text.js":64,"../../core/title.js":65,"../../math/point.js":104,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],129:[function(require,module,exports){
var Window = require('../../core/window.js');

// "window" {
//       "width": INTEGER,
//       "height": INTEGER,
//       "border": INTEGER(2),
//       "bordercolor": COLOR(black),
//       "margin": INTEGER(2),
//       "padding": INTEGER(5),
// }
Window.parseJSON = function (json) {
    var w = new Window(),
        RGBColor         = require('../../math/rgb_color.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger,
        attr;
    if (json) {
        parseAttribute(json.width,  w.width);
        parseAttribute(json.height, w.height);
        parseAttribute(json.border, w.border);

        attr = json.margin;
        if (attr !== undefined) {
            w.margin().set(attr,attr,attr,attr);
        }

        attr = json.padding;
        if (attr !== undefined) {
                w.padding().set(attr,attr,attr,attr);
        }
        parseAttribute(json.bordercolor, w.bordercolor, RGBColor.parse);
    }
    return w;
};

module.exports = Window;

},{"../../core/window.js":70,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],130:[function(require,module,exports){
var Zoom = require('../../core/zoom.js');

Zoom.parseJSON = function (json, type) {
    var zoom             = new Zoom(),
        DataValue        = require('../../core/data_value.js'),
        DataMeasure      = require('../../core/data_measure.js'),
        pF               = require('../../util/parsingFunctions.js'),
        vF               = require('../../util/validationFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        parseBoolean     = pF.parseBoolean,
        parseDataMeasure = function(v) { return DataMeasure.parse(type, v); }, //pF.parseDataMeasure
        attr;
    if (vF.typeOf(json) === 'boolean') {
        parseAttribute(json,         zoom.allowed, parseBoolean);
    } else if (json) {
        parseAttribute(json.allowed, zoom.allowed, parseBoolean);
        parseAttribute(json.min,     zoom.min,     parseDataMeasure);
        parseAttribute(json.max,     zoom.max,     parseDataMeasure);
        attr = json.anchor;
        if (attr !== undefined) {
            if (typeof(attr) === "string" && attr.toLowerCase() === "none") {
                zoom.anchor(null);
            } else {
                zoom.anchor( DataValue.parse(type, attr) );
            }
        }
    }
    return zoom;
};

module.exports = Zoom;

},{"../../core/data_measure.js":28,"../../core/data_value.js":30,"../../core/zoom.js":71,"../../util/parsingFunctions.js":156,"../../util/validationFunctions.js":158}],131:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.

//  <horizontalaxis id="STRING" type="DATATYPE(number)" length="RELLEN(1.0)" base="POINT(-1,1)" anchor="DOUBLE(-1)" position="POINT(0,0)"
//      min="DATAVALUEORAUTO(auto)" max="DATAVALUEORAUTO(auto)" minposition="RELPOS(-1.0)" maxposition="RELPOS(1.0)" color="COLOR(black)" linewidth="INTEGER(1)"
//      tickmin="INTEGER(-3)" tickmax="INTEGER(3)" tickcolor="COLOR(black)">
//    <labels format="STRING" start="DATAVALUE(0)" angle="DOUBLE(0)" position="POINT" anchor="POINT" color="COLOR(black)" spacing="STRING" densityfactor="DOUBLE(1.0)">
//        <label format="STRING" start="STRING" angle="DOUBLE" position="POINT" anchor="POINT" spacing="STRING" densityfactor="DOUBLE">
//        <label format="STRING" start="STRING" angle="DOUBLE" position="POINT" anchor="POINT" spacing="STRING" densityfactor="DOUBLE">
//      </label>
//    </labels>
//    <title base="DOUBLE(0)" anchor="POINT" position="POINT" angle="DOUBLE(0)">TITLETEXT</title>
//    <grid color="COLOR(0xeeeeee)" visible="BOOLEAN(false)" />
//    <pan allowed="BOOLEAN(yes)" min="DATAVALUE" max="DATAVALUE" />
//    <zoom allowed="BOOLEAN(yes)" min="DATAMEASURE" max="DATAMEASURE" anchor="DATAVALUE" />
//    <binding id="STRING!" min="DATAVALUE!" max="DATAVALUE!" />
//  </horizontalaxis>

module.exports = function($) {
    var Axis = require('../../core/axis.js'),
        pF = require('../../util/parsingFunctions.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Axis.parseXML)==="function") { return Axis; };

    var parseLabels = function (xml, axis) {
        var spacingStrings = [],
            spacingString,
            labelsTag = xml.find("labels"),
            labelTags = xml.find("label"),
            labelers  = axis.labelers(),
            Labeler = require('../../core/labeler.js'),
            DataValue = require('../../core/data_value.js'),
            utilityFunctions = require('../../util/utilityFunctions.js'),
            i;
        spacingString = $.trim(pF.getXMLAttr(labelsTag,"spacing"));
        if (spacingString !== "") {
            spacingStrings = spacingString.split(/\s+/);
        }
        if (spacingStrings.length > 0) {
            // If there was a spacing attr on the <labels> tag, create a new labeler for
            // each spacing present in it, using the other values from the <labels> tag
            for (i = 0; i < spacingStrings.length; ++i) {
                labelers.add(Labeler.parseXML(labelsTag, axis, undefined, spacingStrings[i]));
            }
        } else if (labelTags.length > 0) {
            // If there are <label> tags, parse the <labels> tag to get default values
            var defaults = Labeler.parseXML(labelsTag, axis, undefined, null);
            // And loop over each <label> tag, creating labelers for each, splitting multiple
            // spacings on the same <label> tag into multiple labelers:
            $.each(labelTags, function (j, e) {
                spacingString = $.trim(pF.getXMLAttr($(e), "spacing"));
                spacingStrings = [];
                if (spacingString !== "") {
                    spacingStrings = spacingString.split(/\s+/);
                }
                for (i = 0; i < spacingStrings.length; ++i) {
                    labelers.add( Labeler.parseXML($(e), axis, defaults, spacingStrings[i]) );
                }
            });
        } else {
            // Otherwise create labelers using the default spacing, with the other values
            // from the <labels> tag
            var defaultValues = (utilityFunctions.getDefaultValuesFromXSD()).horizontalaxis.labels;
            var defaultSpacings = axis.type() === DataValue.NUMBER ?
                    defaultValues.defaultNumberSpacing :
                    defaultValues.defaultDatetimeSpacing;
            for (i = 0; i < defaultSpacings.length; ++i) {
                labelers.add(Labeler.parseXML(labelsTag, axis, undefined, defaultSpacings[i]));
            }
        }
    };

    
    Axis.parseXML = function (xml, orientation, messageHandler, multigraph) {

        var DataValue = require('../../core/data_value.js'),
            Point = require('../../math/point.js'),
            RGBColor = require('../../math/rgb_color.js'),
            Displacement = require('../../math/displacement.js'),
            AxisTitle = require('../../core/axis_title.js'),
            Grid = require('../../core/grid.js'),
            Pan = require('../../core/pan.js'),
            Zoom = require('../../core/zoom.js'),
            AxisBinding = require('../../core/axis_binding.js'),

            axis              = new Axis(orientation),
            parseAttribute    = pF.parseAttribute,
            parseInteger      = pF.parseInteger,
            parseDisplacement = Displacement.parse,
            parsePoint        = Point.parse,
            parseRGBColor     = RGBColor.parse,
            attr, child,
            value;

        if (xml) {

            parseAttribute(pF.getXMLAttr(xml, "id"),     axis.id);
            parseAttribute(pF.getXMLAttr(xml, "type"),   axis.type,   DataValue.parseType);
            parseAttribute(pF.getXMLAttr(xml, "length"), axis.length, parseDisplacement);

            //
            // The following provides support for the deprecated "positionbase" axis attribute;
            // MUGL files should use the "base" attribute instead.  When we're ready to remove
            // support for the deprecated attribute, delete this block of code:
            //
            (function () {
                var positionbase = pF.getXMLAttr(xml, "positionbase");
                if (positionbase) {
                    messageHandler.warning('Use of deprecated axis attribute "positionbase"; use "base" attribute instead');
                    if ((positionbase === "left") || (positionbase === "bottom")) {
                        axis.base(parsePoint("-1 -1"));
                    } else if (positionbase === "right") {
                        axis.base(parsePoint("1 -1"));
                    } else if (positionbase === "top") {
                        axis.base(parsePoint("-1 1"));
                    }
                }
            }());
            //
            // End of code to delete when removing support for deprecated "positionbase"
            // attribute.
            //

            attr = pF.getXMLAttr(xml, "position");
            if (attr !== undefined) {
                try {
                    axis.position(parsePoint(attr));
                } catch (e) {
                    // If position did not parse as a Point, and if it can be interpreted
                    // as a number, construct the position point by interpreting that
                    // number as an offset from the 0 location along the perpendicular
                    // direction.
                    value = parseInt(attr, 10);
                    if (value !== value) { // test for isNaN
                        throw e;
                    }
                    if (orientation === Axis.HORIZONTAL) {
                        axis.position(new Point(0, value));
                    } else {
                        axis.position(new Point(value, 0));
                    }
                }
            }

            axis.min(pF.getXMLAttr(xml, "min"));
            if (axis.min() !== "auto") {
                axis.dataMin(DataValue.parse(axis.type(), axis.min()));
            }
            axis.max(pF.getXMLAttr(xml, "max"));
            if (axis.max() !== "auto") {
                axis.dataMax(DataValue.parse(axis.type(), axis.max()));
            }

            parseAttribute(pF.getXMLAttr(xml, "pregap"),         axis.pregap,         parseFloat);
            parseAttribute(pF.getXMLAttr(xml, "postgap"),        axis.postgap,        parseFloat);
            parseAttribute(pF.getXMLAttr(xml, "anchor"),         axis.anchor,         parseFloat);
            parseAttribute(pF.getXMLAttr(xml, "base"),           axis.base,           parsePoint);
            parseAttribute(pF.getXMLAttr(xml, "minposition"),    axis.minposition,    parseDisplacement);
            parseAttribute(pF.getXMLAttr(xml, "maxposition"),    axis.maxposition,    parseDisplacement);
            parseAttribute(pF.getXMLAttr(xml, "minoffset"),      axis.minoffset,      parseFloat);
            parseAttribute(pF.getXMLAttr(xml, "maxoffset"),      axis.maxoffset,      parseFloat);
            parseAttribute(pF.getXMLAttr(xml, "color"),          axis.color,          parseRGBColor);
            parseAttribute(pF.getXMLAttr(xml, "tickcolor"),      axis.tickcolor,      parseRGBColor);
            parseAttribute(pF.getXMLAttr(xml, "tickwidth"),      axis.tickwidth,      parseInteger);
            parseAttribute(pF.getXMLAttr(xml, "tickmin"),        axis.tickmin,        parseInteger);
            parseAttribute(pF.getXMLAttr(xml, "tickmax"),        axis.tickmax,        parseInteger);
            parseAttribute(pF.getXMLAttr(xml, "highlightstyle"), axis.highlightstyle);
            parseAttribute(pF.getXMLAttr(xml, "linewidth"),      axis.linewidth,      parseInteger);
            
            child = xml.find("title");
            if (child.length > 0)                    { axis.title(AxisTitle.parseXML(child, axis));     }
            else                                     { axis.title(new AxisTitle(axis));               }
            child = xml.find("grid");
            if (child.length > 0)                    { axis.grid(Grid.parseXML(child));                 }
            child = xml.find("pan");
            if (child.length > 0)                    { axis.pan(Pan.parseXML(child, axis.type()));      }
            child = xml.find("zoom");
            if (child.length > 0)                    { axis.zoom(Zoom.parseXML(child, axis.type()));    }
            if (xml.find("labels").length > 0)       { parseLabels(xml, axis);                             }

            child = xml.find("binding");
            if (child.length > 0) {
                var bindingIdAttr  = pF.getXMLAttr(child,"id"),
                    bindingMinAttr = pF.getXMLAttr(child,"min"),
                    bindingMaxAttr = pF.getXMLAttr(child,"max"),
                    bindingMinDataValue = DataValue.parse(axis.type(), bindingMinAttr),
                    bindingMaxDataValue = DataValue.parse(axis.type(), bindingMaxAttr);
                if (typeof(bindingIdAttr) !== "string" || bindingIdAttr.length <= 0) {
                    throw new Error("invalid axis binding id: '" + bindingIdAttr + "'");
                }
                if (! DataValue.isInstance(bindingMinDataValue)) {
                    throw new Error("invalid axis binding min: '" + bindingMinAttr + "'");
                }
                if (! DataValue.isInstance(bindingMaxDataValue)) {
                    throw new Error("invalid axis binding max: '" + bindingMaxAttr + "'");
                }
                AxisBinding.findByIdOrCreateNew(bindingIdAttr).addAxis(axis, bindingMinDataValue, bindingMaxDataValue, multigraph);
            }

        }
        return axis;
    };

    return Axis;
};

},{"../../core/axis.js":18,"../../core/axis_binding.js":19,"../../core/axis_title.js":20,"../../core/data_value.js":30,"../../core/grid.js":42,"../../core/labeler.js":45,"../../core/pan.js":52,"../../core/zoom.js":71,"../../math/displacement.js":101,"../../math/point.js":104,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156,"../../util/utilityFunctions.js":157}],132:[function(require,module,exports){
var AxisTitle = require('../../core/axis_title.js');

// <title base="23.2" anchor="12 4" position="3 7" angle="45">temperature</title>
// empty title:
//   <title/>
AxisTitle.parseXML = function (xml, axis) {
    var title = new AxisTitle(axis),
        Text = require('../../core/text.js'),
        Point = require('../../math/point.js'),
        pF = require('../../util/parsingFunctions.js'),
        nonEmptyTitle = false,
        parsePoint = Point.parse,
        text,
        parseTitleAttribute = function (value, attribute, preprocessor) {
            if (pF.parseAttribute(value, attribute, preprocessor)) {
                // No.  Don't count the title as nonEmpty just because of attributes.
                // If a <title> tag has only attributes, and no content, this
                // function should return `undefined` so that the normalizer won't
                // come along later and populate the title content with the axis id.
                // Empty <title> content means don't draw a title at all, in which
                // case it's OK to just forget about any attributes that were set.
                //nonEmptyTitle = true;
            }
        };

    if (xml) {
        text = xml.text();
        if (text !== "") {
            title.content(new Text(text));
            nonEmptyTitle = true;
        }
        parseTitleAttribute(pF.getXMLAttr(xml,"anchor"),   title.anchor,   parsePoint);
        parseTitleAttribute(pF.getXMLAttr(xml,"base"),     title.base,     parseFloat);
        parseTitleAttribute(pF.getXMLAttr(xml,"position"), title.position, parsePoint);
        parseTitleAttribute(pF.getXMLAttr(xml,"angle"),    title.angle,    parseFloat);
    }

    if (nonEmptyTitle === true) { 
        return title;
    }
    return undefined;
};

module.exports = AxisTitle;

},{"../../core/axis_title.js":20,"../../core/text.js":64,"../../math/point.js":104,"../../util/parsingFunctions.js":156}],133:[function(require,module,exports){
var Background = require('../../core/background.js');

// <background color="#ffff00">
//   <img src="foo.png" anchor="-1 5" base="3 12" position="-2 3" frame="padding"/>
// </background>
Background.parseXML = function (xml, multigraph) {
    var background       = new Background(),
        pF               = require('../../util/parsingFunctions.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        Img              = require('../../core/img.js'),
        child;

    if (xml) {
        pF.parseAttribute(pF.getXMLAttr(xml,"color"), background.color, RGBColor.parse);
        child = xml.find("img");
        if (child.length > 0) {
            background.img(Img.parseXML(child, multigraph));
        }
    }
    return background;
};

module.exports = Background;

},{"../../core/background.js":21,"../../core/img.js":44,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],134:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Data = require('../../core/data.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Data.parseXML)==="function") { return Data; };

    // <data>
    //   <variables
    //       missingvalue="DATAVALUE"
    //       missingop="COMPARATOR">
    //     <variable
    //         id="STRING!"
    //         column="INTEGER"
    //         type="DATATYPE(number)"
    //         missingvalue="STRING"
    //         missingop="COMPARATOR">
    //     </variable>
    //   </variables>
    //   <repeat period="STRING"/>
    //   <values>
    //   </values>
    //   <csv
    //       location="STRING!">
    //   </csv>
    //   <service
    //       location="STRING!"
    //       format="STRING">
    //   </service>
    // </data>
    Data.parseXML = function (xml, multigraph, messageHandler) {
        var ArrayData = require('../../core/array_data.js'),
            DataVariable = require('../../core/data_variable.js'),
            DataMeasure = require('../../core/data_measure.js'),
            PeriodicArrayData = require('../../core/periodic_array_data.js'),
            CSVData = require('../../core/csv_data.js')($),
            WebServiceData = require('../../core/web_service_data.js')($),
            Multigraph = require('../../core/multigraph.js')($),
            pF = require('../../util/parsingFunctions.js'),
            variables_xml,
            defaultMissingvalueString,
            defaultMissingopString,
            dataVariables = [],
            data,
            adap, adapter = ArrayData;

        if (xml) {

            adap = pF.getXMLAttr($(xml),"adapter");
            if (adap !== undefined && adap !== "") {
                adapter = Multigraph.getDataAdapter(adap);
                if (adapter === undefined) {
                    throw new Error("Missing data adapater: " + adap);
                }
            }

            // parse the <variables> section
            variables_xml = xml.find("variables");
            defaultMissingvalueString = pF.getXMLAttr(variables_xml,"missingvalue");
            defaultMissingopString    = pF.getXMLAttr(variables_xml,"missingop");

            var variables = variables_xml.find(">variable");
            if (variables.length > 0) {
                $.each(variables, function (i, e) {
                    dataVariables.push( DataVariable.parseXML($(e)) );
                });
            }

            // check to see if we have a <repeat> section, and if so, grab the period from it
            var haveRepeat = false,
                period,
                repeat_xml = $(xml.find(">repeat"));
            if (repeat_xml.length > 0) {
                var periodString = pF.getXMLAttr($(repeat_xml),"period");
                if (periodString === undefined || periodString === "") {
                    messageHandler.warning("<repeat> tag requires a 'period' attribute; data treated as non-repeating");
                } else {
                    period = DataMeasure.parse(dataVariables[0].type(),
                                               periodString);
                    haveRepeat = true;
                }
            }

            // if we have a <values> section, parse it and return an ArrayData instance:
            var values_xml = $(xml.find(">values"));
            if (values_xml.length > 0) {
                values_xml = values_xml[0];
                var stringValues = adapter.textToStringArray(dataVariables, $(values_xml).text());
                if (haveRepeat) {
                    data = new PeriodicArrayData(dataVariables, stringValues, period);
                } else {
                    data = new ArrayData(dataVariables, stringValues);
                }
            }

            // if we have a <csv> section, parse it and return a CSVData instance:
            var csv_xml = $(xml.find(">csv"));
            if (csv_xml.length > 0) {
                csv_xml = csv_xml[0];
                var filename = pF.getXMLAttr($(csv_xml),"location");
                data = new CSVData(dataVariables,
                                   multigraph ? multigraph.rebaseUrl(filename) : filename,
                                   messageHandler,
                                   multigraph ? multigraph.getAjaxThrottle(filename) : undefined);
            }

            // if we have a <service> section, parse it and return a WebServiceData instance:
            var service_xml = $(xml.find(">service"));
            if (service_xml.length > 0) {
                service_xml = $(service_xml[0]);
                var location = pF.getXMLAttr(service_xml,"location");
                data = new WebServiceData(dataVariables,
                                          multigraph ? multigraph.rebaseUrl(location) : location,
                                          messageHandler,
                                          multigraph ? multigraph.getAjaxThrottle(location) : undefined);
                var format = pF.getXMLAttr(service_xml,"format");
                if (format) {
                    data.format(format);
                }
            }
        }

        if (data) {
            if (defaultMissingvalueString !== undefined) {
                data.defaultMissingvalue(defaultMissingvalueString);
            }
            if (defaultMissingopString !== undefined) {
                data.defaultMissingop(defaultMissingopString);
            }
            data.adapter(adapter);
        }

        return data;
    };

    return Data;
};


},{"../../core/array_data.js":17,"../../core/csv_data.js":25,"../../core/data.js":26,"../../core/data_measure.js":28,"../../core/data_variable.js":31,"../../core/multigraph.js":48,"../../core/periodic_array_data.js":53,"../../core/web_service_data.js":67,"../../util/parsingFunctions.js":156}],135:[function(require,module,exports){
var DataVariable = require('../../core/data_variable.js');

//  <variable
//      id="STRING!"
//      column="INTEGER"
//      type="DATATYPE(number)"
//      missingvalue="STRING"
//      missingop="COMPARATOR">
//  </variable>
DataVariable.parseXML = function (xml, data) {
    var variable,
        pF = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        DataValue        = require('../../core/data_value.js'),
        attr;

    if (xml && pF.getXMLAttr(xml,"id")) {
        variable = new DataVariable(pF.getXMLAttr(xml,"id"));
        parseAttribute(pF.getXMLAttr(xml,"column"),       variable.column,       pF.parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"type"),         variable.type,         DataValue.parseType);
        //parseAttribute(pF.getXMLAttr(xml,"missingvalue"), variable.missingvalue, pF.parseDataValue(variable.type()));
        parseAttribute(pF.getXMLAttr(xml,"missingvalue"), variable.missingvalue, function(v) { return DataValue.parse(variable.type(), v); });
        parseAttribute(pF.getXMLAttr(xml,"missingop"),    variable.missingop,    DataValue.parseComparator);
    }
    return variable;
};

module.exports = DataVariable;

},{"../../core/data_value.js":30,"../../core/data_variable.js":31,"../../util/parsingFunctions.js":156}],136:[function(require,module,exports){

// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Datatips = require('../../core/datatips.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Datatips.parseXML)==="function") { return Datatips; };

    // <datatips
    //   format="STRING!"
    //   bgcolor="COLOR"
    //   bgalpha="DOUBLE"
    //   border="INTEGER"
    //   bordercolor="COLOR"
    //   pad="INTEGER">
    //   <variable
    //     format="STRING!">
    //   </variable>
    // </datatips>
    Datatips.parseXML = function (xml) {
        var datatips         = new Datatips(),
            RGBColor         = require('../../math/rgb_color.js'),
            DatatipsVariable = require('../../core/datatips_variable.js'),
            pF = require('../../util/parsingFunctions.js'),
            parseRGBColor    = RGBColor.parse,
            parseAttribute   = pF.parseAttribute,
            parseInteger     = pF.parseInteger,
            child;
        if (xml) {
            child = xml.find("variable");
            if (child.length > 0) {
                $.each(child, function (i, e) {
                    datatips.variables().add( DatatipsVariable.parseXML($(e)) );
                });
            }
            
            parseAttribute(pF.getXMLAttr(xml,"format"),      datatips.formatString);
            parseAttribute(pF.getXMLAttr(xml,"bgcolor"),     datatips.bgcolor,     parseRGBColor);
            parseAttribute(pF.getXMLAttr(xml,"bgalpha"),     datatips.bgalpha,     parseFloat);
            parseAttribute(pF.getXMLAttr(xml,"border"),      datatips.border,      parseInteger);
            parseAttribute(pF.getXMLAttr(xml,"bordercolor"), datatips.bordercolor, parseRGBColor);
            parseAttribute(pF.getXMLAttr(xml,"pad"),         datatips.pad,         parseInteger);
        }
        return datatips;
    };

    return Datatips;
};

},{"../../core/datatips.js":32,"../../core/datatips_variable.js":33,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],137:[function(require,module,exports){
var DatatipsVariable = require('../../core/datatips_variable.js');

DatatipsVariable.parseXML = function (xml) {
    var variable = new DatatipsVariable(),
        pF = require('../../util/parsingFunctions.js');

    if (xml) {
        pF.parseAttribute(pF.getXMLAttr(xml,"format"), variable.formatString);
    }
    return variable;
};

module.exports = DatatipsVariable;

},{"../../core/datatips_variable.js":33,"../../util/parsingFunctions.js":156}],138:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Filter = require('../../core/filter.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Filter.parseXML)==="function") { return Filter; };

    // <filter type="STRING">
    //    <option name="STRING!" value="STRING!"/>
    //    <option name="STRING!" value="STRING!"/>
    //    ...
    // </filter>
    Filter.parseXML = function (xml) {
        var filter = new Filter(),
            FilterOption = require('../../core/filter_option.js'),
            pF = require('../../util/parsingFunctions.js'),
            child;
        if (xml) {
            child = xml.find("option");
            if (child.length > 0) {
                $.each(child, function (i, e) {
                    filter.options().add( FilterOption.parseXML($(e)) );
                });
            }
            pF.parseAttribute(pF.getXMLAttr(xml,"type"), filter.type);
        }
        return filter;
    };

    return Filter;
};


},{"../../core/filter.js":39,"../../core/filter_option.js":40,"../../util/parsingFunctions.js":156}],139:[function(require,module,exports){
var FilterOption = require('../../core/filter_option.js');

// <option name="STRING!" value="STRING!"/>
FilterOption.parseXML = function (xml) {
    var pF     = require('../../util/parsingFunctions.js'),
        option = new FilterOption();
    if (xml) {
        option.name(pF.getXMLAttr(xml,"name"));
        option.value(pF.getXMLAttr(xml,"value") === "" ? undefined : pF.getXMLAttr(xml,"value"));
    }
    return option;
};

module.exports = FilterOption;

},{"../../core/filter_option.js":40,"../../util/parsingFunctions.js":156}],140:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Graph = require('../../core/graph.js'),
        pF = require('../../util/parsingFunctions.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Graph.parseXML)==="function") { return Graph; };

    /*
     * This function traverses an XML document looking for attributes values involving deprecated
     * color names and issues a warning about each one found.  Remove this function when removing
     * support for these names.  See src/math/rgb_color.js for a list of the deprecated colors.
     */
    var checkDeprecatedColorNames = function (xml, messageHandler) {
        var RGBColor   = require('../../math/rgb_color.js'),
            $xml       = $(xml),
            attributes = $xml[0].attributes,
            children   = $xml.children(),
            colorNameIsDeprecated = RGBColor.colorNameIsDeprecated,
            dep;
        if (xml.nodeName === "option") {
            if (/color/.test(pF.getXMLAttr($xml,'name'))) {
                dep = colorNameIsDeprecated(pF.getXMLAttr($xml,'value'));
                if (dep) {
                    messageHandler.warning('Warning: color string "' + pF.getXMLAttr($xml,'value') + '" is deprecated; use "' + dep + '" instead');
                }
            }
        }
        if (attributes) {
            $.each(attributes, function () {
                if (/color/.test(this.name)) {
                    dep = colorNameIsDeprecated(this.value);
                    if (dep) {
                        messageHandler.warning('Warning: color string "' + this.value + '" is deprecated; use "' + dep + '" instead');
                    }
                }
            });

        }
        if (children) {
            children.each(function () {
                checkDeprecatedColorNames(this, messageHandler);
            });
        }
    };


    Graph.parseXML = function (xml, multigraph, messageHandler) {
        var graph = new Graph(),
            Axis  = require('../../core/axis.js'),
            Window = require('../../core/window.js'),
            Legend = require('../../core/legend.js'),
            Background = require('../../core/background.js'),
            Plotarea = require('../../core/plotarea.js'),
            Title = require('../../core/title.js'),
            Data = require('../../core/data.js'),
            Plot = require('../../core/plot.js'),
            utilityFunctions = require('../../util/utilityFunctions.js'),
            defaults = utilityFunctions.getDefaultValuesFromXSD(),
            child;

        graph.multigraph(multigraph);
        if (xml) {

            //
            // Delete this try/catch block when removing support for deprecated color names.
            //
            try {
                checkDeprecatedColorNames(xml, messageHandler);
            } catch (e) {
                // just ignore any errors here; the worst that will happen is that the user just
                // won't see the warnings
            }
            //
            // end of block to delete when removing support for deprecated color names
            //

            // NOTE: 'OBJ.find(">TAG")' returns a list of JQuery objects corresponding to the immediate
            // (1st generation) child nodes of OBJ corresponding to xml tag TAG
            child = xml.find(">window");
            if (child.length > 0) {
                graph.window( Window.parseXML(child) );
            }

            child = xml.find(">legend");
            if (child.length > 0) {
                graph.legend( Legend.parseXML(child) );
            } else {
                graph.legend( Legend.parseXML() );
            }
            child = xml.find(">background");
            if (child.length > 0) {
                graph.background( Background.parseXML(child, graph.multigraph()) );
            }
            child = xml.find(">plotarea");
            if (child.length > 0) {
                graph.plotarea( Plotarea.parseXML(child) );
            }
            child = xml.find(">title");
            if (child.length > 0) {
                graph.title( Title.parseXML(child, graph) );
            }
            $.each(xml.find(">horizontalaxis"), function (i, e) {
                graph.axes().add( Axis.parseXML($(e), Axis.HORIZONTAL, messageHandler, graph.multigraph()) );
            });
            $.each(xml.find(">verticalaxis"), function (i, e) {
                graph.axes().add( Axis.parseXML($(e), Axis.VERTICAL, messageHandler, graph.multigraph()) );
            });
            /*
             if (xml.find(">data").length === 0) {
             // On second throught, let's not throw an error if no <data> tag
             // is specified, because conceivably there could be graphs in
             // which all the plots are constant plots, so no data is needed.
             // In particular, in our spec/mugl/constant-plot.xml test!
             // I'm not sure what should be done here --- maybe issue a warning,
             // or maybe don't do anything.
             //    mbp Mon Nov 12 16:05:21 2012
             //throw new Error("Graph Data Error: No data tags specified");
             }
             */
            $.each(xml.find(">throttle"), function (i, e) {
                var pattern    = pF.getXMLAttr($(e),'pattern')    ? pF.getXMLAttr($(e),'pattern')    : defaults.throttle.pattern,
                    requests   = pF.getXMLAttr($(e),'requests')   ? pF.getXMLAttr($(e),'requests')   : defaults.throttle.requests,
                    period     = pF.getXMLAttr($(e),'period')     ? pF.getXMLAttr($(e),'period')     : defaults.throttle.period,
                    concurrent = pF.getXMLAttr($(e),'concurrent') ? pF.getXMLAttr($(e),'concurrent') : defaults.throttle.concurrent;
                multigraph.addAjaxThrottle(pattern, requests, period, concurrent);
            });
            $.each(xml.find(">data"), function (i, e) {
                graph.data().add( Data.parseXML($(e), graph.multigraph(), messageHandler) );
            });
            $.each(xml.find(">plot"), function (i, e) {
                graph.plots().add( Plot.parseXML($(e), graph, messageHandler) );
            });
            graph.postParse();
        }
        return graph;
    };

    return Graph;
};

},{"../../core/axis.js":18,"../../core/background.js":21,"../../core/data.js":26,"../../core/graph.js":41,"../../core/legend.js":46,"../../core/plot.js":54,"../../core/plotarea.js":56,"../../core/title.js":65,"../../core/window.js":70,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156,"../../util/utilityFunctions.js":157}],141:[function(require,module,exports){
var Grid = require('../../core/grid.js');

// <grid color="#ff00ff" visible="true"/>
Grid.parseXML = function (xml) {
    var grid             = new Grid(),
        RGBColor         = require('../../math/rgb_color.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        attr;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"color"), grid.color, RGBColor.parse);
        //NOTE: visible attribute should default to true when parsing, so that
        //      the presence of a <grid> tag at all will turn on a grid.  In
        //      the Grid object itself, though, the default for the visible
        //      attribute is false, so that when we create a default grid object
        //      in code (as opposed to parsing), it defaults to not visible.
        attr = pF.getXMLAttr(xml,"visible");
        if (attr !== undefined) {
            grid.visible(pF.parseBoolean(attr));
        } else {
            grid.visible(true);
        }
    }
    return grid;
};

module.exports = Grid;

},{"../../core/grid.js":42,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],142:[function(require,module,exports){
var Icon = require('../../core/icon.js');

// <icon border="2" width="30" height="20"/>
Icon.parseXML = function (xml) {

    var icon = new Icon(),
        pF = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"height"), icon.height, parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"width"),  icon.width,  parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"border"), icon.border, parseInteger);
    }
    return icon;
};

module.exports = Icon;

},{"../../core/icon.js":43,"../../util/parsingFunctions.js":156}],143:[function(require,module,exports){
var Img = require('../../core/img.js');

//   <img src="foo.png" anchor="-1 5" base="3 12" position="-2 3" frame="padding"/>
Img.parseXML = function (xml, multigraph) {
    var img,
        pF = require('../../util/parsingFunctions.js'),
        Point            = require('../../math/point.js'),
        parseAttribute   = pF.parseAttribute,
        parsePoint       = Point.parse;
    if (xml && pF.getXMLAttr(xml,"src") !== undefined) {
        var src = pF.getXMLAttr(xml,"src");
        if (!src) {
            throw new Error('img elment requires a "src" attribute value');
        }
        if (multigraph) {
            src = multigraph.rebaseUrl(src);
        }
        img = new Img(src);
        parseAttribute(pF.getXMLAttr(xml,"anchor"),   img.anchor,   parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"base"),     img.base,     parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"position"), img.position, parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"frame"),    img.frame,    function (value) { return value.toLowerCase(); });
    }
    return img;
};

module.exports = Img;

},{"../../core/img.js":44,"../../math/point.js":104,"../../util/parsingFunctions.js":156}],144:[function(require,module,exports){
// usage:
// 
//   A valid jQuery object must be passed to the function returned by requiring this file.
//   That function returns a ParseXML object that can be used as follows:
//
//      var ParseXML = require('parse_xml.js')($);
//      ParseXML.stringToJQueryXMLObj(...);
//
var JQueryXMLParser;
module.exports = function($) {
    if (typeof(JQueryXMLParser)!="undefined") { return JQueryXMLParser; };

    JQueryXMLParser = {};

    require('./axis.js')($);
    require('./data.js')($);
    require('./datatips.js')($);
    require('./filter.js')($);
    require('./graph.js')($);
    require('./multigraph.js')($);
    require('./plot.js')($);
    require('./renderer.js')($);

    require('./axis_title.js');
    require('./background.js');
    require('./datatips_variable.js');
    require('./data_variable.js');
    require('./filter_option.js');
    require('./grid.js');
    require('./icon.js');
    require('./img.js');
    require('./labeler.js');
    require('./legend.js');
    require('./pan.js');
    require('./plotarea.js');
    require('./plot_legend.js');
    require('./title.js');
    require('./window.js');
    require('./zoom.js');

    JQueryXMLParser.stringToJQueryXMLObj = function (thingy) {
        if (typeof(thingy) !== "string") {
            return $(thingy);
        }
        var xml = $.parseXML(thingy);
        return $($(xml).children()[0]);
    };

    return JQueryXMLParser;
};

},{"./axis.js":131,"./axis_title.js":132,"./background.js":133,"./data.js":134,"./data_variable.js":135,"./datatips.js":136,"./datatips_variable.js":137,"./filter.js":138,"./filter_option.js":139,"./graph.js":140,"./grid.js":141,"./icon.js":142,"./img.js":143,"./labeler.js":145,"./legend.js":146,"./multigraph.js":147,"./pan.js":148,"./plot.js":149,"./plot_legend.js":150,"./plotarea.js":151,"./renderer.js":152,"./title.js":153,"./window.js":154,"./zoom.js":155}],145:[function(require,module,exports){
var Labeler = require('../../core/labeler.js');

// <labels
//   format="STRING"
//   start="DATAVALUE(0)"
//   angle="DOUBLE(0)"
//   position="POINT"
//   anchor="POINT"
//   color="COLOR(black)"
//   spacing="STRING"
//   densityfactor="DOUBLE(1.0)">
//     <label format="STRING" start="STRING" angle="DOUBLE" position="POINT" anchor="POINT" spacing="STRING" densityfactor="DOUBLE">
//     <label format="STRING" start="STRING" angle="DOUBLE" position="POINT" anchor="POINT" spacing="STRING" densityfactor="DOUBLE">
// </label>
Labeler.parseXML = function (xml, axis, defaults, spacing) {
    // This parser takes an optional final argument, spacing, which is a string representing
    // the spacing to be parsed for the labeler.  If that argument is not present, the spacing
    // value is taken from the xml object.  If a spacing argument is present, it is parsed
    // and used to set the spacing attribute of the Labeler object, and in this case, any
    // spacing value present in the xml is ignored.
    //
    // If the spacing argument has the value null, the resulting labeler will have no spacing
    // attribute set at all.
    var labeler,
        Point = require('../../math/point.js'),
        RGBColor = require('../../math/rgb_color.js'),
        DataMeasure = require('../../core/data_measure.js'),
        DataValue = require('../../core/data_value.js'),
        DataFormatter = require('../../core/data_formatter.js'),
        pF = require('../../util/parsingFunctions.js'),
        parsePoint = Point.parse;

    // `parseAttribute` returns true or false depending on whether or not it set the attribute.
    // If it did not and if the `defaults` object exists then the attribute is set to the
    // appropriate default value.
    var parseLabelerAttribute = function (value, attribute, preprocessor, defaultName) {
        if (!pF.parseAttribute(value, attribute, preprocessor) && defaults !== undefined) {
            attribute(defaults[defaultName]());
        }
    };
    var parseDataFormatter = function (type) {
        return function (value) {
            return DataFormatter.create(type, value);
        };
    };
    var parseDataValue = function (type) {
        return function (value) {
            return DataValue.parse(type, value);
        };
    };

    if (xml) {
        labeler = new Labeler(axis);
        if (spacing !== null) {
            if (spacing === undefined) {
                spacing = pF.getXMLAttr(xml,"spacing");
            }
            //NOTE: spacing might still === undefined at this point
            parseLabelerAttribute(spacing, labeler.spacing,
                                  function(v) { return DataMeasure.parse(axis.type(), v); }, //pF.parseDataMeasure(),
                                  "spacing");
        }
        parseLabelerAttribute(pF.getXMLAttr(xml,"format"),        labeler.formatter,     parseDataFormatter(axis.type()),              "formatter");
        parseLabelerAttribute(pF.getXMLAttr(xml,"start"),         labeler.start,         parseDataValue(axis.type()),                  "start");
        parseLabelerAttribute(pF.getXMLAttr(xml,"angle"),         labeler.angle,         parseFloat,                                   "angle");
        parseLabelerAttribute(pF.getXMLAttr(xml,"position"),      labeler.position,      parsePoint,                                   "position");
        parseLabelerAttribute(pF.getXMLAttr(xml,"anchor"),        labeler.anchor,        parsePoint,                                   "anchor");
        parseLabelerAttribute(pF.getXMLAttr(xml,"densityfactor"), labeler.densityfactor, parseFloat,                                   "densityfactor");
        parseLabelerAttribute(pF.getXMLAttr(xml,"color"),         labeler.color,         RGBColor.parse,                               "color");
        parseLabelerAttribute(pF.getXMLAttr(xml,"visible"),       labeler.visible,       pF.parseBoolean,                "visible");

    }
    return labeler;
};

module.exports = Labeler;

},{"../../core/data_formatter.js":27,"../../core/data_measure.js":28,"../../core/data_value.js":30,"../../core/labeler.js":45,"../../math/point.js":104,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],146:[function(require,module,exports){
var Legend = require('../../core/legend.js');

// <legend
//     visible="BOOLEAN"
//     base="POINT(1,1)"
//     anchor="POINT(1,1)"
//     position="POINT(0,0)"
//     frame="FRAME(padding)"
//     color="COLOR(white)"
//     opacity="DOUBLE(1.0)"
//     border="INTEGER(1)"
//     bordercolor="COLOR(black)"
//     rows="INTEGER"
//     columns="INTEGER"
//     cornerradius="INTEGER(0)"
//     padding="INTEGER(0)">
//   <icon
//       width="INTEGER(40)"
//       height="INTEGER(30)"
//       border="INTEGER(1)">
//   </icon>
// </legend>
Legend.parseXML = function (xml) {
    var legend           = new Legend(),
        pF               = require('../../util/parsingFunctions.js'),
        Point            = require('../../math/point.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        Icon             = require('../../core/icon.js'),
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger,
        parsePoint       = Point.parse,
        parseRGBColor    = RGBColor.parse,
        child;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"visible"),      legend.visible,      pF.parseBoolean);
        parseAttribute(pF.getXMLAttr(xml,"base"),         legend.base,         parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"anchor"),       legend.anchor,       parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"position"),     legend.position,     parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"frame"),        legend.frame);
        parseAttribute(pF.getXMLAttr(xml,"color"),        legend.color,        parseRGBColor);
        parseAttribute(pF.getXMLAttr(xml,"bordercolor"),  legend.bordercolor,  parseRGBColor);
        parseAttribute(pF.getXMLAttr(xml,"opacity"),      legend.opacity,      parseFloat);
        parseAttribute(pF.getXMLAttr(xml,"border"),       legend.border,       parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"rows"),         legend.rows,         parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"columns"),      legend.columns,      parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"cornerradius"), legend.cornerradius, parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"padding"),      legend.padding,      parseInteger);

        child = xml.find("icon");
        if (child.length > 0) {
            legend.icon(Icon.parseXML(child));
        }
    }
    return legend;
};

module.exports = Legend;

},{"../../core/icon.js":43,"../../core/legend.js":46,"../../math/point.js":104,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],147:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Multigraph = require('../../core/multigraph.js')($);

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Multigraph.parseXML)==="function") { return Multigraph; };

    Multigraph.parseXML = function (xml, mugl, messageHandler) {
        var multigraph = new Multigraph(),
            graphs     = multigraph.graphs(),
            Graph      = require('../../core/graph.js'),
            child;
        multigraph.mugl(mugl); // set the mugl url
        if (xml) {
            child = xml.find(">graph");
            if (child.length > 0) {
                $.each(child, function (i, e) {
                    graphs.add( Graph.parseXML($(e), multigraph, messageHandler) );
                });
            } else if (child.length === 0 && xml.children().length > 0) {
                graphs.add( Graph.parseXML(xml, multigraph, messageHandler) );
            }
        }
        return multigraph;
    };

    return Multigraph;
};

},{"../../core/graph.js":41,"../../core/multigraph.js":48}],148:[function(require,module,exports){
var Pan = require('../../core/pan.js');

// <pan allowed="true" min="-100" max="100"/>
Pan.parseXML = function (xml, type) {
    var pan            = new Pan(),
        pF             = require('../../util/parsingFunctions.js'),
        DataValue      = require('../../core/data_value.js'),
        parseAttribute = pF.parseAttribute,
        parseDataValue = function(v) { return DataValue.parse(type, v); };
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"allowed"), pan.allowed, pF.parseBoolean);
        parseAttribute(pF.getXMLAttr(xml,"min"),     pan.min,     parseDataValue);
        parseAttribute(pF.getXMLAttr(xml,"max"),     pan.max,     parseDataValue);
    }
    return pan;
};

module.exports = Pan;

},{"../../core/data_value.js":30,"../../core/pan.js":52,"../../util/parsingFunctions.js":156}],149:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Plot = require('../../core/plot.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Plot.parseXML)==="function") { return Plot; };

    // <plot>
    //   <legend
    //       visible="BOOLEAN"
    //       label="STRING">
    //   </legend>
    //   <horizontalaxis ref="STRING!">
    //     <variable ref="STRING!" />
    //   </horizontalaxis>
    //   <verticalaxis ref="STRING!">
    //     <variable ref="STRING" />
    //     <constant value="DATAVALUE"/>
    //   </verticalaxis>
    //   <renderer type="RENDERERTYPE(line)">
    //     <option name="STRING!" value="STRING!" min="DATAVALUE" max="DATAVALUE"/>
    //     <option name="STRING!" value="STRING!" min="DATAVALUE" max="DATAVALUE"/>
    //     ...
    //   </renderer>
    //   <datatips format="STRING!" bgcolor="COLOR" bgalpha="DOUBLE" border="INTEGER" bordercolor="COLOR" pad="INTEGER">
    //     <variable format="STRING!" />
    //     <variable format="STRING!" />
    //     ...
    //   </datatips>
    // </plot>
    Plot.parseXML = function (xml, graph, messageHandler) {
        var DataPlot     = require('../../core/data_plot.js'),
            PlotLegend   = require('../../core/plot_legend.js'),
            ConstantPlot = require('../../core/constant_plot.js'),
            DataValue    = require('../../core/data_value.js'),
            Renderer     = require('../../core/renderer.js'),
            Filter       = require('../../core/filter.js'),
            Datatips     = require('../../core/datatips.js'),
            pF           = require('../../util/parsingFunctions.js'),
            plot,
            haxis,
            vaxis,
            variable,
            attr, child;
        if (xml) {

            // populate verticalaxis from xml
            child = xml.find(">verticalaxis");
            if (child.length === 1 && pF.getXMLAttr(child,"ref") !== undefined) {
                if (graph) {
                    vaxis = graph.axisById(pF.getXMLAttr(child,"ref"));
                    if (vaxis === undefined) {
                        throw new Error("Plot Vertical Axis Error: The graph does not contain an axis with an id of '" + pF.getXMLAttr(child,"ref") + "'");
                    }
                }
            }

            child = xml.find("verticalaxis constant");
            if (child.length > 0) {
                var constantValueString = pF.getXMLAttr(child,"value");
                if (constantValueString === undefined) {
                    throw new Error("Constant Plot Error: A 'value' attribute is needed to define a Constant Plot");
                }
                plot = new ConstantPlot(DataValue.parse(vaxis.type(), constantValueString));
            } else {
                plot = new DataPlot();
            }

            plot.verticalaxis(vaxis);

            // populate horizontalaxis from xml
            child = xml.find(">horizontalaxis");
            if (child.length === 1 && pF.getXMLAttr(child,"ref") !== undefined) {
                if (graph) {
                    haxis = graph.axisById(pF.getXMLAttr(child,"ref"));
                    if (haxis !== undefined) {
                        plot.horizontalaxis(haxis);
                    } else {
                        throw new Error("Plot Horizontal Axis Error: The graph does not contain an axis with an id of '" + pF.getXMLAttr(child,"ref") + "'");
                    }
                }
            }

            // if this is a DataPlot, parse variables
            if (plot instanceof DataPlot) {

                // provide default horizontalaxis variable if not present in xml
                if (xml.find("horizontalaxis variable").length === 0) {
                    plot.variable().add(null);
                }
                //TODO: defer population of variables until normalizer has executed
                // populate axis variables from xml
                child = xml.find("horizontalaxis variable, verticalaxis variable");
                if (child.length > 0) {
                    if (graph) {
                        $.each(child, function (i, e) {
                            attr = pF.getXMLAttr($(e),"ref");
                            variable = graph.variableById( attr );
                            if (variable !== undefined) {
                                plot.data( variable.data() );
                                plot.variable().add(variable);
                            } else {
                                throw new Error("Plot Variable Error: No Data tag contains a variable with an id of '" + attr + "'");
                            }
                        });
                    }
                }
                }

            // populate legend from xml
            child = xml.find("legend");
            if (child.length > 0) {
                plot.legend(PlotLegend.parseXML(child, plot));
            } else {
                plot.legend(PlotLegend.parseXML(undefined, plot));
            }

            // populate renderer from xml
            child = xml.find("renderer");
            if (child.length > 0) {
                plot.renderer(Renderer.parseXML(child, plot, messageHandler));
            }

            // populate filter from xml
            child = xml.find("filter");
            if (child.length > 0) {
                plot.filter(Filter.parseXML(child));
            }

            // populate datatips from xml
            child = xml.find("datatips");
            if (child.length > 0) {
                plot.datatips(Datatips.parseXML(child));
            }

        }
        return plot;
    };

    return Plot;
};

},{"../../core/constant_plot.js":24,"../../core/data_plot.js":29,"../../core/data_value.js":30,"../../core/datatips.js":32,"../../core/filter.js":39,"../../core/plot.js":54,"../../core/plot_legend.js":55,"../../core/renderer.js":57,"../../util/parsingFunctions.js":156}],150:[function(require,module,exports){
var PlotLegend = require('../../core/plot_legend.js');

// <legend visible="BOOLEAN" label="STRING" />
PlotLegend.parseXML = function (xml, plot) {
    var legend           = new PlotLegend(),
        pF               = require('../../util/parsingFunctions.js'),
        Text             = require('../../core/text.js'),
        parseAttribute   = pF.parseAttribute,
        child;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"visible"), legend.visible, pF.parseBoolean);
        parseAttribute(pF.getXMLAttr(xml,"label"),   legend.label,   function (value) { return new Text(value); });
    }

    if (legend.label() === undefined) {
        // TODO: remove this ugly patch with something that works properly
        if (typeof(plot.variable)==="function" && plot.variable().size() >= 2) { 
            legend.label(new Text(plot.variable().at(1).id()));
        } else {
            legend.label(new Text("plot"));
        }
    }
    return legend;
};

module.exports = PlotLegend;

},{"../../core/plot_legend.js":55,"../../core/text.js":64,"../../util/parsingFunctions.js":156}],151:[function(require,module,exports){
var Plotarea = require('../../core/plotarea.js');

//  <plotarea
//     marginbottom="INTEGER(35)"
//     marginleft="INTEGER(38)"
//     margintop="INTEGER(10)"
//     marginright="INTEGER(35)"
//     border="INTEGER(0)"
//     bordercolor="COLOR(0xeeeeee)"
//     color="COLOR">
//  </plotarea>
Plotarea.parseXML = function (xml) {
    var plotarea = new Plotarea(),
        margin = plotarea.margin(),
        pF               = require('../../util/parsingFunctions.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        parseRGBColor    = RGBColor.parse,
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"marginbottom"), margin.bottom,        parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"marginleft"),   margin.left,          parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"margintop"),    margin.top,           parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"marginright"),  margin.right,         parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"border"),       plotarea.border,      parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"color"),        plotarea.color,       parseRGBColor);
        parseAttribute(pF.getXMLAttr(xml,"bordercolor"),  plotarea.bordercolor, parseRGBColor);
    }
    return plotarea;
};

module.exports = Plotarea;

},{"../../core/plotarea.js":56,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],152:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Renderer = require('../../core/renderer.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Renderer.parseXML)==="function") { return Renderer; };

    // <renderer
    //     type="RENDERERTYPE(line)">
    //   <option
    //       name="STRING!"
    //       value="STRING!"
    //       min="DATAVALUE"
    //       max="DATAVALUE">
    //   </option>
    //   ...
    // </renderer>
    Renderer.parseXML = function (xml, plot, messageHandler) {
        var DataValue   = require('../../core/data_value.js'),
            NumberValue = require('../../core/number_value.js'),
            Warning     = require('../../core/warning.js'),
            pF          = require('../../util/parsingFunctions.js'),
            rendererType,
            renderer,
            opt;

        require('../../core/renderers/all_renderers.js');

        if (xml && pF.getXMLAttr(xml,"type") !== undefined) {
            rendererType = Renderer.Type.parse(pF.getXMLAttr(xml,"type"));
            if (!Renderer.Type.isInstance(rendererType)) {
                throw new Error("unknown renderer type '" + pF.getXMLAttr(xml,"type") + "'");
            }
            renderer = Renderer.create(rendererType);
            renderer.plot(plot);
            if (xml.find("option").length > 0) {

                //
                // The following provides support for deprecatd the "missingvalue" and
                // "missingop" renderer options.  Those options are not officially supported
                // any more; MUGL files should use the  missingvalue/missingop attributes
                // of <data><variable> or <data><variables> instead.  When we're ready to
                // remove this support, delete the block of code:
                //
                (function (renderer, xml, plot, messageHandler) {
                    var i,
                        missingValueOption = xml.find("option[name=missingvalue]"),
                        missingOpOption    = xml.find("option[name=missingop]");
                    if (missingValueOption.length > 0 || missingOpOption.length > 0) {
                        var columns = plot.data().columns(),
                            column;
                        for (i = 0; i < columns.size();  ++i) {
                            column = columns.at(i);
                            if (column.type() === DataValue.NUMBER) {
                                if (missingValueOption.length > 0 && (column.missingvalue() === undefined)) {
                                    column.missingvalue(NumberValue.parse(pF.getXMLAttr(missingValueOption,"value")));
                                }
                                if (missingOpOption.length > 0 && (column.missingop() === undefined)) {
                                    column.missingop(DataValue.parseComparator(pF.getXMLAttr(missingOpOption,"value")));
                                }
                            }
                        }
                    }
                    if (missingValueOption.length > 0) {
                        messageHandler.warning("Renderer option 'missingvalue' is deprecated; " +
                                               "use 'missingvalue' attribute of 'data'/'variable'; instead");
                        // remove the element from the xml so that the option-processing code below doesn't see it
                        missingValueOption.remove();
                    }
                    if (missingOpOption.length > 0) {
                        messageHandler.warning("Renderer option 'missingop' is deprecated; " +
                                               "use 'missingvalue' attribute of 'data'/'variable'; instead");
                        // remove the element from the xml so that the option-processing code below doesn't see it
                        missingOpOption.remove();
                    }
                }(renderer, xml, plot, messageHandler));
                //
                // End of code to delete when removing support for deprecated
                // missingvalue/missingop renderer options.
                //

                $.each(xml.find(">option"), function (i, e) {
                    try {
                        renderer.setOptionFromString(pF.getXMLAttr($(e),"name"),
                                                     pF.getXMLAttr($(e),"value"),
                                                     pF.getXMLAttr($(e),"min"),
                                                     pF.getXMLAttr($(e),"max"));
                    } catch (e) {
                        if (e instanceof Warning) {
                            messageHandler.warning(e);
                        } else {
                            throw e;
                        }
                    }
                });
            }
        }
        return renderer;
    };

    return Renderer;
};

},{"../../core/data_value.js":30,"../../core/number_value.js":51,"../../core/renderer.js":57,"../../core/renderers/all_renderers.js":58,"../../core/warning.js":66,"../../util/parsingFunctions.js":156}],153:[function(require,module,exports){
var Title = require('../../core/title.js');

//  <title
//      base="POINT(0,1)"
//      anchor="POINT(0,1)"
//      position="POINT(0,0)"
//      frame="FRAME(padding)"
//      color="COLOR(white)"
//      opacity="DOUBLE(1.0)"
//      border="INTEGER(0)"
//      bordercolor="COLOR(black)"
//      padding="INTEGER(0)"
//      cornerradius="INTEGER(15)"
//      fontsize="INTEGER">
//  </title>
Title.parseXML = function (xml, graph) {
    var Point            = require('../../math/point.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        Text             = require('../../core/text.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parsePoint       = Point.parse,
        parseRGBColor    = RGBColor.parse,
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger,
        title;

    if (xml) {
        var text = xml.text();
        if (text !== "") {
            title = new Title(new Text(text), graph);
        } else {
            return undefined;
        }                
        parseAttribute(pF.getXMLAttr(xml,"frame"),        title.frame,        function (value) { return value.toLowerCase(); });
        parseAttribute(pF.getXMLAttr(xml,"border"),       title.border,       parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"color"),        title.color,        parseRGBColor);
        parseAttribute(pF.getXMLAttr(xml,"bordercolor"),  title.bordercolor,  parseRGBColor);
        parseAttribute(pF.getXMLAttr(xml,"opacity"),      title.opacity,      parseFloat);
        parseAttribute(pF.getXMLAttr(xml,"padding"),      title.padding,      parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"cornerradius"), title.cornerradius, parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"anchor"),       title.anchor,       parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"base"),         title.base,         parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"position"),     title.position,     parsePoint);
    }
    return title;
};

module.exports = Title;

},{"../../core/text.js":64,"../../core/title.js":65,"../../math/point.js":104,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],154:[function(require,module,exports){
var Window = require('../../core/window.js');

// <window
//       width="INTEGER"
//       height="INTEGER"
//       border="INTEGER(2)"
//       bordercolor="COLOR(black)"
//       margin="INTEGER(2)"
//       padding="INTEGER(5)">
//   </window>
Window.parseXML = function (xml) {
    var w = new Window(),
        RGBColor         = require('../../math/rgb_color.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger,
        attr;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"width"),  w.width,  parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"height"), w.height, parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"border"), w.border, parseInteger);

        attr = pF.getXMLAttr(xml,"margin");
        if (attr !== undefined) {
            (function (m) {
                w.margin().set(m,m,m,m);
            }(parseInt(attr, 10)));
        }

        attr = pF.getXMLAttr(xml,"padding");
        if (attr !== undefined) {
            (function (m) {
                w.padding().set(m,m,m,m);
            }(parseInt(attr, 10)));
        }

        // removed deprecated color name check from commit #17665e2
        //    jrfrimme Tues Apr 2 11:47 2013
        parseAttribute(pF.getXMLAttr(xml,"bordercolor"), w.bordercolor, RGBColor.parse);
    }
    return w;
};

module.exports = Window;

},{"../../core/window.js":70,"../../math/rgb_color.js":105,"../../util/parsingFunctions.js":156}],155:[function(require,module,exports){
var Zoom = require('../../core/zoom.js');

// <zoom allowed="true" min="10" max="100" anchor="0"/>
Zoom.parseXML = function (xml, type) {
    var zoom             = new Zoom(),
        DataValue        = require('../../core/data_value.js'),
        DataMeasure      = require('../../core/data_measure.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        parseDataMeasure = function(v) { return DataMeasure.parse(type, v); }, //pF.parseDataMeasure
        attr;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"allowed"), zoom.allowed, pF.parseBoolean);
        parseAttribute(pF.getXMLAttr(xml,"min"),     zoom.min,     parseDataMeasure);
        parseAttribute(pF.getXMLAttr(xml,"max"),     zoom.max,     parseDataMeasure);
        attr = pF.getXMLAttr(xml,"anchor");
        if (attr !== undefined) {
            if (attr.toLowerCase() === "none") {
                zoom.anchor(null);
            } else {
                zoom.anchor( DataValue.parse(type, attr) );
            }
        }
    }
    return zoom;
};

module.exports = Zoom;

},{"../../core/data_measure.js":28,"../../core/data_value.js":30,"../../core/zoom.js":71,"../../util/parsingFunctions.js":156}],156:[function(require,module,exports){
var ParsingFunctions = {};

/**
 * The Utility Functions module provides utility functions which correspond to general concepts.
 *
 * @module multigraph
 * @submodule utilityfunctions
 * @main utilityfunctions
 */

/**
 * Functions which provide abstractions for the parser.
 *
 * @class ParsingFunctions
 * @for ParsingFunctions
 * @static
 */

/**
 * Abstract function for parsing and setting jermaine attributes which do not require
 * extremely complicated logic to determine their values. Any attributes which require
 * complex logic to determine their proper values should be explicitly set in the parser.
 *
 * @method parseAttribute
 * @param {String} value
 * @param {Function} attribute
 * @param {Function} preprocessor
 * @static
 * @return {Boolean}
 */
ParsingFunctions.parseAttribute = function (value, attribute, preprocessor) {
    if (value !== undefined) {
        attribute((preprocessor !== undefined) ? preprocessor(value) : value);
        return true;
    }
    return false;
};

/**
 * Parses a string argument with a radix of 10 and returns an integer.
 *
 * @method parseInteger
 * @param {String} value
 * @static
 * @return {Integer}
 */
ParsingFunctions.parseInteger = function (value) {
    return parseInt(value, 10);
};

//mbp
///**
// * Returns a curried function that parses a value into a DataValue of the specified type.
// *
// * @method parseDataValue
// * @param {String} type
// * @static
// * @return {Function}
// */
//ParsingFunctions.parseDataValue = function (type) {
//    return function (value) {
//        return window.multigraph.core.DataValue.parse(type, value);
//    };
//};

//mbp
///**
// * Returns a curried function that parses a value into a DataMeasure of the specified type.
// *
// * @method parseDataMeasure
// * @param {String} type
// * @static
// * @return {Function}
// */
//ParsingFunctions.parseDataMeasure = function (type) {
//    return function (value) {
//        return window.multigraph.core.DataMeasure.parse(type, value);
//    };
//};

/**
 * Parses the allowed Boolean Strings and returns the appropriate value. If the parameter
 * is not one of the allowed values then the parameter is returned as an error might not
 * need to be thrown immediately.
 *
 * @method parseBoolean
 * @param {String} param
 * @static
 * @return {Boolean}
 */
ParsingFunctions.parseBoolean = function (param) {
    if (typeof(param) === "string") {
        switch (param.toLowerCase()) {
        case "true":
        case "yes":
            return true;
        case "false":
        case "no":
            return false;
        default:
            return param;
        }
    } else {
        return param;
    }
};

/*
 * The ParsingFunctions.getXMLAttr() function returns the value of an attribute for
 * an XML document node.
 * 
 * The `node` argument should be a node in an XML document as returned by the jQuery
 * parseXML function.
 * 
 * The `attrname` argument should be a string which is the name of an attribute.
 * 
 * This function ensures to return "undefined" if the node does not have the attribute.
 * 
 * This function itself does not depend on jQuery, which is why it is located in this
 * file -- so that code needing to use this function don't have to require jQuery just
 * for this function.  (The use of this function does require jQuery at some point in
 * the program, because this `node` object must be a jQuery object representing an XML
 * document.)
 * 
 * The reason we have this function for extracting attribute values, rather than
 * just calling node.attr(attrname) directly, is that in some cases node.attr()
 * returns the empty string for attributes which have not been set.  This function
 * uses the hasAttribute() method to check to see whether the attribute value
 * is present, and always returns `undefined` if it is not.
 */
ParsingFunctions.getXMLAttr = function(node, attrname) {
    if (node.length >= 1 && node[0].hasAttribute(attrname)) {
        return node.attr(attrname);
    }
    return undefined;
};

module.exports = ParsingFunctions;

},{}],157:[function(require,module,exports){
utilityFunctions = {};

// Why not use Object.getKeys() ??  mbp Fri Mar 13 00:21:57 2015
utilityFunctions.getKeys = function (obj) {
    var keys = [],
        key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            keys.push(key);
        }
    }
    return keys;
};

// coerce a value to a string, but not if it is the undefined value
utilityFunctions.coerceToString = function(s) {
    if (typeof(s) !== 'undefined') {
        return String(s);
    } else {
        return s;
    }
};

utilityFunctions.insertDefaults = function (elem, defaults, attributes) {
    var i;
    for (i = 0; i < attributes.length; i++) {
        if (defaults[attributes[i]] !== undefined && (typeof(defaults[attributes[i]]) !== "object" || defaults[attributes[i]] === null)) {
            if (elem.attributes().indexOf(attributes[i]) > -1) {
                elem.attribute(attributes[i]).defaultsTo(defaults[attributes[i]]);
            }
        }
    }
    return elem;
};


// This should be renamed; the name 'getDefaultValuesFromXSD' is a holdover from when we
// had an XSD that contained default values, and this function consulted it.  Or maybe
// we never actually had that, but intended to implement it?  In any case, it seems clear
// we won't be using an XSD here, so this should be renamed.  mbp Fri Mar 13 00:23:42 2015
utilityFunctions.getDefaultValuesFromXSD = function () {
    
    var DatetimeValue = require('../core/datetime_value.js'),
        NumberValue = require('../core/number_value.js'),
        Displacement = require('../math/displacement.js'),
        Insets = require('../math/insets.js'),
        Point = require('../math/point.js'),
        RGBColor = require('../math/rgb_color.js');

    return {
        "window": {
            //              "width": undefined,
            //              "height": undefined,
            "border": 2,
            "margin" : function () { return new Insets(/*top*/2, /*left*/2, /*bottom*/2, /*right*/2); },
            "padding": function () { return new Insets(/*top*/5, /*left*/5, /*bottom*/5, /*right*/5); },
            "bordercolor": function () { return new RGBColor.parse("0x000000"); }
        },
        "legend": {
            "icon" : {
                "height": 30,
                "width": 40,
                "border": 1
            },
            "visible": null,
            "base": function () { return new Point(1,1); },
            "anchor": function () { return new Point(1,1); },
            "position": function () { return new Point(0,0); },
            "frame": "plot",
            "color": function () { return new RGBColor.parse("0xffffff"); },
            "bordercolor": function () { return new RGBColor.parse("0x000000"); },
            "opacity": 1.0,
            "border": 1,
            "rows": undefined,
            "columns": undefined,
            "cornerradius": 0,
            "padding": 0
        },
        "background": {
            "img": {
                "src": undefined,
                "anchor": function () { return new Point(-1,-1); },
                "base": function () { return new Point(-1,-1); },
                "position": function () { return new Point(0,0); },
                "frame": "padding"
            },
            "color": "0xffffff"
        },
        "plotarea": {
            "margin" : function () { return new Insets(/*top*/10 , /*left*/38, /*bottom*/35, /*right*/35); },
            "border": 0,
            "color" : null,
            "bordercolor": function () { return new RGBColor.parse("0xeeeeee"); }
        },
        "title": {
            "text"         : undefined,
            "frame"        : "padding",
            "border"       : 0,
            "color"        : function () { return new RGBColor.parse("0xffffff"); },
            "bordercolor"  : function () { return new RGBColor.parse("0x000000"); },
            "opacity"      : 1.0,
            "padding"      : 0,
            "cornerradius" : 15,
            "anchor"       : function () { return new Point(0,1); },
            "base"         : function () { return new Point(0,1); },
            "position"     : function () { return new Point(0,0); }
        },
        "horizontalaxis": {
            "title": {
                "content": undefined,
                //                    "fontname": "default",
                //                    "fontsize": "12",
                //                    "fontcolor": "0x000000",
                "anchor": undefined,
                "base" : 0,
                "position": undefined,

                "position-horizontal-top"    : function () { return new Point(0, 15); },
                "position-horizontal-bottom" : function () { return new Point(0, -18); },
                "position-vertical-right"    : function () { return new Point(33, 0); },
                "position-vertical-left"     : function () { return new Point(-25, 0); },

                "anchor-horizontal-top"      : function () { return new Point(0, -1); },
                "anchor-horizontal-bottom"   : function () { return new Point(0, 1); },
                "anchor-vertical-right"      : function () { return new Point(-1, 0); },
                "anchor-vertical-left"       : function () { return new Point(1, 0); },

                "angle": 0
            },
            "labels": {
                "label": {
                    "format": undefined,
                    // NOTE: the Labeler object's default values for position and anchor should be undefined.
                    //       If those attributes are not specified in the MUGL, the Labeler's
                    //       initializeGeometry() method sets them to one of the context-dependent values
                    //       below.
                    "position": undefined,
                    "anchor": undefined,

                    "position-horizontal-top"    : function () { return new Point(0, 5); },
                    "position-horizontal-bottom" : function () { return new Point(0, -5); },
                    "position-vertical-right"    : function () { return new Point(5, 0); },
                    "position-vertical-left"     : function () { return new Point(-8, 0); },

                    "anchor-horizontal-top"      : function () { return new Point(0, -1); },
                    "anchor-horizontal-bottom"   : function () { return new Point(0, 1); },
                    "anchor-vertical-right"      : function () { return new Point(-1, 0); },
                    "anchor-vertical-left"       : function () { return new Point(1, 0); },

                    "angle": 0.0,
                    "spacing": undefined,
                    "densityfactor": 1.0,
                    "color" : function () { return new RGBColor.parse("0x000000"); },
                    "visible" : true
                    //                        "fontname": undefined,
                    //                        "fontsize": undefined,
                    //                        "fontcolor": undefined
                },
                //                    "fontname": "default",
                //                    "fontsize": "12",
                //                    "fontcolor": "0x000000",
                //                    "format": "%1d",
                //                    "visible": "true",
                "start-number": function () { return new NumberValue(0); },
                "start-datetime": function () { return new DatetimeValue(0); },
                "angle": 0.0,
                "position": function () { return new Point(0,0); },
                "anchor": function () { return new Point(0,0); },
                "color" : function () { return new RGBColor.parse("0x000000"); },
                "visible" : true,
                //"defaultNumberSpacing": "10000 5000 2000 1000 500 200 100 50 20 10 5 2 1 0.1 0.01 0.001",
                //"defaultDatetimeSpacing": "1000Y 500Y 200Y 100Y 50Y 20Y 10Y 5Y 2Y 1Y 6M 3M 2M 1M 7D 3D 2D 1D 12H 6H 3H 2H 1H",
                "defaultNumberSpacing": [10000, 5000, 2000, 1000, 500, 200, 100, 50, 20, 10, 5, 2, 1, 0.1, 0.01, 0.001],
                "defaultDatetimeSpacing": ["1000Y", "500Y", "200Y", "100Y", "50Y", "20Y", "10Y", "5Y", "2Y", "1Y", "6M",
                                           "3M", "2M", "1M", "7D", "3D", "2D", "1D", "12H", "6H", "3H", "2H", "1H"],
                "function": undefined,
                "densityfactor": undefined
            },
            "grid": {
                "color": function () { return new RGBColor.parse("0xeeeeee"); },
                "visible": false
            },
            "pan": {
                "allowed": true,
                "min": null,
                "max": null
            },
            "zoom": {
                "allowed": true,
                "min": undefined,
                "max": undefined,
                "anchor": null
            },
            "binding": {
                "id": undefined,
                "min": undefined,
                "max": undefined
            },
            "id": undefined,
            "type": "number",
            //                "length": 1.0,
            "length" : function () { return new Displacement(1,0); },
            "position": function () { return new Point(0,0); },
            "pregap": 0,
            "postgap": 0,
            "anchor": -1,
            "base": function () { return new Point(-1,-1); },
            "min": "auto",
            "minoffset": 0,
            //"minposition": -1,
            "minposition": function () { return new Displacement(-1,0); },
            "max": "auto",
            "maxoffset": 0,
            //"maxposition": 1,
            "maxposition": function () { return new Displacement(1,0); },
            "positionbase": undefined,
            //                "color": "0x000000",
            "color": function () { return new RGBColor(0,0,0); },
            "tickmin": -3,
            "tickmax": 3,
            "tickcolor": null,
            "highlightstyle": "axis",
            "linewidth": 1,
            "orientation": undefined
        },
        "verticalaxis": {
            "title": {
                "content": undefined,
                //                    "fontname": "default",
                //                    "fontsize": "12",
                //                    "fontcolor": "0x000000",
                "anchor": function () { return new Point(0,-20); },
                "position": function () { return new Point(0,1); },
                "angle": "0"
            },
            "labels": {
                "label": {
                    "format": undefined,
                    "start": undefined,
                    "angle": undefined,
                    "position": undefined,
                    "anchor": undefined,
                    "spacing": undefined,
                    "densityfactor": undefined
                    //                        "fontname": undefined,
                    //                        "fontsize": undefined,
                    //                        "fontcolor": undefined
                },
                //                    "fontname": "default",
                //                    "fontsize": "12",
                //                    "fontcolor": "0x000000",
                "format": "%1d",
                "visible": "true",
                "start": "0",
                "angle": "0.0",
                "position": "0 0",
                "anchor": "0 0",
                //                    "spacing": "10000 5000 2000 1000 500 200 100 50 20 10 5 2 1 0.1 0.01 0.001",
                //                    "defaultDatetimeSpacing": "1000Y 500Y 200Y 100Y 50Y 20Y 10Y 5Y 2Y 1Y 6M 3M 2M 1M 7D 3D 2D 1D 12H 6H 3H 2H 1H",
                "function": undefined,
                "densityfactor": undefined
            },
            "grid": {
                //                    "color": "0xeeeeee",
                "visible": "false"
            },
            "pan": {
                "allowed": "yes",
                "min": undefined,
                "max": undefined
            },
            "zoom": {
                "allowed": "yes",
                "min": undefined,
                "max": undefined,
                "anchor": "none"
            },
            "binding": {
                "id": undefined,
                "min": undefined,
                "max": undefined
            },
            "id": undefined,
            "type": "number",
            //                "length": "1.0",
            "position": "0 0",
            "pregap": "0",
            "postgap": "0",
            "anchor": "-1",
            "base": "-1 1",
            "min": "auto",
            "minoffset": "0",
            "minposition": "-1",
            "max": "auto",
            "maxoffset": "0",
            "maxposition": "1",
            "positionbase": undefined,
            //                "color": "0x000000",
            "tickmin": "-3",
            "tickmax": "3",
            "highlightstyle": "axis",
            "linewidth": "1",
            "orientation": undefined
        },
        "plot": {
            "legend": {
                "visible": true,
                "label": undefined
            },
            "horizontalaxis": {
                "variable": {
                    "ref": undefined,
                    "factor": undefined
                },
                "constant": {
                    "value": undefined
                },
                "ref": undefined
            },
            "verticalaxis": {
                "variable": {
                    "ref": undefined,
                    "factor": undefined
                },
                "constant": {
                    "value": undefined
                },
                "ref": undefined
            },
            "filter": {
                "option": {
                    "name": undefined,
                    "value": undefined
                },
                "type": undefined
            },
            "renderer":{
                "option": {
                    "name": undefined,
                    "value": undefined,
                    "min": undefined,
                    "max": undefined
                },
                "type": function () {
                    var Renderer = require('../core/renderer.js');
                    return Renderer.Type.parse("line");
                }
            },
            "datatips":{
                "variable": {
                    "formatString-number" : "%.2f",
                    "formatString-datetime" : "%d %n %Y"
                },
                //                    "visible": "false",
                "formatString": "{0}: {1}",
                "bgcolor": function () { return RGBColor.parse("0xeeeeee"); },
                "bgalpha": 1.0,
                "border": 1,
                "bordercolor": function () { return RGBColor.parse("0x000000"); },
                "pad": 2
            },
        },
        "throttle": {
            "pattern"    : "",
            "requests"   : 0,
            "period"     : 0,
            "concurrent" : 0
        },
        "data": {
            "variables": {
                "variable": {
                    "id": undefined,
                    "column": undefined,
                    "type": "number",
                    "missingvalue": undefined,
                    "missingop": undefined
                },
                "missingvalue": "-9000",
                "missingop": "eq"
            },
            "values": {
                "content": undefined
            },
            "csv": {
                "location": undefined
            },
            "service": {
                "location": undefined
            }
        }
    };
    
};

module.exports = utilityFunctions;


},{"../core/datetime_value.js":37,"../core/number_value.js":51,"../core/renderer.js":57,"../math/displacement.js":101,"../math/insets.js":103,"../math/point.js":104,"../math/rgb_color.js":105}],158:[function(require,module,exports){
var ValidationFunctions = {};

ValidationFunctions.validateNumberRange = function (number, lowerBound, upperBound) {
    return typeof(number) === "number" && number >= lowerBound && number <= upperBound;
};

// This function, from http://javascript.crockford.com/remedial.html, should correctly
// return 'array' for any Array object, including [].
// Returns 'object' for any JS object.
ValidationFunctions.typeOf = function(value) {
    var s = typeof value;
    if (s === 'object') {
        if (value) {
            //NOTE: Crockford used "=="   ?????!!!!!  mbp Fri Sep 28 08:44:34 2012
            //if (Object.prototype.toString.call(value) == '[object Array]') {
            if (Object.prototype.toString.call(value) === '[object Array]') {
                s = 'array';
            }
        } else {
            s = 'null';
        }
    }
    return s;
};

ValidationFunctions.isNumberNotNaN = function(x) {
    return (typeof(x) === "number") && (x === x);
};

module.exports = ValidationFunctions;

},{}]},{},[99])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImxpYi9hamF4dGhyb3R0bGUvc3JjL2FqYXh0aHJvdHRsZS5qcyIsImxpYi9idXN5LXNwaW5uZXIvYnVzeV9zcGlubmVyLmpzIiwibGliL2Vycm9yLWRpc3BsYXkvYnVpbGQvZXJyb3JEaXNwbGF5LmpzIiwibGliL2plcm1haW5lL3NyYy9jb3JlL2F0dHIuanMiLCJsaWIvamVybWFpbmUvc3JjL2NvcmUvYXR0cl9saXN0LmpzIiwibGliL2plcm1haW5lL3NyYy9jb3JlL21ldGhvZC5qcyIsImxpYi9qZXJtYWluZS9zcmMvY29yZS9tb2RlbC5qcyIsImxpYi9qZXJtYWluZS9zcmMvY29yZS92YWxpZGF0b3IuanMiLCJsaWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzIiwibGliL2plcm1haW5lL3NyYy91dGlsL2V2ZW50X2VtaXR0ZXIuanMiLCJsaWIvamVybWFpbmUvc3JjL3V0aWwvaW5kZXhfb2YuanMiLCJsaWIvamVybWFpbmUvc3JjL3V0aWwvbmFtZXNwYWNlLmpzIiwibGliL2pxdWVyeS9qcXVlcnkubW91c2V3aGVlbC5qcyIsImxpYi9saWdodGJveC9saWdodGJveC5qcyIsImxpYi9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL3NwcmludGYvbGliL3NwcmludGYuanMiLCJzcmMvY29yZS9hcnJheV9kYXRhLmpzIiwic3JjL2NvcmUvYXhpcy5qcyIsInNyYy9jb3JlL2F4aXNfYmluZGluZy5qcyIsInNyYy9jb3JlL2F4aXNfdGl0bGUuanMiLCJzcmMvY29yZS9iYWNrZ3JvdW5kLmpzIiwic3JjL2NvcmUvY2F0ZWdvcnlfZm9ybWF0dGVyLmpzIiwic3JjL2NvcmUvY29uc2VjdXRpdmVfZGlzdGFuY2VfZmlsdGVyLmpzIiwic3JjL2NvcmUvY29uc3RhbnRfcGxvdC5qcyIsInNyYy9jb3JlL2Nzdl9kYXRhLmpzIiwic3JjL2NvcmUvZGF0YS5qcyIsInNyYy9jb3JlL2RhdGFfZm9ybWF0dGVyLmpzIiwic3JjL2NvcmUvZGF0YV9tZWFzdXJlLmpzIiwic3JjL2NvcmUvZGF0YV9wbG90LmpzIiwic3JjL2NvcmUvZGF0YV92YWx1ZS5qcyIsInNyYy9jb3JlL2RhdGFfdmFyaWFibGUuanMiLCJzcmMvY29yZS9kYXRhdGlwcy5qcyIsInNyYy9jb3JlL2RhdGF0aXBzX3ZhcmlhYmxlLmpzIiwic3JjL2NvcmUvZGF0ZXRpbWVfZm9ybWF0dGVyLmpzIiwic3JjL2NvcmUvZGF0ZXRpbWVfbWVhc3VyZS5qcyIsInNyYy9jb3JlL2RhdGV0aW1lX3VuaXQuanMiLCJzcmMvY29yZS9kYXRldGltZV92YWx1ZS5qcyIsInNyYy9jb3JlL2V2ZW50X2VtaXR0ZXIuanMiLCJzcmMvY29yZS9maWx0ZXIuanMiLCJzcmMvY29yZS9maWx0ZXJfb3B0aW9uLmpzIiwic3JjL2NvcmUvZ3JhcGguanMiLCJzcmMvY29yZS9ncmlkLmpzIiwic3JjL2NvcmUvaWNvbi5qcyIsInNyYy9jb3JlL2ltZy5qcyIsInNyYy9jb3JlL2xhYmVsZXIuanMiLCJzcmMvY29yZS9sZWdlbmQuanMiLCJzcmMvY29yZS9taXhpbi5qcyIsInNyYy9jb3JlL211bHRpZ3JhcGguanMiLCJzcmMvY29yZS9udW1iZXJfZm9ybWF0dGVyLmpzIiwic3JjL2NvcmUvbnVtYmVyX21lYXN1cmUuanMiLCJzcmMvY29yZS9udW1iZXJfdmFsdWUuanMiLCJzcmMvY29yZS9wYW4uanMiLCJzcmMvY29yZS9wZXJpb2RpY19hcnJheV9kYXRhLmpzIiwic3JjL2NvcmUvcGxvdC5qcyIsInNyYy9jb3JlL3Bsb3RfbGVnZW5kLmpzIiwic3JjL2NvcmUvcGxvdGFyZWEuanMiLCJzcmMvY29yZS9yZW5kZXJlci5qcyIsInNyYy9jb3JlL3JlbmRlcmVycy9hbGxfcmVuZGVyZXJzLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL2JhbmRfcmVuZGVyZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvYmFyX3JlbmRlcmVyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL2ZpbGxfcmVuZGVyZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvcG9pbnRsaW5lX3JlbmRlcmVyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL3JhbmdlYmFyX3JlbmRlcmVyLmpzIiwic3JjL2NvcmUvdGV4dC5qcyIsInNyYy9jb3JlL3RpdGxlLmpzIiwic3JjL2NvcmUvd2FybmluZy5qcyIsInNyYy9jb3JlL3dlYl9zZXJ2aWNlX2RhdGEuanMiLCJzcmMvY29yZS93ZWJfc2VydmljZV9kYXRhX2NhY2hlX25vZGUuanMiLCJzcmMvY29yZS93ZWJfc2VydmljZV9kYXRhX2l0ZXJhdG9yLmpzIiwic3JjL2NvcmUvd2luZG93LmpzIiwic3JjL2NvcmUvem9vbS5qcyIsInNyYy9ldmVudHMvYWxsLmpzIiwic3JjL2V2ZW50cy9kcmFnZ2FibGUvZ3JhcGguanMiLCJzcmMvZXZlbnRzL21vdXNlL2dyYXBoLmpzIiwic3JjL2V2ZW50cy9tb3VzZS9tdWx0aWdyYXBoLmpzIiwic3JjL2V2ZW50cy9tdWx0aWdyYXBoLmpzIiwic3JjL2V2ZW50cy9yZXNpemUvbXVsdGlncmFwaC5qcyIsInNyYy9ldmVudHMvdG91Y2gvZ3JhcGguanMiLCJzcmMvZXZlbnRzL3RvdWNoL211bHRpZ3JhcGguanMiLCJzcmMvZ3JhcGhpY3MvY2FudmFzL2FsbC5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvYXhpcy5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvYXhpc190aXRsZS5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvYmFja2dyb3VuZC5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvZ3JhcGguanMiLCJzcmMvZ3JhcGhpY3MvY2FudmFzL2dyYXBoX3RpdGxlLmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy9pY29uLmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy9pbWcuanMiLCJzcmMvZ3JhcGhpY3MvY2FudmFzL2xhYmVsZXIuanMiLCJzcmMvZ3JhcGhpY3MvY2FudmFzL2xlZ2VuZC5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvbXVsdGlncmFwaC5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvcGxvdGFyZWEuanMiLCJzcmMvZ3JhcGhpY3MvY2FudmFzL3JlbmRlcmVycy9iYW5kX3JlbmRlcmVyLmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy9yZW5kZXJlcnMvYmFyX3JlbmRlcmVyLmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy9yZW5kZXJlcnMvZmlsbF9yZW5kZXJlci5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvcmVuZGVyZXJzL3BvaW50bGluZV9yZW5kZXJlci5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvcmVuZGVyZXJzL3JhbmdlYmFyX3JlbmRlcmVyLmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy90ZXh0LmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy93aW5kb3cuanMiLCJzcmMvbWFpbi5qcyIsInNyYy9tYXRoL2JveC5qcyIsInNyYy9tYXRoL2Rpc3BsYWNlbWVudC5qcyIsInNyYy9tYXRoL2VudW0uanMiLCJzcmMvbWF0aC9pbnNldHMuanMiLCJzcmMvbWF0aC9wb2ludC5qcyIsInNyYy9tYXRoL3JnYl9jb2xvci5qcyIsInNyYy9tYXRoL3V0aWwuanMiLCJzcmMvcGFyc2VyL2pzb24vYXhpcy5qcyIsInNyYy9wYXJzZXIvanNvbi9heGlzX3RpdGxlLmpzIiwic3JjL3BhcnNlci9qc29uL2JhY2tncm91bmQuanMiLCJzcmMvcGFyc2VyL2pzb24vZGF0YS5qcyIsInNyYy9wYXJzZXIvanNvbi9kYXRhX3ZhcmlhYmxlLmpzIiwic3JjL3BhcnNlci9qc29uL2RhdGF0aXBzLmpzIiwic3JjL3BhcnNlci9qc29uL2ZpbHRlci5qcyIsInNyYy9wYXJzZXIvanNvbi9maWx0ZXJfb3B0aW9uLmpzIiwic3JjL3BhcnNlci9qc29uL2dyYXBoLmpzIiwic3JjL3BhcnNlci9qc29uL2dyaWQuanMiLCJzcmMvcGFyc2VyL2pzb24vaWNvbi5qcyIsInNyYy9wYXJzZXIvanNvbi9pbWcuanMiLCJzcmMvcGFyc2VyL2pzb24vanNvbl9wYXJzZXIuanMiLCJzcmMvcGFyc2VyL2pzb24vbGFiZWxlci5qcyIsInNyYy9wYXJzZXIvanNvbi9sZWdlbmQuanMiLCJzcmMvcGFyc2VyL2pzb24vbXVsdGlncmFwaC5qcyIsInNyYy9wYXJzZXIvanNvbi9wYW4uanMiLCJzcmMvcGFyc2VyL2pzb24vcGxvdC5qcyIsInNyYy9wYXJzZXIvanNvbi9wbG90X2xlZ2VuZC5qcyIsInNyYy9wYXJzZXIvanNvbi9wbG90YXJlYS5qcyIsInNyYy9wYXJzZXIvanNvbi9yZW5kZXJlci5qcyIsInNyYy9wYXJzZXIvanNvbi90aXRsZS5qcyIsInNyYy9wYXJzZXIvanNvbi93aW5kb3cuanMiLCJzcmMvcGFyc2VyL2pzb24vem9vbS5qcyIsInNyYy9wYXJzZXIveG1sL2F4aXMuanMiLCJzcmMvcGFyc2VyL3htbC9heGlzX3RpdGxlLmpzIiwic3JjL3BhcnNlci94bWwvYmFja2dyb3VuZC5qcyIsInNyYy9wYXJzZXIveG1sL2RhdGEuanMiLCJzcmMvcGFyc2VyL3htbC9kYXRhX3ZhcmlhYmxlLmpzIiwic3JjL3BhcnNlci94bWwvZGF0YXRpcHMuanMiLCJzcmMvcGFyc2VyL3htbC9kYXRhdGlwc192YXJpYWJsZS5qcyIsInNyYy9wYXJzZXIveG1sL2ZpbHRlci5qcyIsInNyYy9wYXJzZXIveG1sL2ZpbHRlcl9vcHRpb24uanMiLCJzcmMvcGFyc2VyL3htbC9ncmFwaC5qcyIsInNyYy9wYXJzZXIveG1sL2dyaWQuanMiLCJzcmMvcGFyc2VyL3htbC9pY29uLmpzIiwic3JjL3BhcnNlci94bWwvaW1nLmpzIiwic3JjL3BhcnNlci94bWwvanF1ZXJ5X3htbF9wYXJzZXIuanMiLCJzcmMvcGFyc2VyL3htbC9sYWJlbGVyLmpzIiwic3JjL3BhcnNlci94bWwvbGVnZW5kLmpzIiwic3JjL3BhcnNlci94bWwvbXVsdGlncmFwaC5qcyIsInNyYy9wYXJzZXIveG1sL3Bhbi5qcyIsInNyYy9wYXJzZXIveG1sL3Bsb3QuanMiLCJzcmMvcGFyc2VyL3htbC9wbG90X2xlZ2VuZC5qcyIsInNyYy9wYXJzZXIveG1sL3Bsb3RhcmVhLmpzIiwic3JjL3BhcnNlci94bWwvcmVuZGVyZXIuanMiLCJzcmMvcGFyc2VyL3htbC90aXRsZS5qcyIsInNyYy9wYXJzZXIveG1sL3dpbmRvdy5qcyIsInNyYy9wYXJzZXIveG1sL3pvb20uanMiLCJzcmMvdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzIiwic3JjL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcyIsInNyYy91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2paQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBhamF4dGhyb3R0bGUuanNcbiAqIFxuICogVXNhZ2U6XG4gKiBcbiAqICAgICB2YXIgdCA9ICQuYWpheHRocm90dGxlKHtcbiAqICAgICAgICBudW1SZXF1ZXN0c1BlclRpbWVQZXJpb2QgOiBOLFxuICogICAgICAgIHRpbWVQZXJpb2QgICAgICAgICAgICAgICA6IFAsXG4gKiAgICAgICAgbWF4Q29uY3VycmVudCAgICAgICAgICAgIDogTVxuICogICAgIH0pO1xuICogICAgXG4gKiAgICAgdC5hamF4KGFyZ3MpO1xuICpcbiAqIFRoaXMgaXMganVzdCBsaWtlIGNhbGxpbmcgJC5hamF4KGFyZ3MpLCBleGNlcHQgdGhhdCByZXF1ZXN0cyBhcmUgdGhyb3R0bGVkXG4gKiBzbyB0aGF0IG5vIG1vcmUgdGhhbiBOIGFyZSBpbml0aWF0ZWQgaW4gYW55IHRpbWUgcGVyaW9kIG9mIFAgbWlsbGlzZWNvbmRzLFxuICogYW5kIG5vIG1vcmUgdGhhbiBNIGNvbmN1cnJlbnQgKG91dHN0YW5kaW5nIGF0IHRoZSBzYW1lIHRpbWUpIHJlcXVlc3RzIGFyZSBhbGxvd2VkLlxuICogSWYgTiBvciBQIGlzIDAsIHRoZXJlIGlzIG5vIHRpbWUgcGVyaW9kIGJhc2VkIGNvbnN0cmFpbnQsIGFuZCBpZiBNIGlzIDAsIHRoZXJlXG4gKiBpcyBubyBjb25zdHJhaW50IG9uIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCByZXF1ZXN0cy5cbiAqIFxuICogTWFyayBQaGlsbGlwcyA8bXBoaWxsaXBAdW5jYS5lZHU+XG4gKiBUaHUgRGVjIDIwIDExOjA0OjE5IDIwMTJcbiAqL1xuKGZ1bmN0aW9uKCQpIHtcbiAgICAkLmFqYXh0aHJvdHRsZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgdGltZW91dCxcblxuICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgbnVtUmVxdWVzdHNQZXJUaW1lUGVyaW9kIDogMCxcbiAgICAgICAgICAgICAgICB0aW1lUGVyaW9kICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIG1heENvbmN1cnJlbnQgICAgICAgICAgICA6IDFcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpLFxuXG4gICAgICAgICAgICB0aW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBBcnJheSBvZiBvdXRzdGFuZGluZyByZXF1ZXN0czsgdGhlc2UgYXJlIHJlcXVlc3RzIHRoYXQgaGF2ZVxuICAgICAgICAgICAgLy8gYmVlbiBpbml0aWF0ZWQgd2l0aCBhIGNhbGwgdG8gJC5hamF4KCkgYnV0IHRoYXQgaGF2ZSBub3RcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlZCB5ZXQuICBFYWNoIGVudHJ5IGluIHRoaXMgYXJyYXkgaXMgYW4gb2JqZWN0IG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAvLyAgICB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGFyZ3VtZW50czogdGhlIG9yaWdpbmFsIGFyZ3VtZW50cyBsaXN0IHBhc3NlZCB0byAuYWpheCgpXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgdGltZTogdGhlIHRpbWUgdGhpcyByZXF1ZXN0IHdhcyBwYXNzZWQgdG8gJC5hamF4KClcbiAgICAgICAgICAgIC8vICAgICAgICAgIGRlZmVycmVkOiB0aGUgalF1ZXJ5IGRlZmVycmVkIG9iamVjdCBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICAgICAgICAvLyAgICB9XG4gICAgICAgICAgICBvdXRzdGFuZGluZ19yZXFzID0gW10sXG5cbiAgICAgICAgICAgIC8vIEFycmF5IG9mIGluaXRpYXRlZCByZXF1ZXN0czsgZWFjaCBlbnRyeSBpbiB0aGlzIGFycmF5XG4gICAgICAgICAgICAvLyBpcyBhbiBvYmplY3QganVzdCBsaWtlIHRoZSBvbmVzIGluIHRoZSBvdXRzdGFuZGluZ19yZXFzXG4gICAgICAgICAgICAvLyBhcnJheSBhYm92ZSwgYnV0IHRoaXMgYXJyYXkga2VlcHMgdHJhY2sgb2YgYWxsXG4gICAgICAgICAgICAvLyByZXF1ZXN0cywgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXkgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICAgICAgICAvLyBUaGlzIGxpc3QgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHJlcXVlc3RzXG4gICAgICAgICAgICAvLyBoYXZlIGJlZW4gaW5pdGlhdGVkIGluIHNldHRpbmdzLnRpbWVQZXJpb2QuICBSZXF1ZXN0c1xuICAgICAgICAgICAgLy8gdGhhdCBhcmUgb2xkZXIgdGhhbiBzZXR0aW5ncy50aW1lUGVyaW9kIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgLy8gZ2V0IHJlbW92ZWQgZnJvbSB0aGlzIGxpc3Qgd2hlbiBpdCBpcyBwdXJnZWQuXG4gICAgICAgICAgICBpbml0aWF0ZWRfcmVxcyA9IFtdLFxuXG4gICAgICAgICAgICAvLyBBcnJheSBvZiByZXF1ZXN0cyB3YWl0aW5nIHRvIGJlIGluaXRpYXRlZFxuICAgICAgICAgICAgd2FpdGluZ19yZXFzID0gW10sXG5cbiAgICAgICAgICAgIC8vIFB1cmdlIHRoZSBpbml0aWF0ZWQgcmVxcyBsaXN0IHNvIHRoYXQgaXQgZG9lc24ndCBjb250YWluIGFueVxuICAgICAgICAgICAgLy8gcmVxcyBmcm9tIG1vcmUgdGhhbiBzZXR0aW5ncy50aW1lUGVyaW9kIG1zIGFnby4gIFJldHVybiB0aGVcbiAgICAgICAgICAgIC8vIGFtb3VudCBvZiB0aW1lIHRoYXQgbmVlZHMgdG8gYmUgd2FpdGVkIHVudGlsIHRoZSBvbGRlc3QgcmVtYWluaW5nXG4gICAgICAgICAgICAvLyAoYWZ0ZXIgcHVyZ2luZykgcmVxIGluIHRoZSBsaXN0IHdpbGwgYmUgc2V0dGluZ3MudGltZVBlcmlvZCBtcyBvbGQuXG4gICAgICAgICAgICAvLyBEbyBhbGwgb2YgdGhpcyByZWxhdGl2ZSB0byB0aGUgcGFzc2VkIGluICdub3cnIHZhbHVlLlxuICAgICAgICAgICAgcHVyZ2VfaW5pdGlhdGVkX3JlcXMgPSBmdW5jdGlvbihub3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudGltZVBlcmlvZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaW5pdGlhdGVkX3JlcXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5pdGlhdGVkX3JlcXNbMF0udGltZSArIHNldHRpbmdzLnRpbWVQZXJpb2QgLSBub3cgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYXRlZF9yZXFzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYXRlZF9yZXFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWF0ZWRfcmVxc1swXS50aW1lICsgc2V0dGluZ3MudGltZVBlcmlvZCAtIG5vdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhIHJlcSBmcm9tIHRoZSBvdXRzdGFuZGluZ19yZXFzIGxpc3RcbiAgICAgICAgICAgIHJlbW92ZV9vdXRzdGFuZGluZ19yZXEgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAkLmVhY2gob3V0c3RhbmRpbmdfcmVxcywgZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0c3RhbmRpbmdfcmVxc1tpXSA9PT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ19yZXFzLnNwbGljZShpLDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gSW5pdGlhdGUgdGhlIG5leHQgcmVxdWVzdCBvbiB0aGUgd2FpdGluZyBsaXN0LCB1bmxlc3Mgd2UgbmVlZCB0byB3YWl0XG4gICAgICAgICAgICAvLyB0aWxsIHNvbWUgdGltZSBoYXMgcGFzc2VkIG9yIHNvbWUgb3V0c3RhbmRpbmcgcmVxdWVzdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICAgICAgICBwcm9jZXNzX3dhaXRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gdGltZSgpLFxuICAgICAgICAgICAgICAgICAgICBkZWxheSwgcmVxLCBkZWZlcnJlZDtcblxuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nX3JlcXMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGF5ID0gcHVyZ2VfaW5pdGlhdGVkX3JlcXMobm93KTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSB0aW1lUGVyaW9kIGNvbnN0cmFpbnQsIGFuZCB0aGUgbWF4IG51bWJlciBvZiBhbGxvd2VkXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdHMgaGF2ZSBnb25lIG91dCBpbiB0aGF0IHRpbWUgcGVyaW9kLCBhcnJhbmdlIHRvIHdhaXQgZm9yXG4gICAgICAgICAgICAgICAgLy8gJ2RlbGF5JyBtc1xuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MubnVtUmVxdWVzdHNQZXJUaW1lUGVyaW9kID4gMCkgJiYgKHNldHRpbmdzLnRpbWVQZXJpb2QgPiAwKVxuICAgICAgICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgICAgICAgICAoZGVsYXkgPiAwKVxuICAgICAgICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5pdGlhdGVkX3JlcXMubGVuZ3RoID49IHNldHRpbmdzLm51bVJlcXVlc3RzUGVyVGltZVBlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgYW55IGV4aXN0aW5nIHRpbWVvdXQgZmlyc3QsIGJlY2F1c2UgdGhpcyBvbmUgd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1aXJlIHdhaXRpbmcgdGlsbCBhZnRlciBpdCB3b3VsZCBmaW5pc2ggYW55d2F5XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzX3dhaXRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG1heCBudW1iZXIgb2YgYWxsb3dlZCByZXF1ZXN0cyBpcyBvdXRzdGFuZGluZywgZG8gbm90aGluZztcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzX3dhaXRpbmcoKSB3aWxsIGdldCBjYWxsZWQgYWdhaW4gd2hlbiBhIHJlcXVlc3QgY29tcGxldGVzLlxuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MubWF4Q29uY3VycmVudCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKG91dHN0YW5kaW5nX3JlcXMubGVuZ3RoID49IHNldHRpbmdzLm1heENvbmN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBtYWtlIGl0IHRvIGhlcmUsIHRoZW4gaXQncyBPSyB0byBpbml0aWF0ZSB0aGUgbmV4dFxuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgaW4gdGhlIHdhaXRpbmcgbGlzdFxuICAgICAgICAgICAgICAgIHJlcSA9IHdhaXRpbmdfcmVxcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHJlcS50aW1lID0gdGltZSgpO1xuICAgICAgICAgICAgICAgIGluaXRpYXRlZF9yZXFzLnB1c2gocmVxKTtcbiAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ19yZXFzLnB1c2gocmVxKTtcbiAgICAgICAgICAgICAgICAkLmFqYXguYXBwbHkoJCxyZXEuYXJndW1lbnRzKS5kb25lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXEuZGVmZXJyZWQucmVzb2x2ZS5hcHBseShyZXEuZGVmZXJyZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSkuZmFpbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmRlZmVycmVkLnJlamVjdC5hcHBseShyZXEuZGVmZXJyZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSkuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfb3V0c3RhbmRpbmdfcmVxKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3Nfd2FpdGluZygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICA7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFqYXggOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG4gICAgICAgICAgICAgICAgd2FpdGluZ19yZXFzLnB1c2goeyBhcmd1bWVudHMgOiBhcmd1bWVudHMsIGRlZmVycmVkIDogZGVmZXJyZWQgfSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc193YWl0aW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufShqUXVlcnkpKTtcbiIsIihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAgIG9uIDogZnVuY3Rpb24ob24pIHtcbiAgICAgICAgICAgIGlmIChvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZGF0YSgnYnVzeV9zcGlubmVyJykub247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdidXN5X3NwaW5uZXInKS5vbiAgICA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmRhdGEoJ2J1c3lfc3Bpbm5lcicpLmxldmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdidXN5X3NwaW5uZXInKS5vbiAgICA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdidXN5X3NwaW5uZXInKS5sZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSxcblxuICAgICAgICBsZXZlbCA6IGZ1bmN0aW9uKGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmRhdGEoJ2J1c3lfc3Bpbm5lcicpLmxldmVsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5kYXRhKCdidXN5X3NwaW5uZXInKS5sZXZlbCArIGRlbHRhID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuZGF0YSgnYnVzeV9zcGlubmVyJykubGV2ZWwgPSAkKHRoaXMpLmRhdGEoJ2J1c3lfc3Bpbm5lcicpLmxldmVsICsgZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5kYXRhKCdidXN5X3NwaW5uZXInKS5sZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuYnVzeV9zcGlubmVyKCdvbicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkKHRoaXMpLmRhdGEoJ2J1c3lfc3Bpbm5lcicpLmxldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5idXN5X3NwaW5uZXIoJ29uJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXQgOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCdidXN5X3NwaW5uZXInKSxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbiA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmICggISBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdidXN5X3NwaW5uZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbiAgICA6IHNldHRpbmdzLm9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwgOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Mub24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggIDogMzIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgOiAzMlxuICAgICAgICAgICAgICAgICAgICB9KS5hcHBlbmQoJCgnPGltZyBzcmM9XCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhJQUFnQVBNQUFQLy8vd0FBQU1iR3hvU0VoTGEydHBxYW1qWTJObFpXVnRqWTJPVGs1THk4dkI0ZUhnUUVCQUFBQUFBQUFBQUFBQ0gvQzA1RlZGTkRRVkJGTWk0d0F3RUFBQUFoL2hwRGNtVmhkR1ZrSUhkcGRHZ2dZV3BoZUd4dllXUXVhVzVtYndBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTV4RElTV2xocGVyTjUySkxoU1NkUmd3Vm8xSUNRWlJVc2l3SHBUSlQ0aW93TlM4dnlXMmljQ0Y2azhITU1Ca0NFRHNreFRCREFad3VBa2txSWZ4SVF5aEJRQkZ2QVFTRElUTTVWRFc2WE5FNEthZ05oNkJnd2U2MHNtUVVCM2Q0UnoxWkJBcG5GQVNEZDBoaWhoMTJCa0U5a2pBSlZseWNYSWc3Q1FJRkE2U2xuSjg3cGFxYlNLaUtvcXVzbmJNZG1EQzJ0WFFsa1VoemlZdHlXVHhJZnk2QkU4V0p0NVlKdnBKaXZ4TmFHbUxIVDBWbk9nU1lmMGRaWFM3QVBkcEIzMDlSbkhPRzVnRHFYR0xEYUM0NTdEMXpaL1Yvbm1PTTgyWGlIUkxZS2hLUDFvWm1BRGRFQUFBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTZoRElTV2xacE9yTnAxbEdOUlNkUnBEVW9sSUd3NVJVWWhoSHVrcUZ1OERzckV5cW5XVGhHdkFtaFZsdGVCdm9qcFREREJVRUlGd01GQlJBbUJrU2dPckJGWm9nQ0FTd0JERVkvQ1pTZzdHU0UwZ1NDalFCTVZHMDIzeFdCaGtsQW5vRWRoUUVmeU5xTUljS2poUnNqRWRuZXpCK0E0azhnVHdKaEZ1aVc0ZG9rWGlsb1VlcEJBcDVxYUtwcDYrSG83YVdXNTR3bDdvYnZFZTBrUnVvcGxDR2Vwd1N4MmpKdnFIRW1HdDZ3aEpwR3BmSkNIbU9vTkhLYUh4NjFXaVNSOTJFNGxiRm9xK0I2UUR0dWV0Y2FCUG5XNitPN3dESHBJaUs5U2FWSzVHZ1Y1NDN0empnR2NnaEFnQWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU3aERJU1NreHBPck41ekZITldSZGhTaVZvVkxIc3BSVU1veVVha3lFZThQVFBDQVRXOUExNEUwVXZ1QUtNTkFaS1lVWkNpQk11QmFrU1FLRzhHMkZ6VVdveDJBVXRBUUZjQktsVlFvTGdRUmVaaFFsQ0lKZXNRWEk1QjBDQm5VTU94TUNlbm9DZlRDRVdCc0pDb2xUTUFObGR4MTVCR3M4QjV3bENaOVBvNk9Ka3dtUnBucWtxbnVTcmF5cWZLbXFwTGFqb2lXNUhKcTdGTDFHcjJtTU1jS1VNSWlKZ0llbXk3eFp0SnNUbXNNNHhIaUt2NUtNQ1hxZnlVQ0pFb25YUE4yckFPSUFtc2ZCM3VQb0FLKytHK3c0OGVkWlBLK002aExKcFFnNDg0ZW5YSWRRRlNTMXU2VWhrc0VORVFBQUlma0VDUW9BQUFBc0FBQUFBQ0FBSUFBQUJPY1F5RW1wR0tMcXpXY1pSVlVRblpZZzFhQlNoMkdVVkVJUTJhUU9FK0crY0Q0bnRwV2taUWoxSklpWklvZ0RGRnlISTBVeFF3RnVnTVNPRklQSmZ0ZlZBRW9aTEJiY0xFRmhsUWlxR3AxVmQxNDBBVWtsVU4zZUNBNTFDMUVXTXpNQ2V6Q0JCbWt4VklWSEJXZDNISGw5SlFPSUpTZFNuSjBUREtDaEN3VUpqb1dNUGFHcURLYW5uYXNNbzZXbk01NjJSNVlsdVpSd3VyMHdwZ3FaRTdOS1VtK0ZOUlBJaGpCSnhLWnRlV3VJQk1ONHpSTUlWSWhmZmNnb2p3Q0YxMTdpNG5sTG5ZNXp0Ukxzbk9rK2FWK29KWTdWN203NlBka1M0dHJLY2RnMFpjMHRUY0trUkFBQUlma0VDUW9BQUFBc0FBQUFBQ0FBSUFBQUJPNFF5RWtwS3FqcXpTY3BSYVZrWFpXUUV4aW13MUJTQ1VFSWxEb2hyZnQ2Y3BLQ2s1eGlkNU1OSlRhQUlrZWtLR1FrV3lLSGt2aEtzUjdBUm1pdGtBWURZUkliVVFSUWpXQndKUnpDaGk5Q1JsQmNZMVVONGcwL1ZOQjBBbGN2Y0FZSFJ5WlBkRVFGWVY4Y2N3UjVIV3hFSjAyWW1STUxuSjF4Q1lwMFk1aWRwUXVob3BtbUMyS2dvakthc1VRRGs1Qk5Bd3dNT2gyUnRScTV1UXVQWktHSUpRSUd3QXdHZjZJMEpYTXBDOEM3a1hXREJJTkZNeFM0REtNQVdWV0FHWXNBZE5xVzV1YVJ4a1NLSk9aS2FVM3RQT0JaNER1SzJMQVRnSmhrUEpNZ1R3S0NkRmp5UEhFbkt4RkNEaEVBQUNINUJBa0tBQUFBTEFBQUFBQWdBQ0FBQUFUekVNaEphVktwNnMybklrb2xJSjJXa0JTaHBrVlJXcXFRcmhMU0V1OU1aSktLOXkxWnJxWUs5V2lDbG12b1VhRjhnSVFTTmVGMUVyNE1ORm40U1JTREFSV3JvQUlFVGcxaVZ3dUhqWUIxa1ljMW13cnV3WEtDOWdtc0pYbGlHeGMrWGlVQ2J5OXlkaDFzT1NkTWtwTVRCcGFYQnpzZmhvYzVsNThHbTV5VG9BYVpoYU9VcWprRGdDV05IQVVMQ3dPTGFUbXpzd2FkRXFnZ1F3Z0h1UXNISW9aQ0hRTU1RZ1FHdWJWRWN4T1BGQWNNREFZVUE4NWVXQVJtZlNSUUNkY01lMHplUDFBQXlnd0xsSnRQTkFBTDE5REFSZFB6Qk9XU20xYnJKQmk0NXNvUkFXUUFBa3JRSXlrU2hROXdWaEhDd0NRQ0FDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHJFTWhKYVZLcDZzMm5Ja3FGWkYyVklCV2hVc0phVG9rcVVDb0JxK0U3MVNSUWV5cVVUb0xBN1Z4RjBKRHlJUWgvTVZWUE10MUVDWmxmY2paSjltSUtvYVRsMU1SSWw1bzRDVUtYT3dteXJDSW5DS3FjV3R2YWRMMlNZaHlBU3lOREowdUlpUk1EakkwRmQzMC9pSTJVQTVHU1M1VURqMmw2Tm9xZ09nTjRna3NFQmdZRmYwRkRxS2dIbnlaOU9YOEhyZ1lIZEhwY0hRVUxYQVMycUtwRU5SZzdlQU1MQzdrVEJhaXhVWUZrS0F6V0FBbkxDN0ZMVnhMV0RCTEtDd2FLVFVMZ0V3YkxBNGhKdE9rU0JOcUlUVDN4RWdmTHBCdHpFL2ppdUwwNFJHRUJnd1doU2hSZ1FFeEhCQUFoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFN3hESVNXbFNxZXJOcHlKS2hXUmRsU0FWb1ZMQ1drNkpLbEFxQWF2aE85VWtVSHNxbEU2Q3dPMWNSZENROGlFSWZ6RlZUekxkUkFtWlgzSTJTZlppQ3FHazVkVEVTSmVhT0FsQ2x6c0pzcXdpSndpcW5GcmIyblM5a21JY2dFc2pReWRMaUlsSGVoaHBlamFJanpoOWVvbVNqWlIraXBzbFdJUkxBZ01ET1IyRE9xS29nVEI5cENVSkJhZ0RCWFI2WEIwRUJrSUlzYVJzR0dNTUF4b0RCZ1lIVEtKaVVZRUdEQXpIQzlFQUNjVUdrSWdGemd3WjBRc1NCY1hIaVF2T3dnRGRFd2ZGczBzRHp0NFM2Qks0eFlqa0RPem4wdW5GZUJ6T0JpakltMURnbWc1WUZRd3NDTWpwMW9KOEx5SUFBQ0g1QkFrS0FBQUFMQUFBQUFBZ0FDQUFBQVR3RU1oSmFWS3A2czJuSWtxRlpGMlZJQldoVXNKYVRva3FVQ29CcStFNzFTUlFleXFVVG9MQTdWeEYwSkR5SVFoL01WVlBNdDFFQ1psZmNqWko5bUlLb2FUbDFNUklsNW80Q1VLWE93bXlyQ0luQ0txY1d0dmFkTDJTWWh5QVN5TkRKMHVJaVVkNkdHbDZOb2lQT0gxNmlaS05sSDZLbXlXRk9nZ0hoRUV2QXd3TUEwTjlHQnNFQzZhbWhuVmNFd2F2REFhekd3SURhSDFpcGFZTEJVVENHZ1FEQThOZEh6MEZwcWdUQndzTHFBYldBQW5JQTRGV0tkTUxHZFlHRWdyYWlnYlQwT0lUQmNnNVF3UFQ0eExyUk9aTDZBdVFBUFVTN2J4THBvV2lkWTBKdHhMSEtod3dNSkJUSGdQS2RFUUFBQ0g1QkFrS0FBQUFMQUFBQUFBZ0FDQUFBQVRyRU1oSmFWS3A2czJuSWtxRlpGMlZJQldoVXNKYVRva3FVQ29CcStFNzFTUlFleXFVVG9MQTdWeEYwSkR5SVFoL01WVlBNdDFFQ1psZmNqWko5bUlLb2FUbDFNUklsNW80Q1VLWE93bXlyQ0luQ0txY1d0dmFkTDJTWWh5QVN5TkRKMHVJaVVkNkdBVUxESkNSaVhvMUNwR1hESk9ValkrWWlwOURoVG9KQTRSQkx3TUxDd1ZEZlJnYkJBYXFxb1oxWEJNSHN3c0h0eHRGYUgxaXFhb0dOZ0FJeFJwYkZBZ2ZQUVNxcGJnR0JxVUQxd0JYZUNZcDFBWVoxOUpKT1lnSDFLd0E0VUJ2UXdYVUJ4UHFWRDlMM3NicDJCTmsyeHZ2RlBKZCtNRkNONkhBQUlLZ05nZ1kwS3RFQkFBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTZCRElTV2xTcWVyTnB5SktoV1JkbFNBVm9WTENXazZKS2xBcUFhdmhPOVVrVUhzcWxFNkN3TzFjUmRDUThpRUlmekZWVHpMZFJBbVpYM0kyU2ZZSURNYUFGZFRFU0plYUVEQUlNeFlGcXJPVWFOVzRFNE9iWWNDWGFpQlZFZ1VMZTBOSmF4eHRZa3NqaDJOTGtaSVNnRGdKaEh0aGtwVTRtVzZibFJpWW1aT2xoNEpXa0RxSUx3VUdCbkU2VFlFYkNnZXZyME4xZ0g0QXQ3Z0hpUnBGYUxOcnJxOEhOZ0FKQTcwQVd4UUlIMSt2c1lNREF6WlFQQzlWQ05rRFdVaEdrdUU1UHhKTndpVUs0VWZMek9sRDRXdnpBSGFvRzlueFBpNWQrallVcWZBaGh5a09Gd0pXaUFBQUlma0VDUW9BQUFBc0FBQUFBQ0FBSUFBQUJQQVF5RWxwVXFucXphY2lTb1ZrWFZVTUZhRlN3bHBPQ2NNWWxFckFhdmhPTW5OTE5vOEtzWnNNWkl0SkVJRElGU2tMR1FvUVROaElzRmVoUnd3MkNRTEtGMHRZR0tZU2creWdzWkl1TnFKa3NLZ2JmZ0lHZXBObzJjSVVCM1YxQjNJdk5pQllOUWFEU1R0ZmhoeDBDd1ZQSTBVSmUwK2JtNGc1VmdjR29xT2Nuam1qcURTZG5oZ0VvYW1jc1p1WE8xYVdReThLQXdPQXVUWVlHd2k3dzVoK0tyMFNKOE1GaWhwTmJ4KzRFcnE3QllCdXpzZGlIMWpDQXpvU2ZsMHJWaXJOYlJYbEJCbExYK0JQMFhKTEFQR3pUa0F1QU9xYjBXVDVBSDdPY2RDbTVCOFRnUndTUktJSFF0YUxDd2cxUkFBQU93QUFBQUFBQUFBQUFBPT1cIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiBhbHQ9XCJhamF4IGxvYWRpbmdcIj4nKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLmJ1c3lfc3Bpbm5lciA9IGZ1bmN0aW9uKCBtZXRob2QgKSB7XG4gICAgICAgIGlmICggbWV0aG9kc1ttZXRob2RdICkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbIG1ldGhvZCBdLmFwcGx5KCB0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICkpO1xuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhIG1ldGhvZCApIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5lcnJvciggJ01ldGhvZCAnICsgIG1ldGhvZCArICcgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LmJ1c3lfc3Bpbm5lcicgKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9ICAgIFxuICAgIH07XG4gICAgXG59KGpRdWVyeSkpO1xuIiwiKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZXJyb3JEaXNwbGF5SHRtbCA9IChcbiAgICAgICAgJydcbiAgICAgICAgICAgICsgJzxkaXYgY2xhc3M9XCJlcnJvckRpc3BsYXlcIj4nXG4gICAgICAgICAgICArICAgJzxzcGFuIGNsYXNzPVwiZXJyb3JEaXNwbGF5T3B0aW9uc1wiPidcbiAgICAgICAgICAgICsgICAgICc8YnV0dG9uIGNsYXNzPVwiZXJyb3JEaXNwbGF5RGV0YWlsc0J1dHRvblwiPlNlZSBEZXRhaWxzPC9idXR0b24+J1xuICAgICAgICAgICAgKyAgICAgJzxhIGhyZWY9XCJcIiBjbGFzcz1cImVycm9yRGlzcGxheVhCdXR0b25cIj4mIzEwMDA2OzwvYT4nXG4gICAgICAgICAgICArICAgJzwvc3Bhbj4nXG4gICAgICAgICAgICArICAgJzxzcGFuIGNsYXNzPVwiZXJyb3JEaXNwbGF5U2hvcnRNZXNzYWdlXCI+PC9zcGFuPidcbiAgICAgICAgICAgICsgJzwvZGl2PidcbiAgICAgICAgICAgICsgJzxzcGFuIGNsYXNzPVwiZXJyb3JEaXNwbGF5UmV0cmlldmVyXCI+PC9zcGFuPidcbiAgICApO1xuICAgIFxuICAgIHZhciBkZXRhaWxEaXNwbGF5SHRtbCA9IChcbiAgICAgICAgJydcbiAgICAgICAgICAgICsgJzxkaXYgY2xhc3M9XCJlcnJvckRpc3BsYXlEZXRhaWxzXCI+J1xuICAgICAgICAgICAgKyAgICc8c3BhbiBjbGFzcz1cImVycm9yRGlzcGxheU9wdGlvbnNcIj4nXG4gICAgICAgICAgICArICAgICAnPGEgaHJlZj1cIlwiIGNsYXNzPVwiZXJyb3JEaXNwbGF5WEJ1dHRvblwiPiYjMTAwMDY7PC9hPidcbiAgICAgICAgICAgICsgICAnPC9zcGFuPidcbiAgICAgICAgICAgICsgICAnPHNwYW4gY2xhc3M9XCJlcnJvckRpc3BsYXlGdWxsTWVzc2FnZUFyZWFcIj48L3NwYW4+J1xuICAgICAgICAgICAgKyAnPC9kaXY+J1xuICAgICk7XG4gICAgXG4gICAgdmFyIGRldGFpbERpc3BsYXlMaXN0SHRtbCA9IChcbiAgICAgICAgJydcbiAgICAgICAgICAgICsgJzx1bCBjbGFzcz1cImVycm9yRGlzcGxheUZ1bGxNZXNzYWdlTGlzdFwiPidcbiAgICAgICAgICAgICsgJzwvdWw+J1xuICAgICk7XG4gICAgXG4gICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAgIGluaXQgOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCdlcnJvckRpc3BsYXknKSxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9udENvbG9yJyA6ICcjZmYwMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kQ29sb3InIDogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc3BsYXlUaW1lJyA6IDEwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5kaWNhdG9yQ29sb3InIDogJyNmZjAwMDAnXG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICggISBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXBwZW5kKGVycm9yRGlzcGxheUh0bWwpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5Jykud2lkdGgoJHRoaXMud2lkdGgoKS02KTsgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRldGFpbERpc3BsYXkgPSAkKGRldGFpbERpc3BsYXlIdG1sKS5hcHBlbmRUbygkKFwiYm9keVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXRhaWxEaXNwbGF5TGlzdCA9ICQoZGV0YWlsRGlzcGxheUxpc3RIdG1sKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICQoZGV0YWlsRGlzcGxheSkuZmluZCgnLmVycm9yRGlzcGxheVhCdXR0b24nKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZGV0YWlsRGlzcGxheSkuZmluZCgnLmVycm9yRGlzcGxheU9wdGlvbnMnKS5oaWRlKCk7ICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAkKGRldGFpbERpc3BsYXkpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlSZXRyaWV2ZXInKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBzZXR0aW5ncy5pbmRpY2F0b3JDb2xvcikuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9KTsgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ2Vycm9yRGlzcGxheScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXRhaWxEaXNwbGF5JyA6IGRldGFpbERpc3BsYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGV0YWlsRGlzcGxheUxpc3QnIDogZGV0YWlsRGlzcGxheUxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9udENvbG9yJyA6IHNldHRpbmdzLmZvbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kQ29sb3InIDogc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc3BsYXlUaW1lJyA6IHNldHRpbmdzLmRpc3BsYXlUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2luZGljYXRvckNvbG9yJyA6IHNldHRpbmdzLmluZGljYXRvckNvbG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlYQnV0dG9uJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheU9wdGlvbnMnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5Jykuc2xpZGVVcChzZXR0aW5ncy5kaXNwbGF5VGltZSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5UmV0cmlldmVyJykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pOyAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlEZXRhaWxzQnV0dG9uJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheScpLm9mZigpOyAvL3N0b3BzIG1vdXNlbGVhdmVldmVudCB3aGVuIGRldGFpbHMgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXknKS5oaWRlKCk7ICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlSZXRyaWV2ZXInKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGRldGFpbERpc3BsYXkpLmZpbmQoJy5lcnJvckRpc3BsYXlGdWxsTWVzc2FnZUFyZWEnKS5lbXB0eSgpLmFwcGVuZCgkKGRldGFpbERpc3BsYXlMaXN0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGRldGFpbERpc3BsYXkpLmZpbmQoJy5lcnJvckRpc3BsYXlPcHRpb25zJykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChkZXRhaWxEaXNwbGF5KS5zaG93KCk7ICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgLy8gaW5pdCgpIG1ldGhvZFxuICAgICAgICBcbiAgICAgICAgZGlzcGxheUVycm9yIDogZnVuY3Rpb24oZnVsbE1lc3NhZ2UsIHNob3J0TWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgnZXJyb3JEaXNwbGF5JyksXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvbnRDb2xvcicgOiBkYXRhLmZvbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kQ29sb3InIDogZGF0YS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGlzcGxheVRpbWUnIDogZGF0YS5kaXNwbGF5VGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmRpY2F0b3JDb2xvcicgOiBkYXRhLmluZGljYXRvckNvbG9yXG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlSZXRyaWV2ZXInKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheU9wdGlvbnMnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheVNob3J0TWVzc2FnZScpLmNzcygnY29sb3InLCBzZXR0aW5ncy5mb250Q29sb3IpOyAgIFxuICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXknKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheU9wdGlvbnMnKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3IpOyAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5U2hvcnRNZXNzYWdlJykudGV4dChzaG9ydE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheScpLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlSZXRyaWV2ZXInKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBzZXR0aW5ncy5pbmRpY2F0b3JDb2xvcik7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIGlmKHNldHRpbmdzLmRpc3BsYXlUaW1lICE9IC0xKXsgICBcbiAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXknKS5zbGlkZVVwKHNldHRpbmdzLmRpc3BsYXlUaW1lLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlSZXRyaWV2ZXInKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgZWxzZXsgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheU9wdGlvbnMnKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheScpLnNob3coKTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQoZGF0YS5kZXRhaWxEaXNwbGF5TGlzdCkuYXBwZW5kKCQoJzxsaT4nK2Z1bGxNZXNzYWdlKyc8L2xpPicpLmNzcygnY29sb3InLCBzZXR0aW5ncy5mb250Q29sb3IpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5UmV0cmlldmVyJykuaG92ZXIoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5T3B0aW9ucycpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheVNob3J0TWVzc2FnZScpLnRleHQoc2hvcnRNZXNzYWdlKS5jc3MoJ2NvbG9yJywgc2V0dGluZ3MuZm9udENvbG9yKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheScpLnNsaWRlRG93bihmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlPcHRpb25zJykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXknKS5tb3VzZWxlYXZlKGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheU9wdGlvbnMnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5Jykuc2xpZGVVcChzZXR0aW5ncy5kaXNwbGF5VGltZSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5UmV0cmlldmVyJykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7ICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgfSk7ICAgICBcbiAgICAgICAgICAgICAgICAgICAgfSk7ICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5UmV0cmlldmVyJykuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSAvLyBkaXNwbGF5RXJyb3IoKSBtZXRob2RcblxuXG4gICAgfTtcblxuICAgICQuZm4uZXJyb3JEaXNwbGF5ID0gZnVuY3Rpb24oIG1ldGhvZCApIHtcbiAgICAgICAgaWYgKCBtZXRob2RzW21ldGhvZF0gKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1sgbWV0aG9kIF0uYXBwbHkoIHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnIHx8ICEgbWV0aG9kICkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVycm9yKCAnTWV0aG9kICcgKyAgbWV0aG9kICsgJyBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkuZXJyb3JEaXNwbGF5JyApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gICAgXG4gICAgfTtcblxufShqUXVlcnkpKTtcbmpRdWVyeSgnaGVhZCcpLmFwcGVuZChqUXVlcnkoJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4uZXJyb3JEaXNwbGF5IHsgZm9udC1mYW1pbHk6IEhlbHZldGljYSwgc2Fucy1zZXJpZjsgY29sb3I6ICMzMjQ0NkI7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyB0ZXh0LWFsaWduOiBsZWZ0OyBmb250LXNpemU6IDEycHg7IGxpbmUtaGVpZ2h0OiAxMnB4OyBoZWlnaHQ6IDQ1cHg7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAwcHg7IGxlZnQ6IDBweDsgd2lkdGg6IGluaGVyaXQ7IHdpZHRoOiBleHByZXNzaW9uKHRoaXMucGFyZW50Tm9kZS5jdXJyZW50U3R5bGVbXFwnd2lkdGhcXCddKTsgYm9yZGVyOiBzb2xpZDsgYm9yZGVyLWNvbG9yOiAjQTlCQURFOyBib3JkZXItc3R5bGU6IHJpZGdlOyBkaXNwbGF5OiBub25lOyB9IC5lcnJvckRpc3BsYXlSZXRyaWV2ZXJ7IGhlaWdodDogOHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmYwMDAwOyBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMTBweDsgd2lkdGg6IDhweDsgcG9zaXRpb246IGFic29sdXRlOyBib3R0b206IDBweDsgbGVmdDogMHB4OyBkaXNwbGF5OiBub25lOyB9IC5lcnJvckRpc3BsYXlTaG9ydE1lc3NhZ2V7IG92ZXJmbG93LXg6IGhpZGRlbjsgb3ZlcmZsb3cteTogaGlkZGVuOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBwb3NpdGlvbjogYWJzb2x1dGU7IGJvdHRvbTogMHB4OyBsZWZ0OiAwcHg7IHdpZHRoOiA5NSU7IG1hcmdpbi10b3A6IDIwcHg7IG1hcmdpbi1sZWZ0OiAxMHB4OyBtYXJnaW4tYm90dG9tOiA1cHg7IH0gLmVycm9yRGlzcGxheVhCdXR0b24geyB0ZXh0LWRlY29yYXRpb246IG5vbmU7IGZvbnQtc2l6ZTogMTVweDsgbWFyZ2luLXRvcDogMnB4OyBwb3NpdGlvbjogYWJzb2x1dGU7IHJpZ2h0OiAzcHg7IHRvcDogMHB4OyBjb2xvcjogIzRENjhBMzsgfSAuZXJyb3JEaXNwbGF5RGV0YWlsc0J1dHRvbiB7IG1hcmdpbi1sZWZ0OiAxMHB4OyBtYXJnaW4tcmlnaHQ6IDEwcHg7IHBvc2l0aW9uOiByZWxhdGl2ZTsgfSAuZXJyb3JEaXNwbGF5RGV0YWlsc3sgcG9zaXRpb246IGZpeGVkOyB0b3A6IDI1JTsgaGVpZ2h0OiAxMDBweDsgd2lkdGg6IDc1JTsgdGV4dC1hbGlnbjogbGVmdDsgYm9yZGVyOiBzb2xpZDsgYm9yZGVyLWNvbG9yOiAjQTlCQURFOyBib3JkZXItc3R5bGU6IHJpZGdlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsgZGlzcGxheTogbm9uZTsgfSAuZXJyb3JEaXNwbGF5RnVsbE1lc3NhZ2VBcmVhIHsgZm9udC1mYW1pbHk6IEhlbHZldGljYSwgc2Fucy1zZXJpZjsgZm9udC1zaXplOiAuODMzZW07IGNvbG9yOiAjMzI0NDZCOyBoZWlnaHQ6IDgwcHg7IHdpZHRoOiBpbmhlcml0OyB3aWR0aDogZXhwcmVzc2lvbih0aGlzLnBhcmVudE5vZGUuY3VycmVudFN0eWxlW1xcJ3dpZHRoXFwnXSk7IHBvc2l0aW9uOiBmaXhlZDsgbWFyZ2luLXRvcDogMTVweDsgfSAuZXJyb3JEaXNwbGF5RnVsbE1lc3NhZ2VMaXN0IHsgb3ZlcmZsb3c6IGF1dG87IHdoaXRlLXNwYWNlOiBub3dyYXA7IGhlaWdodDogODBweDsgbWFyZ2luLXRvcDogNXB4OyB9IC5lcnJvckRpc3BsYXlPcHRpb25zeyBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGOyBkaXNwbGF5OiBpbmxpbmU7IH0gPC9zdHlsZT4nKSk7XG4iLCIvKipcbiAqIEF0dHJcbiAqIFxuICogQ3JlYXRlcyBhbiBlbmNhcHN1bGF0ZWQsIGNoYWluYWJsZSBhdHRyaWJ1dGUgdGhhdCBhcmUgdmFsaWRhdGVkIGJ5IFxuICogdXNlci1zcGVjaWZpZWQgdmFsaWRhdGlvbiBmdW5jdGlvbnMgYW5kIGNhbiBiZSBhdHRhY2hlZCB0byBhbiBhcmJpdHJhcnlcbiAqIEphdmFTY3JpcHQgb2JqZWN0LiBUaGV5IGNhbiBhbHNvIGNhbGwgdXNlci1zcGVjaWZpZWQgbGlzdGVuZXJzIHVwb24gYmVpbmdcbiAqIGFjY2Vzc2VkIG9yIGNoYW5nZWQuXG4gKlxuICogSmVybWFpbmUgbW9kZWxzIGhvbGQgYW5kIG1hbmlwdWxhdGUgQXR0ciAoYW5kIEF0dHJMaXN0KSBvYmplY3RzIHVudGlsIHRoZXlcbiAqIGFyZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuXG4gKi9cblxuLyohXG4gKlxuICogTm90ZXMgYW5kIFRvRG9zOlxuICogKyB3aGF0IGFib3V0IGlzTm90R3JlYXRlclRoYW4oKT8sIGlzTm90TGVzc1RoYW4oKT8gIE9yLCBiZXR0ZXIgc3RpbGw6IGFcbiAqICAgZ2VuZXJhbCAnbm90JyBvcGVyYXRvciwgYXMgaW4gamFzbWluZT9cbiAqXG4gKiArIEF0dHIgc2hvdWxkIGJlIGRlY291cGxlZCBmcm9tIEF0dHJMaXN0LCBzZWUgdGhlIGNsb25lKCkgbWV0aG9kXG4gKlxuICogKyBTZWUgaXNzdWUgMjQgb24gZ2l0aHViXG4gKi9cblwidXNlIHN0cmljdFwiO1xuIFxudmFyIEF0dHIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBBdHRyTGlzdCA9IHJlcXVpcmUoJy4vYXR0cl9saXN0LmpzJyksXG4gICAgICAgIFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdmFsaWRhdG9yLmpzJyk7XG5cbiAgICB2YXIgdmFsaWRhdG9ycyA9IFtdLFxuICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJpbnZhbGlkIHNldHRlciBjYWxsIGZvciBcIiArIG5hbWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb24sXG4gICAgICAgIGksXG4gICAgICAgIHByb3AsXG4gICAgICAgIGFkZFZhbGlkYXRvcixcbiAgICAgICAgaW1tdXRhYmxlID0gZmFsc2UsXG4gICAgICAgIHZhbGlkYXRvcixcbiAgICAgICAgbGlzdGVuZXJzID0ge307XG5cbiAgICAvLyBjaGVjayBmb3IgZXJyb3JzIHdpdGggY29uc3RydWN0b3IgcGFyYW1ldGVyc1xuICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQgfHwgdHlwZW9mKG5hbWUpICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyOiBjb25zdHJ1Y3RvciByZXF1aXJlcyBhIG5hbWUgcGFyYW1ldGVyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2hpY2ggbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdXAgdGhlIHZhbGlkYXRvciB0aGF0IGNvbWJpbmVzIGFsbCB2YWxpZGF0b3JzXG4gICAgdmFsaWRhdG9yID0gZnVuY3Rpb24gKHRoaW5nQmVpbmdWYWxpZGF0ZWQpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbGlkYXRvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnNbaV0odGhpbmdCZWluZ1ZhbGlkYXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIE1PRElGSUVSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGlzIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiB2YWxpZGF0b3IuIFRoaXMgYWxzbyBhbGxvd3NcbiAgICAgKiB0aGlzLm1lc3NhZ2UgdG8gYmUgb3ZlcnJpZGRlbiB0byBzcGVjaWZ5IHRoZSBlcnJvciBtZXNzYWdlIG9uXG4gICAgICogdmFsaWRhdGlvbiBmYWlsdXJlLlxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgICAgYWdlLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGFnZSkge1xuICAgICAqICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJhZ2UgbXVzdCBiZSBiZXR3ZWVuIDE4IGFuZCA5OSwgXCIgKyBhZ2UgK1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgXCIgZmFpbHMuXCI7XG4gICAgICogICAgICAgICByZXR1cm4gYWdlID49IDE4ICYmIGFnZSA8PSA5OTtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgbmFtZS52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICogICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIm5hbWUgbXVzdCBiZSBhIHN0cmluZyBhbmQgY29udGFpbiBhdCBsZWFzdFwiICtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIFwiIDMgbGV0dGVycywgXCIgKyBuYW1lICsgXCIgZmFpbHMuXCI7XG4gICAgICogICAgICAgICByZXR1cm4gdHlwZW9mKG5hbWUpID09PSBcInN0cmluZyAmJiBuYW1lLmxlbmd0aCA+PSAzO1xuICAgICAqICAgICB9KTtcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBhcmd1bWVudCBwYXNzZXMgdmFsaWRhdGlvbiBcbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkYXRlc1dpdGggPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodHlwZW9mKHYpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2gobmV3IFZhbGlkYXRvcih2KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHI6IHZhbGlkYXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXNzaWduIGEgZGVmYXVsdCB2YWx1ZSB0byBhbGwgYXR0cmlidXRlcyBvZiB0aGlzIHR5cGUuIFRoZSBkZWZhdWx0XG4gICAgICogdmFsdWUgbWF5IGJlIGFuIGV4cGxpY2l0IHZhbHVlIG9yIG9iamVjdCwgb3IgaXQgbWF5IGJlIGEgZnVuY3Rpb25cbiAgICAgKiB0aGF0IHJldHVybnMgYSBkZWZhdWx0IHZhbHVlLlxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3ZhbHVlfSB0aGUgZXhwbGljaXQgZGVmYXVsdCB2YWx1ZSwgb3IgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogICAgICAgICAgICAgICAgcmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdHNUbyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBkZWZhdWx0VmFsdWVPckZ1bmN0aW9uID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRoaXMgYXR0cmlidXRlIHJlYWQtb25seS4gSWYgYSBzZXR0ZXIgaXMgY2FsbGVkIG9uIHRoaXNcbiAgICAgKiBhdHRyaWJ1dGUsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICAgKlxuICAgICAqIEV4YW1wbGVzOlxuICAgICAqL1xuICAgIHRoaXMuaXNSZWFkT25seSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW1tdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdGhpcyBhdHRyaWJ1dGUgd3JpdGFibGUuIE5vdGUgdGhhdCB0aGlzIGlzIHRoZSBkZWZhdWx0IGZvciBhbGwgXG4gICAgICogYXR0cmlidXRlcywgYnV0IHRoaXMgbWF5IGJlIGNhbGxlZCBpZiBhbiBhdHRyaWJ1dGUgaGFzIGJlZW4gc2V0IHRvXG4gICAgICogcmVhZCBvbmx5IGFuZCB0aGVuIG5lZWRzIHRvIGJlIGNoYW5nZWQgYmFja1xuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICovXG4gICAgdGhpcy5pc1dyaXRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbW11dGFibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgYSBsaXN0ZW5lciBmb3IgJ3NldHMnIG9yICdnZXRzJyB0byB0aGlzIGF0dHJpYnV0ZS4gSXQgdGhyb3dzXG4gICAgICogYW4gZXJyb3IgaWYgdGhlIGV2ZW50IGlzIG5vdCBcInNldFwiIG9yIFwiZ2V0XCIsIGFuZCBpZiBhIHNldHRlciBpc1xuICAgICAqIGFscmVhZHkgc2V0IHVwIGZvciB0aGUgZXZlbnQsIGl0IG92ZXJyaWRlcyBpdC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGVzOlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gU3RyaW5nIHRoYXQgY2FuIG9ubHkgYmUgXCJzZXRcIiBvciBcImdldFwiXG4gICAgICogQHBhcmFtIHtsaXN0ZW5lcn0gRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzXG4gICAgICovXG4gICAgdGhpcy5vbiA9IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50ICE9PSBcInNldFwiICYmIGV2ZW50ICE9PSBcImdldFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyOiBmaXJzdCBhcmd1bWVudCB0byB0aGUgJ29uJyBtZXRob2QgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hvdWxkIGJlICdzZXQnIG9yICdnZXQnXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihsaXN0ZW5lcikgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0cjogc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSAnb24nIG1ldGhvZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaG91bGQgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gRU5EIE1PRElGSUVSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBHRVRURVJTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhpcyBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjb21iaW5lcyBhbGwgb2YgdGhlIHZhbGlkYXRvcnMgaW50b1xuICAgICAqIGEgc2luZ2xlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9yIGZhbHNlLlxuICAgICAqL1xuICAgIHRoaXMudmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBFTkQgR0VUVEVSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBTWU5UQUNUSUMgU1VHQVIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIEFuIGFsaWFzIGZvciB0aGlzIG9iamVjdCwgZm9yIHJlYWRhYmlsaXR5IHdoZW4gY2FsbGluZyBtdWx0aXBsZVxuICAgICAqIG1vZGlmaWVyc1xuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICovXG4gICAgdGhpcy5hbmQgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWxpYXMgZm9yIHRoaXMgb2JqZWN0LCBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKi9cbiAgICB0aGlzLndoaWNoID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIEFuIGFsaWFzIGZvciBpc1JlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5pc0ltbXV0YWJsZSA9IHRoaXMuaXNSZWFkT25seTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFsaWFzIGZvciBpc1dyaXRhYmxlXG4gICAgICovXG4gICAgdGhpcy5pc011dGFibGUgPSB0aGlzLmlzV3JpdGFibGU7XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBFTkQgU1lOVEFDVElDIFNVR0FSIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBVVElMSVRJRVMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHdpdGggdGhlIHNhbWUgbW9kaWZpZXJzLCBkZWZhdWx0VmFsdWUsIGFuZFxuICAgICAqIHZhbGlkYXRvcnMuIFRoaXMgaXMgdXNlZCBpbiBKZXJtYWluZSdzIGFwcHJvYWNoIHRvIGluaGVyaXRhbmNlLlxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICovXG4gICAgdGhpcy5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSByZXN1bHQgdG8gdGhlIGRlZmF1bHQgYXR0cmlidXRlIG9yIGF0dHJpYnV0ZSBsaXN0XG4gICAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRvIG1ha2UgdGhpcyB3b3JrIHdpdGhvdXQgZXhwbGljaXRseVxuICAgICAgICAvLyAgICAgICBrbm93aW5nIGFib3V0IEF0dHJMaXN0IHNvIGl0IGNhbiBiZSBkZWNvdXBsZWQgZnJvbSB0aGlzXG4gICAgICAgIC8vICAgICAgIGNvZGVcbiAgICAgICAgcmVzdWx0ID0gdGhpcyBpbnN0YW5jZW9mIEF0dHJMaXN0P25ldyBBdHRyTGlzdChuYW1lKTpuZXcgQXR0cihuYW1lKTtcblxuICAgICAgICAvLyBhZGQgdGhpcyBhdHRyaWJ1dGVzIHZhbGlkYXRvcnMgdG8gdGhlIG5ldyBhdHRyaWJ1dGVcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbGlkYXRvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWxpZGF0ZXNXaXRoKHZhbGlkYXRvcnNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBzYW1lIGRlZmF1bHQgZm9yIHRoZSBuZXcgYXR0cmlidXRlXG4gICAgICAgIHJlc3VsdC5kZWZhdWx0c1RvKGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb24pO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0aGlzIGF0dHIgaXMgaW1tdXRhYmxlLCB0aGUgY2xvbmVkIGF0dHIgc2hvdWxkIGFsc28gYmVcbiAgICAgICAgLy8gaW1tdXRhYmxlXG4gICAgICAgIGlmIChpbW11dGFibGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pc0ltbXV0YWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBhdHRhY2hlcyB0aGUgYXR0cmlidXRlIHRvIGEgY29uY3JldGUgb2JqZWN0LiBJdCBhZGRzIHRoZVxuICAgICAqIGdldHRlci9zZXR0ZXIgZnVuY3Rpb24gdG8gdGhlIG9iamVjdCwgYW5kIGNhcHR1cmVzIHRoZSBhY3R1YWxcbiAgICAgKiB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGluIGEgY2xvc3VyZS5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHRpbmcgZ2V0dGVyL3NldHRlciBjYWxscyBhbGwgdmFsaWRhdG9ycyBvbiB0aGUgcGFyYW1ldGVyXG4gICAgICogYW5kIGNhbGxzIHRoZSBhcHByb3ByaWF0ZSBsaXN0ZW5lciBvbiB0aGlzIGF0dHJpYnV0ZS4gSXQgYWxzb1xuICAgICAqIHJldHVybnMgdGhlIG9iamVjdCBpdHNlbGYgc28gdGhhdCBhdHRyaWJ1dGUgc2V0dGVycyBjYW4gYmUgY2hhaW5lZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGVzOlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmp9IHRoZSBvYmplY3QgdG8gd2hpY2ggdGhpcyBhdHRyaWJ1dGUgd2lsbCBiZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIHRoaXMuYWRkVG8gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUsXG4gICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICBpZiAoIW9iaiB8fCB0eXBlb2Yob2JqKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHI6IGFkZEF0dHIgbWV0aG9kIHJlcXVpcmVzIGFuIG9iamVjdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBhdHRyaWJ1dGUgZ2V0dGVyL3NldHRlciBtZXRob2QgdGhhdCBnZXRzIGFkZGRlZCB0b1xuICAgICAgICAvLyB0aGUgb2JqZWN0XG4gICAgICAgIG9ialtuYW1lXSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByZVZhbHVlO1xuXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHNldHRlclxuICAgICAgICAgICAgICAgIGlmIChpbW11dGFibGUgJiYgYXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHNldCB0aGUgaW1tdXRhYmxlIHByb3BlcnR5IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKyBcIiBhZnRlciBpdCBoYXMgYmVlbiBzZXRcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdmFsaWRhdG9yKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG9sZFZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHByZVZhbHVlID0gYXR0cmlidXRlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IHNldCB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgc2V0IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMuc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQuY2FsbChvYmosIG5ld1ZhbHVlLCBwcmVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgZ2V0IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZ2V0LmNhbGwob2JqLCBhdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgLy8gYXNzaWduIHRoZSBkZWZhdWx0IHZhbHVlLCBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaXMgYSBmdW5jdGlvblxuICAgICAgICAvLyBvciBhbiBleHBsaWNpdCB2YWx1ZVxuICAgICAgICBkZWZhdWx0VmFsdWUgPSB0eXBlb2YoZGVmYXVsdFZhbHVlT3JGdW5jdGlvbikgPT09ICdmdW5jdGlvbic/XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVPckZ1bmN0aW9uKCk6XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVPckZ1bmN0aW9uO1xuXG4gICAgICAgIC8vIGNhbGwgdGhlIHNldHRlciB3aXRoIHRoZSBkZWZhdWx0VmFsdWUgdXBvbiBhdHRhY2hpbmcgaXQgdG8gdGhlXG4gICAgICAgIC8vIG9iamVjdFxuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsaWRhdG9yKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICAgIG9ialtuYW1lXShkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICF2YWxpZGF0b3IoZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0cjogRGVmYXVsdCB2YWx1ZSBvZiBcIiArIGRlZmF1bHRWYWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgZG9lcyBub3QgcGFzcyB2YWxpZGF0aW9uIGZvciBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEVORCBVVElMSVRJRVMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIFZBTElEQVRPUiBSRUxBVEVEIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLy8gYWRkIGEgc2luZ2xlIHZhbGlkYXRvciBvYmplY3QgdG8gdGhlIGF0dHJpYnV0ZVxuICAgIGFkZFZhbGlkYXRvciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoYXRbbmFtZV0gPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3IuZ2V0VmFsaWRhdG9yKG5hbWUpKHBhcmFtKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gdGhlIFZhbGlkYXRvciBvYmplY3QgY29udGFpbnMgc2V2ZXJhbCBkZWZhdWx0IHZhbGlkYXRvcnNcbiAgICAvLyB0aGF0IG5lZWQgdG8gYmUgYXR0YWNoZWQgdG8gYWxsIEF0dHJzXG4gICAgZm9yIChpID0gMDsgaSA8IFZhbGlkYXRvci52YWxpZGF0b3JzKCkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYWRkVmFsaWRhdG9yKFZhbGlkYXRvci52YWxpZGF0b3JzKClbaV0pO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEVORCBWQUxJREFUT1IgUkVMQVRFRCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBBdHRyID0gcmVxdWlyZSgnLi9hdHRyLmpzJyk7XG5cbnZhciBBdHRyTGlzdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGxpc3RlbmVycyA9IHt9O1xuXG5cbiAgICAvL3RoaXMgaXMgd2hlcmUgdGhlIGluaGVyaXRhbmNlIGhhcHBlbnMgbm93XG4gICAgQXR0ci5jYWxsKHRoaXMsIG5hbWUpO1xuXG4gICAgdmFyIGRlbGVnYXRlID0gZnVuY3Rpb24gKG9iaiwgZnVuYykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqW2Z1bmNdLmFwcGx5KG9iaiwgYXJndW1lbnRzKTsgfTtcbiAgICB9O1xuXG4gICAgLy9zeW50YWN0aWMgc3VnYXIgdG8ga2VlcCB0aGluZ3MgZ3JhbW1hdGljYWxseSBjb3JyZWN0XG4gICAgdGhpcy52YWxpZGF0ZVdpdGggPSB0aGlzLnZhbGlkYXRlc1dpdGg7XG5cbiAgICAvL2Rpc2FibGUgZGVmYXVsdHNUbyBhbmQgaXNJbW11dGFibGUgdW50aWwgd2UgZmlndXJlIG91dCBob3cgdG8gbWFrZSBpdCBtYWtlIHNlbnNlXG4gICAgdGhpcy5kZWZhdWx0c1RvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvL25vIG9wXG4gICAgfTtcblxuICAgIHRoaXMuaXNJbW11dGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vbm8gb3BcbiAgICB9O1xuXG4gICAgdGhpcy5pc011dGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vbm8gb3BcbiAgICB9O1xuXG4gICAgdGhpcy5lYWNoT2ZXaGljaCA9IHRoaXM7XG5cbiAgICB0aGlzLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoZXZlbnQgIT09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHJMaXN0OiAnb24nIG9ubHkgcmVzcG9uZHMgdG8gJ2FkZCcgZXZlbnRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGxpc3RlbmVyKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyTGlzdDogJ29uJyByZXF1aXJlcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IGxpc3RlbmVyO1xuICAgIH07XG5cblxuICAgIHRoaXMuYWRkVG8gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBwcm9wLFxuICAgICAgICAgICAgYXJyID0gW10sXG4gICAgICAgICAgICBhY3R1YWxMaXN0ID0ge307XG4gICAgICAgIGlmKCFvYmogfHwgdHlwZW9mKG9iaikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyTGlzdDogYWRkVG8gbWV0aG9kIHJlcXVpcmVzIGFuIG9iamVjdCBwYXJhbWV0ZXJcIik7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0dWFsTGlzdC5wb3AgPSBkZWxlZ2F0ZShhcnIsIFwicG9wXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhY3R1YWxMaXN0LmFkZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0aGF0LnZhbGlkYXRvcigpKShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5hZGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9saXN0ZW5lcnMuYWRkLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5hZGQuY2FsbChvYmosIGl0ZW0sIGFjdHVhbExpc3Quc2l6ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhhdC5lcnJvck1lc3NhZ2UoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYWN0dWFsTGlzdC5yZXBsYWNlID0gZnVuY3Rpb24gKGluZGV4LCBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZihpbmRleCkgIT09ICdudW1iZXInKSB8fCAocGFyc2VJbnQoaW5kZXgsIDEwKSAhPT0gaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHJMaXN0OiByZXBsYWNlIG1ldGhvZCByZXF1aXJlcyBpbmRleCBwYXJhbWV0ZXIgdG8gYmUgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHJMaXN0OiByZXBsYWNlIG1ldGhvZCBpbmRleCBwYXJhbWV0ZXIgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoISh0aGF0LnZhbGlkYXRvcigpKShvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGF0LmVycm9yTWVzc2FnZSgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJbaW5kZXhdID0gb2JqO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYWN0dWFsTGlzdC5hdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5zaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ckxpc3Q6IEluZGV4IG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJbaW5kZXhdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy90byBrZWVwIHRoaW5ncyBtb3JlIGphdmEteVxuICAgICAgICAgICAgYWN0dWFsTGlzdC5nZXQgPSBhY3R1YWxMaXN0LmF0O1xuXG4gICAgICAgICAgICBhY3R1YWxMaXN0LnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyci5sZW5ndGg7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhY3R1YWxMaXN0LnRvSlNPTiA9IGZ1bmN0aW9uIChKU09OcmVwcykge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgXG4gICAgICAgICAgICAgICAgICAgIGksIGo7XG5cbiAgICAgICAgICAgICAgICAvL2NoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgY3VycmVudCBsaXN0IGlzIG5vdCBpbiBKU09OcmVwc1xuICAgICAgICAgICAgICAgIGlmIChKU09OcmVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7aSA8IEpTT05yZXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSlNPTnJlcHNbaV0ub2JqZWN0ID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTnJlcHNbaV0uSlNPTnJlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0udG9KU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJbaV0udG9KU09OKEpTT05yZXBzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvYmpbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbExpc3Q7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8vIC8vdGhpcyBuZWVkcyB0byBzdGF5IGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpbnN0YW5jZW9mXG4vLyAvL2J1dCBub3RlIHdlIG92ZXJyaWRlIGFsbCBvZiB0aGUgbWV0aG9kcyB2aWEgZGVsZWdhdGlvblxuLy8gLy9zbyBpdCdzIG5vdCBkb2luZyBhbnl0aGluZyBleGNlcHQgZm9yIG1ha2luZyBhbiBBdHRyTGlzdFxuLy8gLy9hbiBpbnN0YW5jZSBvZiBBdHRyXG4vL0F0dHJMaXN0LnByb3RvdHlwZSA9IG5ldyBBdHRyKG5hbWUpO1xuQXR0ckxpc3QucHJvdG90eXBlID0gbmV3IEF0dHIoXCI/Pz9cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gQXR0ckxpc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBtZXRob2QpIHtcbiAgICBpZiAoIW5hbWUgfHwgdHlwZW9mKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7IFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Q6IGNvbnN0cnVjdG9yIHJlcXVpcmVzIGEgbmFtZSBwYXJhbWV0ZXIgd2hpY2ggbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9IGVsc2UgaWYgKCFtZXRob2QgfHwgdHlwZW9mKG1ldGhvZCkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Q6IHNlY29uZCBwYXJhbWV0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmFkZFRvID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoIW9iaiB8fCB0eXBlb2Yob2JqKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZDogYWRkVG8gbWV0aG9kIHJlcXVpcmVzIGFuIG9iamVjdCBwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG9ialtuYW1lXSA9IG1ldGhvZDtcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXRob2Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZSgnLi4vdXRpbC9pbmRleF9vZi5qcycpO1xuXG52YXIgbW9kZWxzID0ge307XG5cbi8qKlxuICogdGhpcyBmdW5jdGlvbiByZXR1cm4gYSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggYSBuYW1lXG4gKi9cbnZhciBnZXRNb2RlbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHR5cGVvZihuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKZXJtYWluZTogYXJndW1lbnQgdG8gZ2V0TW9kZWwgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG5cbiAgICBpZiAobW9kZWxzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbW9kZWwgYnkgdGhlIG5hbWUgb2YgXCIgKyBuYW1lICsgXCIgZm91bmRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsc1tuYW1lXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgbW9kZWwgbmFtZXMgc3RvcmVkIGJ5XG4gKiBqZXJtYWluZVxuICovXG52YXIgZ2V0TW9kZWxzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbW9kZWwsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgIFxuICAgIGZvciAobW9kZWwgaW4gbW9kZWxzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1vZGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgbW9kZWwgY29uc3RydWN0b3JcbiAqL1xuXG52YXIgTW9kZWwgPSBmdW5jdGlvbiAoc3BlY2lmaWNhdGlvbikge1xuICAgIHZhciBtZXRob2RzID0ge30sXG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7fSxcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgbW9kZWxOYW1lLFxuICAgICAgICBtb2RpZmllZCA9IHRydWUsXG4gICAgICAgIHJlcXVpcmVkQ29uc3RydWN0b3JBcmdzID0gW10sXG4gICAgICAgIG9wdGlvbmFsQ29uc3RydWN0b3JBcmdzID0gW10sXG4gICAgICAgIHBhcmVudHMgPSBbXSxcbiAgICAgICAgTWV0aG9kID0gcmVxdWlyZSgnLi9tZXRob2QuanMnKSxcbiAgICAgICAgQXR0ciA9IHJlcXVpcmUoJy4vYXR0ci5qcycpLFxuICAgICAgICBBdHRyTGlzdCA9IHJlcXVpcmUoJy4vYXR0cl9saXN0LmpzJyksXG4gICAgICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRfZW1pdHRlci5qcycpLFxuICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgbGlzdFByb3BlcnRpZXMsXG4gICAgICAgIHVwZGF0ZUNvbnN0cnVjdG9yLFxuICAgICAgICBpc0ltbXV0YWJsZSxcbiAgICAgICAgaW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgY29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgbW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAvL3ZhbGlkYXRlIHRoZSBtb2RlbCBpZiBpdCBoYXMgYmVlbiBtb2RpZmllZFxuICAgICAgICAgICAgICAgIG1vZGVsLnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZihzcGVjaWZpY2F0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kZWxOYW1lID0gc3BlY2lmaWNhdGlvbjtcbiAgICAgICAgICAgIHNwZWNpZmljYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbW9kZWxOYW1lID0gc3BlY2lmaWNhdGlvbjtcbiAgICAgICAgc3BlY2lmaWNhdGlvbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdO1xuICAgIH1cblxuICAgIC8vaGFuZGxlIHNwZWNpZmljYXRpb24gZnVuY3Rpb25cbiAgICBpZiAoc3BlY2lmaWNhdGlvbiAmJiB0eXBlb2Yoc3BlY2lmaWNhdGlvbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBtb2RlbCA9IG5ldyBNb2RlbChtb2RlbE5hbWUpO1xuICAgICAgICBzcGVjaWZpY2F0aW9uLmNhbGwobW9kZWwpO1xuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSBlbHNlIGlmIChzcGVjaWZpY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsOiBzcGVjaWZpY2F0aW9uIHBhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgLy9oYW5kbGUgbW9kZWwgbmFtZVxuICAgIGlmIChtb2RlbE5hbWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YobW9kZWxOYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtb2RlbHNbbW9kZWxOYW1lXSA9IG1vZGVsO1xuICAgIH0gZWxzZSBpZiAobW9kZWxOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWw6IG1vZGVsIG5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG5cbiAgICBcbiAgICAvKioqKioqKioqKiBCRUdJTiBQUklWQVRFIE1FVEhPRFMgKioqKioqKioqKioqKioqKi9cbiAgICAvKiBwcml2YXRlIG1ldGhvZCB0aGF0IGFic3RyYWN0cyBoYXNBL2hhc01hbnkgKi9cbiAgICB2YXIgaGFzQVByb3BlcnR5ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUpIHtcbiAgICAgICAgdmFyIFByb3BlcnR5LFxuICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTtcblxuICAgICAgICAvL1Byb3BlcnR5IGlzIG9uZSBvZiBBdHRyIG9yIEF0dHJMaXN0XG4gICAgICAgIFByb3BlcnR5ID0gdHlwZT09PVwiQXR0clwiP0F0dHI6QXR0ckxpc3Q7XG5cbiAgICAgICAgLy9tZXRob2ROYW1lIGlzIGVpdGhlciBoYXNBIG9yIGhhc01hbnlcbiAgICAgICAgbWV0aG9kTmFtZSA9IHR5cGU9PT1cIkF0dHJcIj9cImhhc0FcIjpcImhhc01hbnlcIjtcblxuICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mKG5hbWUpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYXR0cmlidXRlID0gbmV3IFByb3BlcnR5KG5hbWUpO1xuICAgICAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbDogXCIgKyBtZXRob2ROYW1lICsgXCIgcGFyYW1ldGVyIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogcHJpdmF0ZSBtZXRob2QgdGhhdCBhYnN0cmFjdHMgYXR0cmlidXRlL21ldGhvZCAqL1xuICAgIHByb3BlcnR5ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAodHlwZW9mKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbDogZXhwZWN0ZWQgc3RyaW5nIGFyZ3VtZW50IHRvIFwiICsgdHlwZSArIFwiIG1ldGhvZCwgYnV0IHJlY2lldmVkIFwiICsgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0eXBlPT09XCJhdHRyaWJ1dGVcIiA/IGF0dHJpYnV0ZXNbbmFtZV0gOiBtZXRob2RzW25hbWVdO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWw6IFwiICsgdHlwZSArIFwiIFwiICsgbmFtZSAgKyBcIiBkb2VzIG5vdCBleGlzdCFcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKiBwcml2YXRlIG1ldGhvZCB0aGF0IGFic3RyYWN0cyBhdHRyaWJ1dGVzL21ldGhvZHMgKi9cbiAgICBsaXN0UHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbGlzdCA9IFtdLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHR5cGU9PT1cImF0dHJpYnV0ZXNcIj9hdHRyaWJ1dGVzOm1ldGhvZHM7XG5cbiAgICAgICAgZm9yIChpIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIC8qIHByaXZhdGUgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHRoZSBjb25zdHJ1Y3RvciAqL1xuICAgIHVwZGF0ZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpLCBqLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlTGlzdCA9IG1vZGVsLmF0dHJpYnV0ZXMoKSwgXG4gICAgICAgICAgICAgICAgbWV0aG9kTGlzdCA9IG1vZGVsLm1ldGhvZHMoKSwgXG4gICAgICAgICAgICAgICAgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKSxcbiAgICAgICAgICAgICAgICBhdHRyLFxuICAgICAgICAgICAgICAgIGF0dHJDaGFuZ2VMaXN0ZW5lcnMgPSB7fSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VIYW5kbGVyLFxuICAgICAgICAgICAgICAgIGFkZFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBtb2RlbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9iYWQgZm9ybSwgYnV0IGhvcGVmdWxseSB0ZW1wb3JhcnlcbiAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgbmV3Y2FwOmZhbHNlICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbW9kZWwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2JhZCBmb3JtLCBidXQgaG9wZWZ1bGx5IHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgICAgICAvKmpzaGludCBuZXdjYXA6ZmFsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtb2RlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihcIk1vZGVsOiBpbnN0YW5jZXMgbXVzdCBiZSBjcmVhdGVkIHVzaW5nIHRoZSBuZXcgb3BlcmF0b3JcIik7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8gUFVCTElDIEFQSSBGT1IgQUxMIElOU1RBTkNFUyAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgbWV0aG9kIGFzc29jaWF0ZWQgd2l0aCB1bml0IHRlc3RcbiAgICAgICAgICAgIC8vIGl0KFwic2hvdWxkIG5vdCBpbmNyZW1lbnQgdGhlIGxpc3RlbmVycyBhc3NvY2lhdGVkIHdpdGggdGhlIGxhc3Qgb2JqZWN0IGNyZWF0ZWRcIlxuICAgICAgICAgICAgLy8gaXQgaGFzIGJlZW4gcmVtb3ZlZCBub3cgdGhhdCB0aGUgYnVnIGhhcyBiZWVuIGZpeGVkXG4gICAgICAgICAgICAvKnRoaXMuYXR0ckNoYW5nZUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICByZXR1cm4gYXR0ckNoYW5nZUxpc3RlbmVycztcbiAgICAgICAgICAgICB9OyovXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgRXZlbnRFbWl0dGVyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcmFwcGVyIG1ldGhvZHMgYWRkZWQgdG8gdGhlIGludGVybmFsIEV2ZW50RW1pdHRlciBvYmplY3RcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUplcm1haW5lQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIG9iaikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoYXR0ck5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dHJOYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoudG9KU09OID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5lbWl0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqIG11c3QgYmUgYSBqZXJtYWluZSBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihcImNoYW5nZVwiLCBhdHRyQ2hhbmdlTGlzdGVuZXJzW2F0dHJOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyKCkuYWRkSmVybWFpbmVDaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihhdHRyTmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ck5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihvYmopICE9PSBcIm9iamVjdFwiIHx8IG9iai50b0pTT04gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmVtaXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmogbXVzdCBiZSBhIGplcm1haW5lIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ckNoYW5nZUxpc3RlbmVyc1thdHRyTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ckNoYW5nZUxpc3RlbmVyc1thdHRyTmFtZV0gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAmJiBlbWl0ID09PSB0cnVlOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YS5wdXNoKGRhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXS5vcmlnaW4gPT09IHRoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhLnB1c2goe2tleTphdHRyTmFtZSwgb3JpZ2luOnRoYXR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5lbWl0KFwiY2hhbmdlXCIsIG5ld0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmouZW1pdHRlcigpLm9uKFwiY2hhbmdlXCIsIGF0dHJDaGFuZ2VMaXN0ZW5lcnNbYXR0ck5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIHRoaXMgaW5zdGFuY2UncyBjaGFuZ2VzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vbiA9IHRoaXMuZW1pdHRlcigpLm9uO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVtaXRzIGFuIGV2ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW1pdCA9IHRoaXMuZW1pdHRlcigpLmVtaXQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudG9KU09OID0gZnVuY3Rpb24gKEpTT05yZXBzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpLCBqLFxuICAgICAgICAgICAgICAgICAgICB0aGlzSlNPTnJlcCA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVKU09OcmVwO1xuXG4gICAgICAgICAgICAgICAgaWYgKEpTT05yZXBzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY2FsbFxuICAgICAgICAgICAgICAgICAgICBKU09OcmVwcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBKU09OcmVwcy5wdXNoKHtvYmplY3Q6dGhpcywgSlNPTnJlcDp0aGlzSlNPTnJlcH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKEpTT05yZXBzKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBlcnJvciBjb25kaXRpb24gXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluc3RhbmNlOiB0b0pTT04gc2hvdWxkIG5vdCB0YWtlIGEgcGFyYW1ldGVyICh1bmxlc3MgY2FsbGVkIHJlY3Vyc2l2ZWx5KVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBjdXJyZW50IEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QsIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgSlNPTnJlcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChKU09OcmVwc1tpXS5vYmplY3QgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzSlNPTnJlcCA9IEpTT05yZXBzW2ldLkpTT05yZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlidXRlTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVKU09OcmVwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlVmFsdWUgPSB0aGlzW2F0dHJpYnV0ZUxpc3RbaV1dKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBjdXJyZW50IEpTT04gcmVwcmVzZW50YXRpb24gZm9yIHRoZSBhdHRyaWJ1dGUsIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgSlNPTnJlcHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChKU09OcmVwc1tqXS5vYmplY3QgPT09IGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSlNPTnJlcCA9IEpTT05yZXBzW2pdLkpTT05yZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBhdHRyaWJ1dGVWYWx1ZSAhPT0gbnVsbCAmJiBhdHRyaWJ1dGVWYWx1ZS50b0pTT04gIT09IHVuZGVmaW5lZCAmJiBhdHRyaWJ1dGVKU09OcmVwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgZW50cnkgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUpTT05yZXAgPSAoYXR0cmlidXRlc1thdHRyaWJ1dGVMaXN0W2ldXSBpbnN0YW5jZW9mIEF0dHJMaXN0KT9bXTp7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT05yZXBzLnB1c2goe29iamVjdDphdHRyaWJ1dGVWYWx1ZSwgSlNPTnJlcDphdHRyaWJ1dGVKU09OcmVwfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OcmVwc1tKU09OcmVwcy5sZW5ndGgtMV0uSlNPTnJlcCA9IGF0dHJpYnV0ZVZhbHVlLnRvSlNPTihKU09OcmVwcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBmaWxsIG91dCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgdGhpcyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0cmlidXRlSlNPTnJlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0pTT05yZXBbYXR0cmlidXRlTGlzdFtpXV0gPSBhdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNKU09OcmVwW2F0dHJpYnV0ZUxpc3RbaV1dID0gYXR0cmlidXRlSlNPTnJlcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0pTT05yZXA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IChwYXR0ZXJuICE9PSB1bmRlZmluZWQpP3BhdHRlcm46ZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkplcm1haW5lIE1vZGVsIEluc3RhbmNlXCI7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vIEVORCBQVUJMSUMgQVBJIEZPUiBBTEwgSU5TVEFOQ0VTIC8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgaXMgYSBwcml2YXRlIG1ldGhvZCB0aGF0IHNldHMgdXAgaGFuZGxpbmcgZm9yIHRoZSBzZXR0ZXJcbiAgICAgICAgICAgICAqIEl0IGF0dGFjaGVzIGEgY2hhbmdlIGxpc3RlbmVyIG9uIG5ldyBvYmplY3RzXG4gICAgICAgICAgICAgKiBhbmQgaXQgcmVtb3ZlcyB0aGUgY2hhbmdlIGxpc3RlbmVyIGZyb20gb2xkIG9iamVjdHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoYXR0ciBpbnN0YW5jZW9mIEF0dHJMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAvL3doZW4gc2V0IGhhbmRsZXIgaXMgY2FsbGVkLCB0aGlzIHNob3VsZCBiZSB0aGUgY3VycmVudCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgYXR0ci5vbihcInNldFwiLCBmdW5jdGlvbiAobmV3VmFsdWUsIHByZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBwcmVWYWx1ZSBpcyBhIG1vZGVsIGluc3RhbmNlLCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZVZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJlVmFsdWUgIT09IG51bGwgJiYgcHJlVmFsdWUub24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZVZhbHVlLnRvSlNPTiAhPT0gdW5kZWZpbmVkICYmIHByZVZhbHVlLmVtaXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5vdyBhc3N1bWUgcHJlVmFsdWUgaXMgYSBtb2RlbCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbml0eSBjaGVjayAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZVZhbHVlLmVtaXR0ZXIoKS5saXN0ZW5lcnMoXCJjaGFuZ2VcIikubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmVWYWx1ZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBsaXN0ZW5lciBkZWZpbmVkIGlmIGl0IGlzIGEgbW9kZWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUplcm1haW5lQ2hhbmdlTGlzdGVuZXIoYXR0ci5uYW1lKCksIHByZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbmV3VmFsdWUgaXMgYSBtb2RlbCBpbnN0YW5jZSwgd2UgbmVlZCB0byBhdHRhY2ggYSBsaXN0ZW5lciB0byBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSB1bmRlZmluZWQgJiYgbmV3VmFsdWUgIT09IG51bGwgJiYgbmV3VmFsdWUub24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLnRvSlNPTiAhPT0gdW5kZWZpbmVkICYmIG5ld1ZhbHVlLmVtaXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5vdyBhc3N1bWUgbmV3VmFsdWUgaXMgYSBtb2RlbCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBhIGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyKCkuYWRkSmVybWFpbmVDaGFuZ2VMaXN0ZW5lcihhdHRyLm5hbWUoKSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5hbGx5IGVtaXQgdGhhdCBhIGNoYW5nZSBoYXMgaGFwcGVuZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCBbe2tleTphdHRyLm5hbWUoKSwgdmFsdWU6bmV3VmFsdWUsIG9yaWdpbjp0aGlzfV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhdHRyLm9uKFwiYWRkXCIsIGZ1bmN0aW9uIChuZXdWYWx1ZSwgbmV3U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIFt7YWN0aW9uOlwiYWRkXCIsIGtleTphdHRyLm5hbWUoKSwgdmFsdWU6bmV3VmFsdWUsIG9yaWdpbjp0aGlzfV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL3NldCB1cCBldmVudCBoYW5kbGluZyBmb3Igc3ViIG9iamVjdHNcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJ1dGVMaXN0Lmxlbmd0aDsgICsraSkge1xuICAgICAgICAgICAgICAgIGF0dHIgPSBtb2RlbC5hdHRyaWJ1dGUoYXR0cmlidXRlTGlzdFtpXSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcmlseSBub3QgYWRkaW5nIGhhbmRsZXJzIHRvIGF0dHIgbGlzdHNcbiAgICAgICAgICAgICAgICAvLyB1bnRpbCB3ZSBnZXQgdGhlIGJ1Z3Mgc29ydGVkIG91dFxuICAgICAgICAgICAgICAgIC8vIHNlZSBtb2RlbCB0ZXN0IFwic2hvdWxkIG5vdCBhZGQgY2hhbmdlIGxpc3RlbmVycyB0byBhdHRyIGxpc3RcIlxuICAgICAgICAgICAgICAgIC8vaWYgKCEoYXR0ciBpbnN0YW5jZW9mIEF0dHJMaXN0KSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUhhbmRsZXIuY2FsbCh0aGlzLCBhdHRyKTtcbiAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBhZGQgYWxsIG9mIHRoZSBhdHRyaWJ1dGVzIGFuZCB0aGUgbWV0aG9kcyB0byB0aGUgb2JqZWN0XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlidXRlTGlzdC5sZW5ndGggKyBtZXRob2RMaXN0Lmxlbmd0aDsgKytpKSAge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgYXR0cmlidXRlTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgb2JqZWN0IGlzIGltbXV0YWJsZSwgYWxsIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGltbXV0YWJsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmF0dHJpYnV0ZShhdHRyaWJ1dGVMaXN0W2ldKS5pc0ltbXV0YWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmF0dHJpYnV0ZShhdHRyaWJ1dGVMaXN0W2ldKS5hZGRUbyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5tZXRob2QobWV0aG9kTGlzdFtpLWF0dHJpYnV0ZUxpc3QubGVuZ3RoXSkuYWRkVG8odGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBidWlsZCB0aGUgb2JqZWN0IHVzaW5nIHRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAgICAgICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCByZXF1aXJlZENvbnN0cnVjdG9yQXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdHJ1Y3QgYW5kIHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IFwiQ29uc3RydWN0b3IgcmVxdWlyZXMgXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IHJlcXVpcmVkQ29uc3RydWN0b3JBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgKz0gcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgKz0gaT09PXJlcXVpcmVkQ29uc3RydWN0b3JBcmdzLmxlbmd0aC0xP1wiXCI6XCIsIFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVyciArPSBcIiB0byBiZSBzcGVjaWZpZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IHJlcXVpcmVkQ29uc3RydWN0b3JBcmdzLmxlbmd0aCArIG9wdGlvbmFsQ29uc3RydWN0b3JBcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSBhcmd1bWVudHMgdG8gY29uc3RydWN0b3IuIEV4cGVjdGVkIFwiICsgcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MubGVuZ3RoICsgXCIgcmVxdWlyZWQgYXJndW1lbnRzIGFuZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbENvbnN0cnVjdG9yQXJncy5sZW5ndGggKyBcIiBvcHRpb25hbCBhcmd1bWVudHNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgPSBpIDwgcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MubGVuZ3RoP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkQ29uc3RydWN0b3JBcmdzW2ldOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsQ29uc3RydWN0b3JBcmdzW2ktcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MubGVuZ3RoXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmF0dHJpYnV0ZShhdHRyaWJ1dGUpIGluc3RhbmNlb2YgQXR0ckxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSB0aGF0IGFyZ3VtZW50c1tpXSBpcyBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzW2ldKSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsOiBDb25zdHJ1Y3RvciByZXF1aXJlcyAnbmFtZXMnIGF0dHJpYnV0ZSB0byBiZSBzZXQgd2l0aCBhbiBBcnJheVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2l0ZXJhdGUgb3ZlciB0aGUgYXJyYXkgYWRkaW5nIHRoZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJndW1lbnRzW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2F0dHJpYnV0ZV0oKS5hZGQoYXJndW1lbnRzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nbyBhaGVhZCBhbmQgc2V0IGl0IGxpa2Ugbm9ybWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1thdHRyaWJ1dGVdKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpbmFsbHksIGNhbGwgdGhlIGluaXRpYWxpemVyXG4gICAgICAgICAgICBpbml0aWFsaXplci5jYWxsKHRoaXMpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqKioqKioqKioqIEVORCBQUklWQVRFIE1FVEhPRFMgKioqKioqKioqKioqKiovXG5cblxuICAgIC8qKioqKioqKioqKiBCRUdJTiBQVUJMSUMgQVBJICoqKioqKioqKioqKioqKioqL1xuICAgIG1vZGVsLmhhc0EgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICByZXR1cm4gaGFzQVByb3BlcnR5KFwiQXR0clwiLCBhdHRyKTtcbiAgICB9O1xuICAgIFxuICAgIG1vZGVsLmhhc0FuID0gbW9kZWwuaGFzQTtcbiAgICBtb2RlbC5oYXNTb21lID0gbW9kZWwuaGFzQTtcbiAgICBcbiAgICBtb2RlbC5oYXNNYW55ID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgICAgIHJldHVybiBoYXNBUHJvcGVydHkoXCJBdHRyTGlzdFwiLCBhdHRycyk7XG4gICAgfTtcblxuICAgIG1vZGVsLmlzQSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgcGFyZW50TWV0aG9kcyxcbiAgICAgICAgICAgIGlzQU1vZGVsO1xuXG4gICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcblxuICAgICAgICAvL2NoZWNrcyB0byBtYWtlIHN1cmUgYSBwb3RlbnRpYWxNb2RlbCBoYXMgYWxsIGF0dHJpYnV0ZXMgb2YgYSBtb2RlbFxuICAgICAgICBpc0FNb2RlbCA9IGZ1bmN0aW9uIChwb3RlbnRpYWxNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgTSA9IG5ldyBNb2RlbCgpO1xuICAgICAgICAgICAgZm9yIChpIGluIE0pIHtcbiAgICAgICAgICAgICAgICBpZiAoTS5oYXNPd25Qcm9wZXJ0eShpKSAmJiB0eXBlb2YocG90ZW50aWFsTW9kZWxbaV0pICE9PSB0eXBlb2YoTVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vY29uZmlybSBwYXJlbnQgaXMgYSBtb2RlbCB2aWEgZHVjay10eXBpbmdcbiAgICAgICAgaWYgKHR5cGVvZiAocGFyZW50KSAhPT0gXCJmdW5jdGlvblwiIHx8ICFpc0FNb2RlbChwYXJlbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbDogcGFyYW1ldGVyIHNlbnQgdG8gaXNBIGZ1bmN0aW9uIG11c3QgYmUgYSBNb2RlbFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vb25seSBhbGxvdyBzaW5nbGUgaW5oZXJpdGFuY2UgZm9yIG5vd1xuICAgICAgICBpZiAocGFyZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWw6IE1vZGVsIG9ubHkgc3VwcG9ydHMgc2luZ2xlIGluaGVyaXRhbmNlIGF0IHRoaXMgdGltZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYWRkIGF0dHJpYnV0ZXMgYW5kIG1ldGhvZHMgdG8gY3VycmVudCBtb2RlbFxuICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzID0gcGFyZW50c1swXS5hdHRyaWJ1dGVzKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJlbnRBdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlc1twYXJlbnRBdHRyaWJ1dGVzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1twYXJlbnRBdHRyaWJ1dGVzW2ldXSA9IHBhcmVudHNbMF0uYXR0cmlidXRlKHBhcmVudEF0dHJpYnV0ZXNbaV0pLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgLy9zdWJjbGFzcyBhdHRyaWJ1dGVzIGFyZSBtdXRhYmxlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW3BhcmVudEF0dHJpYnV0ZXNbaV1dLmlzTXV0YWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50TWV0aG9kcyA9IHBhcmVudHNbMF0ubWV0aG9kcygpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyZW50TWV0aG9kcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZHNbcGFyZW50TWV0aG9kc1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1ldGhvZHNbcGFyZW50TWV0aG9kc1tpXV0gPSBwYXJlbnRzWzBdLm1ldGhvZChwYXJlbnRNZXRob2RzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAgICAgICAgICAgIFxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtb2RlbC5wcm90b3R5cGUgPSBuZXcgcGFyZW50c1tpXSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZGVsLmlzQW4gPSBtb2RlbC5pc0E7XG5cbiAgICBtb2RlbC5wYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRzWzBdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIG1vZGVsLmF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eShcImF0dHJpYnV0ZVwiLCBhdHRyKTtcbiAgICB9O1xuXG4gICAgbW9kZWwuYXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RQcm9wZXJ0aWVzKFwiYXR0cmlidXRlc1wiKTtcbiAgICB9O1xuXG4gICAgbW9kZWwubWV0aG9kID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5KFwibWV0aG9kXCIsIG0pO1xuICAgIH07XG4gICAgXG4gICAgbW9kZWwubWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RQcm9wZXJ0aWVzKFwibWV0aG9kc1wiKTtcbiAgICB9O1xuXG4gICAgbW9kZWwuaXNCdWlsdFdpdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25hbFBhcmFtRmxhZyA9IGZhbHNlLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHJlcXVpcmVkQ29uc3RydWN0b3JBcmdzID0gW107XG4gICAgICAgIG9wdGlvbmFsQ29uc3RydWN0b3JBcmdzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihhcmd1bWVudHNbaV0pID09PSBcInN0cmluZ1wiICYmIGFyZ3VtZW50c1tpXS5jaGFyQXQoMCkgIT09ICclJykge1xuICAgICAgICAgICAgICAgIC8vaW4gcmVxdWlyZWQgcGFybXNcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWxQYXJhbUZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyBlcnJvclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbDogaXNCdWlsdFdpdGggcmVxdWlyZXMgcGFyYW1ldGVycyBwcmVjZWRlZCB3aXRoIGEgJSB0byBiZSB0aGUgZmluYWwgcGFyYW1ldGVycyBiZWZvcmUgdGhlIG9wdGlvbmFsIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaW5zZXJ0IGludG8gcmVxdWlyZWQgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YoYXJndW1lbnRzW2ldKSA9PT0gXCJzdHJpbmdcIiAmJiBhcmd1bWVudHNbaV0uY2hhckF0KDApID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICAvL2luIG9wdGlvbmFsIHBhcm1zXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxQYXJhbUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vaW5zZXJ0IGludG8gb3B0aW9uYWwgYXJyYXlcbiAgICAgICAgICAgICAgICBvcHRpb25hbENvbnN0cnVjdG9yQXJncy5wdXNoKGFyZ3VtZW50c1tpXS5zbGljZSgxKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYodHlwZW9mKGFyZ3VtZW50c1tpXSkgPT09IFwiZnVuY3Rpb25cIiAmJiBpID09PSBhcmd1bWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vaW5pdCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVyID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbDogaXNCdWlsdFdpdGggcGFyYW1ldGVycyBtdXN0IGJlIHN0cmluZ3MgZXhjZXB0IGZvciBhIGZ1bmN0aW9uIGFzIHRoZSBvcHRpb25hbCBmaW5hbCBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIG1vZGVsLmlzSW1tdXRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpc0ltbXV0YWJsZSA9IHRydWU7XG4gICAgfTtcblxuICAgIG1vZGVsLmxvb2tzTGlrZSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgcGF0dGVybiA9IHA7XG4gICAgfTtcblxuICAgIG1vZGVsLnJlc3BvbmRzVG8gPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgbWV0aG9kQm9keSkge1xuICAgICAgICB2YXIgbSA9IG5ldyBNZXRob2QobWV0aG9kTmFtZSwgbWV0aG9kQm9keSk7XG4gICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgbWV0aG9kc1ttZXRob2ROYW1lXSA9IG07XG4gICAgfTtcbiAgICBcbiAgICBtb2RlbC52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzKCksXG4gICAgICAgICAgICBtZXRob2RzID0gdGhpcy5tZXRob2RzKCk7XG5cbiAgICAgICAgLy9jaGVjayB0byBtYWtlIHN1cmUgdGhhdCBpc0J1aWx0V2l0aCBoYXMgYWN0dWFsIGF0dHJpYnV0ZXNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcXVpcmVkQ29uc3RydWN0b3JBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlKHJlcXVpcmVkQ29uc3RydWN0b3JBcmdzW2ldKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3NbaV0gKyBcIiwgc3BlY2lmaWVkIGluIHRoZSBpc0J1aWx0V2l0aCBtZXRob2QsIGlzIG5vdCBhbiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9uYWxDb25zdHJ1Y3RvckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUob3B0aW9uYWxDb25zdHJ1Y3RvckFyZ3NbaV0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25hbENvbnN0cnVjdG9yQXJnc1tpXSArIFwiLCBzcGVjaWZpZWQgaW4gdGhlIGlzQnVpbHRXaXRoIG1ldGhvZCwgaXMgbm90IGFuIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG1ldGhvZC9hdHRyaWJ1dGUgY29sbGlzaW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1ldGhvZHMuaW5kZXhPZihhdHRyaWJ1dGVzW2ldKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWw6IGludmFsaWQgbW9kZWwgc3BlY2lmaWNhdGlvbiB0byBcIiArIGF0dHJpYnV0ZXNbaV0gKyBcIiBiZWluZyBib3RoIGFuIGF0dHJpYnV0ZSBhbmQgbWV0aG9kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayB0byBtYWtlIHN1cmUgdGhhdCBhbGwgYXR0cmlidXRlcyBhcmUgcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MgaWYgdGhlIG9iamVjdCBpcyBpbW11dGFibGVcbiAgICAgICAgaWYgKGlzSW1tdXRhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZENvbnN0cnVjdG9yQXJncy5pbmRleE9mKGF0dHJpYnV0ZXNbaV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbW11dGFibGUgb2JqZWN0cyBtdXN0IGhhdmUgYWxsIGF0dHJpYnV0ZXMgcmVxdWlyZWQgaW4gYSBjYWxsIHRvIGlzQnVpbHRXaXRoXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2V0IG1vZGlmaWVkU2luY2VMYXN0VmFsaWRhdGlvbiB0byBmYWxzZVxuICAgICAgICBtb2RpZmllZCA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqKioqKioqKioqKioqIEVORCBQVUJMSUMgQVBJICoqKioqKioqKioqKioqKiovXG4gICAgXG4gICAgLy9oZXJlIHdlIGFyZSByZXR1cm5pbmcgb3VyIG1vZGVsIG9iamVjdFxuICAgIC8vd2hpY2ggaXMgYSBmdW5jdGlvbiB3aXRoIGEgYnVuY2ggb2YgbWV0aG9kcyB0aGF0XG4gICAgLy9tYW5pcHVsYXRlIGhvdyB0aGUgZnVuY3Rpb24gYmVoYXZlc1xuICAgIHJldHVybiBtb2RlbDtcbn07XG5cbi8vbnMuZ2V0TW9kZWwgPSBnZXRNb2RlbDtcbi8vbnMuZ2V0TW9kZWxzID0gZ2V0TW9kZWxzO1xuXG5Nb2RlbC5nZXRNb2RlbCA9IGdldE1vZGVsO1xuTW9kZWwuZ2V0TW9kZWxzID0gZ2V0TW9kZWxzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuXG5cbiIsIi8qKlxuICogVmFsaWRhdG9yXG4gKiBcbiAqIENyZWF0ZXMgYSBuYW1lZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhdHRyaWJ1dGUgZm9yIHZhbGlkYXRpb24uXG4gKiBUaGUgVmFsaWRhdG9yIGZ1bmN0aW9uIGFsbG93cyBmb3IgY3VzdG9taXphdGlvbiBvZiB0aGUgdGhyb3duIGVycm9yIG1lc3NhZ2UuXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBhbHNvIGhhbmRsZXMgYWxsIGRlZmF1bHQgdmFsaWRhdG9ycyB0aGF0IGNvbWUgcGFja2FnZWQgd2l0aFxuICogSmVybWFpbmUuIFRoaXMgaW5jbHVkZXMgaXNBLCBpc09uZU9mLCBpc0dyZWF0ZXJUaGFuLCBpc0xlc3NUaGFuLCBldGMuXG4gKlxuICogU2ltcGxlIGV4YW1wbGU6XG4gKlxuICogaXNHcmVhdGVyVGhhbiA9IG5ldyBWYWxpZGF0b3IoZnVuY3Rpb24gKG51bWJlcikge1xuICogICAgIC8vdGhpcy5tZXNzYWdlIHBvaW50cyB0byB0aGUgZXJyb3IgbWVzc2FnZVxuICogICAgIC8vdGhhdCB3aWxsIGJlIHRocm93blxuICogICAgIHRoaXMubWVzc2FnZSA9IFwiVmFsaWRhdGlvbiBFcnJvcjogXCIgKyBcbiAqICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtICsgXCIgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBcIiArIG51bWJlcjtcbiAqXG4gKiAgICAgLy90aGlzLnBhcmFtIHBvaW50cyB0byB0aGUgYWN0dWFsIHBhcmFtZXRlciBzZW50IHRvIHRoZSB2YWxpZGF0b3JcbiAqICAgICAvL3JldHVybiB0cnVlIGlmIHRoZSB2YWxpZGF0aW9uIHBhc3NlcywgZmFsc2Ugb3RoZXJ3aXNlXG4gKiAgICAgcmV0dXJuIHRoaXMucGFyYW0gPiBudW1iZXI7XG4gKiB9KTtcbiAqXG4gKiBMYXRlciwgYSB2YWxpZGF0b3IgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBhdHRyaWJ1dGUgb2JqZWN0LlxuICpcbiAqIEF0dHIuaXNHcmVhdGVyVGhhbiA9IGlzR3JlYXRlclRoYW47XG4gKlxuICogYW5kIGNhbiBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgYXR0cmlidXRlczpcbiAqXG4gKiB2YXIgYWdlID0gbmV3IEF0dHIoXCJhZ2VcIikud2hpY2guaXNHcmVhdGVyVGhhbigwKTtcbiAqXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoJy4uL3V0aWwvaW5kZXhfb2YuanMnKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbC5qcycpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHt9OyAgLy90aGUgc2V0IG9mIHN0YXRpYyB2YWxpZGF0b3JzXG5cbi8qKlxuICogVmFsaWRhdG9yICdDb25zdHJ1Y3RvcidcbiAqXG4gKiBUaGlzIHNpbXBseSByZXR1cm5zIGEgdmFsaWRhdGlvbiBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgdGhlIGN1c3RvbSBlcnJvclxuICogbWVzc2FnZSBhbmQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIGF0dHJpYnV0ZS4gU28gaXQncyBub3QgcmVhbGx5XG4gKiB0ZWNobmljYWxseSBhIGNvbnN0cnVjdG9yLiBUaGlzIGlzIG9ubHkgaW1wb3J0YW50IHRvIGtub3cgc28gdGhhdCB5b3VcbiAqIGRvbid0IHRyeSBzb21ldGhpbmcgbGlrZSB0aGlzOlxuICpcbiAqIHZhciB2ID0gbmV3IFZhbGlkYXRvciggLi4uICk7XG4gKiBcbiAqIC8vdGhpcyB3aWxsIGFsd2F5cyBmYWlsLCBiYyB2IGlzIG5vdCBhbiBvYmplY3RcbiAqIGlmICh2IGluc3RhbmNlb2YgVmFsaWRhdG9yKSB7IC4uLiB9XG4gKiBcbiAqIFRoZSBzcGVjIGZ1bmN0aW9uIGlzIGp1c3QgYSBzcGVjaWZpY2F0aW9uIGZvciB0aGUgdmFsaWRhdG9yLiBJdCBhbGxvd3NcbiAqIGZvciBhIGNvdXBsZSBvZiB0aGluZ3MgdG8gYmUgYXR0YWNoZWQgdG8gXCJ0aGlzXCIgdGhhdCB3aWxsIGJlIHVzZWRcbiAqIGluIHRoZSByZXR1cm4gZnVuY3Rpb24uIFRoaXMgaW5jbHVkZXMgXCJ0aGlzLm1lc3NhZ2VcIiBhbmQgXCJ0aGlzLnBhcmFtXCIuXG4gKiBUaGUgbWVzc2FnZSBpcyB0aGUgZXJyb3Igc3RyaW5nIHRoYXQgaXMgdGhyb3duIG9uIGZhaWx1cmUgYW5kXG4gKiB0aGlzLnBhcmFtIGlzIHRoZSBhY3R1YWwgcGFyYW1ldGVyIHRoYXQgZ2V0cyBzZW50IGluIHRvIGJlIHZhbGlkYXRlZC5cbiAqL1xudmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgLy8gdGhpcyBpcyB0aGUgYWN0dWFsIGZ1bmN0aW9uIHRoYXQgaXMgcmV0dXJuZWRcbiAgICB2YXIgdmFsaWRhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQsIFxuICAgICAgICAgICAgcmVzdWx0T2JqZWN0ID0ge30sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U7XG5cbiAgICAgICAgLy8gc3BlYyBpcyBjYWxsZWQgb24gdGhlIGFyZ3VtZW50IHdpdGggJ3RoaXMnIHBvaW50aW5nXG4gICAgICAgIC8vIHRvIGFuIGVtcHR5IG9iamVjdCAocmVzdWx0T2JqZWN0KSxcbiAgICAgICAgLy8gbm90ZSB0aGUgdmFsaWRhdG9yIHdpbGwgcmV0dXJuIGVpdGhlciB0cnVlIG9yIGZhbHNlXG4gICAgICAgIHJlc3VsdCA9IHNwZWMuY2FsbChyZXN1bHRPYmplY3QsIGFyZyk7XG5cbiAgICAgICAgLy8gaWYgaXQncyBmYWxzZSwgdGhlIHBhcmFtZXRlciBoYXMgZmFpbGVkIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIHRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gcmVzdWx0T2JqZWN0Lm1lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgICBcInZhbGlkYXRvciBmYWlsZWQgd2l0aCBwYXJhbWV0ZXIgXCIgKyBhcmc7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBzZWU/IGFsbCB0aGF0J3MgYmVpbmcgcmV0dXJuZWQgaXMgYSBmdW5jdGlvblxuICAgIC8vIGFsc28gbm90ZSB0aGF0IHNpbmNlICd0aGlzJyBpcyBuZXZlciB1c2VkLFxuICAgIC8vIHdlIGNhbiBjYWxsIHRoaXMgY29uc3RydWN0b3Igd2l0aCBvciB3aXRob3V0ICduZXcnXG4gICAgcmV0dXJuIHZhbGlkYXRvckZ1bmN0aW9uO1xufTtcblxuLyoqXG4gKiBUaGlzIHN0YXRpYyBmdW5jdGlvbiBhZGRzIGEgbmFtZWQgdmFsaWRhdG9yIHRvIHRoZSBsaXN0IG9mXG4gKiB2YWxpZGF0b3JzLiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEgdmFsaWRhdGlvbiBmdW5jdGlvblxuICogdGhhdCBzaW1wbHkgcmV0dXJucyBhIFZhbGlkYXRvciBmdW5jdGlvbiBjcmVhdGVkIGFzIGFib3ZlLlxuICpcbiAqIFRoZSBuaWNlIHRoaW5nIGFib3V0IGFkZGluZyBhIFZhbGlkYXRvciB0aGlzIHdheSBpcyB0aGF0XG4gKiB5b3UgY2FuIGFjdHVhbGx5IHZhbGlkYXRlIHRoZSBwYXJhbWV0ZXIgc2VudCB0byB0aGUgdmFsaWRhdG9yIVxuICogV2h5IG1pZ2h0IHRoYXQgYmUgaW1wb3J0YW50PyBXZWxsLCBjb25zaWRlciB0aGUgZm9sbG93aW5nOlxuICpcbiAqIHZhciBpc0dyZWF0ZXJUaGFuSW50ZWdlciA9IG5ldyBWYWxpZGF0b3IoZnVuY3Rpb24gKHZhbCkge1xuICogICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucGFyYW0gKyBcIiBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIFwiICsgdmFsO1xuICogICAgIHJldHVybiB0aGlzLnBhcmFtID4gdmFsO1xuICogfSk7XG4gKlxuICogTm93IHdlIGNhbiBjYWxsIGlzR3JlYXRlclRoYW5OdW1iZXIgbGlrZSB0aGlzOlxuICpcbiAqIGlzR3JlYXRlclRoYW5OdW1iZXIoNSkoNik7IC8vIHdpbGwgcGFzcyB2YWxpZGF0aW9uXG4gKiBpc0dyZWF0ZXJUaGFuTnVtYmVyKDUpKDMpOyAvLyB3aWxsIHRocm93XG4gKiBpc0dyZWF0ZXJUaGFuTnVtYmVyKFwiZG9nXCIpKDMpOyAvLyA/Pz9cbiAqXG4gKiBTbyB3ZSBuZWVkIHRvIGNvbmZpcm0gdGhhdCB0aGUgdXNlciBzZW5kcyBpbiBhbiBpbnRlZ2VyIGFzIGEgcGFyYW1ldGVyLlxuICogWW91IG1pZ2h0IHdhbnQgdG8gdHJ5IHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gKlxuICogdmFyIGlzR3JlYXRlclRoYW5JbnRlZ2VyID0gbmV3IFZhbGlkYXRvcihmdW5jdGlvbiAodmFsKSB7XG4gKiAgICAgaWYgKHR5cGVvZih2YWwpICE9PSBcIm51bWJlclwiKSB0aHJvdyBFcnJvcihcIk5vdCBjb29sIVwiKTtcbiAqICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBhcmFtICsgXCIgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBcIiArIHZhbDtcbiAqICAgICByZXR1cm4gdGhpcy5wYXJhbSA+IHZhbDtcbiAqIH0pO1xuICpcbiAqIFRoaXMgd2lsbCBhY3R1YWxseSB3b3JrIG9uIHRoZSBleGFtcGxlIGFib3ZlOlxuICpcbiAqIGlzR3JlYXRlclRoYW5OdW1iZXIoXCJkb2dcIikoMyk7IC8vIHRocm93cyBlcnJvciBub3dcbiAqXG4gKiBUaGUgcHJvYmxlbSBpcyB0aGF0IHdpdGggSmVybWFpbmUsIHdlIGNyZWF0ZSB0aGUgdmFsaWRhdG9yXG4gKiBhbmQgdGhlbiBkb24ndCBhY3R1YWxseSBjYWxsIGl0IHVudGlsIGFuIGF0dHJpYnV0ZSBpcyBhYm91dCB0byBiZVxuICogc2V0LiBTbywgaW4gb3RoZXIgd29yZHM6XG4gKlxuICogdmFyIGEgPSBuZXcgQXR0cihcInRoaW5nXCIpLndoaWNoLmlzR3JlYXRlclRoYW5OdW1iZXIoXCJkb2dcIik7IC8vbm8gZXJyb3IgKHlldClcbiAqXG4gKiB3aWxsIG5vdCBjYXVzZSBhbiBlcnJvciB1bnRpbCBpdCdzIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBhbmQgdGhpbmdcbiAqIGlzIGF0dGVtcHRlZCB0byBiZSBzZXQuXG4gKlxuICogU28gYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZCBpcyB0byB2YWxpZGF0ZSB0aGUgdmFsaWRhdG9yIGluIHRoZVxuICogYWRkVmFsaWRhdG9yIGZ1bmN0aW9uIGJlbG93LiBUaGF0J3MgaGFuZGxlZCBieSB0aGUgYXJnVmFsaWRhdG9yXG4gKiB2YWxpZGF0b3IuIChQaGV3LCB0aGlzIGlzIGdldHRpbmcgcmVhbGx5IG1ldGEpXG4gKlxuICogSSdtIG5vdCBzdXJlIHRoaXMgaXMgdGhlIGJlc3Qgc29sdXRpb24uIFNlZW1zIGxpa2UgdGhlcmUgc2hvdWxkIGJlXG4gKiBhIHdheSB0byB2YWxpZGF0ZSB0aGUgYXJndW1lbnQgaW4gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBidXRcbiAqIHRoYXQgbWlnaHQgcmVxdWlyZSBzb21lIHJld2lyaW5nIHRoYXQgYnJlYWtzIG11bHRpZ3JhcGguIFRoaXMgaXNcbiAqIHRoZSBiZXN0IEkgY291bGQgY29tZSB1cCB3aXRoIGZvciBub3cuXG4gKlxuICogQG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZhbGlkYXRvciBmb3IgdGhlIGF0dHJpYnV0ZSwgbXVzdCBiZSBhIHN0cmluZ1xuICogICAgICAgb3IgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqXG4gKiBAdiBUaGUgdmFsaWRhdG9yIHNwZWNpZmljYXRpb24gKHJldHVybnMgYSBib29sZWFuKVxuICogICAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKlxuICogQGFyZ1ZhbGlkYXRvciBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IGNoZWNrcyB0aGUgdHlwZXMgb2YgYXJncyBzZW50XG4gKiAgICAgICAgICAgdG8gdGhlIHZhbGlkYXRvciwgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKlxuICogU28gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gaW4gdGhlIGNhc2VzIHRoYXQgXCJuYW1lXCIgaXMgbm90IGEgc3RyaW5nLFxuICogdiBpcyBub3QgYSBmdW5jdGlvbiwgYXJnVmFsaWRhdG9yIGlzIG5vdCBhIGZ1bmN0aW9uLCBvciBpZiB0aGUgc3RhdGljXG4gKiB2YWxpZGF0b3IgaXMgYWxyZWFkeSBkZWZpbmVkLlxuICovXG5WYWxpZGF0b3IuYWRkVmFsaWRhdG9yID0gZnVuY3Rpb24gKG5hbWUsIHYsIGFyZ1ZhbGlkYXRvcikge1xuICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQgfHwgdHlwZW9mKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZFZhbGlkYXRvciByZXF1aXJlcyBhIG5hbWUgdG8gYmUgc3BlY2lmaWVkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YodikgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRWYWxpZGF0b3IgcmVxdWlyZXMgYSBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlclwiKTtcbiAgICB9XG5cbiAgICAvLyBvcHRpb25hbCB0aGlyZCBhcmd1bWVudCB0byB2YWxpZGF0ZSB0aGUgXG4gICAgLy8gZXhwZWN0ZWQgdmFsdWUgdGhhdCBnZXRzIHNlbnQgdG8gdGhlIHZhbGlkYXRvclxuICAgIC8vIGZvciBleGFtcGxlLCBpc0EoXCJudW1iZXJcIikgd29ya3MgYnV0IGlzQShcIm5tYmVyXCIpXG4gICAgLy8gZG9lc24ndCB3b3JrXG4gICAgaWYgKGFyZ1ZhbGlkYXRvciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZihhcmdWYWxpZGF0b3IpICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkVmFsaWRhdG9yIHRoaXJkIG9wdGlvbmFsIGFyZ3VtZW50IG11c3QgYmUgYSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHZhbGlkYXRvcnNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWxpZGF0b3JzW25hbWVdID0gZnVuY3Rpb24gKGV4cGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAoYXJnVmFsaWRhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ1ZhbGlkYXRvcihleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yIChcIlZhbGlkYXRvcjogSW52YWxpZCBhcmd1bWVudCBmb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKyBcIiB2YWxpZGF0b3JcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0b3IoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRPYmplY3QgPSB7XCJhY3R1YWxcIjp2YWwsIFwicGFyYW1cIjp2YWx9LFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2LmNhbGwocmVzdWx0T2JqZWN0LCBleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gcmVzdWx0T2JqZWN0Lm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRvciAnXCIgKyBuYW1lICtcIicgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGJ1aWx0LWluIHZhbGlkYXRvciBieSBpdHMgbmFtZS5cbiAqXG4gKiBAbmFtZSBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIHZhbGlkYXRvciB0byByZXR1cm5cbiAqIFxuICogdGhyb3dzIGFuIGVycm9yIGlmIG5hbWUgaXMgbm90IGEgc3RyaW5nXG4gKi9cblZhbGlkYXRvci5nZXRWYWxpZGF0b3IgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRvcjogZ2V0VmFsaWRhdG9yIG1ldGhvZCByZXF1aXJlcyBhIHN0cmluZyBwYXJhbWV0ZXJcIik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRvcjogcGFyYW1ldGVyIHRvIGdldFZhbGlkYXRvciBtZXRob2QgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSB2YWxpZGF0b3JzW25hbWVdO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRvcjogJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKlxuICogcmV0dXJuIGFuIGFycmF5IG9mIG9mIHN0YXRpYyB2YWxpZGF0b3IgbmFtZXNcbiAqL1xuVmFsaWRhdG9yLnZhbGlkYXRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3AsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgIGZvciAocHJvcCBpbiB2YWxpZGF0b3JzKSB7XG4gICAgICAgIGlmICh2YWxpZGF0b3JzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEJ1aWx0LUluIHZhbGlkYXRvcnMuIEhvcGVmdWxseSB0aGVzZSBhcmUgc2VsZi1leHBsYW5hdG9yeVxuICogV2lsbCBkb2N1bWVudCB0aGVtIG1vcmUgbGF0ZXIuXG4gKi9cblZhbGlkYXRvci5hZGRWYWxpZGF0b3IoXCJpc0dyZWF0ZXJUaGFuXCIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBhcmFtICsgXCIgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBcIiArIHZhbDtcbiAgICByZXR1cm4gdGhpcy5wYXJhbSA+IHZhbDtcbn0pO1xuXG5WYWxpZGF0b3IuYWRkVmFsaWRhdG9yKFwiaXNMZXNzVGhhblwiLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wYXJhbSArIFwiIHNob3VsZCBiZSBsZXNzIHRoYW4gXCIgKyB2YWw7XG4gICAgcmV0dXJuIHRoaXMucGFyYW0gPCB2YWw7XG59KTtcblxuXG4vLyBUT0RPOiBhZGQgYXJyYXkgdmFsaWRhdGlvbiBmb3IgdmFsXG5WYWxpZGF0b3IuYWRkVmFsaWRhdG9yKFwiaXNPbmVPZlwiLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wYXJhbSArIFwiIHNob3VsZCBiZSBvbmUgb2YgdGhlIHNldDogXCIgKyB2YWw7XG4gICAgcmV0dXJuIHZhbC5pbmRleE9mKHRoaXMucGFyYW0pID4gLTE7XG59KTtcblxuLyoqXG4gKiBUaGlzIG9uZSBpcyB0aGUgb25seSBvbmUgdGhhdCB1c2VzIGFuIGFyZ3VtZW50IHZhbGlkYXRvci4gSXQgY29uZmlybXNcbiAqIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGEgcHJpbWl0aXZlIGphdmFzY3JpcHQgdHlwZSBvciBhIG5hbWVkIEplcm1haW5lXG4gKiBtb2RlbC5cbiAqL1xuVmFsaWRhdG9yLmFkZFZhbGlkYXRvcihcImlzQVwiLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIHR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiLCBcImZ1bmN0aW9uXCIsIFwib2JqZWN0XCJdLFxuICAgICAgICBtb2RlbHMgPSBNb2RlbC5nZXRNb2RlbHMoKTtcbiAgICBpZiAodHlwZW9mKHZhbCkgPT09IFwic3RyaW5nXCIgJiYgdHlwZXMuaW5kZXhPZih2YWwpID4gLTEpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wYXJhbSArIFwiIHNob3VsZCBiZSBhIFwiICsgdmFsO1xuICAgICAgICByZXR1cm4gdHlwZW9mKHRoaXMucGFyYW0pID09PSB2YWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YodmFsKSA9PT0gXCJzdHJpbmdcIiAmJiBtb2RlbHMuaW5kZXhPZih2YWwpID4gLTEpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIFwiICsgdmFsO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbSBpbnN0YW5jZW9mIE1vZGVsLmdldE1vZGVsKHZhbCk7XG4gICAgfSBlbHNlIGlmICh2YWwgPT09ICdpbnRlZ2VyJykge1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yICdpbnRlZ2VyJzsgc2luY2UgamF2YXNjcmlwdCBoYXMgbm8gaW50ZWdlciB0eXBlLFxuICAgICAgICAvLyBqdXN0IGNoZWNrIGZvciBudW1iZXIgdHlwZSBhbmQgY2hlY2sgdGhhdCBpdCdzIG51bWVyaWNhbGx5IGFuIGludFxuICAgICAgICBpZiAodGhpcy5wYXJhbS50b1N0cmluZyAhPT0gdW5kZWZpbmVkKSAge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wYXJhbS50b1N0cmluZygpICsgXCIgc2hvdWxkIGJlIGFuIGludGVnZXJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwicGFyYW1ldGVyIHNob3VsZCBiZSBhbiBpbnRlZ2VyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0eXBlb2YodGhpcy5wYXJhbSkgPT09ICdudW1iZXInKSAmJiAocGFyc2VJbnQodGhpcy5wYXJhbSwxMCkgPT09IHRoaXMucGFyYW0pO1xuICAgIH0gLyplbHNlIGlmICh0eXBlb2YodmFsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRvcjogaXNBIGFjY2VwdHMgYSBzdHJpbmcgd2hpY2ggaXMgb25lIG9mIFwiICsgdHlwZXMpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdG9yOiBpc0Egb25seSBhY2NlcHRzIGEgc3RyaW5nIGZvciBhIHByaW1pdGl2ZSB0eXBlcyBmb3IgdGhlIHRpbWUgYmVpbmdcIik7XG4gICAgICAgfSovXG59LFxuICAgICAgICAgICAgICAgICAgICAgICAvL2FyZ3VtZW50IHZhbGlkYXRvclxuICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZXNBbmRNb2RlbHMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCIsIFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiLCBcImludGVnZXJcIl0uY29uY2F0KE1vZGVsLmdldE1vZGVscygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc0FuZE1vZGVscy5pbmRleE9mKHZhbCkgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cblxuLy8gZ3JhbW1hdGljYWwgYWxpYXMgZm9yIGlzQVxudmFsaWRhdG9ycy5pc0FuID0gdmFsaWRhdG9ycy5pc0E7XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdG9yO1xuIiwicmVxdWlyZSgnLi91dGlsL2luZGV4X29mLmpzJyk7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vY29yZS9tb2RlbC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnQXR0cicgICAgICA6IHJlcXVpcmUoJy4vY29yZS9hdHRyLmpzJyksXG4gICAgJ0F0dHJMaXN0JyAgOiByZXF1aXJlKCcuL2NvcmUvYXR0cl9saXN0LmpzJyksXG4gICAgJ01vZGVsJyAgICAgOiBNb2RlbCxcbiAgICAnZ2V0TW9kZWwnICA6IE1vZGVsLmdldE1vZGVsLFxuICAgICdnZXRNb2RlbHMnIDogTW9kZWwuZ2V0TW9kZWxzLFxuICAgICdWYWxpZGF0b3InIDogcmVxdWlyZSgnLi9jb3JlL3ZhbGlkYXRvci5qcycpLFxuICAgICdNZXRob2QnICAgIDogcmVxdWlyZSgnLi9jb3JlL21ldGhvZC5qcycpLFxuICAgICd1dGlsJyAgICAgIDoge1xuICAgICAgICAnRXZlbnRFbWl0dGVyJyA6IHJlcXVpcmUoJy4vdXRpbC9ldmVudF9lbWl0dGVyLmpzJyksXG4gICAgICAgICduYW1lc3BhY2UnICAgIDogcmVxdWlyZSgnLi91dGlsL25hbWVzcGFjZS5qcycpXG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKCcuL2luZGV4X29mLmpzJyk7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBsaXN0ZW5lcnMgPSB7fTtcblxuICAgIC8vYW4gcmVnaXN0ZXJzIGV2ZW50IGFuZCBhIGxpc3RlbmVyXG4gICAgdGhpcy5vbiA9IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZihldmVudCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlcjogZmlyc3QgYXJndW1lbnQgdG8gJ29uJyBzaG91bGQgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihsaXN0ZW5lcikgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyOiBzZWNvbmQgYXJndW1lbnQgdG8gJ29uJyBzaG91bGQgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgLy9hbGlhcyBhZGRMaXN0ZW5lclxuICAgIHRoaXMuYWRkTGlzdGVuZXIgPSB0aGlzLm9uO1xuICAgIFxuICAgIHRoaXMub25jZSA9IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhhdC5yZW1vdmVMaXN0ZW5lcihldmVudCwgZik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhhdC5vbihldmVudCwgZik7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgaW5kZXg7XG5cbiAgICAgICAgaWYgKHR5cGVvZihldmVudCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlcjogZmlyc3QgcGFyYW1ldGVyIHRvIHJlbW92ZUxpc3RlbmVyIG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBldmVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKGxpc3RlbmVyKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudEVtaXR0ZXI6IHNlY29uZCBwYXJhbWV0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIHRvIHJlbW92ZSBhcyBhbiBldmVudCBsaXN0ZW5lclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXJzW2V2ZW50XSA9PT0gdW5kZWZpbmVkIHx8IGxpc3RlbmVyc1tldmVudF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudEVtaXR0ZXI6IHRoZXJlIGFyZSBubyBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgdGhlICdcIiArIGV2ZW50ICsgXCInIGV2ZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBsaXN0ZW5lcnNbZXZlbnRdLmluZGV4T2YobGlzdGVuZXIpO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0uc3BsaWNlKGluZGV4LDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YoZXZlbnQpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudEVtaXR0ZXI6IHBhcmFtZXRlciB0byByZW1vdmVBbGxMaXN0ZW5lcnMgc2hvdWxkIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBldmVudFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0ZW5lcnNbZXZlbnRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIC8vZ2V0IHRoZSBsaXN0ZW5lcnMgZm9yIGFuIGV2ZW50XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZihldmVudCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudEVtaXR0ZXI6IGxpc3RlbmVycyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmFtZSBvZiBhbiBldmVudFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnNbZXZlbnRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXJzW2V2ZW50XTtcbiAgICB9O1xuXG4gICAgLy9leGVjdXRlIGVhY2ggb2YgdGhlIGxpc3RlbmVycyBpbiBvcmRlciB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzXG4gICAgdGhpcy5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgcGFyYW1zO1xuXG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdGVuZXJzW2V2ZW50XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzW2V2ZW50XS5sZW5ndGg7IGk9aSsxKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XVtpXS5hcHBseSh0aGlzLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB0aGF0O1xufTsgLy9lbmQgRXZlbnRFbWl0dGVyXG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuIiwiaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuID0gTnVtYmVyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgICBpZiAobiAhPT0gbikgeyAvLyBzaG9ydGN1dCBmb3IgdmVyaWZ5aW5nIGlmIGl0J3MgTmFOXG4gICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gSW5maW5pdHkgJiYgbiAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+PSBsZW4pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgayA9IG4gPj0gMCA/IG4gOiBNYXRoLm1heChsZW4gLSBNYXRoLmFicyhuKSwgMCk7XG4gICAgICAgIGZvciAoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChrIGluIHQgJiYgdFtrXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmFtZXNwYWNlIChucywgYWxpYXNlcywgZnVuYykge1xuICAgIHZhciBuc1JlZ0V4cCA9IC9eKFthLXpBLVpdKykoXFwuW2EtekEtWl0qKSokLyxcbiAgICAgICAgbnNBcnJheSxcbiAgICAgICAgY3VycmVudE5TLFxuICAgICAgICBpO1xuXG4gICAgLy9jaGVjayB0byBhc3N1cmUgbnMgaXMgYSBwcm9wZXJseSBmb3JtYXR0ZWQgbmFtZXNwYWNlIHN0cmluZ1xuICAgIGlmIChucy5tYXRjaChuc1JlZ0V4cCkgPT09IG51bGwgfHwgbnMgPT09IFwid2luZG93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZXNwYWNlOiBcIiArIG5zICsgXCIgaXMgYSBtYWxmb3JtZWQgbmFtZXNwYWNlIHN0cmluZ1wiKTtcbiAgICB9XG5cbiAgICAvL2NoZWNrIHRvIGFzc3VyZSB0aGF0IGlmIGFsaWFzIGlzIGRlZmluZWQgdGhhdCBmdW5jIGlzIGRlZmluZWRcbiAgICBpZiAoYWxpYXNlcyAhPT0gdW5kZWZpbmVkICYmIGZ1bmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIChhbGlhc2VzKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBmdW5jID0gYWxpYXNlcztcbiAgICAgICAgICAgIGFsaWFzZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChhbGlhc2VzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZXNwYWNlOiBpZiBzZWNvbmQgYXJndW1lbnQgZXhpc3RzLCBmaW5hbCBmdW5jdGlvbiBhcmd1bWVudCBtdXN0IGV4aXN0XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAoYWxpYXNlcykgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWVzcGFjZTogc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0IG9mIGFsaWFzZWQgbG9jYWwgbmFtZXNwYWNlc1wiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIChhbGlhc2VzKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKGZ1bmMpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZXNwYWNlOiBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3Qgb2YgYWxpYXNlZCBsb2NhbCBuYW1lc3BhY2VzXCIpO1xuICAgIH1cblxuICAgIC8vcGFyc2UgbmFtZXNwYWNlIHN0cmluZ1xuICAgIG5zQXJyYXkgPSBucy5zcGxpdChcIi5cIik7XG5cbiAgICAvL3NldCB0aGUgcm9vdCBuYW1lc3BhY2UgdG8gd2luZG93IChpZiBpdCdzIG5vdCBleHBsaWN0bHkgc3RhdGVkKVxuICAgIGlmIChuc0FycmF5WzBdID09PSBcIndpbmRvd1wiKSB7XG4gICAgICAgIGN1cnJlbnROUyA9IHdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50TlMgPSAod2luZG93W25zQXJyYXlbMF1dID09PSB1bmRlZmluZWQpID8gd2luZG93W25zQXJyYXlbMF1dID0ge30gOiB3aW5kb3dbbnNBcnJheVswXV07XG4gICAgfVxuXG4gICAgLy9jb25maXJtIGZ1bmMgaXMgYWN0dWFsbHkgYSBmdW5jdGlvblxuICAgIGlmIChmdW5jICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIChmdW5jKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWVzcGFjZTogbGFzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIG5hbWVzcGFjZSBwYXJhbWV0ZXJcIik7XG4gICAgfVxuXG4gICAgLy9idWlsZCBuYW1lc3BhY2VcbiAgICBmb3IgKGkgPSAxOyBpIDwgbnNBcnJheS5sZW5ndGg7IGkgPSBpICsgMSkge1xuICAgICAgICBpZiAoY3VycmVudE5TW25zQXJyYXlbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnROU1tuc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnROUyA9IGN1cnJlbnROU1tuc0FycmF5W2ldXTtcbiAgICB9XG5cbiAgICAvL25hbWVzcGFjZXMucHVzaChjdXJyZW50TlMpO1xuICAgIC8vbmFtZXNwYWNlID0gY3VycmVudE5TO1xuXG4gICAgLy9pZiB0aGUgZnVuY3Rpb24gd2FzIGRlZmluZWQsIGJ1dCBubyBhbGlhc2VzIHJ1biBpdCBvbiB0aGUgY3VycmVudCBuYW1lc3BhY2VcbiAgICBpZiAoYWxpYXNlcyA9PT0gdW5kZWZpbmVkICYmIGZ1bmMpIHtcbiAgICAgICAgZnVuYyhjdXJyZW50TlMpO1xuICAgIH0gZWxzZSBpZiAoZnVuYykge1xuICAgICAgICBmb3IgKGkgaW4gYWxpYXNlcykge1xuICAgICAgICAgICAgaWYgKGFsaWFzZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBhbGlhc2VzW2ldID0gbmFtZXNwYWNlKGFsaWFzZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmMuY2FsbChhbGlhc2VzLCBjdXJyZW50TlMpO1xuICAgIH1cblxuICAgIC8vcmV0dXJuIG5hbWVzcGFjZVxuICAgIHJldHVybiBjdXJyZW50TlM7XG59O1xuIiwiLyohIENvcHlyaWdodCAoYykgMjAxMSBCcmFuZG9uIEFhcm9uIChodHRwOi8vYnJhbmRvbmFhcm9uLm5ldClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTElDRU5TRS50eHQpLlxuICpcbiAqIFRoYW5rcyB0bzogaHR0cDovL2Fkb21hcy5vcmcvamF2YXNjcmlwdC1tb3VzZS13aGVlbC8gZm9yIHNvbWUgcG9pbnRlcnMuXG4gKiBUaGFua3MgdG86IE1hdGhpYXMgQmFuayhodHRwOi8vd3d3Lm1hdGhpYXMtYmFuay5kZSkgZm9yIGEgc2NvcGUgYnVnIGZpeC5cbiAqIFRoYW5rcyB0bzogU2VhbXVzIExlYWh5IGZvciBhZGRpbmcgZGVsdGFYIGFuZCBkZWx0YVlcbiAqXG4gKiBWZXJzaW9uOiAzLjAuNlxuICogXG4gKiBSZXF1aXJlczogMS4yLjIrXG4gKi9cblxuKGZ1bmN0aW9uKCQpIHtcblxudmFyIHR5cGVzID0gWydET01Nb3VzZVNjcm9sbCcsICdtb3VzZXdoZWVsJ107XG5cbmlmICgkLmV2ZW50LmZpeEhvb2tzKSB7XG4gICAgZm9yICggdmFyIGk9dHlwZXMubGVuZ3RoOyBpOyApIHtcbiAgICAgICAgJC5ldmVudC5maXhIb29rc1sgdHlwZXNbLS1pXSBdID0gJC5ldmVudC5tb3VzZUhvb2tzO1xuICAgIH1cbn1cblxuJC5ldmVudC5zcGVjaWFsLm1vdXNld2hlZWwgPSB7XG4gICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgIGZvciAoIHZhciBpPXR5cGVzLmxlbmd0aDsgaTsgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCB0eXBlc1stLWldLCBoYW5kbGVyLCBmYWxzZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbm1vdXNld2hlZWwgPSBoYW5kbGVyO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICB0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICggdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgZm9yICggdmFyIGk9dHlwZXMubGVuZ3RoOyBpOyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGVzWy0taV0sIGhhbmRsZXIsIGZhbHNlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ubW91c2V3aGVlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4kLmZuLmV4dGVuZCh7XG4gICAgbW91c2V3aGVlbDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuID8gdGhpcy5iaW5kKFwibW91c2V3aGVlbFwiLCBmbikgOiB0aGlzLnRyaWdnZXIoXCJtb3VzZXdoZWVsXCIpO1xuICAgIH0sXG4gICAgXG4gICAgdW5tb3VzZXdoZWVsOiBmdW5jdGlvbihmbikge1xuICAgICAgICByZXR1cm4gdGhpcy51bmJpbmQoXCJtb3VzZXdoZWVsXCIsIGZuKTtcbiAgICB9XG59KTtcblxuXG5mdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgdmFyIG9yZ0V2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50LCBhcmdzID0gW10uc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICksIGRlbHRhID0gMCwgcmV0dXJuVmFsdWUgPSB0cnVlLCBkZWx0YVggPSAwLCBkZWx0YVkgPSAwO1xuICAgIGV2ZW50ID0gJC5ldmVudC5maXgob3JnRXZlbnQpO1xuICAgIGV2ZW50LnR5cGUgPSBcIm1vdXNld2hlZWxcIjtcbiAgICBcbiAgICAvLyBPbGQgc2Nob29sIHNjcm9sbHdoZWVsIGRlbHRhXG4gICAgaWYgKCBvcmdFdmVudC53aGVlbERlbHRhICkgeyBkZWx0YSA9IG9yZ0V2ZW50LndoZWVsRGVsdGEvMTIwOyB9XG4gICAgaWYgKCBvcmdFdmVudC5kZXRhaWwgICAgICkgeyBkZWx0YSA9IC1vcmdFdmVudC5kZXRhaWwvMzsgfVxuICAgIFxuICAgIC8vIE5ldyBzY2hvb2wgbXVsdGlkaW1lbnNpb25hbCBzY3JvbGwgKHRvdWNocGFkcykgZGVsdGFzXG4gICAgZGVsdGFZID0gZGVsdGE7XG4gICAgXG4gICAgLy8gR2Vja29cbiAgICBpZiAoIG9yZ0V2ZW50LmF4aXMgIT09IHVuZGVmaW5lZCAmJiBvcmdFdmVudC5heGlzID09PSBvcmdFdmVudC5IT1JJWk9OVEFMX0FYSVMgKSB7XG4gICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgIGRlbHRhWCA9IC0xKmRlbHRhO1xuICAgIH1cbiAgICBcbiAgICAvLyBXZWJraXRcbiAgICBpZiAoIG9yZ0V2ZW50LndoZWVsRGVsdGFZICE9PSB1bmRlZmluZWQgKSB7IGRlbHRhWSA9IG9yZ0V2ZW50LndoZWVsRGVsdGFZLzEyMDsgfVxuICAgIGlmICggb3JnRXZlbnQud2hlZWxEZWx0YVggIT09IHVuZGVmaW5lZCApIHsgZGVsdGFYID0gLTEqb3JnRXZlbnQud2hlZWxEZWx0YVgvMTIwOyB9XG4gICAgXG4gICAgLy8gQWRkIGV2ZW50IGFuZCBkZWx0YSB0byB0aGUgZnJvbnQgb2YgdGhlIGFyZ3VtZW50c1xuICAgIGFyZ3MudW5zaGlmdChldmVudCwgZGVsdGEsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICBcbiAgICByZXR1cm4gKCQuZXZlbnQuZGlzcGF0Y2ggfHwgJC5ldmVudC5oYW5kbGUpLmFwcGx5KHRoaXMsIGFyZ3MpO1xufVxuXG59KShqUXVlcnkpO1xuIiwiKGZ1bmN0aW9uICgkKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBmdWxsc2NyZWVuIDogZmFsc2UsXG4gICAgICAgIHNjYWxlIDogZmFsc2UsXG4gICAgICAgIGRlZmF1bHRFdmVudEhhbmRsaW5nIDogdHJ1ZSxcbiAgICAgICAgcHJlb3BlbiA6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBwb3N0b3BlbiA6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBwcmVjbG9zZSA6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBwb3N0Y2xvc2UgOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgcHJlcmVzaXplIDogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIHBvc3RyZXNpemUgOiBmdW5jdGlvbiAoKSB7fVxuICAgIH07XG5cbiAgICB2YXIgbWV0aG9kcyA9IHtcbiAgICAgICAgb3BlbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IHRoaXMuY2xvbmUodHJ1ZSksXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YShcImxpZ2h0Ym94XCIpLFxuICAgICAgICAgICAgICAgIHcsIGg7XG5cbiAgICAgICAgICAgIGRhdGEuY29udGVudHMgPSBjbG9uZTtcbiAgICAgICAgICAgIGRhdGEucHJlb3Blbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY2xvbmUgPSBkYXRhLmNvbnRlbnRzOyAvLyBkYXRhLmNvbnRlbnRzIG1pZ2h0IGhhdmUgYmVlbiBhbHRlcmVkIGJ5IGRhdGEucHJlb3BlblxuICAgICAgICAgICAgdmFyIGNsb25lRGF0YSA9IGNsb25lLmRhdGEoXCJsaWdodGJveFwiKTtcblxuICAgICAgICAgICAgZGF0YS5vdmVybGF5ID0gJChcIjxkaXYvPlwiKVxuICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCIgICAgICAgICA6IFwiZml4ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCIgICAgICAgICAgICAgOiBcIjBweFwiLFxuICAgICAgICAgICAgICAgICAgICBcInRvcFwiICAgICAgICAgICAgICA6IFwiMHB4XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCIgICAgICAgICAgIDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWluLWhlaWdodFwiICAgICAgIDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIiAgICAgICAgICAgIDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiei1pbmRleFwiICAgICAgICAgIDogXCI5OTk5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiIDogXCJibGFja1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm9wYWNpdHlcIiAgICAgICAgICA6IFwiMC41XCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhcImJvZHlcIik7XG5cbiAgICAgICAgICAgIGRhdGEuYm94ID0gJChcIjxkaXYvPlwiKVxuICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCIgICAgICAgICA6IFwiZml4ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ6LWluZGV4XCIgICAgICAgICAgOiBcIjk5OTlcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKFwiYm9keVwiKTtcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBkYXRhLmJveC5hcHBlbmQoY2xvbmUpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5mdWxsc2NyZWVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdyA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICAgIGggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSBjbG9uZS53aWR0aCgpO1xuICAgICAgICAgICAgICAgIGggPSBjbG9uZS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zY2FsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGNvbXB1dGVSYXRpbyh3LCBoKTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHBhcnNlSW50KHcgKiByLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGggPSBwYXJzZUludChoICogciwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NhbGVFbGVtZW50KGRhdGEuYm94LCB3LCBoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChkYXRhLmJveCwgdywgaCk7XG5cbiAgICAgICAgICAgIHNjYWxlRWxlbWVudChjbG9uZSwgdywgaCk7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoY2xvbmUsIHcsIGgpO1xuICAgICAgICAgICAgY2xvbmUuY3NzKFwicG9zaXRpb25cIiwgXCJmaXhlZFwiKVxuICAgICAgICAgICAgICAgIC5jc3MoXCJ6LWluZGV4XCIsIDk5OTkpO1xuXG4gICAgICAgICAgICBkYXRhLmJveC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxpbWcgc3JjPVxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXNDQVlBQUFBZWhGb0JBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlKcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1TXkxak1ERXhJRFkyTGpFME5UWTJNU3dnTWpBeE1pOHdNaTh3TmkweE5EbzFOam95TnlBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVOVE5pQW9WMmx1Wkc5M2N5a2lJSGh0Y0UxTk9rbHVjM1JoYm1ObFNVUTlJbmh0Y0M1cGFXUTZOa1k0T1VFNFFVRTJNREV5TVRGRk1rRkJNRU00UTBZMlJUbEZOa0k0UXpFaUlIaHRjRTFOT2tSdlkzVnRaVzUwU1VROUluaHRjQzVrYVdRNk5rWTRPVUU0UVVJMk1ERXlNVEZGTWtGQk1FTTRRMFkyUlRsRk5rSTRRekVpUGlBOGVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwZ2MzUlNaV1k2YVc1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMlJqZzVRVGhCT0RZd01USXhNVVV5UVVFd1F6aERSalpGT1VVMlFqaERNU0lnYzNSU1pXWTZaRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8yUmpnNVFUaEJPVFl3TVRJeE1VVXlRVUV3UXpoRFJqWkZPVVUyUWpoRE1TSXZQaUE4TDNKa1pqcEVaWE5qY21sd2RHbHZiajRnUEM5eVpHWTZVa1JHUGlBOEwzZzZlRzF3YldWMFlUNGdQRDk0Y0dGamEyVjBJR1Z1WkQwaWNpSS9QdlhDL3VrQUFBY2pTVVJCVkhqYXhGbHBURlZYRUo3SERySUlVa0NSellpdFFKUUsva0JUeEFvcDJFUWhhcWtFcWpacUs5RkdhKzJDZjJwYWJkSWxFYkUwRkVrVEFyRmFGNkNBS0NDU3RHNUJva1hBZ2xwVUlrS3FnbjBLeU5iNWp2ZStQQjl2Znl5VGZJRjczNzNuekprelo3Nlp1WXFSa1JHeVVLd1lvWXdReHFzTUQ0YWo5RnNQbzROeGcxSFA2TFIwTWhzejM3Tmx4RE5TR0xIdDdlMmU5Ky9mcHdjUEh0RFRwMC9wK2ZQbjRpRkhSMGVhT25VcVRaOCtuUUlDQXNqVjFiV0piNWN3Q2hpTjVreXNNTkhDc053SGpFK3VYcjNxZStuU0pXcHNiQ1NsVW1uVXl6Tm16S0R3OEhDS2lvb2lYMS9mR3I2MWwxRTlYZ29uTWpMUG5EbmpYMU5USTZ4cGlVUkdSdExTcFVzcEpDU2tsQzgvWXZ3elZnbzdNN0xyNit2VHpwNDlTOWV2WDZleGxJU0VCRXBPVHNZV2ZjZ290RlJoWDBaRmVYbDUySkVqUjJpOEpEZzRtSll0V3daWHllVExqeG5ENWlnOG0xRjE3Tml4Z0pLU0VocHZzYkd4b1pTVUZJcU5qZjJWTDFNWlE2WW83TTM0bzdDd2NQYXBVNmRvSW1YZHVuVVVGeGYzRS8rYmJxekNDRm0xeDQ4Zmp6cHg0Z1JOaG16WXNBR1d4a0hNMGhiME5lV3Jpb3FLS0ZhWXNKakp3T25UcDZISDk0elhEU2tjenRoNTlPalJTVk1XWUNLaTNOeGNPOWJsWjRhMVBxYkw1QWR0d0ZhNlpNNmNPV1J2YjA5V1ZsYWtVQ2hVOTV1YW1sUU1weW51N3U0Z0N2RU9JRXRuWnlkMWRIUm9mYWVxcW9wbXpab1Z5ZEhqZmI3TTFhWndETE5XZEdWbHBWNy82dTN0cFNWTGxnakt0YlcxVmQzMzh2S1N0L0lsc2JPekU4dzJjK1pNY25OelU3M3o1TWtUT25Ub0VPa0xxMHhTQ0hkZjhMKy9NQVkxRmQ2SkNZZUhoL1VxM05iV1JxMnRyYlI4K1hKaE9kbGlzQ0R5aVd2WHJyMzAvUHo1ODhWdmdZR0I1T25wU2RiV0wzWTRNek9UOU8wazVOYXRXM1Rod29VZ1huQVNYLzZtN3NOZVNHWXVYcnhvbEk5aHUyN2Z2aTFjWXNxVUtlVHM3Q3lVeCtuMjhQQlFQUmNVRkVSejU4NFZPWVNQancrU0gvRnNiVzB0TVhNYU5kZTVjK2VnMzN1YWh5NkpyV3N6TURBZ0xHd004dlB6NmQ2OWU5VGYzeThHZ09XOHZiMXB5NVl0NG5jb0ZoRVJJUlFGa0xsaGdUZHYzaFN1WU93OFY2NWN3ZkJ2TVZ6VUZZNXBhR2d3ZWhEZzBhTkh4Q3dvL2c0T0RyNEk0T3lmc09pS0ZTc0UvUHo4aEhWaFdiZ08vSC8vL3YwbXpRTWpzdEp3L0RmVUZWN1UzTnhzY3ZpcHE2c2pKRVE0UUxMdkk0S3NXclZLV0JkK0N4Y0I3VUk0QXRIZHUzZE5udWZHRGVUL0ZDVWZPaWVHWDFkWEY1bFRmUlFYRnd0TFFrSDRzK3pYY3VpVGxhMnVyaGFuM2h6QklsbGVreFVPNUJzS1E5RkJseng3OW93S0NnckkzOTlmdUFRVWhUL0wwUUFDSXNqTHl5Tnp5ekVwOXc2U1hjSVZrNXJpVjVxQVFrZy91N3U3YVdob2FGVGNSZ2g3L1BpeDJlTkw0YzlWdHJDZEhCMHNFUXo2OE9GRGNuRnhJU2NuSjlWOUJ3Y0hzUWhMeHBjaWtiMXM0WDVzcFNVV0JpRXNYTGhRZThMTlByMXQyemF4Q0hQSGw5aXhWMWE0QjRmRTNFUUZQc3Y1SzAyYk5rMEExNlBLRm1ZNjVMbm16b0ZkWXZsUGRvazJQdVZ3UEd0enRpMG1Ka1pFQ2VRS1lEdjF3NlpLc05sQ1dCUVNKTENrcVlKWXp0SXFXN2dQU29PbFRGMTVhR2lvaW5yaEZuSmljL0xrU1ZIK0kzdkRjM0FMTU4zNjlldVJnWms4RHd6QzhyYzZjWnpuY3Rza3YwSjJ0bmp4NGxIVTI5TFNJdGhzMzc1OUluNzI5Zlc5eUFFNEp1T2Q5UFIwazMwNExDd01RL3lwcm5EMWdnVUxUQm9FUFFYNEpxeUx5Q0JUNzY1ZHU4VHZVRFk3TzF0UU42S1FYR2pDTUJzM2JqUjZIcmdZazFLL3BzTEZDUWtKL1JqUW1DMkNzc2pFb0N6OFZtYXpyS3dzRWRyazV5NWZ2aXlZc0tlblJ4V2ZjU2dURXhQRjdoZ3pGNTZUMmx1OTZncDNRMmtjREVNclJzV0JyZzJVeFJiTFVZSHJRQ29xS2hyMVBGZ1FPVExJU2ZabmhMaXRXN2VLN003UWZQSHhhT0ZSdnJhYTdydWtwQ1NENFlXcldlR3phUEJoWWlpQU5IUFBuajA2MzBNNkNSZlJURVczYjkrdWR6NzA0ZGpDYUJxV2F5dVI2dmpFbHlVbko3OTkrUEJocmVFRkhVaFVHNkJnSEM0NWhDRWgxeGNTa2V6bjVPVFF2SG56Vkl1RUlJcGd4NlJzYkpUQWdLamkxVHRCbW4ySllNWmZLMWV1ZE5CVkhFNlVyRjI3bG5iczJJRnk0MDNHaUs0eUg4SDV5N1MwdEVrdDg3RVRyS3hTYXUyT0dHcG9mN3Q2OWVvWXBWSVpqMU0vMFlMcUJBV0ExTTFzTWFiemd4Vzl5NnpVc0duVHBnbTFMQ0lPaUlWRDdGNWRyVmQ5M1VzZlJpVW4zbUVIRHg0Y2Q4c2lUSUs2MTZ4Wjh3TTYvT2IyaDkwWlJSdzFvcUcwb1Q2Q3VSSWRIVTBIRGh5QUlwL0RKUzN0d01QUHYyWjhtcEdSb1Nnckt4c3pSVUhuYUF0czNyeTVDMDFMOVhnN0Z0ODRGakYrWkVZTFJ6a2s5UXZNYmw3allPM2V2UnZ4TlkrUndmaDNQTDRpNFpDK3cvaU1jOXZ3MHRKU3RKSkVjOFNRNEVDQnVaQS9wNmFtRGtpdHAyOFlKbjAwVVZqd1lURkNhdTNIY1lFWkNxWHYzTGtqRWgxOEJrTnVERllEQmFNL3dTeUs1T1U4NDNjR3FMUnJJcjdUNlpKWHBLK2h3ZEtYVURjd0x3UEJ2MTFLdnB1bFlzRWlHU3VGSjB6K0YyQUF5Q2FwMzRNMnVrVUFBQUFBU1VWT1JLNUNZSUk9XFxcIiBhbHQ9XFxcImNsb3NlXFxcIi8+XCIpXG4gICAgICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiIDogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyaWdodFwiICAgIDogXCItOXB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRvcFwiICAgICAgOiBcIi04cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIiAgICA6IFwiNDRweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIiAgIDogXCI0NHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInotaW5kZXhcIiAgOiBcIjEwMDAwXCJcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lLmxpZ2h0Ym94KFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjbG9uZURhdGEuY29udGVudFdpZHRoID0gdztcbiAgICAgICAgICAgIGNsb25lRGF0YS5jb250ZW50SGVpZ2h0ID0gaDtcbiAgICAgICAgICAgIGNsb25lRGF0YS5vcGVuZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2xvbmVEYXRhLnJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUubGlnaHRib3goXCJyZXNpemVcIik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkKHdpbmRvdykub24oXCJyZXNpemVcIiwgY2xvbmVEYXRhLnJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICAgICAgJCh3aW5kb3cpLm9uKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgY2xvbmVEYXRhLnJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgICAgICAgICBkYXRhLnBvc3RvcGVuLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFxuICAgICAgICBjbG9zZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhKFwibGlnaHRib3hcIik7XG5cbiAgICAgICAgICAgIGRhdGEucHJlY2xvc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgJCh3aW5kb3cpLm9mZihcInJlc2l6ZVwiLCBkYXRhLnJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICAgICAgJCh3aW5kb3cpLm9mZihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIGRhdGEucmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgICAgIGRhdGEub3BlbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBkYXRhLm92ZXJsYXkucmVtb3ZlKCk7XG4gICAgICAgICAgICBkYXRhLm92ZXJsYXkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGRhdGEucG9zdGNsb3NlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIGRhdGEuYm94LnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHJlc2l6ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhKFwibGlnaHRib3hcIiksXG4gICAgICAgICAgICAgICAgdywgaDtcblxuICAgICAgICAgICAgZGF0YS5wcmVyZXNpemUuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuZnVsbHNjcmVlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHcgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBoID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gZGF0YS5jb250ZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgaCA9IGRhdGEuY29udGVudEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zY2FsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGNvbXB1dGVSYXRpbyh3LCBoKTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHBhcnNlSW50KHcgKiByLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGggPSBwYXJzZUludChoICogciwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NhbGVFbGVtZW50KGRhdGEuYm94LCB3LCBoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChkYXRhLmJveCwgdywgaCk7XG5cbiAgICAgICAgICAgIHNjYWxlRWxlbWVudChkYXRhLmNvbnRlbnRzLCB3LCBoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChkYXRhLmNvbnRlbnRzLCB3LCBoKTtcblxuICAgICAgICAgICAgZGF0YS5jb250ZW50V2lkdGggPSB3O1xuICAgICAgICAgICAgZGF0YS5jb250ZW50SGVpZ2h0ID0gaDtcblxuICAgICAgICAgICAgZGF0YS5wb3N0cmVzaXplLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEoXCJsaWdodGJveFwiKS5vcGVuZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpZ2h0Ym94KFwiY2xvc2VcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGlnaHRib3goXCJvcGVuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoXCJsaWdodGJveFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoICFkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucywgeyBvcGVuZWQgOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZGF0YShcImxpZ2h0Ym94XCIsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoJHRoaXMuZGF0YShcImxpZ2h0Ym94XCIpLmRlZmF1bHRFdmVudEhhbmRsaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vZGlmaWVkIGZyb20gZWNtYW5hdXQncyBhbnN3ZXIgYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMTAzODQyL3NhZmFyaS1pcGFkLXByZXZlbnQtem9vbS1vbi1kb3VibGUtdGFwXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9uKFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQyID0gZS50aW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSAkdGhpcy5kYXRhKFwibGlnaHRib3hcIikubGFzdFRvdWNoIHx8IHQyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0ID0gdDIgLSB0MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5nZXJzID0gZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZGF0YShcImxpZ2h0Ym94XCIpLmxhc3RUb3VjaCA9IHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkdCB8fCBkdCA+IDUwMCB8fCBmaW5nZXJzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gZG91YmxlIHRhcCAtIHByZXZlbnQgdGhlIHpvb21cbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmxpZ2h0Ym94KFwidG9nZ2xlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4ubGlnaHRib3ggPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIGlmICggbWV0aG9kc1ttZXRob2RdICkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbIG1ldGhvZCBdLmFwcGx5KCB0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICkpO1xuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbWV0aG9kID09PSBcIm9iamVjdFwiIHx8ICFtZXRob2QgKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuZXJyb3IoIFwiTWV0aG9kIFwiICsgIG1ldGhvZCArIFwiIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS5saWdodGJveFwiICk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY29tcHV0ZVJhdGlvID0gZnVuY3Rpb24gKG9yaWdpbmFsV2lkdGgsIG9yaWdpbmFsSGVpZ2h0KSB7XG4gICAgICAgIHZhciB3ciA9IChvcmlnaW5hbFdpZHRoID4gMCkgPyB3aW5kb3cuaW5uZXJXaWR0aCAvIG9yaWdpbmFsV2lkdGggOiAxLFxuICAgICAgICAgICAgaHIgPSAob3JpZ2luYWxIZWlnaHQgPiAwKSA/IHdpbmRvdy5pbm5lckhlaWdodCAvIG9yaWdpbmFsSGVpZ2h0IDogMSxcbiAgICAgICAgICAgIHIgPSBNYXRoLm1pbih3ciwgaHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgdmFyIHNjYWxlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGVsZW0uY3NzKFwid2lkdGhcIiwgd2lkdGggKyBcInB4XCIpXG4gICAgICAgICAgICAuY3NzKFwiaGVpZ2h0XCIsIGhlaWdodCArIFwicHhcIik7XG4gICAgfTtcblxuICAgIHZhciBwb3NpdGlvbkVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgbGVmdCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAgLSB3aWR0aCkgLyAyLFxuICAgICAgICAgICAgdG9wID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgICB0b3AgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbS5jc3MoXCJsZWZ0XCIsIGxlZnQgKyBcInB4XCIpXG4gICAgICAgICAgICAuY3NzKFwidG9wXCIsIHRvcCArIFwicHhcIik7XG4gICAgfTtcblxufShqUXVlcnkpKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgdmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuICAgIGZvcih2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSsnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdKydDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IHdpbmRvd1t2ZW5kb3JzW3hdKydDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICB9XG4gXG4gICAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgICAgICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpOyB9LCBcbiAgICAgICAgICAgICAgdGltZVRvQ2FsbCk7XG4gICAgICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICB9XG4gXG4gICAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTtcbiIsIi8qKlxuc3ByaW50ZigpIGZvciBKYXZhU2NyaXB0IDAuNy1iZXRhMVxuaHR0cDovL3d3dy5kaXZlaW50b2phdmFzY3JpcHQuY29tL3Byb2plY3RzL2phdmFzY3JpcHQtc3ByaW50ZlxuXG5Db3B5cmlnaHQgKGMpIEFsZXhhbmRydSBNYXJhc3RlYW51IDxhbGV4YWhvbGljIFthdCkgZ21haWwgKGRvdF0gY29tPlxuQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG5tb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2Ygc3ByaW50ZigpIGZvciBKYXZhU2NyaXB0IG5vciB0aGVcbiAgICAgIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gICAgICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgQWxleGFuZHJ1IE1hcmFzdGVhbnUgQkUgTElBQkxFIEZPUiBBTllcbkRJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbk9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cblxuQ2hhbmdlbG9nOlxuMjAxMC4xMS4wNyAtIDAuNy1iZXRhMS1ub2RlXG4gIC0gY29udmVydGVkIGl0IHRvIGEgbm9kZS5qcyBjb21wYXRpYmxlIG1vZHVsZVxuXG4yMDEwLjA5LjA2IC0gMC43LWJldGExXG4gIC0gZmVhdHVyZXM6IHZzcHJpbnRmLCBzdXBwb3J0IGZvciBuYW1lZCBwbGFjZWhvbGRlcnNcbiAgLSBlbmhhbmNlbWVudHM6IGZvcm1hdCBjYWNoZSwgcmVkdWNlZCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvblxuXG4yMDEwLjA1LjIyIC0gMC42OlxuIC0gcmV2ZXJ0ZWQgdG8gMC40IGFuZCBmaXhlZCB0aGUgYnVnIHJlZ2FyZGluZyB0aGUgc2lnbiBvZiB0aGUgbnVtYmVyIDBcbiBOb3RlOlxuIFRoYW5rcyB0byBSYXBoYWVsIFBpZ3VsbGEgPHJhcGggKGF0XSBuM3JkIFtkb3QpIG9yZz4gKGh0dHA6Ly93d3cubjNyZC5vcmcvKVxuIHdobyB3YXJuZWQgbWUgYWJvdXQgYSBidWcgaW4gMC41LCBJIGRpc2NvdmVyZWQgdGhhdCB0aGUgbGFzdCB1cGRhdGUgd2FzXG4gYSByZWdyZXNzLiBJIGFwcG9sb2dpemUgZm9yIHRoYXQuXG5cbjIwMTAuMDUuMDkgLSAwLjU6XG4gLSBidWcgZml4OiAwIGlzIG5vdyBwcmVjZWVkZWQgd2l0aCBhICsgc2lnblxuIC0gYnVnIGZpeDogdGhlIHNpZ24gd2FzIG5vdCBhdCB0aGUgcmlnaHQgcG9zaXRpb24gb24gcGFkZGVkIHJlc3VsdHMgKEthbWFsIEFiZGFsaSlcbiAtIHN3aXRjaGVkIGZyb20gR1BMIHRvIEJTRCBsaWNlbnNlXG5cbjIwMDcuMTAuMjEgLSAwLjQ6XG4gLSB1bml0IHRlc3QgYW5kIHBhdGNoIChEYXZpZCBCYWlyZClcblxuMjAwNy4wOS4xNyAtIDAuMzpcbiAtIGJ1ZyBmaXg6IG5vIGxvbmdlciB0aHJvd3MgZXhjZXB0aW9uIG9uIGVtcHR5IHBhcmFtZW50ZXJzIChIYW5zIFB1ZmFsKVxuXG4yMDA3LjA5LjExIC0gMC4yOlxuIC0gZmVhdHVyZTogYWRkZWQgYXJndW1lbnQgc3dhcHBpbmdcblxuMjAwNy4wNC4wMyAtIDAuMTpcbiAtIGluaXRpYWwgcmVsZWFzZVxuKiovXG5cbnZhciBzcHJpbnRmID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRfdHlwZSh2YXJpYWJsZSkge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFyaWFibGUpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cdGZ1bmN0aW9uIHN0cl9yZXBlYXQoaW5wdXQsIG11bHRpcGxpZXIpIHtcblx0XHRmb3IgKHZhciBvdXRwdXQgPSBbXTsgbXVsdGlwbGllciA+IDA7IG91dHB1dFstLW11bHRpcGxpZXJdID0gaW5wdXQpIHsvKiBkbyBub3RoaW5nICovfVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHR2YXIgc3RyX2Zvcm1hdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghc3RyX2Zvcm1hdC5jYWNoZS5oYXNPd25Qcm9wZXJ0eShhcmd1bWVudHNbMF0pKSB7XG5cdFx0XHRzdHJfZm9ybWF0LmNhY2hlW2FyZ3VtZW50c1swXV0gPSBzdHJfZm9ybWF0LnBhcnNlKGFyZ3VtZW50c1swXSk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHJfZm9ybWF0LmZvcm1hdC5jYWxsKG51bGwsIHN0cl9mb3JtYXQuY2FjaGVbYXJndW1lbnRzWzBdXSwgYXJndW1lbnRzKTtcblx0fTtcblxuXHQvLyBjb252ZXJ0IG9iamVjdCB0byBzaW1wbGUgb25lIGxpbmUgc3RyaW5nIHdpdGhvdXQgaW5kZW50YXRpb24gb3Jcblx0Ly8gbmV3bGluZXMuIE5vdGUgdGhhdCB0aGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHByaW50IGFycmF5XG5cdC8vIHZhbHVlcyB0byB0aGVpciBhY3R1YWwgcGxhY2UgZm9yIHNwYXJzZSBhcnJheXMuIFxuXHQvL1xuXHQvLyBGb3IgZXhhbXBsZSBzcGFyc2UgYXJyYXkgbGlrZSB0aGlzXG5cdC8vICAgIGwgPSBbXVxuXHQvLyAgICBsWzRdID0gMVxuXHQvLyBXb3VsZCBiZSBwcmludGVkIGFzIFwiWzFdXCIgaW5zdGVhZCBvZiBcIlssICwgLCAsIDFdXCJcblx0Ly8gXG5cdC8vIElmIGFyZ3VtZW50ICdzZWVuJyBpcyBub3QgbnVsbCBhbmQgYXJyYXkgdGhlIGZ1bmN0aW9uIHdpbGwgY2hlY2sgZm9yIFxuXHQvLyBjaXJjdWxhciBvYmplY3QgcmVmZXJlbmNlcyBmcm9tIGFyZ3VtZW50LlxuXHRzdHJfZm9ybWF0Lm9iamVjdF9zdHJpbmdpZnkgPSBmdW5jdGlvbihvYmosIGRlcHRoLCBtYXhkZXB0aCwgc2Vlbikge1xuXHRcdHZhciBzdHIgPSAnJztcblx0XHRpZiAob2JqICE9IG51bGwpIHtcblx0XHRcdHN3aXRjaCggdHlwZW9mKG9iaikgKSB7XG5cdFx0XHRjYXNlICdmdW5jdGlvbic6IFxuXHRcdFx0XHRyZXR1cm4gJ1tGdW5jdGlvbicgKyAob2JqLm5hbWUgPyAnOiAnK29iai5uYW1lIDogJycpICsgJ10nO1xuXHRcdFx0ICAgIGJyZWFrO1xuXHRcdFx0Y2FzZSAnb2JqZWN0Jzpcblx0XHRcdFx0aWYgKCBvYmogaW5zdGFuY2VvZiBFcnJvcikgeyByZXR1cm4gJ1snICsgb2JqLnRvU3RyaW5nKCkgKyAnXScgfTtcblx0XHRcdFx0aWYgKGRlcHRoID49IG1heGRlcHRoKSByZXR1cm4gJ1tPYmplY3RdJ1xuXHRcdFx0XHRpZiAoc2Vlbikge1xuXHRcdFx0XHRcdC8vIGFkZCBvYmplY3QgdG8gc2VlbiBsaXN0XG5cdFx0XHRcdFx0c2VlbiA9IHNlZW4uc2xpY2UoMClcblx0XHRcdFx0XHRzZWVuLnB1c2gob2JqKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2JqLmxlbmd0aCAhPSBudWxsKSB7IC8vYXJyYXlcblx0XHRcdFx0XHRzdHIgKz0gJ1snO1xuXHRcdFx0XHRcdHZhciBhcnIgPSBbXVxuXHRcdFx0XHRcdGZvciAodmFyIGkgaW4gb2JqKSB7XG5cdFx0XHRcdFx0XHRpZiAoc2VlbiAmJiBzZWVuLmluZGV4T2Yob2JqW2ldKSA+PSAwKSBhcnIucHVzaCgnW0NpcmN1bGFyXScpO1xuXHRcdFx0XHRcdFx0ZWxzZSBhcnIucHVzaChzdHJfZm9ybWF0Lm9iamVjdF9zdHJpbmdpZnkob2JqW2ldLCBkZXB0aCsxLCBtYXhkZXB0aCwgc2VlbikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHIgKz0gYXJyLmpvaW4oJywgJykgKyAnXSc7XG5cdFx0XHRcdH0gZWxzZSBpZiAoJ2dldE1vbnRoJyBpbiBvYmopIHsgLy8gZGF0ZVxuXHRcdFx0XHRcdHJldHVybiAnRGF0ZSgnICsgb2JqICsgJyknO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBvYmplY3Rcblx0XHRcdFx0XHRzdHIgKz0gJ3snO1xuXHRcdFx0XHRcdHZhciBhcnIgPSBbXVxuXHRcdFx0XHRcdGZvciAodmFyIGsgaW4gb2JqKSB7IFxuXHRcdFx0XHRcdFx0aWYob2JqLmhhc093blByb3BlcnR5KGspKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzZWVuICYmIHNlZW4uaW5kZXhPZihvYmpba10pID49IDApIGFyci5wdXNoKGsgKyAnOiBbQ2lyY3VsYXJdJyk7XG5cdFx0XHRcdFx0XHRcdGVsc2UgYXJyLnB1c2goayArJzogJyArc3RyX2Zvcm1hdC5vYmplY3Rfc3RyaW5naWZ5KG9ialtrXSwgZGVwdGgrMSwgbWF4ZGVwdGgsIHNlZW4pKTsgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0ciArPSBhcnIuam9pbignLCAnKSArICd9Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc3RyO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3N0cmluZyc6XHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuICdcIicgKyBvYmogKyAnXCInO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gJycgKyBvYmo7XG5cdH1cblxuXHRzdHJfZm9ybWF0LmZvcm1hdCA9IGZ1bmN0aW9uKHBhcnNlX3RyZWUsIGFyZ3YpIHtcblx0XHR2YXIgY3Vyc29yID0gMSwgdHJlZV9sZW5ndGggPSBwYXJzZV90cmVlLmxlbmd0aCwgbm9kZV90eXBlID0gJycsIGFyZywgb3V0cHV0ID0gW10sIGksIGssIG1hdGNoLCBwYWQsIHBhZF9jaGFyYWN0ZXIsIHBhZF9sZW5ndGg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHRyZWVfbGVuZ3RoOyBpKyspIHtcblx0XHRcdG5vZGVfdHlwZSA9IGdldF90eXBlKHBhcnNlX3RyZWVbaV0pO1xuXHRcdFx0aWYgKG5vZGVfdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0b3V0cHV0LnB1c2gocGFyc2VfdHJlZVtpXSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChub2RlX3R5cGUgPT09ICdhcnJheScpIHtcblx0XHRcdFx0bWF0Y2ggPSBwYXJzZV90cmVlW2ldOyAvLyBjb252ZW5pZW5jZSBwdXJwb3NlcyBvbmx5XG5cdFx0XHRcdGlmIChtYXRjaFsyXSkgeyAvLyBrZXl3b3JkIGFyZ3VtZW50XG5cdFx0XHRcdFx0YXJnID0gYXJndltjdXJzb3JdO1xuXHRcdFx0XHRcdGZvciAoayA9IDA7IGsgPCBtYXRjaFsyXS5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRcdFx0aWYgKCFhcmcuaGFzT3duUHJvcGVydHkobWF0Y2hbMl1ba10pKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihzcHJpbnRmKCdbc3ByaW50Zl0gcHJvcGVydHkgXCIlc1wiIGRvZXMgbm90IGV4aXN0JywgbWF0Y2hbMl1ba10pKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFyZyA9IGFyZ1ttYXRjaFsyXVtrXV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKG1hdGNoWzFdKSB7IC8vIHBvc2l0aW9uYWwgYXJndW1lbnQgKGV4cGxpY2l0KVxuXHRcdFx0XHRcdGFyZyA9IGFyZ3ZbbWF0Y2hbMV1dO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyAvLyBwb3NpdGlvbmFsIGFyZ3VtZW50IChpbXBsaWNpdClcblx0XHRcdFx0XHRhcmcgPSBhcmd2W2N1cnNvcisrXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICgvW15zT10vLnRlc3QobWF0Y2hbOF0pICYmIChnZXRfdHlwZShhcmcpICE9ICdudW1iZXInKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihzcHJpbnRmKCdbc3ByaW50Zl0gZXhwZWN0aW5nIG51bWJlciBidXQgZm91bmQgJXMgXCInICsgYXJnICsgJ1wiJywgZ2V0X3R5cGUoYXJnKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAobWF0Y2hbOF0pIHtcblx0XHRcdFx0XHRjYXNlICdiJzogYXJnID0gYXJnLnRvU3RyaW5nKDIpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdjJzogYXJnID0gU3RyaW5nLmZyb21DaGFyQ29kZShhcmcpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdkJzogYXJnID0gcGFyc2VJbnQoYXJnLCAxMCk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2UnOiBhcmcgPSBtYXRjaFs3XSA/IGFyZy50b0V4cG9uZW50aWFsKG1hdGNoWzddKSA6IGFyZy50b0V4cG9uZW50aWFsKCk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2YnOiBhcmcgPSBtYXRjaFs3XSA/IHBhcnNlRmxvYXQoYXJnKS50b0ZpeGVkKG1hdGNoWzddKSA6IHBhcnNlRmxvYXQoYXJnKTsgYnJlYWs7XG5cdFx0XHRcdCAgICBjYXNlICdPJzogYXJnID0gc3RyX2Zvcm1hdC5vYmplY3Rfc3RyaW5naWZ5KGFyZywgMCwgcGFyc2VJbnQobWF0Y2hbN10pIHx8IDUpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdvJzogYXJnID0gYXJnLnRvU3RyaW5nKDgpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdzJzogYXJnID0gKChhcmcgPSBTdHJpbmcoYXJnKSkgJiYgbWF0Y2hbN10gPyBhcmcuc3Vic3RyaW5nKDAsIG1hdGNoWzddKSA6IGFyZyk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3UnOiBhcmcgPSBNYXRoLmFicyhhcmcpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICd4JzogYXJnID0gYXJnLnRvU3RyaW5nKDE2KTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnWCc6IGFyZyA9IGFyZy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgYnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0YXJnID0gKC9bZGVmXS8udGVzdChtYXRjaFs4XSkgJiYgbWF0Y2hbM10gJiYgYXJnID49IDAgPyAnKycrIGFyZyA6IGFyZyk7XG5cdFx0XHRcdHBhZF9jaGFyYWN0ZXIgPSBtYXRjaFs0XSA/IG1hdGNoWzRdID09ICcwJyA/ICcwJyA6IG1hdGNoWzRdLmNoYXJBdCgxKSA6ICcgJztcblx0XHRcdFx0cGFkX2xlbmd0aCA9IG1hdGNoWzZdIC0gU3RyaW5nKGFyZykubGVuZ3RoO1xuXHRcdFx0XHRwYWQgPSBtYXRjaFs2XSA/IHN0cl9yZXBlYXQocGFkX2NoYXJhY3RlciwgcGFkX2xlbmd0aCkgOiAnJztcblx0XHRcdFx0b3V0cHV0LnB1c2gobWF0Y2hbNV0gPyBhcmcgKyBwYWQgOiBwYWQgKyBhcmcpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9O1xuXG5cdHN0cl9mb3JtYXQuY2FjaGUgPSB7fTtcblxuXHRzdHJfZm9ybWF0LnBhcnNlID0gZnVuY3Rpb24oZm10KSB7XG5cdFx0dmFyIF9mbXQgPSBmbXQsIG1hdGNoID0gW10sIHBhcnNlX3RyZWUgPSBbXSwgYXJnX25hbWVzID0gMDtcblx0XHR3aGlsZSAoX2ZtdCkge1xuXHRcdFx0aWYgKChtYXRjaCA9IC9eW15cXHgyNV0rLy5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRwYXJzZV90cmVlLnB1c2gobWF0Y2hbMF0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoKG1hdGNoID0gL15cXHgyNXsyfS8uZXhlYyhfZm10KSkgIT09IG51bGwpIHtcblx0XHRcdFx0cGFyc2VfdHJlZS5wdXNoKCclJyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgobWF0Y2ggPSAvXlxceDI1KD86KFsxLTldXFxkKilcXCR8XFwoKFteXFwpXSspXFwpKT8oXFwrKT8oMHwnW14kXSk/KC0pPyhcXGQrKT8oPzpcXC4oXFxkKykpPyhbYi1mb3NPdXhYXSkvLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChtYXRjaFsyXSkge1xuXHRcdFx0XHRcdGFyZ19uYW1lcyB8PSAxO1xuXHRcdFx0XHRcdHZhciBmaWVsZF9saXN0ID0gW10sIHJlcGxhY2VtZW50X2ZpZWxkID0gbWF0Y2hbMl0sIGZpZWxkX21hdGNoID0gW107XG5cdFx0XHRcdFx0aWYgKChmaWVsZF9tYXRjaCA9IC9eKFthLXpfXVthLXpfXFxkXSopL2kuZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuXHRcdFx0XHRcdFx0d2hpbGUgKChyZXBsYWNlbWVudF9maWVsZCA9IHJlcGxhY2VtZW50X2ZpZWxkLnN1YnN0cmluZyhmaWVsZF9tYXRjaFswXS5sZW5ndGgpKSAhPT0gJycpIHtcblx0XHRcdFx0XHRcdFx0aWYgKChmaWVsZF9tYXRjaCA9IC9eXFwuKFthLXpfXVthLXpfXFxkXSopL2kuZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRfbGlzdC5wdXNoKGZpZWxkX21hdGNoWzFdKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIGlmICgoZmllbGRfbWF0Y2ggPSAvXlxcWyhcXGQrKVxcXS8uZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRfbGlzdC5wdXNoKGZpZWxkX21hdGNoWzFdKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1tzcHJpbnRmXSAnICsgcmVwbGFjZW1lbnRfZmllbGQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbc3ByaW50Zl0gJyArIHJlcGxhY2VtZW50X2ZpZWxkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bWF0Y2hbMl0gPSBmaWVsZF9saXN0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGFyZ19uYW1lcyB8PSAyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhcmdfbmFtZXMgPT09IDMpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1tzcHJpbnRmXSBtaXhpbmcgcG9zaXRpb25hbCBhbmQgbmFtZWQgcGxhY2Vob2xkZXJzIGlzIG5vdCAoeWV0KSBzdXBwb3J0ZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZV90cmVlLnB1c2gobWF0Y2gpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignW3NwcmludGZdICcgKyBfZm10KTtcblx0XHRcdH1cblx0XHRcdF9mbXQgPSBfZm10LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyc2VfdHJlZTtcblx0fTtcblxuXHRyZXR1cm4gc3RyX2Zvcm1hdDtcbn0pKCk7XG5cbnZhciB2c3ByaW50ZiA9IGZ1bmN0aW9uKGZtdCwgYXJndikge1xuXHR2YXIgYXJndkNsb25lID0gYXJndi5zbGljZSgpO1xuXHRhcmd2Q2xvbmUudW5zaGlmdChmbXQpO1xuXHRyZXR1cm4gc3ByaW50Zi5hcHBseShudWxsLCBhcmd2Q2xvbmUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzcHJpbnRmO1xuc3ByaW50Zi5zcHJpbnRmID0gc3ByaW50ZjtcbnNwcmludGYudnNwcmludGYgPSB2c3ByaW50ZjtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIERhdGEgPSByZXF1aXJlKCcuL2RhdGEuanMnKSxcbiAgICBEYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKTtcblxuLyoqXG4gKiBAY2xhc3MgQXJyYXlEYXRhXG4gKiBAZm9yIEFycmF5RGF0YVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2FycmF5fSBjb2x1bW5zIEEgYXJyYXkgb2YgRGF0YVZhcmlhYmxlc1xuICogQHBhcmFtIHthcnJheX0gc3RyaW5nQXJyYXkgQSBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIHdpbGwgbGF0ZXIgYmUgcGFyc2VkIGludG8gRGF0YVZhbHVlc1xuICovXG52YXIgQXJyYXlEYXRhID0gbmV3IGplcm1haW5lLk1vZGVsKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgQXJyYXlEYXRhID0gdGhpczsgLy8gaHVoPyAgVGhpcyBzaGFkb3dzIHRoZSBBcnJheURhdGEgZGVmaW5lZCBvbiB0aGUgcHJldmlvdXMgbGluZS5cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgSXMgdGhhdCBpbnRlbmRlZC9jb3JyZWN0PyAgUHJvYmFibHksIGJ1dCBuZWVkIHRvIGNoZWNrIGZvciBzdXJlLlxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICBtYnAgV2VkIEZlYiAyNSAxODozMToxNSAyMDE1XG5cbiAgICB0aGlzLmlzQShEYXRhKTtcbiAgICB0aGlzLmhhc0FuKFwiYXJyYXlcIik7XG4gICAgdGhpcy5oYXNBKFwic3RyaW5nQXJyYXlcIik7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcImNvbHVtbnNcIiwgXCJzdHJpbmdBcnJheVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLmFkZExpc3RlbmVyKFwibGlzdGVuZXJBZGRlZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXRUeXBlID09PSBcImRhdGFSZWFkeVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmFycmF5KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQubGlzdGVuZXIoZGF0YVswXVswXSwgZGF0YVtkYXRhLmxlbmd0aC0xXVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEl0ZXJhdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmcgYXJyYXl9IGNvbHVtbklEc1xuICAgICAqIEBwYXJhbSB7RGF0YVZhbHVlfSBtaW5cbiAgICAgKiBAcGFyYW0ge0RhdGFWYWx1ZX0gbWF4XG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBidWZmZXJcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZ2V0SXRlcmF0b3JcIiwgZnVuY3Rpb24gKGNvbHVtbklkcywgbWluLCBtYXgsIGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gQXJyYXlEYXRhLmdldEFycmF5RGF0YUl0ZXJhdG9yKHRoaXMsIGNvbHVtbklkcywgbWluLCBtYXgsIGJ1ZmZlcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSB1cHBlciBhbmQgbG93ZXIgYm91bmRzIG9mIGEgY29sdW1uIGluIGEgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0Qm91bmRzXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBjb2x1bW5OdW1iZXIgQ29sdW1uIGluIHRoZSBkYXRhc2V0IHRvIGhhdmUgaXRzIGJvdW5kcyBkZXRlcm1pbmVkLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBpbiB0aGUgZm9ybTogW2xvd2VyQm91bmQsIHVwcGVyQm91bmRdLlxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJnZXRCb3VuZHNcIiwgZnVuY3Rpb24gKGNvbHVtbk51bWJlcikge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuYXJyYXkoKSxcbiAgICAgICAgICAgIG1pbiA9IGRhdGFbMF1bY29sdW1uTnVtYmVyXSxcbiAgICAgICAgICAgIG1heCA9IG1pbixcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRhW2ldW2NvbHVtbk51bWJlcl0gPCBtaW4pIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBkYXRhW2ldW2NvbHVtbk51bWJlcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YVtpXVtjb2x1bW5OdW1iZXJdID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gZGF0YVtpXVtjb2x1bW5OdW1iZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIG9uUmVhZHlcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZ2V0QXJyYXlEYXRhSXRlcmF0b3JcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheURhdGF9IGFycmF5RGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIGFycmF5fSBjb2x1bW5JRHNcbiAgICAgKiBAcGFyYW0ge0RhdGFWYWx1ZX0gbWluXG4gICAgICogQHBhcmFtIHtEYXRhVmFsdWV9IG1heFxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gYnVmZmVyXG4gICAgICogQHJldHVybiBpdGVyXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIEFycmF5RGF0YS5nZXRBcnJheURhdGFJdGVyYXRvciA9IGZ1bmN0aW9uIChhcnJheURhdGEsIGNvbHVtbklkcywgbWluLCBtYXgsIGJ1ZmZlcikge1xuXG4gICAgICAgIHZhciBpLCBqLFxuICAgICAgICAgICAgZmlyc3RJbmRleCwgbGFzdEluZGV4LFxuICAgICAgICAgICAgY3VycmVudEluZGV4LFxuICAgICAgICAgICAgY29sdW1uSW5kaWNlcyxcbiAgICAgICAgICAgIGFycmF5ID0gYXJyYXlEYXRhLmFycmF5KCk7XG5cbiAgICAgICAgYnVmZmVyID0gYnVmZmVyIHx8IDA7XG5cbiAgICAgICAgLy8gY29sdW1uSWRzIGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KGNvbHVtbklkcykgIT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlEYXRhOiBnZXRJdGVyYXRvciBtZXRob2QgcmVxdWlyZXMgdGhhdCB0aGUgZmlyc3QgcGFyYW1ldGVyIGJlIGFuIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uSWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjb2x1bW5JZHNbaV0pICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5RGF0YTogZ2V0SXRlcmF0b3IgbWV0aG9kIHJlcXVpcmVzIHRoYXQgdGhlIGZpcnN0IHBhcmFtZXRlciBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vbWluLG1heCBhcmd1bWVudHMgc2hvdWxkIGJlIGRhdGEgdmFsdWVzXG4gICAgICAgIGlmICghRGF0YVZhbHVlLmlzSW5zdGFuY2UobWluKSB8fCAhRGF0YVZhbHVlLmlzSW5zdGFuY2UobWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlEYXRhOiBnZXRJdGVyYXRvciBtZXRob2QgcmVxdWlyZXMgdGhlIHNlY29uZCBhbmQgdGhpcmQgYXJndW1lbnQgdG8gYmUgbnVtYmVyIHZhbHVlc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYnVmZmVyIGFyZ3VtZW50IHNob3VsZCBiZSBhbiBpbnRlZ2VyXG4gICAgICAgIGlmICh0eXBlb2YoYnVmZmVyKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlEYXRhOiBnZXRJdGVyYXRvciBtZXRob2QgcmVxdWlyZXMgbGFzdCBhcmd1bWVudCB0byBiZSBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBubyBkYXRhLCByZXR1cm4gYW4gZW1wdHkgaXRlcmF0b3JcbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBcIm5leHRcIiAgICA6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgICAgICAgIFwiaGFzTmV4dFwiIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgcm93IGluIHRoZSBhcnJheSB3aG9zZSBjb2x1bW4wIHZhbHVlIGlzID49IG1pblxuICAgICAgICBmb3IgKGZpcnN0SW5kZXggPSAwOyBmaXJzdEluZGV4IDwgYXJyYXkubGVuZ3RoOyArK2ZpcnN0SW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChhcnJheVtmaXJzdEluZGV4XVswXS5nZShtaW4pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmFjayB1cCAnYnVmZmVyJyBzdGVwc1xuICAgICAgICBmaXJzdEluZGV4ID0gZmlyc3RJbmRleCAtIGJ1ZmZlcjtcbiAgICAgICAgaWYgKGZpcnN0SW5kZXggPCAwKSB7XG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gZmluZCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgcm93IGluIHRoZSBhcnJheSB3aG9zZSBjb2x1bW4wIHZhbHVlIGlzIDw9IG1heFxuICAgICAgICBpZiAoZmlyc3RJbmRleCA9PT0gYXJyYXkubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IGZpcnN0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxhc3RJbmRleCA9IGZpcnN0SW5kZXg7IGxhc3RJbmRleCA8IGFycmF5Lmxlbmd0aC0xOyArK2xhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtsYXN0SW5kZXgrMV1bMF0uZ3QobWF4KSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW92ZSBmb3J3YXJkICdidWZmZXInIHN0ZXBzXG4gICAgICAgIGxhc3RJbmRleCA9IGxhc3RJbmRleCArIGJ1ZmZlcjtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGFycmF5Lmxlbmd0aC0xKSB7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBhcnJheS5sZW5ndGgtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbHVtbkluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbklkcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIGsgPSBhcnJheURhdGEuY29sdW1uSWRUb0NvbHVtbk51bWJlcihjb2x1bW5JZHNbal0pO1xuICAgICAgICAgICAgY29sdW1uSW5kaWNlcy5wdXNoKCBrICk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50SW5kZXggPSBmaXJzdEluZGV4O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2plY3Rpb24gPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uSW5kaWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0aW9uLnB1c2goYXJyYXlbY3VycmVudEluZGV4XVtjb2x1bW5JbmRpY2VzW2ldXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc05leHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRleCA8PSBsYXN0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgdGV4dFRvRGF0YVZhbHVlc0FycmF5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IGRhdGFWYXJpYWJsZUFycmF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gZGF0YVZhbHVlc1xuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKiBAdG9kbyBJZiB0aGUgbnVtYmVyIG9mIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXMgb24gdGhlIGN1cnJlbnQgbGluZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtZXRhZGF0YSwgc2hvdWxkIHRocm93IGFuIGVycm9yLlxuICAgICAqL1xuICAgIEFycmF5RGF0YS50ZXh0VG9EYXRhVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAoZGF0YVZhcmlhYmxlQXJyYXksIHRleHQpIHtcbiAgICAgICAgLy9JTVBPUlRBTlQgTk9URTogZGF0YVZhcmlhYmxlQXJyYXkgaXMgYSBwbGFpbiBqYXZhc2NyaXB0IGFycmF5IG9mIERhdGFWYXJpYWJsZSBpbnN0YW5jZXM7IGl0XG4gICAgICAgIC8vaXMgTk9UIGEgamVybWFpbmUgYXR0cl9saXN0LlxuICAgICAgICB2YXIgZGF0YVZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgbGluZXMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoL1xcZC8udGVzdChsaW5lc1tpXSkpIHsgLy8gc2tpcCBsaW5lIHVubGVzcyBpdCBjb250YWlucyBhIGRpZ2l0XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlc1RoaXNSb3cgPSBsaW5lc1tpXS5zcGxpdCgvXFxzKixcXHMqLyksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXNUaGlzUm93ID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGo7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZ1ZhbHVlc1RoaXNSb3cubGVuZ3RoID09PSBkYXRhVmFyaWFibGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0cmluZ1ZhbHVlc1RoaXNSb3cubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXNUaGlzUm93LnB1c2goRGF0YVZhbHVlLnBhcnNlKGRhdGFWYXJpYWJsZUFycmF5W2pdLnR5cGUoKSwgc3RyaW5nVmFsdWVzVGhpc1Jvd1tqXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCggZGF0YVZhbHVlc1RoaXNSb3cgKTtcbiAgICAgICAgICAgICAgICAgICAgLy99IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBnZXQgaGVyZSBpZiB0aGUgbnVtYmVyIG9mIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXMgb24gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICAvLyAobGluZXNbaV0pIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1ldGFkYXRhLiAgVGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgcHJvYmFibHkgdGhyb3cgYW4gZXJyb3IsIG9yIHNvbWV0aGluZyBsaWtlIHRoYXQuICBGb3Igbm93LCB0aG91Z2gsIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgaWdub3JlIGl0LlxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdiYWQgbGluZTogJyArIGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFWYWx1ZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgdGV4dFRvU3RyaW5nQXJyYXlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgXG4gICAgICogQHJldHVybiB7YXJyYXl9IHN0cmluZ1ZhbHVlc1xuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICBBcnJheURhdGEudGV4dFRvU3RyaW5nQXJyYXkgPSBmdW5jdGlvbiAoZGF0YVZhcmlhYmxlcywgdGV4dCkge1xuICAgICAgICB2YXIgc3RyaW5nVmFsdWVzID0gW10sXG4gICAgICAgICAgICBsaW5lcyA9IHRleHQuc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICBzdHJpbmdWYWx1ZXNUaGlzUm93LFxuICAgICAgICAgICAgbnVtQ29sdW1ucyxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgZWFjaCBsaW5lXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzKy8sICAgICBcIlwiKSAgIC8vIHJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKyQvLCAgICAgXCJcIikgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqLFxccyovZywgXCIsXCIpICAvLyByZW1vdmUgYW55IHdoaXRlc3BhY2UgbmV4dCB0byBjb21tYXNcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAgICAgXCIsXCIpOyAvLyByZXBsYWNlIGFueSByZW1haW5pbmcgd2hpdGVzcGFjZSBydW5zIHdpdGggYSBjb21tYVxuICAgICAgICAgICAgLy8gbm93IGxpbmUgY29uc2lzdHMgb2YgY29tbWEtc2VwYXJhdGVkIHZhbHVlcywgd2l0aCBubyB3aGl0ZXNwYWNlXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICgvXFxkLy50ZXN0KGxpbmVzW2ldKSkgeyAvLyBza2lwIGxpbmUgdW5sZXNzIGl0IGNvbnRhaW5zIGEgZGlnaXRcbiAgICAgICAgICAgICAgICBudW1Db2x1bW5zID0gbGluZXNbaV0uc3BsaXQoLywvKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICgvXFxkLy50ZXN0KGxpbmVzW2ldKSkgeyAvLyBza2lwIGxpbmUgdW5sZXNzIGl0IGNvbnRhaW5zIGEgZGlnaXRcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZXNUaGlzUm93ID0gbGluZXNbaV0uc3BsaXQoLywvKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nVmFsdWVzVGhpc1Jvdy5sZW5ndGggPT09IG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nVmFsdWVzLnB1c2goIHN0cmluZ1ZhbHVlc1RoaXNSb3cgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFBhcnNpbmcgRXJyb3I6IFRoZSBsaW5lICdcIiArIGxpbmVzW2ldICsgXCInIGhhcyBcIiArIHN0cmluZ1ZhbHVlc1RoaXNSb3cubGVuZ3RoICsgXCIgZGF0YSBjb2x1bW5zIHdoZW4gaXQgcmVxdWlyZXMgXCIgKyBudW1Db2x1bW5zICsgXCIgY29sdW1uc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIGFycmF5IG9mIHN0cmluZ3MgaW50byBhbiBhcnJheSBvZiBEYXRhVmFsdWVzLlxuICAgICAqIFxuICAgICAqIEBtZXRob2QgdGV4dFRvU3RyaW5nQXJyYXlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHthcnJheX0gZGF0YVZhcmlhYmxlQXJyYXkgcGxhaW4gamF2YXNjcmlwdCBhcnJheSBvZiBEYXRhVmFyaWFibGVzXG4gICAgICogQHBhcmFtIHthcnJheX0gc3RyaW5nQXJyYXkgcGxhaW4gamF2YXNjcmlwdCBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogQHJldHVybiB7YXJyYXl9IHBsYWluIGphdmFzY3JpcHQgYXJyYXkgb2YgRGF0YVZhbHVlIGluc3RhbmNlc1xuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICBBcnJheURhdGEuc3RyaW5nQXJyYXlUb0RhdGFWYWx1ZXNBcnJheSA9IGZ1bmN0aW9uIChkYXRhVmFyaWFibGVBcnJheSwgc3RyaW5nQXJyYXkpIHtcbiAgICAgICAgLy9JTVBPUlRBTlQgTk9URTogZGF0YVZhcmlhYmxlQXJyYXkgaXMgYSBwbGFpbiBqYXZhc2NyaXB0IGFycmF5IG9mIERhdGFWYXJpYWJsZSBpbnN0YW5jZXM7IGl0XG4gICAgICAgIC8vaXMgTk9UIGEgamVybWFpbmUgYXR0cl9saXN0LlxuXG4gICAgICAgIHZhciBkYXRhVmFsdWVzID0gW10sXG4gICAgICAgICAgICBkYXRhVmFsdWVzVGhpc1JvdyxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmdBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZGF0YVZhbHVlc1RoaXNSb3cgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzdHJpbmdBcnJheVtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXNUaGlzUm93LnB1c2goRGF0YVZhbHVlLnBhcnNlKGRhdGFWYXJpYWJsZUFycmF5W2pdLnR5cGUoKSwgc3RyaW5nQXJyYXlbaV1bal0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCggZGF0YVZhbHVlc1RoaXNSb3cgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVZhbHVlcztcbiAgICB9O1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheURhdGE7XG5cbiIsIi8vdmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xudmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzKSxcbiAgICBEaXNwbGFjZW1lbnQgPSByZXF1aXJlKCcuLi9tYXRoL2Rpc3BsYWNlbWVudC5qcycpLFxuICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vbWF0aC9wb2ludC5qcycpLFxuICAgIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi4vY29yZS9kYXRhX21lYXN1cmUuanMnKSxcbiAgICBSR0JDb2xvciA9IHJlcXVpcmUoJy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgRW51bSA9IHJlcXVpcmUoJy4uL21hdGgvZW51bS5qcycpLFxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vZXZlbnRfZW1pdHRlci5qcycpLFxuICAgIFRleHQgPSByZXF1aXJlKCcuLi9jb3JlL3RleHQuanMnKSxcbiAgICBBeGlzQmluZGluZyA9IHJlcXVpcmUoJy4vYXhpc19iaW5kaW5nLmpzJyksXG4gICAgQXhpc1RpdGxlID0gcmVxdWlyZSgnLi9heGlzX3RpdGxlLmpzJyksXG4gICAgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyksXG4gICAgR3JpZCA9IHJlcXVpcmUoJy4vZ3JpZC5qcycpLFxuICAgIExhYmVsZXIgPSByZXF1aXJlKCcuL2xhYmVsZXIuanMnKSxcbiAgICBQYW4gPSByZXF1aXJlKCcuL3Bhbi5qcycpLFxuICAgIFpvb20gPSByZXF1aXJlKCcuL3pvb20uanMnKSxcblxuICAgIFV0aWwgPSByZXF1aXJlKCcuLi9tYXRoL3V0aWwuanMnKSxcblxuICAgIE9yaWVudGF0aW9uID0gbmV3IEVudW0oXCJBeGlzT3JpZW50YXRpb25cIik7XG5cbnZhciBBeGlzID0gbmV3IGplcm1haW5lLk1vZGVsKFwiQXhpc1wiLCBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmlzQShFdmVudEVtaXR0ZXIpO1xuXG4gICAgdGhpcy5oYXNBKFwidGl0bGVcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIHRpdGxlIGluc3RhbmNlb2YgQXhpc1RpdGxlO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzTWFueShcImxhYmVsZXJzXCIpLmVhY2hPZldoaWNoLnZhbGlkYXRlV2l0aChmdW5jdGlvbiAobGFiZWxlcnMpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsZXJzIGluc3RhbmNlb2YgTGFiZWxlcjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJncmlkXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQgaW5zdGFuY2VvZiBHcmlkO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcInBhblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChwYW4pIHtcbiAgICAgICAgcmV0dXJuIHBhbiBpbnN0YW5jZW9mIFBhbjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJ6b29tXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHpvb20pIHtcbiAgICAgICAgcmV0dXJuIHpvb20gaW5zdGFuY2VvZiBab29tO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImJpbmRpbmdcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICByZXR1cm4gYmluZGluZyA9PT0gbnVsbCB8fCBiaW5kaW5nIGluc3RhbmNlb2YgQXhpc0JpbmRpbmc7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBbihcImlkXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcbiAgICB0aGlzLmhhc0EoXCJ0eXBlXCIpLndoaWNoLmlzT25lT2YoRGF0YVZhbHVlLnR5cGVzKCkpO1xuICAgIHRoaXMuaGFzQShcImxlbmd0aFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCBpbnN0YW5jZW9mIERpc3BsYWNlbWVudDtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJwb3NpdGlvblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJwcmVnYXBcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQShcInBvc3RnYXBcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQW4oXCJhbmNob3JcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQShcImJhc2VcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICByZXR1cm4gYmFzZSBpbnN0YW5jZW9mIFBvaW50O1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNBKFwidmlzaWJsZVwiKS53aGljaC5pc0EoXCJib29sZWFuXCIpLmFuZC53aGljaC5kZWZhdWx0c1RvKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBcIm1pblwiIHZhbHVlIGZyb20gdGhlIG11Z2wgZmlsZSBhcyBhIHN0cmluZywgaWYgdGhlcmUgd2FzIG9uZS5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIHN0b3JlZCBhcyBhIHN0cmluZywgcmF0aGVyIHRoYW4gYXMgYSBudW1iZXIgb3IgYSBEYXRhVmFsdWUsXG4gICAgICogYmVjYXVzZSBpdCBtaWdodCBoYXZlIHRoZSB2YWx1ZSBcImF1dG9cIi5cbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJtaW5cIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgbWluIERhdGFWYWx1ZSBmb3IgdGhlIGF4aXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZGF0YU1pblxuICAgICAqIEB0eXBlIHtEYXRhVmFsdWV9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImRhdGFNaW5cIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhVmFsdWUuaXNJbnN0YW5jZSk7XG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGVja2luZyB0byBzZWUgaWYgZGF0YU1pbiBoYXMgYmVlbiBzZXQgb3Igbm90XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGhhc0RhdGFNaW5cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJoYXNEYXRhTWluXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1pbigpICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG5cbiAgICBcbiAgICB0aGlzLmhhc0EoXCJtaW5vZmZzZXRcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQShcIm1pbnBvc2l0aW9uXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKG1pbnBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBtaW5wb3NpdGlvbiBpbnN0YW5jZW9mIERpc3BsYWNlbWVudDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgXCJtYXhcIiB2YWx1ZSBmcm9tIHRoZSBtdWdsIGZpbGUgYXMgYSBzdHJpbmcsIGlmIHRoZXJlIHdhcyBvbmUuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBzdG9yZWQgYXMgYSBzdHJpbmcsIHJhdGhlciB0aGFuIGFzIGEgbnVtYmVyIG9yIGEgRGF0YVZhbHVlLFxuICAgICAqIGJlY2F1c2UgaXQgbWlnaHQgaGF2ZSB0aGUgdmFsdWUgXCJhdXRvXCIuXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwibWF4XCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IG1heCBEYXRhVmFsdWUgZm9yIHRoZSBheGlzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRhdGFNYXhcbiAgICAgKiBAdHlwZSB7RGF0YVZhbHVlfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJkYXRhTWF4XCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YVZhbHVlLmlzSW5zdGFuY2UpO1xuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hlY2tpbmcgdG8gc2VlIGlmIGRhdGFNYXggaGFzIGJlZW4gc2V0IG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaGFzRGF0YU1heFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImhhc0RhdGFNYXhcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTWF4KCkgIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcblxuXG5cbiAgICB0aGlzLmhhc0EoXCJtYXhvZmZzZXRcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQShcIm1heHBvc2l0aW9uXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKG1heHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBtYXhwb3NpdGlvbiBpbnN0YW5jZW9mIERpc3BsYWNlbWVudDtcbiAgICB9KTtcblxuXG4gICAgdGhpcy5oYXNBKFwicG9zaXRpb25iYXNlXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTsgLy8gZGVwcmVjYXRlZFxuICAgIHRoaXMuaGFzQShcImNvbG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvciBpbnN0YW5jZW9mIFJHQkNvbG9yO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcInRpY2tjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3IgPT09IG51bGwgfHwgY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJ0aWNrd2lkdGhcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJ0aWNrbWluXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG4gICAgdGhpcy5oYXNBKFwidGlja21heFwiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuICAgIHRoaXMuaGFzQShcImhpZ2hsaWdodHN0eWxlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGhpZ2hsaWdodHN0eWxlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YoaGlnaGxpZ2h0c3R5bGUpID09PSBcInN0cmluZ1wiO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImxpbmV3aWR0aFwiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuICAgIHRoaXMuaGFzQShcIm9yaWVudGF0aW9uXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoT3JpZW50YXRpb24uaXNJbnN0YW5jZSk7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcIm9yaWVudGF0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ncmlkKG5ldyBHcmlkKCkpO1xuICAgICAgICB0aGlzLnpvb20obmV3IFpvb20oKSk7XG4gICAgICAgIHRoaXMucGFuKG5ldyBQYW4oKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc0EoXCJwaXhlbExlbmd0aFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5oYXNBKFwicGFyYWxsZWxPZmZzZXRcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQShcInBlcnBPZmZzZXRcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuXG4gICAgdGhpcy5oYXNBKFwiYXhpc1RvRGF0YVJhdGlvXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImluaXRpYWxpemVHZW9tZXRyeVwiLCBmdW5jdGlvbiAoZ3JhcGgsIGdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgICB2YXIgcGxvdEJveCA9IGdyYXBoLnBsb3RCb3goKSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbigpLFxuICAgICAgICAgICAgYmFzZSAgICAgPSB0aGlzLmJhc2UoKSxcbiAgICAgICAgICAgIHBpeGVsTGVuZ3RoLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24oKSA9PT0gQXhpcy5IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBwaXhlbExlbmd0aCA9IHRoaXMubGVuZ3RoKCkuY2FsY3VsYXRlTGVuZ3RoKCBwbG90Qm94LndpZHRoKCkgKTtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxMZW5ndGgocGl4ZWxMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5wYXJhbGxlbE9mZnNldCggcG9zaXRpb24ueCgpICsgKGJhc2UueCgpICsgMSkgKiBwbG90Qm94LndpZHRoKCkvMiAtICh0aGlzLmFuY2hvcigpICsgMSkgKiBwaXhlbExlbmd0aCAvIDIgKTtcbiAgICAgICAgICAgIHRoaXMucGVycE9mZnNldCggcG9zaXRpb24ueSgpICsgKGJhc2UueSgpICsgMSkgKiBwbG90Qm94LmhlaWdodCgpIC8gMiApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGl4ZWxMZW5ndGggPSB0aGlzLmxlbmd0aCgpLmNhbGN1bGF0ZUxlbmd0aCggcGxvdEJveC5oZWlnaHQoKSApO1xuICAgICAgICAgICAgdGhpcy5waXhlbExlbmd0aChwaXhlbExlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnBhcmFsbGVsT2Zmc2V0KCBwb3NpdGlvbi55KCkgKyAoYmFzZS55KCkgKyAxKSAqIHBsb3RCb3guaGVpZ2h0KCkvMiAtICh0aGlzLmFuY2hvcigpICsgMSkgKiBwaXhlbExlbmd0aCAvIDIgKTtcbiAgICAgICAgICAgIHRoaXMucGVycE9mZnNldCggcG9zaXRpb24ueCgpICsgKGJhc2UueCgpICsgMSkgKiBwbG90Qm94LndpZHRoKCkgLyAyICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5vZmZzZXQodGhpcy5taW5wb3NpdGlvbigpLmNhbGN1bGF0ZUNvb3JkaW5hdGUocGl4ZWxMZW5ndGgpKTtcbiAgICAgICAgdGhpcy5tYXhvZmZzZXQocGl4ZWxMZW5ndGggLSB0aGlzLm1heHBvc2l0aW9uKCkuY2FsY3VsYXRlQ29vcmRpbmF0ZShwaXhlbExlbmd0aCkpO1xuICAgICAgICBpZiAodGhpcy5oYXNEYXRhTWluKCkgJiYgdGhpcy5oYXNEYXRhTWF4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUF4aXNUb0RhdGFSYXRpbygpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxhYmVsZXJzKCkuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxlcnMoKS5hdChpKS5pbml0aWFsaXplR2VvbWV0cnkoZ3JhcGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpdGxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGl0bGUoKS5pbml0aWFsaXplR2VvbWV0cnkoZ3JhcGgsIGdyYXBoaWNzQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImNvbXB1dGVBeGlzVG9EYXRhUmF0aW9cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNEYXRhTWluKCkgJiYgdGhpcy5oYXNEYXRhTWF4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXhpc1RvRGF0YVJhdGlvKCh0aGlzLnBpeGVsTGVuZ3RoKCkgLSB0aGlzLm1heG9mZnNldCgpIC0gdGhpcy5taW5vZmZzZXQoKSkgLyAodGhpcy5kYXRhTWF4KCkuZ2V0UmVhbFZhbHVlKCkgLSB0aGlzLmRhdGFNaW4oKS5nZXRSZWFsVmFsdWUoKSkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJkYXRhVmFsdWVUb0F4aXNWYWx1ZVwiLCBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdGhpcy5heGlzVG9EYXRhUmF0aW8oKSAqICggdi5nZXRSZWFsVmFsdWUoKSAtIHRoaXMuZGF0YU1pbigpLmdldFJlYWxWYWx1ZSgpICkgKyB0aGlzLm1pbm9mZnNldCgpICsgdGhpcy5wYXJhbGxlbE9mZnNldCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiYXhpc1ZhbHVlVG9EYXRhVmFsdWVcIiwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIERhdGFWYWx1ZS5jcmVhdGUoIHRoaXMudHlwZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzLmRhdGFNaW4oKS5nZXRSZWFsVmFsdWUoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggYSAtIHRoaXMubWlub2Zmc2V0KCkgLSB0aGlzLnBhcmFsbGVsT2Zmc2V0KCkgKSAvIHRoaXMuYXhpc1RvRGF0YVJhdGlvKCkpICk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc0EoXCJjdXJyZW50TGFiZWxlclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChsYWJlbGVyKSB7XG4gICAgICAgIHJldHVybiBsYWJlbGVyPT09bnVsbCB8fCBsYWJlbGVyIGluc3RhbmNlb2YgTGFiZWxlcjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJjdXJyZW50TGFiZWxEZW5zaXR5XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJjdXJyZW50TGFiZWxlckluZGV4XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImRlc3Ryb3lcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nKCkucmVtb3ZlQXhpcyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGVjaWRlcyB3aGljaCBsYWJlbGVyIHRvIHVzZTogdGFrZSB0aGUgb25lIHdpdGggdGhlIGxhcmdlc3QgZGVuc2l0eSA8PSAwLjguXG4gICAgICogVW5sZXNzIGFsbCBoYXZlIGRlbnNpdHkgPiAwLjgsIGluIHdoaWNoIGNhc2Ugd2UgdGFrZSB0aGUgZmlyc3Qgb25lLiAgVGhpcyBhc3N1bWVzXG4gICAgICogdGhhdCB0aGUgbGFiZWxlcnMgbGlzdCBpcyBvcmRlcmVkIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgbGFiZWwgZGVuc2l0eS5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNldHMgdGhlIGBjdXJyZW50TGFiZWxlcmAgYW5kIGBjdXJyZW50TGFiZWxEZW5zaXR5YCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBwcmVwYXJlUmVuZGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoaWNzQ29udGV4dFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJwcmVwYXJlUmVuZGVyXCIsIGZ1bmN0aW9uIChncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0RhdGFNaW4oKSB8fCAhdGhpcy5oYXNEYXRhTWF4KCkpIHtcbiAgICAgICAgICAgIC8vIGlmIGVpdGhlciBlbmRwb2ludCBkYXRhTWluKCkgb3IgZGF0YU1heCgpIGhhc24ndCBiZWVuIHNwZWNpZmllZCB5ZXQsXG4gICAgICAgICAgICAvLyByZXR1cm4gaW1tZWRpYXRlbHkgd2l0aG91dCBkb2luZyBhbnl0aGluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50TGFiZWxlcixcbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbERlbnNpdHkgPSAwLFxuICAgICAgICAgICAgc3RvcmVkRGVuc2l0eSA9IDAsXG4gICAgICAgICAgICBkZW5zaXR5VGhyZXNob2xkID0gMC44LFxuICAgICAgICAgICAgbGFiZWxlcnMgID0gdGhpcy5sYWJlbGVycygpLFxuICAgICAgICAgICAgbmxhYmVsZXJzID0gbGFiZWxlcnMuc2l6ZSgpLFxuICAgICAgICAgICAgaW5kZXggICAgID0gdGhpcy5jdXJyZW50TGFiZWxlckluZGV4KCksXG4gICAgICAgICAgICBzdG9yZWRJbmRleDtcblxuICAgICAgICBpZiAobmxhYmVsZXJzIDw9IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbGVyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmbGFnID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICBsYXN0TGFiZWxlckluZGV4ID0gbGFiZWxlcnMuc2l6ZSgpIC0gMTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yZWRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgY3VycmVudExhYmVsRGVuc2l0eSA9IGxhYmVsZXJzLmF0KGluZGV4KS5nZXRMYWJlbERlbnNpdHkoZ3JhcGhpY3NDb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMYWJlbERlbnNpdHkgPiBkZW5zaXR5VGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7IC8vIHVzZSBsYWJlbGVyIGF0IHBvc2l0aW9uIDBcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGNoZWNrIHRoZSBwcmlvciBsYWJlbGVyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZERlbnNpdHkgPSBjdXJyZW50TGFiZWxEZW5zaXR5O1xuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudExhYmVsRGVuc2l0eSA8IGRlbnNpdHlUaHJlc2hvbGQpIHsgLy8gY2hlY2sgdGhlIG5leHQgbGFiZWxlclxuICAgICAgICAgICAgICAgIHN0b3JlZERlbnNpdHkgPSBjdXJyZW50TGFiZWxEZW5zaXR5O1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbGFzdExhYmVsZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRMYWJlbERlbnNpdHkgPT09IGRlbnNpdHlUaHJlc2hvbGQpIHsgLy8gdXNlIGxhYmVsZXIgYXQgcG9zaXRpb24gMFxuICAgICAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGFiZWxEZW5zaXR5ID0gbGFiZWxlcnMuYXQoaW5kZXgpLmdldExhYmVsRGVuc2l0eShncmFwaGljc0NvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGFiZWxEZW5zaXR5ID4gZGVuc2l0eVRocmVzaG9sZCkgeyAvLyBsYWJlbGVyIGJlZm9yZSBjdXJyZW50IG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHsgLy8gdXNlIGxhYmVsZXIgYXQgcG9zaXRpb24gMFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RvcmVkSW5kZXggPiBpbmRleCkgeyAvLyBnb2luZyBiYWNrd2FyZHMgdGhyb3VnaCBsYWJlbGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZERlbnNpdHkgPSBjdXJyZW50TGFiZWxEZW5zaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdGhlIHByaW9yIGxhYmVsZXIgaGFkIGRlbnNpdHkgPCB0aHJlc2hvbGQgYW5kIHdhcyBjaGVja2luZyB0aGUgbmV4dCBsYWJlbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHN0b3JlZEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExhYmVsRGVuc2l0eSA9IHN0b3JlZERlbnNpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudExhYmVsRGVuc2l0eSA8IGRlbnNpdHlUaHJlc2hvbGQpIHsgLy8gdGhpcyBsYWJlbGVyIG9yIG9uZSBhZnRlciBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmVkSW5kZXggPiBpbmRleCkgeyAvLyBnb2luZyBiYWNrd2FyZHMgdGhyb3VnaCBsYWJlbGVycyBzbyBwcmlvciBsYWJlbGVyIGhhZCBkZW5zaXR5ID4gdGhyZXNob2xkXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gbGFzdExhYmVsZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGNoZWNrIG5leHQgbGFiZWxlciB0byBzZWUgaWYgaXQgaGFzIGRlbnNpdHkgPCB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWREZW5zaXR5ID0gY3VycmVudExhYmVsRGVuc2l0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRMYWJlbERlbnNpdHkgPT09IGRlbnNpdHlUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMYWJlbGVyID0gbGFiZWxlcnMuYXQoaW5kZXgpO1xuXG4gICAgICAgIHRoaXMuY3VycmVudExhYmVsZXIoY3VycmVudExhYmVsZXIpO1xuICAgICAgICB0aGlzLmN1cnJlbnRMYWJlbGVySW5kZXgoaW5kZXgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRMYWJlbERlbnNpdHkoY3VycmVudExhYmVsRGVuc2l0eSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJ0b1JlYWxWYWx1ZVwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChEYXRhVmFsdWUuaXNJbnN0YW5jZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRSZWFsVmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdmFsdWUgdHlwZSBmb3IgYXhpcyB2YWx1ZSBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwidG9EYXRhVmFsdWVcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0YVZhbHVlLmNyZWF0ZSh0aGlzLnR5cGUoKSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKERhdGFWYWx1ZS5pc0luc3RhbmNlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB2YWx1ZSB0eXBlIGZvciBheGlzIHZhbHVlIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJzZXREYXRhUmFuZ2VOb0JpbmRcIiwgZnVuY3Rpb24obWluLCBtYXgsIGRpc3BhdGNoKSB7XG5cbiAgICAgICAgLy8gTk9URTogbWluIGFuZCBtYXggbWF5IGVpdGhlciBiZSBwbGFpbiBudW1iZXJzLCBvclxuICAgICAgICAvLyBEYXRhVmFsdWUgaW5zdGFuY2VzLiAgSWYgdGhleSdyZSBwbGFpbiBudW1iZXJzLCB0aGV5XG4gICAgICAgIC8vIGdldCBjb252ZXJ0ZWQgdG8gRGF0YVZhbHVlIGluc3RhbmNlcyBoZXJlIGJlZm9yZSBiZWluZ1xuICAgICAgICAvLyBwYXNzZWQgdG8gdGhlIGRhdGFNaW4oKS9kYXRhTWF4KCkgc2V0dGVycyBiZWxvdy5cblxuICAgICAgICB2YXIgZGF0YVZhbHVlTWluID0gdGhpcy50b0RhdGFWYWx1ZShtaW4pLFxuICAgICAgICAgICAgZGF0YVZhbHVlTWF4ID0gdGhpcy50b0RhdGFWYWx1ZShtYXgpO1xuXG4gICAgICAgIHRoaXMuZGF0YU1pbihkYXRhVmFsdWVNaW4pO1xuICAgICAgICB0aGlzLmRhdGFNYXgoZGF0YVZhbHVlTWF4KTtcbiAgICAgICAgLy8gaWYgKF9ncmFwaCAhPSBudWxsKSB7IF9ncmFwaC5pbnZhbGlkYXRlRGlzcGxheUxpc3QoKTsgfVxuICAgICAgICBpZiAoZGlzcGF0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGlzcGF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KHsndHlwZScgOiAnZGF0YVJhbmdlU2V0JyxcbiAgICAgICAgICAgICAgICAgICAnbWluJyAgOiBkYXRhVmFsdWVNaW4sXG4gICAgICAgICAgICAgICAgICAgJ21heCcgIDogZGF0YVZhbHVlTWF4fSk7XG4gICAgICAgIC8qXG4gICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgIC8vZGlzcGF0Y2hFdmVudChuZXcgQXhpc0V2ZW50KEF4aXNFdmVudC5DSEFOR0UsbWluLG1heCkpOyAgXG4gICAgICAgICB9XG4gICAgICAgICAqL1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwic2V0RGF0YVJhbmdlXCIsIGZ1bmN0aW9uIChtaW4sIG1heCwgZGlzcGF0Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmcoKS5zZXREYXRhUmFuZ2UodGhpcywgbWluLCBtYXgsIGRpc3BhdGNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YVJhbmdlTm9CaW5kKG1pbiwgbWF4LCBkaXNwYXRjaCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImRvUGFuXCIsIGZ1bmN0aW9uIChwaXhlbEJhc2UsIHBpeGVsRGlzcGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBwYW4gPSB0aGlzLnBhbigpLFxuICAgICAgICAgICAgcGFuTWluID0gcGFuLm1pbigpLFxuICAgICAgICAgICAgcGFuTWF4ID0gcGFuLm1heCgpLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgbmV3UmVhbE1pbixcbiAgICAgICAgICAgIG5ld1JlYWxNYXg7XG5cbiAgICAgICAgaWYgKCFwYW4uYWxsb3dlZCgpKSB7IHJldHVybjsgfVxuICAgICAgICBvZmZzZXQgPSBwaXhlbERpc3BsYWNlbWVudCAvIHRoaXMuYXhpc1RvRGF0YVJhdGlvKCk7XG4gICAgICAgIG5ld1JlYWxNaW4gPSB0aGlzLmRhdGFNaW4oKS5nZXRSZWFsVmFsdWUoKSAtIG9mZnNldDtcbiAgICAgICAgbmV3UmVhbE1heCA9IHRoaXMuZGF0YU1heCgpLmdldFJlYWxWYWx1ZSgpIC0gb2Zmc2V0O1xuICAgICAgICBcbiAgICAgICAgaWYgKHBhbk1pbiAmJiBuZXdSZWFsTWluIDwgcGFuTWluLmdldFJlYWxWYWx1ZSgpKSB7XG4gICAgICAgICAgICBuZXdSZWFsTWF4ICs9IChwYW5NaW4uZ2V0UmVhbFZhbHVlKCkgLSBuZXdSZWFsTWluKTtcbiAgICAgICAgICAgIG5ld1JlYWxNaW4gPSBwYW5NaW4uZ2V0UmVhbFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhbk1heCAmJiBuZXdSZWFsTWF4ID4gcGFuTWF4LmdldFJlYWxWYWx1ZSgpKSB7XG4gICAgICAgICAgICBuZXdSZWFsTWluIC09IChuZXdSZWFsTWF4IC0gcGFuTWF4LmdldFJlYWxWYWx1ZSgpKTtcbiAgICAgICAgICAgIG5ld1JlYWxNYXggPSBwYW5NYXguZ2V0UmVhbFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXREYXRhUmFuZ2UoRGF0YVZhbHVlLmNyZWF0ZSh0aGlzLnR5cGUoKSwgbmV3UmVhbE1pbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIERhdGFWYWx1ZS5jcmVhdGUodGhpcy50eXBlKCksIG5ld1JlYWxNYXgpKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImRvWm9vbVwiLCBmdW5jdGlvbiAocGl4ZWxCYXNlLCBwaXhlbERpc3BsYWNlbWVudCkge1xuICAgICAgICB2YXIgem9vbSA9IHRoaXMuem9vbSgpLFxuICAgICAgICAgICAgcGFuICA9IHRoaXMucGFuKCksXG4gICAgICAgICAgICB0eXBlID0gdGhpcy50eXBlKCksXG4gICAgICAgICAgICBkYXRhTWluID0gdGhpcy5kYXRhTWluKCksXG4gICAgICAgICAgICBkYXRhTWF4ID0gdGhpcy5kYXRhTWF4KCksXG4gICAgICAgICAgICBwYW5NaW4gID0gcGFuLm1pbigpLFxuICAgICAgICAgICAgcGFuTWF4ICA9IHBhbi5tYXgoKSxcbiAgICAgICAgICAgIHpvb21NaW4gPSB6b29tLm1pbigpLFxuICAgICAgICAgICAgem9vbU1heCA9IHpvb20ubWF4KCksXG4gICAgICAgICAgICBiYXNlUmVhbFZhbHVlLFxuICAgICAgICAgICAgZmFjdG9yLFxuICAgICAgICAgICAgbmV3TWluLFxuICAgICAgICAgICAgbmV3TWF4LFxuICAgICAgICAgICAgZDtcbiAgICAgICAgaWYgKCF6b29tLmFsbG93ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VSZWFsVmFsdWUgPSB0aGlzLmF4aXNWYWx1ZVRvRGF0YVZhbHVlKHBpeGVsQmFzZSkuZ2V0UmVhbFZhbHVlKCk7XG4gICAgICAgIGlmIChEYXRhVmFsdWUuaXNJbnN0YW5jZSh6b29tLmFuY2hvcigpKSkge1xuICAgICAgICAgICAgYmFzZVJlYWxWYWx1ZSA9IHpvb20uYW5jaG9yKCkuZ2V0UmVhbFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjdG9yID0gMTAgKiBNYXRoLmFicyhwaXhlbERpc3BsYWNlbWVudCAvICh0aGlzLnBpeGVsTGVuZ3RoKCkgLSB0aGlzLm1heG9mZnNldCgpIC0gdGhpcy5taW5vZmZzZXQoKSkpO1xuICAgICAgICAvKlRPRE86IHVuY29tbWVudCBhZnRlciB0aGlzLnJldmVyc2VkKCkgaGFzIGJlZW4gaW1wbGVtZW50ZWRcbiAgICAgICAgIGlmICh0aGlzLnJldmVyc2VkKCkpIHsgZmFjdG9yID0gLWZhY3RvcjsgfVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHBpeGVsRGlzcGxhY2VtZW50IDw9IDApIHtcbiAgICAgICAgICAgIG5ld01pbiA9IERhdGFWYWx1ZS5jcmVhdGUodHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGFNaW4uZ2V0UmVhbFZhbHVlKCkgLSBiYXNlUmVhbFZhbHVlKSAqICggMSArIGZhY3RvciApICsgYmFzZVJlYWxWYWx1ZSk7XG4gICAgICAgICAgICBuZXdNYXggPSBEYXRhVmFsdWUuY3JlYXRlKHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkYXRhTWF4LmdldFJlYWxWYWx1ZSgpIC0gYmFzZVJlYWxWYWx1ZSkgKiAoIDEgKyBmYWN0b3IgKSArIGJhc2VSZWFsVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TWluID0gRGF0YVZhbHVlLmNyZWF0ZSh0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YU1pbi5nZXRSZWFsVmFsdWUoKSAtIGJhc2VSZWFsVmFsdWUpICogKCAxIC0gZmFjdG9yICkgKyBiYXNlUmVhbFZhbHVlKTtcbiAgICAgICAgICAgIG5ld01heCA9IERhdGFWYWx1ZS5jcmVhdGUodHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGFNYXguZ2V0UmVhbFZhbHVlKCkgLSBiYXNlUmVhbFZhbHVlKSAqICggMSAtIGZhY3RvciApICsgYmFzZVJlYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhbk1pbiAmJiBuZXdNaW4ubHQocGFuTWluKSkge1xuICAgICAgICAgICAgbmV3TWluID0gcGFuTWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYW5NYXggJiYgbmV3TWF4Lmd0KHBhbk1heCkpIHtcbiAgICAgICAgICAgIG5ld01heCA9IHBhbk1heDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKChkYXRhTWluLmxlKGRhdGFNYXgpICYmIG5ld01pbi5sdChuZXdNYXgpKSB8fFxuICAgICAgICAgICAgKGRhdGFNaW4uZ2UoZGF0YU1heCkgJiYgbmV3TWluLmd0KG5ld01heCkpKSB7XG4gICAgICAgICAgICBpZiAoem9vbU1heCAmJiAobmV3TWF4Lmd0KG5ld01pbi5hZGQoem9vbU1heCkpKSkge1xuICAgICAgICAgICAgICAgIGQgPSAobmV3TWF4LmdldFJlYWxWYWx1ZSgpIC0gbmV3TWluLmdldFJlYWxWYWx1ZSgpIC0gem9vbU1heC5nZXRSZWFsVmFsdWUoKSkgLyAyO1xuICAgICAgICAgICAgICAgIG5ld01heCA9IG5ld01heC5hZGRSZWFsVmFsdWUoLWQpO1xuICAgICAgICAgICAgICAgIG5ld01pbiA9IG5ld01pbi5hZGRSZWFsVmFsdWUoZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHpvb21NaW4gJiYgKG5ld01heC5sdChuZXdNaW4uYWRkKHpvb21NaW4pKSkpIHtcbiAgICAgICAgICAgICAgICBkID0gKHpvb21NaW4uZ2V0UmVhbFZhbHVlKCkgLSAobmV3TWF4LmdldFJlYWxWYWx1ZSgpIC0gbmV3TWluLmdldFJlYWxWYWx1ZSgpKSkgLyAyO1xuICAgICAgICAgICAgICAgIG5ld01heCA9IG5ld01heC5hZGRSZWFsVmFsdWUoZCk7XG4gICAgICAgICAgICAgICAgbmV3TWluID0gbmV3TWluLmFkZFJlYWxWYWx1ZSgtZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldERhdGFSYW5nZShuZXdNaW4sIG5ld01heCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGRpc3RhbmNlIGZyb20gYW4gYXhpcyB0byBhIHBvaW50LiAgVGhlIHBvaW50XG4gICAgICogKHgseSkgaXMgZXhwcmVzc2VkIGluIHBpeGVsIGNvb3JkaW5hdGVzIGluIHRoZSBzYW1lXG4gICAgICogY29vcmRpbmF0ZSBzeXN0ZW0gYXMgdGhlIGF4aXMuXG4gICAgICogXG4gICAgICogV2UgdXNlIHR3byBkaWZmZXJlbnQga2luZHMgb2YgY29tcHV0YXRpb25zIGRlcGVuZGluZyBvblxuICAgICAqIHdoZXRoZXIgdGhlIHBvaW50IGxpZXMgaW5zaWRlIG9yIG91dHNpZGUgdGhlIHJlZ2lvbiBib3VuZGVkXG4gICAgICogYnkgdGhlIHR3byBsaW5lcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBheGlzIHRocm91Z2ggaXRzXG4gICAgICogZW5kcG9pbnRzLiAgSWYgdGhlIHBvaW50IGxpZXMgaW5zaWRlIHRoaXMgcmVnaW9uLCB0aGVcbiAgICAgKiBkaXN0YW5jZSBpcyBzaW1wbHkgdGhlIGRpZmZlcmVuY2UgaW4gdGhlIHBlcnBlbmRpY3VsYXJcbiAgICAgKiBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBhbmQgdGhlIHBlcnBlbmRpY3VsYXIgY29vcmRpbmF0ZSBvZlxuICAgICAqIHRoZSBheGlzLlxuICAgICAqIFxuICAgICAqIElmIHRoZSBwb2ludCBsaWVzIG91dHNpZGUgdGhlIHJlZ2lvbiwgdGhlbiB0aGUgZGlzdGFuY2UgaXNcbiAgICAgKiB0aGUgTDIgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnQgYW5kIHRoZSBjbG9zZXN0IGVuZHBvaW50XG4gICAgICogb2YgdGhlIGF4aXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRpc3RhbmNlVG9Qb2ludFxuICAgICAqIEBwYXJhbSB7fSB4XG4gICAgICogQHBhcmFtIHt9IHlcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZGlzdGFuY2VUb1BvaW50XCIsIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBwZXJwQ29vcmQgICAgID0gKHRoaXMub3JpZW50YXRpb24oKSA9PT0gQXhpcy5IT1JJWk9OVEFMKSA/IHkgOiB4LFxuICAgICAgICAgICAgcGFyYWxsZWxDb29yZCA9ICh0aGlzLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuSE9SSVpPTlRBTCkgPyB4IDogeSxcbiAgICAgICAgICAgIHBhcmFsbGVsT2Zmc2V0ID0gdGhpcy5wYXJhbGxlbE9mZnNldCgpLFxuICAgICAgICAgICAgcGVycE9mZnNldCAgICAgPSB0aGlzLnBlcnBPZmZzZXQoKSxcbiAgICAgICAgICAgIHBpeGVsTGVuZ3RoICAgID0gdGhpcy5waXhlbExlbmd0aCgpLFxuICAgICAgICAgICAgbDJkaXN0ICAgICAgICAgPSBVdGlsLmwyZGlzdDtcblxuICAgICAgICBpZiAocGFyYWxsZWxDb29yZCA8IHBhcmFsbGVsT2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyBwb2ludCBpcyB1bmRlciBvciBsZWZ0IG9mIHRoZSBheGlzOyByZXR1cm4gTDIgZGlzdGFuY2UgdG8gYm90dG9tIG9yIGxlZnQgYXhpcyBlbmRwb2ludFxuICAgICAgICAgICAgcmV0dXJuIGwyZGlzdChwYXJhbGxlbENvb3JkLCBwZXJwQ29vcmQsIHBhcmFsbGVsT2Zmc2V0LCBwZXJwT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYWxsZWxDb29yZCA+IHBhcmFsbGVsT2Zmc2V0ICsgcGl4ZWxMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHBvaW50IGlzIGFib3ZlIG9yIHJpZ2h0IG9mIHRoZSBheGlzOyByZXR1cm4gTDIgZGlzdGFuY2UgdG8gdG9wIG9yIHJpZ2h0IGF4aXMgZW5kcG9pbnRcbiAgICAgICAgICAgIHJldHVybiBsMmRpc3QocGFyYWxsZWxDb29yZCwgcGVycENvb3JkLCBwYXJhbGxlbE9mZnNldCArIHBpeGVsTGVuZ3RoLCBwZXJwT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwb2ludCBpcyBiZXR3ZWVuIHRoZSBheGlzIGVuZHBvaW50czsgcmV0dXJuIGRpZmZlcmVuY2UgaW4gcGVycGVuZGljdWxhciBjb29yZHNcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHBlcnBDb29yZCAtIHBlcnBPZmZzZXQpO1xuICAgIH0pO1xuXG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJub3JtYWxpemVcIiwgZnVuY3Rpb24gKGdyYXBoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBsYWJlbDtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBIYW5kbGVzIHRpdGxlIHRhZ3NcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHRoaXMudGl0bGUoKSAmJiB0aGlzLnRpdGxlKCkuY29udGVudCgpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGl0bGUoKS5jb250ZW50KG5ldyBUZXh0KHRoaXMuaWQoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSGFuZGxlcyBtaXNzaW5nIGxhYmVsZXJzXG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0aGlzLmxhYmVsZXJzKCkuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlcyA9ICh1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCkpLmhvcml6b250YWxheGlzLmxhYmVscyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3BhY2luZ3MgPSB0aGlzLnR5cGUoKSA9PT0gRGF0YVZhbHVlLk5VTUJFUiA/XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXMuZGVmYXVsdE51bWJlclNwYWNpbmcgOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzLmRlZmF1bHREYXRldGltZVNwYWNpbmc7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZWZhdWx0U3BhY2luZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IG5ldyBMYWJlbGVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIGxhYmVsLnNwYWNpbmcoRGF0YU1lYXN1cmUucGFyc2UodGhpcy50eXBlKCksIGRlZmF1bHRTcGFjaW5nc1tpXSkpO1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxlcnMoKS5hZGQobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbm9ybWFsaXplcyB0aGUgbGFiZWxlcnNcbiAgICAgICAgLy9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGFiZWxlcnMoKS5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5sYWJlbGVycygpLmF0KGkpLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcywgYXR0cmlidXRlcyk7XG59KTtcblxuQXhpcy5IT1JJWk9OVEFMID0gbmV3IE9yaWVudGF0aW9uKFwiaG9yaXpvbnRhbFwiKTtcbkF4aXMuVkVSVElDQUwgICA9IG5ldyBPcmllbnRhdGlvbihcInZlcnRpY2FsXCIpO1xuXG5BeGlzLk9yaWVudGF0aW9uID0gT3JpZW50YXRpb247XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpcztcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIEF4aXNCaW5kaW5nID0gbmV3IGplcm1haW5lLk1vZGVsKFwiQXhpc0JpbmRpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBBeGlzQmluZGluZyA9IHRoaXM7XG4gICAgXG4gICAgQXhpc0JpbmRpbmcuaW5zdGFuY2VzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImlkXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGF4ZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImF4ZXNcIik7IC8vIGpzIGFycmF5XG5cbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIEF4aXNCaW5kaW5nLmluc3RhbmNlc1t0aGlzLmlkKCldID0gdGhpcztcbiAgICAgICAgdGhpcy5heGVzKFtdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRBeGlzXG4gICAgICogQHBhcmFtIHtBeGlzfSBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ8RGF0YVZhbHVlfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxEYXRhVmFsdWV9IG1heFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJhZGRBeGlzXCIsIGZ1bmN0aW9uKGF4aXMsIG1pbiwgbWF4LCBtdWx0aWdyYXBoLypvcHRpb25hbCovKSB7XG4gICAgICAgIC8vIE5PVEU6IG1pbi9tYXggY2FuIGJlIGVpdGhlciBudW1iZXJzLCBvciBEYXRhVmFsdWVcbiAgICAgICAgLy8gaW5zdGFuY2VzLCBidXQgdGhleSBDQU5OT1QgYmUgc3RyaW5ncy5cblxuICAgICAgICBpZiAoYXhpcy5iaW5kaW5nKCkpIHtcbiAgICAgICAgICAgIGF4aXMuYmluZGluZygpLnJlbW92ZUF4aXMoYXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXhpcy5iaW5kaW5nKHRoaXMpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgbWluL21heCB0byBudW1iZXJzXG4gICAgICAgIG1pbiA9IGF4aXMudG9SZWFsVmFsdWUobWluKTtcbiAgICAgICAgbWF4ID0gYXhpcy50b1JlYWxWYWx1ZShtYXgpO1xuXG4gICAgICAgIHRoaXMuYXhlcygpLnB1c2goe1xuICAgICAgICAgICAgYXhpcyAgICAgICA6IGF4aXMsXG4gICAgICAgICAgICBtdWx0aWdyYXBoIDogbXVsdGlncmFwaCxcbiAgICAgICAgICAgIGZhY3RvciAgICAgOiAxIC8gKG1heCAtIG1pbiksXG4gICAgICAgICAgICBvZmZzZXQgICAgIDogLW1pbiAvIChtYXggLSBtaW4pLFxuICAgICAgICAgICAgbWluICAgICAgICA6IG1pbixcbiAgICAgICAgICAgIG1heCAgICAgICAgOiBtYXhcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlQXhpc1xuICAgICAqIEBwYXJhbSB7QXhpc30gYXhpc1xuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZW1vdmVBeGlzXCIsIGZ1bmN0aW9uKGF4aXMpIHtcbiAgICAgICAgdmFyIGF4ZXMgPSB0aGlzLmF4ZXMoKSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaT0wOyBpPGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChheGVzW2ldLmF4aXMgPT09IGF4aXMpIHtcbiAgICAgICAgICAgICAgICBheGVzLnNwbGljZShpLDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZSBhbGwgdGhlIGF4ZXMgaW4gdGhpcyBiaW5kaW5nIHRvIHN5bmMgdXAgd2l0aCBlYWNoXG4gICAgICogb3RoZXIsIGlmIHBvc3NpYmxlLlxuICAgICAqIFxuICAgICAqIFRoaXMgaXMgZG9uZSBieSBsb29raW5nIGZvciBhbiBheGlzIGluIHRoaXMgYmluZGluZyB3aGljaFxuICAgICAqIGhhcyBpdHMgZGF0YU1pbiBhbmQgZGF0YU1heCB2YWx1ZXMgc2V0LCBhbmQgdGhlbiBjYWxsaW5nXG4gICAgICogaXRzIHNldERhdGFSYW5nZSgpIG1ldGhvZCB3aXRoIHRob3NlIHZhbHVlcy4gIFRoZSBtYWluXG4gICAgICogcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBmYWNpbGl0YXRlIHRoZSBpbml0aWFsIHNldHRpbmdcbiAgICAgKiBvZiBkYXRhTWluL2RhdGFNYXggdmFsdWVzIGZvciBheGVzIGluIGEgYmluZGluZyB0aGF0IGRvIG5vdFxuICAgICAqIGFscmVhZHkgaGF2ZSBkYXRhTWluL2RhdGFNYXggdmFsdWVzIHNldDsgdGhpcyBmb3JjZXMgdGhlbVxuICAgICAqIHRvIGJlIHNldCBiYXNlZCBvbiB0aGUgYmluZGluZywgYXMgZGV0ZXJtaW5lZCBieSBhbm90aGVyXG4gICAgICogYXhpcyBpbiB0aGUgYmluZGluZy5cbiAgICAgKiBcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgaXMgTk9UIHRoZSBub3JtYWwgd2F5IGZvciBib3VuZCBheGVzXG4gICAgICogdG8gaW50ZXJhY3Qgd2l0aCBlYWNoIG90aGVyIG9uY2UgaW5pdGlhbGl6YXRpb24gaXNcbiAgICAgKiBjb21wbGV0ZTsgdGhhdCBpcyBkb25lIHZpYSB0aGUgYXhlcycgb3duIHNldERhdGFSYW5nZSgpXG4gICAgICogbWV0aG9kLlxuICAgICAqIFxuICAgICAqIEBtZXRob2Qgc3luY1xuICAgICAqIFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzeW5jIHdhc1xuICAgICAqICAgICAgICAgICAgICAgICAgIGRvbmU7IHRoaXMgd2lsbCBiZSB0cnVlIGlmIGFuZCBvbmx5IGlmXG4gICAgICogICAgICAgICAgICAgICAgICAgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGF4aXMgaW4gdGhlIGJpbmRpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICBoYXZpbmcgYm90aCBpdHMgZGF0YU1pbiBhbmQgZGF0YU1heFxuICAgICAqICAgICAgICAgICAgICAgICAgIHZhbHVlcyBzZXQuXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwic3luY1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBheGVzID0gdGhpcy5heGVzKCksXG4gICAgICAgICAgICBheGlzO1xuICAgICAgICBmb3IgKGk9MDsgaTxheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBheGlzID0gYXhlc1tpXS5heGlzO1xuICAgICAgICAgICAgaWYgKGF4aXMuaGFzRGF0YU1pbigpICYmIGF4aXMuaGFzRGF0YU1heCgpKSB7XG4gICAgICAgICAgICAgICAgYXhpcy5zZXREYXRhUmFuZ2UoYXhpcy5kYXRhTWluKCksIGF4aXMuZGF0YU1heCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXREYXRhUmFuZ2VcbiAgICAgKiBAcGFyYW0ge0F4aXN9IGluaXRpYXRpbmdBeGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ8RGF0YVZhbHVlfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxEYXRhVmFsdWV9IG1heFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzcGF0Y2hcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwic2V0RGF0YVJhbmdlXCIsIGZ1bmN0aW9uKGluaXRpYXRpbmdBeGlzLCBtaW4sIG1heCwgZGlzcGF0Y2gpIHtcblxuICAgICAgICAvLyBOT1RFOiBtaW4gYW5kIG1heCBtYXkgZWl0aGVyIGJlIHBsYWluIG51bWJlcnMsIG9yXG4gICAgICAgIC8vIERhdGFWYWx1ZSBpbnN0YW5jZXMuICBJZiB0aGV5J3JlIERhdGFWYWx1ZSBpbnN0YW5jZXMsXG4gICAgICAgIC8vIGdldCBjb252ZXJ0ZWQgdG8gbnVtYmVycyBoZXJlIGJlZm9yZSBiZWluZ1xuICAgICAgICAvLyBwYXNzZWQgdG8gdGhlIGluZGl2aWR1YWwgYXhlcycgc2V0RGF0YVJhbmdlTm9CaW5kKClcbiAgICAgICAgLy8gbWV0aG9kIGJlbG93LlxuXG4gICAgICAgIHZhciBpbml0aWF0aW5nQXhpc0luZGV4LFxuICAgICAgICAgICAgaSwgaixcbiAgICAgICAgICAgIGF4ZXMgPSB0aGlzLmF4ZXMoKSxcbiAgICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgICBtaW5SZWFsVmFsdWUgPSBpbml0aWF0aW5nQXhpcy50b1JlYWxWYWx1ZShtaW4pLFxuICAgICAgICAgICAgbWF4UmVhbFZhbHVlID0gaW5pdGlhdGluZ0F4aXMudG9SZWFsVmFsdWUobWF4KSxcbiAgICAgICAgICAgIHJlZHJhd25fbXVsdGlncmFwaHMgPSBbXSxcbiAgICAgICAgICAgIHJlZHJhd247XG5cbiAgICAgICAgaWYgKGRpc3BhdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoID0gdHJ1ZTsgLy8gZGlzcGF0Y2ggZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpPTA7IGk8YXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGF4ZXNbaV0uYXhpcyA9PT0gaW5pdGlhdGluZ0F4aXMpIHtcbiAgICAgICAgICAgICAgICBpbml0aWF0aW5nQXhpc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByZWRyYXduX211bHRpZ3JhcGhzID0gWyBheGVzW2ldLm11bHRpZ3JhcGggXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGk9MDsgaTxheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBheGlzID0gYXhlc1tpXTtcbiAgICAgICAgICAgIGlmIChpID09PSBpbml0aWF0aW5nQXhpc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgYXhpcy5heGlzLnNldERhdGFSYW5nZU5vQmluZChtaW5SZWFsVmFsdWUsIG1heFJlYWxWYWx1ZSwgZGlzcGF0Y2gpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBheGlzLmF4aXMuc2V0RGF0YVJhbmdlTm9CaW5kKFxuICAgICAgICAgICAgICAgICAgICAobWluUmVhbFZhbHVlICogYXhlc1tpbml0aWF0aW5nQXhpc0luZGV4XS5mYWN0b3IgKyBheGVzW2luaXRpYXRpbmdBeGlzSW5kZXhdLm9mZnNldCAtIGF4aXMub2Zmc2V0KSAvIGF4aXMuZmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICAobWF4UmVhbFZhbHVlICogYXhlc1tpbml0aWF0aW5nQXhpc0luZGV4XS5mYWN0b3IgKyBheGVzW2luaXRpYXRpbmdBeGlzSW5kZXhdLm9mZnNldCAtIGF4aXMub2Zmc2V0KSAvIGF4aXMuZmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMubXVsdGlncmFwaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgYXhpcyBoYXMgYSBtdWx0aWdyYXBoIHN0b3JlZCB3aXRoIGl0LCBhbmQgaWYgdGhhdCBtdWx0aWdyYXBoIGlzbid0IGFscmVhZHkgaW4gdGhlIGByZWRyYXduX211bHRpZ3JhcGhzYFxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSwgY2FsbCBpdHMgYHJlZHJhd2AgbWV0aG9kLCBhbmQgYWRkIGl0IHRvIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGo9MDsgajxyZWRyYXduX211bHRpZ3JhcGhzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5tdWx0aWdyYXBoID09PSByZWRyYXduX211bHRpZ3JhcGhzW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkcmF3biA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWRyYXduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLm11bHRpZ3JhcGgucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWRyYXduX211bHRpZ3JhcGhzLnB1c2goYXhpcy5tdWx0aWdyYXBoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEluc3RhbmNlQnlJZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gaWRcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgQXhpc0JpbmRpbmcuZ2V0SW5zdGFuY2VCeUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIEF4aXNCaW5kaW5nLmluc3RhbmNlc1tpZF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQG1ldGhvZCBmaW5kQnlJZE9yQ3JlYXRlTmV3XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSBpZFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICBBeGlzQmluZGluZy5maW5kQnlJZE9yQ3JlYXRlTmV3ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBBeGlzQmluZGluZy5nZXRJbnN0YW5jZUJ5SWQoaWQpO1xuICAgICAgICBpZiAoIWJpbmRpbmcpIHtcbiAgICAgICAgICAgIGJpbmRpbmcgPSBuZXcgQXhpc0JpbmRpbmcoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc3luY0FsbEJpbmRpbmdzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICBBeGlzQmluZGluZy5zeW5jQWxsQmluZGluZ3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBmb3IgKGlkIGluIEF4aXNCaW5kaW5nLmluc3RhbmNlcykge1xuICAgICAgICAgICAgQXhpc0JpbmRpbmcuaW5zdGFuY2VzW2lkXS5zeW5jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGZvcmdldEFsbEJpbmRpbmdzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICBBeGlzQmluZGluZy5mb3JnZXRBbGxCaW5kaW5ncyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMganVzdCBmb3IgdXNlIGluIHRlc3RpbmcsIHNvIHdlIGNhbiBjbGVhciBvdXQgdGhlIGdsb2JhbCBsaXN0XG4gICAgICAgIC8vIG9mIGJpbmRpbmdzIHRvIGdldCBhIGZyZXNoIHN0YXJ0IGJldHdlZW4gdGVzdHMuXG5cbiAgICAgICAgdmFyIGlkLGosYmluZGluZztcblxuICAgICAgICAvLyBsb29wIG92ZXIgYWxsIGJpbmRpbmdzLCBhbGwgYXhlcywgc2V0dGluZyB0aGUgYXhpcyBiaW5kaW5nIHRvIG51bGxcbiAgICAgICAgZm9yIChpZCBpbiBBeGlzQmluZGluZy5pbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGJpbmRpbmcgPSBBeGlzQmluZGluZy5pbnN0YW5jZXNbaWRdO1xuICAgICAgICAgICAgZm9yIChqPTA7IGo8YmluZGluZy5heGVzKCkubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nLmF4ZXMoKVtqXS5heGlzLmJpbmRpbmcobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB0aGUgZ2xvYmFsIGJpbmRpbmcgbGlzdFxuICAgICAgICBBeGlzQmluZGluZy5pbnN0YW5jZXMgPSB7fTtcbiAgICB9O1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlzQmluZGluZztcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzICAgID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgICAgICAgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcy50aXRsZSksXG4gICAgUG9pbnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL21hdGgvcG9pbnQuanMnKTtcblxuLyoqXG4gKiBBeGlzIFRpdGxlIGlzIGEgSmVybWFpbmUgbW9kZWwgdGhhdCBzdXBwb3J0cyB0aGUgcmVuZGVyaW5nIG9mIEF4aXMgVGl0bGVzLlxuICpcbiAqIEBjbGFzcyBBeGlzVGl0bGVcbiAqIEBmb3IgQXhpc1RpdGxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXhpc30gYXhpc1xuICovXG52YXIgQXhpc1RpdGxlID0gbmV3IGplcm1haW5lLk1vZGVsKFwiQXhpc1RpdGxlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBcbiAgICAvKipcbiAgICAgKiBQb2ludGVyIHRvIHRoZSBUaXRsZSdzIHBhcmVudCBBeGlzIGplcm1pYW5lIG1vZGVsLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGF4aXNcbiAgICAgKiBAdHlwZSB7QXhpc31cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYXhpc1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHZhciBBeGlzID0gcmVxdWlyZSgnLi9heGlzLmpzJyk7XG4gICAgICAgIHJldHVybiBheGlzIGluc3RhbmNlb2YgQXhpcztcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggaXMgdXNlZCBhcyB0aGUgdGl0bGUgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbnRlbnRcbiAgICAgKiBAdHlwZSB7VGV4dH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiY29udGVudFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgIHZhciBUZXh0ID0gcmVxdWlyZSgnLi90ZXh0LmpzJyk7XG4gICAgICAgIHJldHVybiBjb250ZW50IGluc3RhbmNlb2YgVGV4dDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggZ2l2ZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBUaXRsZSdzIGFuY2hvciBwb2ludCB0byBiZSBhdHRhY2hlZCB0byB0aGVcbiAgICAgKiBiYXNlIHBvaW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFuY2hvclxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYW5jaG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGFuY2hvcikge1xuICAgICAgICByZXR1cm4gYW5jaG9yIGluc3RhbmNlb2YgUG9pbnQ7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGdpdmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgYmFzZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgVGl0bGUncyBBeGlzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJhc2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJiYXNlXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICAvKipcbiAgICAgKiBBIGNvb3JkaW5hdGUgcGFpciBvZiBwaXhlbCBvZmZzZXRzIGZvciB0aGUgYmFzZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwicG9zaXRpb25cIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uIGluc3RhbmNlb2YgUG9pbnQ7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGRldGVybWluZXMgdGhlIHJvdGF0aW9uIG9mIHRoZSBUaXRsZSBpbiBkZWdyZWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYW5nbGVcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuXG4gICAgdGhpcy5oYXNBKFwiZm9udFwiKS53aGljaC5pc0EoXCJzdHJpbmdcIikuYW5kLndoaWNoLmRlZmF1bHRzVG8oXCJcIik7XG5cbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwiYXhpc1wiKTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdmFsdWVzIGZvciB0aGUgYHBvc2l0aW9uYCBhbmQgYGFuY2hvcmAgYXR0cmlidXRlcyBpZiB0aGV5IHdlcmUgbm90IHNldDsgZGV0ZXJtaW5lcyB0aGVcbiAgICAgKiBnZW9tZXRyeSBvZiB0aGUgYGNvbnRlbnRgIGF0dHJpYnV0ZS4gQ2FsbGVkIGJ5IGBBeGlzLmluaXRpYWxpemVHZW9tZXRyeSgpYC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZUdlb21ldHJ5XG4gICAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhpY3NDb250ZXh0XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJpbml0aWFsaXplR2VvbWV0cnlcIiwgZnVuY3Rpb24gKGdyYXBoLCBncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgdmFyIEF4aXMgPSByZXF1aXJlKCcuL2F4aXMuanMnKTtcbiAgICAgICAgdmFyIHRpdGxlRGVmYXVsdHMgPSBkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzLnRpdGxlLFxuICAgICAgICAgICAgYXhpcyAgICAgPSB0aGlzLmF4aXMoKSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgIGFuY2hvciAgID0gdGhpcy5hbmNob3IsXG4gICAgICAgICAgICBwbG90Qm94ICA9IGdyYXBoLnBsb3RCb3goKSxcbiAgICAgICAgICAgIGF4aXNQZXJwT2Zmc2V0ICAgPSBheGlzLnBlcnBPZmZzZXQoKSxcbiAgICAgICAgICAgIGF4aXNJc0hvcml6b250YWwgPSAoYXhpcy5vcmllbnRhdGlvbigpID09PSBBeGlzLkhPUklaT05UQUwpO1xuXG4gICAgICAgIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZU9yRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YodmFsdWVPckZ1bmN0aW9uKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlT3JGdW5jdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVPckZ1bmN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwb3NpdGlvbigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChheGlzSXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNQZXJwT2Zmc2V0ID4gcGxvdEJveC5oZWlnaHQoKS8yKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKCBnZXRWYWx1ZSh0aXRsZURlZmF1bHRzW1wicG9zaXRpb24taG9yaXpvbnRhbC10b3BcIl0pICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24oIGdldFZhbHVlKHRpdGxlRGVmYXVsdHNbXCJwb3NpdGlvbi1ob3Jpem9udGFsLWJvdHRvbVwiXSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChheGlzUGVycE9mZnNldCA+IHBsb3RCb3gud2lkdGgoKS8yKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKCBnZXRWYWx1ZSh0aXRsZURlZmF1bHRzW1wicG9zaXRpb24tdmVydGljYWwtcmlnaHRcIl0pICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24oIGdldFZhbHVlKHRpdGxlRGVmYXVsdHNbXCJwb3NpdGlvbi12ZXJ0aWNhbC1sZWZ0XCJdKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbmNob3IoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXhpc0lzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGlmIChheGlzUGVycE9mZnNldCA+IHBsb3RCb3guaGVpZ2h0KCkvMikge1xuICAgICAgICAgICAgICAgICAgICBhbmNob3IoIGdldFZhbHVlKHRpdGxlRGVmYXVsdHNbXCJhbmNob3ItaG9yaXpvbnRhbC10b3BcIl0pICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yKCBnZXRWYWx1ZSh0aXRsZURlZmF1bHRzW1wiYW5jaG9yLWhvcml6b250YWwtYm90dG9tXCJdKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNQZXJwT2Zmc2V0ID4gcGxvdEJveC53aWR0aCgpLzIpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yKCBnZXRWYWx1ZSh0aXRsZURlZmF1bHRzW1wiYW5jaG9yLXZlcnRpY2FsLXJpZ2h0XCJdKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciggZ2V0VmFsdWUodGl0bGVEZWZhdWx0c1tcImFuY2hvci12ZXJ0aWNhbC1sZWZ0XCJdKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoaWNzQ29udGV4dC5hbmdsZSA9IHRoaXMuYW5nbGUoKTtcbiAgICAgICAgdGhpcy5jb250ZW50KCkuaW5pdGlhbGl6ZUdlb21ldHJ5KGdyYXBoaWNzQ29udGV4dCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBBeGlzIFRpdGxlLiBPdmVycmlkZGVuIGJ5IGltcGxlbWVudGF0aW9ucyBpbiBncmFwaGljcyBkcml2ZXJzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZW5kZXJcIiwgZnVuY3Rpb24gKCkge30pO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzLnRpdGxlLCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aXNUaXRsZTtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzICAgID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgICAgICAgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5iYWNrZ3JvdW5kKSxcbiAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICBJbWcgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9pbWcuanMnKTtcblxudmFyIEJhY2tncm91bmQgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJCYWNrZ3JvdW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhc0EoXCJjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KS5kZWZhdWx0c1RvKFJHQkNvbG9yLnBhcnNlKGRlZmF1bHRWYWx1ZXMuYmFja2dyb3VuZC5jb2xvcikpO1xuICAgIHRoaXMuaGFzQShcImltZ1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgcmV0dXJuIGltZyBpbnN0YW5jZW9mIEltZztcbiAgICB9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tncm91bmQ7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG52YXIgdkYgPSByZXF1aXJlKCcuLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKTtcblxudmFyIENhdGVnb3J5Rm9ybWF0dGVyID0gZnVuY3Rpb24gKGZvcm1hdFZhbHVlcykge1xuICAgIGlmICh2Ri50eXBlT2YoZm9ybWF0VmFsdWVzKSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1hdFZhbHVlcyBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IGZvcm1hdFZhbHVlcztcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4LmFwcGx5KHRoaXMsIHRoaXMuZm9ybWF0VmFsdWVzLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiBzLmxlbmd0aDsgfSkpO1xufTtcblxuQ2F0ZWdvcnlGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBpID0gTWF0aC5yb3VuZCh2YWx1ZS5nZXRSZWFsVmFsdWUoKSk7XG4gICAgdmFyIGsgPSB0aGlzLmZvcm1hdFZhbHVlcy5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0VmFsdWVzWygoaSAlIGspICsgaykgJSBrXTtcbn07XG5cbkNhdGVnb3J5Rm9ybWF0dGVyLnByb3RvdHlwZS5nZXRNYXhMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuQ2F0ZWdvcnlGb3JtYXR0ZXIucHJvdG90eXBlLmdldEZvcm1hdFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRWYWx1ZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhdGVnb3J5Rm9ybWF0dGVyO1xuIiwidmFyIENvbnNlY3V0aXZlRGlzdGFuY2VGaWx0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5wcmV2UHggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wcmV2UHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oYXZlUHJldiA9IGZhbHNlO1xuICAgIHRoaXMuZGlzdGFuY2UgPSAoXCJkaXN0YW5jZVwiIGluIG9wdGlvbnMpID8gb3B0aW9ucy5kaXN0YW5jZSA6IDU7XG59O1xuXG5Db25zZWN1dGl2ZURpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhdmVQcmV2ID0gZmFsc2U7XG59O1xuXG5Db25zZWN1dGl2ZURpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZGF0YXAsIHBpeGVscCkge1xuICAgIHZhciBmaWx0ZXJPdXQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmhhdmVQcmV2KSB7XG4gICAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMocGl4ZWxwWzBdIC0gdGhpcy5wcmV2UHgpO1xuICAgICAgICAgIHZhciBkeSA9IE1hdGguYWJzKHBpeGVscFsxXSAtIHRoaXMucHJldlB5KTtcbiAgICAgICAgICBmaWx0ZXJPdXQgPSAoZHggKyBkeSA8IHRoaXMuZGlzdGFuY2UpO1xuICAgICAgICAgIGlmICghZmlsdGVyT3V0KSB7XG4gICAgICAgICAgICAgIHRoaXMucHJldlB4ID0gcGl4ZWxwWzBdO1xuICAgICAgICAgICAgICB0aGlzLnByZXZQeSA9IHBpeGVscFsxXTtcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJldlB4ID0gcGl4ZWxwWzBdO1xuICAgICAgICAgIHRoaXMucHJldlB5ID0gcGl4ZWxwWzFdO1xuICAgICAgfVxuICAgIHRoaXMuaGF2ZVByZXYgPSB0cnVlO1xuICAgIHJldHVybiBmaWx0ZXJPdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnNlY3V0aXZlRGlzdGFuY2VGaWx0ZXI7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cblxudmFyIENvbnN0YW50UGxvdCA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkNvbnN0YW50UGxvdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgZGVmYXVsdFZhbHVlcyAgICA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICAgICAgYXR0cmlidXRlcyAgICAgICA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLnBsb3QpLFxuICAgICAgICBQbG90ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9wbG90LmpzJyksXG4gICAgICAgIERhdGFWYWx1ZSAgICAgICAgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKTtcblxuICAgIHRoaXMuaXNBKFBsb3QpO1xuICAgIHRoaXMuaGFzQShcImNvbnN0YW50VmFsdWVcIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhVmFsdWUuaXNJbnN0YW5jZSk7XG5cbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwiY29uc3RhbnRWYWx1ZVwiKTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5wbG90LCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcInJlbmRlclwiLCBmdW5jdGlvbiAoZ3JhcGgsIGdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgICAvLyBncmFwaGljc0NvbnRleHQgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgcGFzc2VkIHRvIENvbnN0YW50UGxvdC5yZW5kZXIoKSBieSB0aGVcbiAgICAgICAgLy8gZ3JhcGhpY3MgZHJpdmVyLCBhbmQgdXNlZCBieSB0aGF0IGRyaXZlcidzIGltcGxlbWVudGF0aW9uIG9mIFJlbmRlcmVyLmJlZ2luKCkuXG4gICAgICAgIC8vIEl0IGNhbiBiZSBhbnkgb2JqZWN0IHVzZWQgYnkgdGhlIGRyaXZlciAtLSB1c3VhbGx5IHNvbWUga2luZCBvZiBncmFwaGljc1xuICAgICAgICAvLyBjb250ZXh0IG9iamVjdC4gIEl0IGNhbiBhbHNvIGJlIG9taXR0ZWQgaWYgYSBkcml2ZXIgZG9lcyBub3QgbmVlZCBpdC5cblxuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSgpKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBoYXhpcyA9IHRoaXMuaG9yaXpvbnRhbGF4aXMoKSxcbiAgICAgICAgICAgIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpLFxuICAgICAgICAgICAgY29uc3RhbnRWYWx1ZSA9IHRoaXMuY29uc3RhbnRWYWx1ZSgpO1xuXG4gICAgICAgIGlmICghaGF4aXMuaGFzRGF0YU1pbigpIHx8ICFoYXhpcy5oYXNEYXRhTWF4KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLnNldFVwTWlzc2luZygpOyAvL1RPRE86IHRoaXMgaXMgYXdrd2FyZCAtLSBmaWd1cmUgb3V0IGEgYmV0dGVyIHdheSFcbiAgICAgICAgcmVuZGVyZXIuYmVnaW4oZ3JhcGhpY3NDb250ZXh0KTtcbiAgICAgICAgcmVuZGVyZXIuZGF0YVBvaW50KFsgaGF4aXMuZGF0YU1pbigpLCBjb25zdGFudFZhbHVlIF0pO1xuICAgICAgICByZW5kZXJlci5kYXRhUG9pbnQoWyBoYXhpcy5kYXRhTWF4KCksIGNvbnN0YW50VmFsdWUgXSk7XG4gICAgICAgIHJlbmRlcmVyLmVuZCgpO1xuXG4gICAgfSk7XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0YW50UGxvdDtcblxuIiwiLy8gVGhpcyBmaWxlIHVzZXMgalF1ZXJ5LiAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZVxuLy8gZnVuY3Rpb24gcmV0dXJuZWQgYnkgcmVxdWlyaW5nIHRoaXMgZmlsZS5cbnZhciBDU1ZEYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkKSB7XG4gICAgaWYgKHR5cGVvZihDU1ZEYXRhKSAhPT0gXCJ1bmRlZmluZWRcIikgeyByZXR1cm4gQ1NWRGF0YTsgfVxuXG4gICAgdmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpLFxuICAgICAgICBBcnJheURhdGEgPSByZXF1aXJlKCcuL2FycmF5X2RhdGEuanMnKTtcblxuICAgIENTVkRhdGEgPSBuZXcgamVybWFpbmUuTW9kZWwoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMuaXNBKEFycmF5RGF0YSk7XG4gICAgICAgIHRoaXMuaGFzQShcImZpbGVuYW1lXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcbiAgICAgICAgdGhpcy5oYXNBKFwibWVzc2FnZUhhbmRsZXJcIik7XG4gICAgICAgIHRoaXMuaGFzQShcImFqYXh0aHJvdHRsZVwiKTtcbiAgICAgICAgdGhpcy5oYXNBKFwiZGF0YUlzUmVhZHlcIikud2hpY2guaXNBKFwiYm9vbGVhblwiKS5hbmQuZGVmYXVsdHNUbyhmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5yZXNwb25kc1RvKFwiZ2V0SXRlcmF0b3JcIiwgZnVuY3Rpb24gKGNvbHVtbklkcywgbWluLCBtYXgsIGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YUlzUmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheURhdGEuZ2V0QXJyYXlEYXRhSXRlcmF0b3IodGhpcywgY29sdW1uSWRzLCBtaW4sIG1heCwgYnVmZmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuZXh0XCIgICAgOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJoYXNOZXh0XCIgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcIl9kaXNwbGF5RXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyKCkuZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJjb2x1bW5zXCIsIFwiZmlsZW5hbWVcIiwgXCIlbWVzc2FnZUhhbmRsZXJcIiwgXCIlYWpheHRocm90dGxlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFqYXh0aHJvdHRsZSA9IHRoaXMuYWpheHRocm90dGxlKCk7XG5cbiAgICAgICAgICAgIGlmIChhamF4dGhyb3R0bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFqYXh0aHJvdHRsZSA9ICQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWRhcHRlcihBcnJheURhdGEpO1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGF0LmZpbGVuYW1lKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZW1pdCh7dHlwZSA6ICdhamF4RXZlbnQnLCBhY3Rpb24gOiAnc3RhcnQnfSk7XG4gICAgICAgICAgICAgICAgYWpheHRocm90dGxlLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICB1cmwgOiB0aGF0LmZpbGVuYW1lKCksXG5cbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3BhcnNlIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVZhbHVlcyA9IHRoYXQuYWRhcHRlcigpLnRleHRUb1N0cmluZ0FycmF5KHRoYXQuZ2V0Q29sdW1ucygpLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc3RyaW5nQXJyYXkoZGF0YVZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW5vcm1hbGl6ZSAmIHBvcHVsYXRlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFqYXhOb3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZGF0YUlzUmVhZHkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmVtaXQoe3R5cGUgOiBcImRhdGFSZWFkeVwifSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgOiBmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVycm9yVGhyb3duO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpxWEhSLnN0YXR1c0NvZGUoKS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkZpbGUgbm90IGZvdW5kOiAnXCIgKyB0aGF0LmZpbGVuYW1lKCkgKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gdGV4dFN0YXR1cyArIFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fZGlzcGxheUVycm9yKG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gJ2NvbXBsZXRlJyBjYWxsYmFjayBnZXRzIGNhbGxlZCBhZnRlciBlaXRoZXIgJ3N1Y2Nlc3MnIG9yICdlcnJvcicsIHdoaWNoZXZlcjpcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgOiBmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZW1pdCh7dHlwZSA6ICdhamF4RXZlbnQnLCBhY3Rpb24gOiAnY29tcGxldGUnfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBDU1ZEYXRhO1xufTtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vZXZlbnRfZW1pdHRlci5qcycpLFxuICAgIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4uL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgIERhdGFWYXJpYWJsZSA9IHJlcXVpcmUoJy4vZGF0YV92YXJpYWJsZS5qcycpO1xuXG52YXIgRGF0YSA9IG5ldyBqZXJtYWluZS5Nb2RlbChmdW5jdGlvbiAoKSB7XG4gICAgXG4gICAgdGhpcy5pc0EoRXZlbnRFbWl0dGVyKTtcblxuICAgIHRoaXMuaGFzQW4oXCJpZFwiKS53aGljaC5pc0EoXCJzdHJpbmdcIik7XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aHJvdWdoIGEgamVybWFpbmUgYXR0cl9saXN0IG9mIERhdGFWYXJpYWJsZXMgKGNvbHVtbnMpIGZvclxuICAgICAqIGFuIGVudHJ5IGhhdmluZyBhIGdpdmVuIGlkIG9yIGNvbHVtbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGZpbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyTmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHNlYXJjaCBvbjtcbiAgICAgKiAgICAgc2hvdWxkIGJlIGVpdGhlciBcImlkXCIgb3IgXCJjb2x1bW5cIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xJbnRlZ2VyfSBhdHRyVmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuIElmIGF0dHJOYW1lXG4gICAgICogICAgIGlzIFwiaWRcIiwgdGhpcyB2YWx1ZSBzaG91bGQgYmUgYSBzdHJpbmcuICBJZiBhdHRyTmFtZSBpcyBcImNvbHVtblwiLFxuICAgICAqICAgICB0aGlzIHZhbHVlIHNob3VsZCBiZSBhbiBpbnQuXG4gICAgICogQHBhcmFtIHtEYXRhVmFyaWFibGUgQXR0cl9MaXN0fSBjb2x1bW5zIFRoZSBhdHRyX2xpc3QgdG8gc2VhcmNoIHRocm91Z2guXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4ge0ludGVnZXJ9IFRoZSBpbmRleCAoYW4gaW50KSBvZiB0aGUgRGF0YVZhcmlhYmxlIGVudHJ5IGhhdmluZ1xuICAgICAqICAgICB0aGUgZ2l2ZW4gYXR0cmlidXRlIHZhbHVlLCBpZiBhbnksIG9yIC0xIGlmIG5vbmUgd2FzIGZvdW5kXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBmaW5kKFwiaWRcIiwgXCJ4XCIsIGNvbHVtbnMpXG4gICAgICpcbiAgICAgKiAgICAgICAgIGZpbmRzIHRoZSBpbmRleCBvZiB0aGUgRGF0YVZhcmlhYmxlIGluIHRoZSBjb2x1bW5zIGF0dHJfbGlzdFxuICAgICAqICAgICAgICAgaGF2aW5nIGFuIGlkIG9mIFwieFwiXG4gICAgICpcbiAgICAgKiAgICAgZmluZChcImNvbHVtblwiLCAxLCBjb2x1bW5zKVxuICAgICAqXG4gICAgICogICAgICAgICBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIERhdGFWYXJpYWJsZSBpbiB0aGUgY29sdW1ucyBhdHRyX2xpc3RcbiAgICAgKiAgICAgICAgIGhhdmluZyBhIFwiY29sdW1uXCIgYXR0cmlidXRlIG9mIDFcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgYXR0clZhbHVlLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAtMSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1ucy5hdChpKVthdHRyTmFtZV0oKSA9PT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGBkYXRhYCBhdHRyaWJ1dGUgb2YgZWFjaCBvZiB0aGlzIGRhdGEgb2JqZWN0J3MgY29sdW1uc1xuICAgICAqIHRvIHBvaW50IHRvIHRoZSBkYXRhIG9iamVjdCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVDb2x1bW5zXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImluaXRpYWxpemVDb2x1bW5zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnMoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zKCkuYXQoaSkuZGF0YSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNNYW55KFwiY29sdW1uc1wiKS5lYWNoT2ZXaGljaC52YWxpZGF0ZVdpdGgoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkRhdGE6IGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzaG91bGQgYmUgYW4gYXJyYXkgb2YgRGF0YVZhcmlhYmxlIG9iamVjdHNcIjtcbiAgICAgICAgcmV0dXJuIGNvbHVtbiBpbnN0YW5jZW9mIERhdGFWYXJpYWJsZTtcbiAgICB9KTtcblxuICAgIHRoaXMuaGFzQShcImRlZmF1bHRNaXNzaW5ndmFsdWVcIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuICAgIHRoaXMuaGFzQShcImRlZmF1bHRNaXNzaW5nb3BcIikud2hpY2guaXNBKFwic3RyaW5nXCIpLmFuZC5kZWZhdWx0c1RvKFwiZXFcIik7XG4gICAgdGhpcy5oYXNBbihcImFkYXB0ZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXphdGlvbiBmdW5jdGlvbiAtLS0gc2hvdWxkIGJlIGNhbGxlZCBmcm9tIGlzQnVpbHRXaXRoIGluaXRpYWxpemVyLiAgVGhpcyBpcyBzcGxpdFxuICAgICAqIG9mZiBpbnRvIGEgc2VwYXJhdGUgZnVuY3Rpb24gc28gdGhhdCBpdCBjYW4gYmUgY2FsbGVkIGZyb20gc3VibW9kZWwncyBpc0J1aWx0V2l0aCBpbml0aWFsaXplcnNcbiAgICAgKiBhcyB3ZWxsLCBzaW5jZSBKZXJtYWluZSBkb2VzIG5vdCBwcm92aWRlIGEgd2F5IHRvIGNhbGwgdGhlIHBhcmVudCBtb2RlbHMnIGlzQnVpbHRXaXRoIGluaXRpYWxpemVyXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaW5pdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ29sdW1ucygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pc0J1aWx0V2l0aChcImNvbHVtbnNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImNvbHVtbklkVG9Db2x1bW5OdW1iZXJcIiwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICh0eXBlb2YoaWQpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhOiBjb2x1bW5JZFRvQ29sdW1uTnVtYmVyIGV4cGVjdHMgcGFyYW1ldGVyIHRvIGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbHVtbkluZGV4ID0gZmluZChcImlkXCIsIGlkLCB0aGlzLmNvbHVtbnMoKSksXG4gICAgICAgICAgICBjb2x1bW4gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGNvbHVtbkluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuY29sdW1ucygpLmF0KGNvbHVtbkluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YTogbm8gY29sdW1uIHdpdGggdGhlIGxhYmVsIFwiICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY29sdW1uLmNvbHVtbigpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiY29sdW1uSWRUb0RhdGFWYXJpYWJsZVwiLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZihpZCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGE6IGNvbHVtbklkVG9EYXRhVmFyaWFibGUgcmVxdWlyZXMgYSBzdHJpbmcgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1ucygpLFxuICAgICAgICAgICAgZHYgPSBmaW5kKFwiaWRcIiwgaWQsIGNvbHVtbnMpICE9PSAtMSA/IGNvbHVtbnMuYXQoZmluZChcImlkXCIsIGlkLCBjb2x1bW5zKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGR2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGE6IG5vIGNvbHVtbiB3aXRoIHRoZSBsYWJlbCBcIiArIGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkdjtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImdldENvbHVtbklkXCIsIGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZihjb2x1bW4pICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhOiBnZXRDb2x1bW5JZCBtZXRob2QgZXhwZWN0cyBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZpbmQoXCJjb2x1bW5cIiwgY29sdW1uLCB0aGlzLmNvbHVtbnMoKSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGE6IGNvbHVtbiBcIiArIGNvbHVtbiArIFwiIGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zKCkuYXQocmVzdWx0KS5pZCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZ2V0Q29sdW1uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoKSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbHVtbnMuYXQoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImdldEJvdW5kc1wiLCBmdW5jdGlvbiAoY29sdW1uTnVtYmVyKSB7XG4gICAgICAgIC8vIHN1Ym1vZGVscyBtdXN0IGltcGxlbWVudCB0aGlzXG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJnZXRJdGVyYXRvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHN1Ym1vZGVscyBtdXN0IGltcGxlbWVudCB0aGlzXG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAqIFRoZSBcIm9uUmVhZHlcIiBjb250cmFjdDpcbiAgICAgKiBcbiAgICAgKiBFYWNoIHN1Ym1vZGVsIG9mIHRoaXMgRGF0YSBtb2RlbCBzaG91bGQgZG8gdGhlIGZvbGxvd2luZzpcbiAgICAgKiBcbiAgICAgKiAxLiBFbWl0IGFuIFwib25SZWFkeVwiIGV2ZW50IHdoZW5ldmVyIG5ldyBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgKiAgICBUaGUgYXJndW1lbnRzIHRvIHRoZSBldmVudCBsaXN0ZW5lciBhcmUgdGhlIG1pbiBhbmQgbWF4XG4gICAgICogICAgdmFsdWVzIG9mIHRoZSByYW5nZSBvZiAobmV3bHkpIGF2YWlsYWJsZSBkYXRhLlxuICAgICAqIFxuICAgICAqIDIuIE9wdGlvbmFsbHksIHJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIGl0cyBvd24gXCJsaXN0ZW5lckFkZGVkXCJcbiAgICAgKiAgICBldmVudHMsIHdoaWNoIHBlcmZvcm1zIHdoYXRldmVyIGFjdGlvbnMgYXJlIG5lZWRlZCwgaWYgYW55LFxuICAgICAqICAgIHdoZW4gYSBuZXcgXCJvblJlYWR5XCIgbGlzdGVuZXIgaXMgcmVnaXN0ZXJlZC5cbiAgICAgKi9cblxuICAgIHRoaXMucmVzcG9uZHNUbyhcInBhdXNlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvL25vIG9wXG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwicmVzdW1lXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvL25vIG9wXG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJpc01pc3NpbmdcIiwgZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiB0aGUgRGF0YVZhbHVlIFwidmFsdWVcIiBtZWV0cyB0aGUgXCJtaXNzaW5nXCIgY3JpdGVyaWEgb2ZcbiAgICAgICAgLy8gdGhlIGktdGggY29sdW1uXG4gICAgICAgIHZhciBjb2x1bW47XG4gICAgICAgIGlmIChpIDwgMCB8fCBpID49IHRoaXMuY29sdW1ucygpLnNpemUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWV0YWRhdGEuaXNNaXNzaW5nKCk6IGluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb2x1bW4gPSB0aGlzLmNvbHVtbnMoKS5hdChpKTtcbiAgICAgICAgaWYgKCFjb2x1bW4ubWlzc2luZ3ZhbHVlKCkgfHwgIWNvbHVtbi5taXNzaW5nb3AoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVtjb2x1bW4ubWlzc2luZ29wKCldKGNvbHVtbi5taXNzaW5ndmFsdWUoKSk7XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0cyB2YXJpYWJsZXMgaW50byBhcHByb3ByaWF0ZSBvcmRlclxuICAgIHZhciBzb3J0VmFyaWFibGVzID0gZnVuY3Rpb24gKGRhdGEsIHNvcnRlZFZhcmlhYmxlcywgdW5zb3J0ZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBkYXRhLmNvbHVtbnMoKSxcbiAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zLmF0KGkpO1xuICAgICAgICAgICAgaWYgKGNvbHVtbi5jb2x1bW4oKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc29ydGVkVmFyaWFibGVzW2NvbHVtbi5jb2x1bW4oKV0gPSBjb2x1bW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuc29ydGVkVmFyaWFibGVzLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBjcmVhdGVzIHBsYWNlaG9sZGVyIHZhcmlhYmxlc1xuICAgIHZhciBjcmVhdGVQbGFjZWhvbGRlclZhcmlhYmxlcyA9IGZ1bmN0aW9uIChkYXRhLCB1bnNvcnRlZFZhcmlhYmxlcykge1xuICAgICAgICB2YXIgbnVtTWlzc2luZ1ZhcmlhYmxlcyA9IGRhdGEuc3RyaW5nQXJyYXkoKVswXS5sZW5ndGggLSBkYXRhLmNvbHVtbnMoKS5zaXplKCksXG4gICAgICAgICAgICBpO1xuICAgICAgICBpZiAobnVtTWlzc2luZ1ZhcmlhYmxlcyA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1NaXNzaW5nVmFyaWFibGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB1bnNvcnRlZFZhcmlhYmxlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGluc2VydHMgdW5zb3J0ZWQgdmFyaWFibGVzIGludG8gdGhlIGNvcnJlY3QgbG9jYXRpb25cbiAgICB2YXIgaW5zZXJ0VW5zb3J0ZWRWYXJpYWJsZXMgPSBmdW5jdGlvbiAoc29ydGVkVmFyaWFibGVzLCB1bnNvcnRlZFZhcmlhYmxlcykge1xuICAgICAgICB2YXIgaW5kZXgsIGk7XG4gICAgICAgIGZvciAoaSA9IDAsIGluZGV4ID0gMDsgaSA8IHVuc29ydGVkVmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRWYXJpYWJsZXNbaW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3J0ZWRWYXJpYWJsZXNbaW5kZXhdID0gdW5zb3J0ZWRWYXJpYWJsZXNbaV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY2hlY2tzIHRoYXQgY29sdW1ucyB3ZXJlIGNvcnJlY3RseSBzcGVjaWZpZWRcbiAgICB2YXIgY2hlY2tDb2x1bW5JbmRpY2llcyA9IGZ1bmN0aW9uIChkYXRhLCBzb3J0ZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEuc3RyaW5nQXJyYXkoKVswXS5sZW5ndGgsXG4gICAgICAgICAgICBpO1xuICAgICAgICBpZiAoc29ydGVkVmFyaWFibGVzLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvcnRlZFZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRWYXJpYWJsZXNbaV0gaW5zdGFuY2VvZiBEYXRhVmFyaWFibGUgJiYgc29ydGVkVmFyaWFibGVzW2ldLmNvbHVtbigpID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgVmFyaWFibGUgRXJyb3I6IEF0dGVtcHRpbmcgdG8gc3BlY2lmeSBjb2x1bW4gJ1wiICsgc29ydGVkVmFyaWFibGVzW2ldLmNvbHVtbigpICsgXCInIGZvciBhIHZhcmlhYmxlLCB3aGlsZSB0aGVyZSBhcmUgb25seSBcIiArIGxlbmd0aCArIFwiIGRhdGEgY29sdW1ucyBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlcyBtaXNzaW5nIGF0dHJpYnV0ZXNcbiAgICAvLyBjcmVhdGVzIHRoZSBhcHByb3ByaWF0ZSB2YXJpYWJsZXMgaWYgbWlzc2luZ1xuICAgIHZhciBoYW5kbGVNaXNzaW5nQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChzb3J0ZWRWYXJpYWJsZXMsIGRlZmF1bHRNaXNzaW5nb3AsIGRlZmF1bHRNaXNzaW5ndmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRpZCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGRlZmF1bHRNaXNzaW5nb3AgPSBEYXRhVmFsdWUucGFyc2VDb21wYXJhdG9yKGRlZmF1bHRNaXNzaW5nb3ApO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkVmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXNvcnRlZFZhcmlhYmxlc1tpXSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRpZCA9IFwieFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0aWQgPSBcInlcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0aWQgPSBcInlcIiArIChpLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb3J0ZWRWYXJpYWJsZXNbaV0gPSBuZXcgRGF0YVZhcmlhYmxlKGRlZmF1bHRpZCwgaSwgRGF0YVZhbHVlLk5VTUJFUik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRWYXJpYWJsZXNbaV0uY29sdW1uKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRWYXJpYWJsZXNbaV0uY29sdW1uKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkVmFyaWFibGVzW2ldLnR5cGUoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFZhcmlhYmxlc1tpXS50eXBlKERhdGFWYWx1ZS5OVU1CRVIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlZmF1bHRNaXNzaW5ndmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRWYXJpYWJsZXNbaV0ubWlzc2luZ3ZhbHVlKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRWYXJpYWJsZXNbaV0ubWlzc2luZ3ZhbHVlKERhdGFWYWx1ZS5wYXJzZShzb3J0ZWRWYXJpYWJsZXNbaV0udHlwZSgpLCBkZWZhdWx0TWlzc2luZ3ZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvcnRlZFZhcmlhYmxlc1tpXS5taXNzaW5nb3AoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc29ydGVkVmFyaWFibGVzW2ldLm1pc3NpbmdvcChkZWZhdWx0TWlzc2luZ29wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbnNlcnRzIHRoZSBub3JtYWxpemVkIHZhcmlhYmxlcyBpbnRvIHRoZSBkYXRhIGluc3RhbmNlXG4gICAgdmFyIGluc2VydE5vcm1hbGl6ZWRWYXJpYWJsZXMgPSBmdW5jdGlvbiAoZGF0YSwgc29ydGVkVmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gZGF0YS5jb2x1bW5zKCksXG4gICAgICAgICAgICBpO1xuICAgICAgICB3aGlsZSAoY29sdW1ucy5zaXplKCkgPiAwKSB7XG4gICAgICAgICAgICBjb2x1bW5zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3J0ZWRWYXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbHVtbnMuYWRkKHNvcnRlZFZhcmlhYmxlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5pbml0aWFsaXplQ29sdW1ucygpO1xuICAgIH07XG5cblxuICAgIC8vIHBhcnNlcyBzdHJpbmcgdmFsdWVzIGludG8gdGhlIHByb3BlciBkYXRhIHR5cGVzXG4gICAgLy8gSWYgdGhlcmUgd2FzIGFjdHVhbCBkYXRhLCB2YWxpZGF0ZSB0aGF0IHRoZSBudW1iZXIgb2YgdmFsdWVzIGZvdW5kIGluIHN0cmluZ0FycmF5XG4gICAgLy8gYXMgbGFyZ2UgYXMgdGhlIHRoZSBudW1iZXIgb2YgdmFyaWFibGVzIGRlY2xhcmVkLiAgQXJyYXlEYXRhLnRleHRUb1N0cmluZ0FycmF5KCksXG4gICAgLy8gd2hpY2ggaXMgdGhlIGZ1bmN0aW9uIHRoYXQgY29uc3RydWN0ZWQgc3RyaW5nQXJyYXksIGhhcyBhbHJlYWR5IGd1YXJhbnRlZWQgdGhhdFxuICAgIC8vIGV2ZXJ5IHJvdyBpbiBzdHJpbmdBcnJheSBpcyBvZiB0aGUgc2FtZSBsZW5ndGgsIHNvIHdlIGNhbiB1c2UgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAvLyBmaXJzdCByb3cgYXMgdGhlIG51bWJlciBvZiB2YXJpYWJsZXMuXG4gICAgdmFyIGNyZWF0ZURhdGFWYWx1ZUFycmF5ID0gZnVuY3Rpb24gKGRhdGEsIHNvcnRlZFZhcmlhYmxlcykge1xuICAgICAgICB2YXIgQXJyYXlEYXRhID0gcmVxdWlyZSgnLi9hcnJheV9kYXRhLmpzJyk7XG4gICAgICAgIHZhciBzdHJpbmdBcnJheSA9IGRhdGEuc3RyaW5nQXJyYXkoKTtcbiAgICAgICAgaWYgKHN0cmluZ0FycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChzdHJpbmdBcnJheVswXS5sZW5ndGggPCBzb3J0ZWRWYXJpYWJsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBjb250YWlucyBvbmx5IFwiICsgc3RyaW5nQXJyYXlbMF0ubGVuZ3RoICsgXCIgY29sdW1uKHMpLCBidXQgc2hvdWxkIGNvbnRhaW4gXCIgKyBzb3J0ZWRWYXJpYWJsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhVmFsdWVzID0gQXJyYXlEYXRhLnN0cmluZ0FycmF5VG9EYXRhVmFsdWVzQXJyYXkoc29ydGVkVmFyaWFibGVzLCBzdHJpbmdBcnJheSk7XG5cbiAgICAgICAgZGF0YS5hcnJheShkYXRhVmFsdWVzKTtcbiAgICAgICAgZGF0YS5zdHJpbmdBcnJheShbXSk7XG4gICAgfTtcblxuICAgIHRoaXMucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIEFycmF5RGF0YSA9IHJlcXVpcmUoJy4vYXJyYXlfZGF0YS5qcycpLFxuICAgICAgICAgICAgc29ydGVkVmFyaWFibGVzICAgPSBbXSxcbiAgICAgICAgICAgIHVuc29ydGVkVmFyaWFibGVzID0gW10sXG4gICAgICAgICAgICAvLyAgbWJwIFR1ZSBNYXIgIDMgMTA6NTE6NDAgMjAxNTpcbiAgICAgICAgICAgIC8vICAgIGF2b2lkIHJlcXVpcmluZyB3ZWJfc2VydmljZV9kYXRhLmpzIGFuZCBjc3ZfZGF0YS5qcyBoZXJlIGJlY2F1c2UgdGhleSBoYXZlXG4gICAgICAgICAgICAvLyAgICBhIGRlcGVuZGVuY3kgb24galF1ZXJ5OyBhbHNvIGF2b2lkIGluc3RhbmNlb2ZcbiAgICAgICAgICAgIC8vQ1NWRGF0YSA9IHJlcXVpcmUoJy4vY3N2X2RhdGEuanMnKSxcbiAgICAgICAgICAgIC8vV2ViU2VydmljZURhdGEgPSByZXF1aXJlKCcuL3dlYl9zZXJ2aWNlX2RhdGEuanMnKSxcbiAgICAgICAgICAgIC8vaXNDc3ZPcldlYlNlcnZpY2UgPSB0aGlzIGluc3RhbmNlb2YgQ1NWRGF0YSB8fCB0aGlzIGluc3RhbmNlb2YgV2ViU2VydmljZURhdGEsXG4gICAgICAgICAgICBpc1dlYlNlcnZpY2VEYXRhID0gKHR5cGVvZih0aGlzLnNlcnZpY2VhZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKSxcbiAgICAgICAgICAgIGlzQ1NWRGF0YSA9ICh0eXBlb2YodGhpcy5maWxlbmFtZSkgPT09IFwiZnVuY3Rpb25cIiksXG4gICAgICAgICAgICBpc0Nzdk9yV2ViU2VydmljZSA9IGlzV2ViU2VydmljZURhdGEgfHwgaXNDU1ZEYXRhO1xuXG4gICAgICAgIC8vIEhhbmRsZXMgbWlzc2luZyB2YXJpYWJsZSB0YWdzIGlmIHRoZSBkYXRhIHRhZyBoYXMgYSAnY3N2JyBvciAnc2VydmljZScgdGFnXG4gICAgICAgIGlmIChpc0Nzdk9yV2ViU2VydmljZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1ucygpLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgTm9ybWFsaXphdGlvbjogRGF0YSBnb3R0ZW4gZnJvbSBjc3YgYW5kIHdlYiBzZXJ2aWNlIHNvdXJjZXMgcmVxdWlyZSB2YXJpYWJsZXMgdG8gYmUgc3BlY2lmaWVkIGluIHRoZSBtdWdsLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNvcnRWYXJpYWJsZXModGhpcywgc29ydGVkVmFyaWFibGVzLCB1bnNvcnRlZFZhcmlhYmxlcyk7XG5cbiAgICAgICAgLy8gY3JlYXRlcyBwbGFjZWhvbGRlciB2YXJpYWJsZXMgaWYgdGhlIGRhdGEgdGFnIGhhcyBhICd2YWx1ZXMnIHRhZ1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEFycmF5RGF0YSA9PT0gdHJ1ZSAmJiAhaXNDc3ZPcldlYlNlcnZpY2UpIHtcbiAgICAgICAgICAgIGNyZWF0ZVBsYWNlaG9sZGVyVmFyaWFibGVzKHRoaXMsIHVuc29ydGVkVmFyaWFibGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluc2VydFVuc29ydGVkVmFyaWFibGVzKHNvcnRlZFZhcmlhYmxlcywgdW5zb3J0ZWRWYXJpYWJsZXMpO1xuXG4gICAgICAgIC8vIGNoZWNrcyB0aGF0IGNvbHVtbnMgd2VyZSBjb3JyZWN0bHkgc3BlY2lmaWVkIGZvciAndmFsdWVzJyBkYXRhIHRhZ3NcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBBcnJheURhdGEgPT09IHRydWUgJiYgIWlzQ3N2T3JXZWJTZXJ2aWNlKSB7XG4gICAgICAgICAgICBjaGVja0NvbHVtbkluZGljaWVzKHRoaXMsIHNvcnRlZFZhcmlhYmxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVNaXNzaW5nQXR0cmlidXRlcyhzb3J0ZWRWYXJpYWJsZXMsIHRoaXMuZGVmYXVsdE1pc3NpbmdvcCgpLCB0aGlzLmRlZmF1bHRNaXNzaW5ndmFsdWUoKSk7XG4gICAgICAgIGluc2VydE5vcm1hbGl6ZWRWYXJpYWJsZXModGhpcywgc29ydGVkVmFyaWFibGVzKTtcblxuICAgICAgICAvLyBwYXJzZXMgc3RyaW5nIHZhbHVlcyBpbnRvIHRoZSBwcm9wZXIgZGF0YSB0eXBlcyBpZiB0aGUgZGF0YSB0YWcgaGFzIGEgJ3ZhbHVlcycgdGFnXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQXJyYXlEYXRhID09PSB0cnVlICYmICFpc0Nzdk9yV2ViU2VydmljZSkge1xuICAgICAgICAgICAgY3JlYXRlRGF0YVZhbHVlQXJyYXkodGhpcywgc29ydGVkVmFyaWFibGVzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnByb3RvdHlwZS5hamF4Tm9ybWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc29ydGVkVmFyaWFibGVzICAgPSBbXSxcbiAgICAgICAgICAgIHVuc29ydGVkVmFyaWFibGVzID0gW107XG5cbiAgICAgICAgc29ydFZhcmlhYmxlcyh0aGlzLCBzb3J0ZWRWYXJpYWJsZXMsIHVuc29ydGVkVmFyaWFibGVzKTtcbiAgICAgICAgY3JlYXRlUGxhY2Vob2xkZXJWYXJpYWJsZXModGhpcywgdW5zb3J0ZWRWYXJpYWJsZXMpO1xuICAgICAgICBpbnNlcnRVbnNvcnRlZFZhcmlhYmxlcyhzb3J0ZWRWYXJpYWJsZXMsIHVuc29ydGVkVmFyaWFibGVzKTtcbiAgICAgICAgY2hlY2tDb2x1bW5JbmRpY2llcyh0aGlzLCBzb3J0ZWRWYXJpYWJsZXMpO1xuICAgICAgICBoYW5kbGVNaXNzaW5nQXR0cmlidXRlcyhzb3J0ZWRWYXJpYWJsZXMsIHRoaXMuZGVmYXVsdE1pc3NpbmdvcCgpLCB0aGlzLmRlZmF1bHRNaXNzaW5ndmFsdWUoKSk7XG4gICAgICAgIGluc2VydE5vcm1hbGl6ZWRWYXJpYWJsZXModGhpcywgc29ydGVkVmFyaWFibGVzKTtcbiAgICAgICAgY3JlYXRlRGF0YVZhbHVlQXJyYXkodGhpcywgc29ydGVkVmFyaWFibGVzKTtcbiAgICB9O1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyksXG4gICAgTnVtYmVyRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9udW1iZXJfZm9ybWF0dGVyLmpzJyksXG4gICAgRGF0ZXRpbWVGb3JtYXR0ZXIgPSByZXF1aXJlKCcuL2RhdGV0aW1lX2Zvcm1hdHRlci5qcycpO1xuXG52YXIgRGF0YUZvcm1hdHRlciA9IHt9O1xuLypcbiAqIFJldHVybiB0cnVlIG9yIGZhbHNlIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9iaiBpcyBhbiBpbnN0YW5jZSBvZiBhIERhdGFGb3JtYXR0ZXIgdHlwZVxuICovXG5EYXRhRm9ybWF0dGVyLmlzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIChvYmogJiYgKHR5cGVvZihvYmouZm9ybWF0KSA9PT0gXCJmdW5jdGlvblwiKSAmJiAodHlwZW9mKG9iai5nZXRNYXhMZW5ndGgpID09PSBcImZ1bmN0aW9uXCIpKTtcbn07XG5cbi8qXG4gKiBDcmVhdGUgYSBuZXcgRGF0YUZvcm1hdHRlciBzdWJ0eXBlIG9mIGEgZ2l2ZW4gdHlwZVxuICovXG5EYXRhRm9ybWF0dGVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBmb3JtYXQpIHtcbiAgICBpZiAodHlwZSA9PT0gRGF0YVZhbHVlLk5VTUJFUikge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlckZvcm1hdHRlcihmb3JtYXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gRGF0YVZhbHVlLkRBVEVUSU1FKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZXRpbWVGb3JtYXR0ZXIoZm9ybWF0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdCB0byBjcmVhdGUgYW4gdW5rbm93biBEYXRhRm9ybWF0dGVyIHR5cGVcIik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFGb3JtYXR0ZXI7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBEYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKSxcbiAgICBOdW1iZXJNZWFzdXJlID0gcmVxdWlyZSgnLi9udW1iZXJfbWVhc3VyZS5qcycpLFxuICAgIERhdGV0aW1lTWVhc3VyZSA9IHJlcXVpcmUoJy4vZGF0ZXRpbWVfbWVhc3VyZS5qcycpO1xuXG52YXIgRGF0YU1lYXN1cmUgPSB7fTtcblxuLypcbiAqIFJldHVybiB0cnVlIG9yIGZhbHNlIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9iaiBpcyBhbiBpbnN0YW5jZSBvZiBhIERhdGFNZWFzdXJlIHR5cGVcbiAqL1xuRGF0YU1lYXN1cmUuaXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gKG9iaiAmJiAodHlwZW9mKG9iai5nZXRSZWFsVmFsdWUpID09PSBcImZ1bmN0aW9uXCIpICYmICghb2JqLmNvbXBhcmVUbykpO1xufTtcblxuLypcbiAqIENyZWF0ZSBhIG5ldyBEYXRhTWVhc3VyZSBzdWJ0eXBlIG9mIGEgZ2l2ZW4gdHlwZSBieSBwYXJzaW5nIGEgc3RyaW5nXG4gKi9cbkRhdGFNZWFzdXJlLnBhcnNlID0gZnVuY3Rpb24gKHR5cGUsIHN0cmluZykge1xuICAgIGlmICh0eXBlID09PSBEYXRhVmFsdWUuTlVNQkVSKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXJNZWFzdXJlLnBhcnNlKHN0cmluZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBEYXRhVmFsdWUuREFURVRJTUUpIHtcbiAgICAgICAgcmV0dXJuIERhdGV0aW1lTWVhc3VyZS5wYXJzZShzdHJpbmcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0IHRvIHBhcnNlIGFuIHVua25vd24gRGF0YU1lYXN1cmUgdHlwZVwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU1lYXN1cmU7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBQbG90ID0gcmVxdWlyZSgnLi9wbG90LmpzJyksXG4gICAgRGF0YVZhcmlhYmxlID0gcmVxdWlyZSgnLi9kYXRhX3ZhcmlhYmxlLmpzJyksXG4gICAgRmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXIuanMnKSxcbiAgICBEYXRhdGlwcyA9IHJlcXVpcmUoJy4vZGF0YXRpcHMuanMnKSxcbiAgICBEYXRhID0gcmVxdWlyZSgnLi9kYXRhLmpzJyksXG4gICAgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLnBsb3QpO1xuXG52YXIgZ3JhcGhDb29yZHNUb1BpeGVsQ29vcmRzID0gZnVuY3Rpb24gKGdyYXBoQ29vcmRzLCBncmFwaCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZ3JhcGhDb29yZHNbMF0gKyBncmFwaC54MCgpLFxuICAgICAgICBoZWlnaHQgLSAoZ3JhcGhDb29yZHNbMV0gKyBncmFwaC55MCgpKVxuICAgIF07XG59O1xuXG52YXIgRGF0YVBsb3QgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJEYXRhUGxvdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUGxvdCk7XG4gICAgdGhpcy5oYXNNYW55KFwidmFyaWFibGVcIikuZWFjaE9mV2hpY2gudmFsaWRhdGVXaXRoKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgICByZXR1cm4gdmFyaWFibGUgaW5zdGFuY2VvZiBEYXRhVmFyaWFibGUgfHwgdmFyaWFibGUgPT09IG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiZmlsdGVyXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gZmlsdGVyIGluc3RhbmNlb2YgRmlsdGVyO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImRhdGF0aXBzXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGRhdGF0aXBzKSB7XG4gICAgICAgIHJldHVybiBkYXRhdGlwcyBpbnN0YW5jZW9mIERhdGF0aXBzO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImRhdGFcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIERhdGE7XG4gICAgfSk7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMucGxvdCwgYXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZW5kZXJcIiwgZnVuY3Rpb24gKGdyYXBoLCBncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgLy8gZ3JhcGhpY3NDb250ZXh0IGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHBhc3NlZCB0byBEYXRhUGxvdC5yZW5kZXIoKSBieSB0aGVcbiAgICAgICAgLy8gZ3JhcGhpY3MgZHJpdmVyLCBhbmQgdXNlZCBieSB0aGF0IGRyaXZlcidzIGltcGxlbWVudGF0aW9uIG9mIFJlbmRlcmVyLmJlZ2luKCkuXG4gICAgICAgIC8vIEl0IGNhbiBiZSBhbnkgb2JqZWN0ZGVkIGJ5IHRoZSBkcml2ZXIgLS0gdXN1YWxseSBzb21lIGtpbmQgb2YgZ3JhcGhpY3NcbiAgICAgICAgLy8gY29udGV4dCBvYmplY3QuICBJdCBjYW4gYWxzbyBiZSBvbWl0dGVkIGlmIGEgZHJpdmVyIGRvZXMgbm90IG5lZWQgaXQuXG4gICAgICAgIC8vdmFyIGRhdGEgPSB0aGlzLmRhdGEoKS5hcnJheWRhdGEoKTtcblxuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSgpKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhKCk7XG4gICAgICAgIGlmICghIGRhdGEpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIGhheGlzID0gdGhpcy5ob3Jpem9udGFsYXhpcygpLFxuICAgICAgICAgICAgdmF4aXMgPSB0aGlzLnZlcnRpY2FsYXhpcygpO1xuXG4gICAgICAgIGlmICghaGF4aXMuaGFzRGF0YU1pbigpIHx8ICFoYXhpcy5oYXNEYXRhTWF4KCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgcGxvdCdzIGhvcml6b250YWwgYXhpcyBkb2VzIG5vdCBoYXZlIGEgbWluIG9yIG1heCB2YWx1ZSB5ZXQsXG4gICAgICAgICAgICAvLyByZXR1cm4gaW1tZWRpYXRlbHkgd2l0aG91dCBkb2luZyBhbnl0aGluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhcmlhYmxlcyAgID0gdGhpcy52YXJpYWJsZSgpLFxuICAgICAgICAgICAgdmFyaWFibGVJZHMgPSBbXSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YXJpYWJsZXMuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlSWRzLnB1c2goIHZhcmlhYmxlcy5hdChpKS5pZCgpICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlciA9IGRhdGEuZ2V0SXRlcmF0b3IodmFyaWFibGVJZHMsIGhheGlzLmRhdGFNaW4oKSwgaGF4aXMuZGF0YU1heCgpLCAxKSxcbiAgICAgICAgICAgIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpO1xuXG4gICAgICAgIHJlbmRlcmVyLnNldFVwTWlzc2luZygpOyAvL1RPRE86IHRoaXMgaXMgYXdrd2FyZCAtLSBmaWd1cmUgb3V0IGEgYmV0dGVyIHdheSFcbiAgICAgICAgcmVuZGVyZXIuYmVnaW4oZ3JhcGhpY3NDb250ZXh0KTtcbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgZGF0YXAgPSBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmRhdGFQb2ludChkYXRhcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIuZW5kKCk7XG5cbiAgICB9KTtcblxuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZ2V0RGF0YXRpcHNEYXRhXCIsIGZ1bmN0aW9uIChsb2MsIGdyYXBoV2lkdGgsIGdyYXBoSGVpZ2h0LCBncmFwaCwgdGVzdEVsZW0pIHtcbiAgICAgICAgdmFyIGRhdGF0aXBzID0gdGhpcy5kYXRhdGlwcygpO1xuICAgICAgICBpZiAoIWRhdGF0aXBzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSgpO1xuXG4gICAgICAgIGlmICghZGF0YSkgeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgaGF4aXMgPSB0aGlzLmhvcml6b250YWxheGlzKCksXG4gICAgICAgICAgICB2YXhpcyA9IHRoaXMudmVydGljYWxheGlzKCk7XG5cbiAgICAgICAgaWYgKCFoYXhpcy5oYXNEYXRhTWluKCkgfHwgIWhheGlzLmhhc0RhdGFNYXgoKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBwbG90J3MgaG9yaXpvbnRhbCBheGlzIGRvZXMgbm90IGhhdmUgYSBtaW4gb3IgbWF4IHZhbHVlIHlldCxcbiAgICAgICAgICAgIC8vIHJldHVybiBpbW1lZGlhdGVseSB3aXRob3V0IGRvaW5nIGFueXRoaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFyaWFibGVzICAgPSB0aGlzLnZhcmlhYmxlKCksXG4gICAgICAgICAgICB2YXJpYWJsZUlkcyA9IFtdLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFyaWFibGVzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICB2YXJpYWJsZUlkcy5wdXNoKCB2YXJpYWJsZXMuYXQoaSkuaWQoKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXIgICAgICAgID0gZGF0YS5nZXRJdGVyYXRvcih2YXJpYWJsZUlkcywgaGF4aXMuZGF0YU1pbigpLCBoYXhpcy5kYXRhTWF4KCksIDEpLFxuICAgICAgICAgICAgcmVuZGVyZXIgICAgPSB0aGlzLnJlbmRlcmVyKCksXG4gICAgICAgICAgICBwb2ludHMgICAgICA9IFtdLFxuICAgICAgICAgICAgeCAgICAgICAgICAgPSBsb2MueCgpLFxuICAgICAgICAgICAgeSAgICAgICAgICAgPSBsb2MueSgpLFxuICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSAyMCxcbiAgICAgICAgICAgIGN1ckRpc3QsXG4gICAgICAgICAgICBkYXRhcDtcblxuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGRhdGFwID0gcmVuZGVyZXIudHJhbnNmb3JtUG9pbnQoaXRlci5uZXh0KCkpO1xuICAgICAgICAgICAgY3VyRGlzdCA9IHdpbmRvdy5tdWx0aWdyYXBoLm1hdGgudXRpbC5sMmRpc3QoeCwgeSwgZGF0YXBbMF0sIGRhdGFwWzFdKTtcbiAgICAgICAgICAgIGlmIChjdXJEaXN0IDwgbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YXBcIiAgOiBkYXRhcCxcbiAgICAgICAgICAgICAgICAgICAgXCJkaXN0XCIgICA6IGN1ckRpc3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluSW5kZXggPSAwLFxuICAgICAgICAgICAgbWluRGlzdCAgPSBwb2ludHNbMF0uZGlzdDtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaW5kZXggb2YgY2xvc2VzdCBwb2ludCB0byBtb3VzZVxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocG9pbnRzW2ldLmRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBwb2ludHNbaV0uZGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhY2hlIGNsb3Nlc3QgcG9pbnQgdG8gbW91c2VcbiAgICAgICAgdmFyIHBvaW50ICAgICAgPSBwb2ludHNbbWluSW5kZXhdLFxuICAgICAgICAgICAgYXhpc1ZhbHVlcyA9IFtdO1xuXG4gICAgICAgIC8vIGNhY2hlIGRhdGEgZm9yIHBvaW50XG4gICAgICAgIGRhdGFwID0gcG9pbnQuZGF0YXA7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHBpeGVsIGxvY2F0aW9uIG9mIGRhdGEgcG9pbnRcbiAgICAgICAgcG9pbnQucGl4ZWxwID0gZ3JhcGhDb29yZHNUb1BpeGVsQ29vcmRzKGRhdGFwLCBncmFwaCwgZ3JhcGhIZWlnaHQpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSByZWFsIERhdGFWYWx1ZXMgZm9yIHRoZSBkYXRhcG9pbnRcbiAgICAgICAgYXhpc1ZhbHVlc1swXSA9IGhheGlzLmF4aXNWYWx1ZVRvRGF0YVZhbHVlKGRhdGFwWzBdKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGRhdGFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBheGlzVmFsdWVzW2ldID0gdmF4aXMuYXhpc1ZhbHVlVG9EYXRhVmFsdWUoZGF0YXBbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgICAgPSBkYXRhdGlwcy5mb3JtYXQoYXhpc1ZhbHVlcyksXG4gICAgICAgICAgICBkaW1lbnNpb25zID0gZGF0YXRpcHMuY29tcHV0ZURpbWVuc2lvbnMoY29udGVudCwgdGVzdEVsZW0pO1xuXG4gICAgICAgIHBvaW50LmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICBwb2ludC5kaW1lbnNpb25zID0gZGltZW5zaW9ucztcblxuICAgICAgICAvLyBmb3Igbm93IGp1c3QgdXNlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSByZXN1bHRzXG4gICAgICAgIHBvaW50LnR5cGUgPSBkYXRhdGlwcy5jb21wdXRlT3JpZW50YXRpb24ocG9pbnQsIGdyYXBoV2lkdGgsIGdyYXBoSGVpZ2h0KVswXTtcblxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJjcmVhdGVEYXRhdGlwXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciAkICAgICAgICAgICA9IHdpbmRvdy5tdWx0aWdyYXBoLmpRdWVyeSxcbiAgICAgICAgICAgIGNvbnRlbnQgICAgID0gZGF0YS5jb250ZW50LFxuICAgICAgICAgICAgdHlwZSAgICAgICAgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICBkaW1lbnNpb25zICA9IGRhdGEuZGltZW5zaW9ucyxcbiAgICAgICAgICAgIHBpeGVscCAgICAgID0gZGF0YS5waXhlbHAsXG4gICAgICAgICAgICB3ICAgICAgICAgICA9IGRpbWVuc2lvbnMud2lkdGgsXG4gICAgICAgICAgICBoICAgICAgICAgICA9IGRpbWVuc2lvbnMuaGVpZ2h0LFxuICAgICAgICAgICAgeCAgICAgICAgICAgPSBwaXhlbHBbMF0sXG4gICAgICAgICAgICB5ICAgICAgICAgICA9IHBpeGVscFsxXSxcbiAgICAgICAgICAgIGFycm93TGVuZ3RoID0gZGF0YS5hcnJvdyxcbiAgICAgICAgICAgIG9mZnNldCAgICAgID0gZGV0ZXJtaW5lT2Zmc2V0cyh0eXBlLCB4LCB5LCB3LCBoLCBhcnJvd0xlbmd0aCksXG4gICAgICAgICAgICBkYXRhdGlwcyAgICA9IHRoaXMuZGF0YXRpcHMoKSxcbiAgICAgICAgICAgIGJvcmRlcmNvbG9yID0gZGF0YXRpcHMuYm9yZGVyY29sb3IoKS5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuXG4gICAgICAgIHZhciBib3ggICAgID0gJChcIjxkaXY+XCIgKyBjb250ZW50ICsgXCI8L2Rpdj5cIiksXG4gICAgICAgICAgICBhcnJvdyAgID0gJChcIjxkaXY+Jm5ic3A8L2Rpdj5cIiksXG4gICAgICAgICAgICBkYXRhdGlwID0gJChcIjxkaXY+PC9kaXY+XCIpO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIERhdGF0aXBzLkRPV046XG4gICAgICAgICAgICBhcnJvdy5jc3Moe1xuICAgICAgICAgICAgICAgIFwibGVmdFwiICAgICAgICAgIDogKCh3LzIpIC0gNSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItYm90dG9tXCIgOiBhcnJvd0xlbmd0aCArIFwicHggc29saWQgXCIgKyBib3JkZXJjb2xvcixcbiAgICAgICAgICAgICAgICBcImJvcmRlci1sZWZ0XCIgICA6IFwiNXB4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItcmlnaHRcIiAgOiBcIjVweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLXRvcFwiICAgIDogXCIwcHhcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhdGlwLmFwcGVuZChhcnJvdyk7XG4gICAgICAgICAgICBkYXRhdGlwLmFwcGVuZChib3gpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRGF0YXRpcHMuUklHSFQ6XG4gICAgICAgICAgICBhcnJvdy5jc3Moe1xuICAgICAgICAgICAgICAgIFwidG9wXCIgICAgICAgICAgIDogKChoLzIpIC0gNSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItYm90dG9tXCIgOiBcIjVweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLXRvcFwiICAgIDogXCI1cHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICBcImJvcmRlci1yaWdodFwiICA6IGFycm93TGVuZ3RoICsgXCJweCBzb2xpZCBcIiArIGJvcmRlcmNvbG9yLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLWxlZnRcIiAgIDogXCIwcHhcIixcbiAgICAgICAgICAgICAgICBcImZsb2F0XCIgICAgICAgICA6IFwibGVmdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJveC5jc3MoXCJmbG9hdFwiLCBcImxlZnRcIik7XG4gICAgICAgICAgICBkYXRhdGlwLmFwcGVuZChhcnJvdyk7XG4gICAgICAgICAgICBkYXRhdGlwLmFwcGVuZChib3gpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRGF0YXRpcHMuVVA6XG4gICAgICAgICAgICBhcnJvdy5jc3Moe1xuICAgICAgICAgICAgICAgIFwibGVmdFwiICAgICAgICAgIDogKCh3LzIpIC0gNSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItdG9wXCIgICAgOiBhcnJvd0xlbmd0aCArIFwicHggc29saWQgXCIgKyBib3JkZXJjb2xvcixcbiAgICAgICAgICAgICAgICBcImJvcmRlci1sZWZ0XCIgICA6IFwiNXB4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItcmlnaHRcIiAgOiBcIjVweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLWJvdHRvbVwiIDogXCIwcHhcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhdGlwLmFwcGVuZChib3gpO1xuICAgICAgICAgICAgZGF0YXRpcC5hcHBlbmQoYXJyb3cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRGF0YXRpcHMuTEVGVDpcbiAgICAgICAgICAgIGFycm93LmNzcyh7XG4gICAgICAgICAgICAgICAgXCJ0b3BcIiAgICAgICAgICAgOiAoKGgvMikgLSA1KSArIFwicHhcIixcbiAgICAgICAgICAgICAgICBcImJvcmRlci1ib3R0b21cIiA6IFwiNXB4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItdG9wXCIgICAgOiBcIjVweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLWxlZnRcIiAgIDogYXJyb3dMZW5ndGggKyBcInB4IHNvbGlkIFwiICsgYm9yZGVyY29sb3IsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItcmlnaHRcIiAgOiBcIjBweFwiLFxuICAgICAgICAgICAgICAgIFwiZmxvYXRcIiAgICAgICAgIDogXCJsZWZ0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYm94LmNzcyhcImZsb2F0XCIsIFwibGVmdFwiKTtcbiAgICAgICAgICAgIGRhdGF0aXAuYXBwZW5kKGJveCk7XG4gICAgICAgICAgICBkYXRhdGlwLmFwcGVuZChhcnJvdyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGF0aXAuY3NzKHtcbiAgICAgICAgICAgIFwidGV4dC1hbGlnblwiIDogXCJsZWZ0XCIsXG4gICAgICAgICAgICBcInBvc2l0aW9uXCIgICA6IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIFwiY2xlYXJcIiAgICAgIDogXCJib3RoXCIsXG4gICAgICAgICAgICBcImxlZnRcIiAgICAgICA6IG9mZnNldFswXSArIFwicHhcIixcbiAgICAgICAgICAgIFwidG9wXCIgICAgICAgIDogb2Zmc2V0WzFdICsgXCJweFwiLFxuICAgICAgICAgICAgXCJtYXJnaW5cIiAgICAgOiBcIjBweFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nXCIgICAgOiBcIjBweFwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJveC5jc3Moe1xuICAgICAgICAgICAgXCJkaXNwbGF5XCIgICAgICAgICAgOiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICAgICAgXCJwb3NpdGlvblwiICAgICAgICAgOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIiA6IGRhdGF0aXBzLmJnY29sb3IoKS50b1JHQkEoZGF0YXRpcHMuYmdhbHBoYSgpKSxcbiAgICAgICAgICAgIFwidGV4dC1hbGlnblwiICAgICAgIDogXCJsZWZ0XCIsXG4gICAgICAgICAgICBcIm1hcmdpblwiICAgICAgICAgICA6IFwiMHB4XCIsXG4gICAgICAgICAgICBcInBhZGRpbmctbGVmdFwiICAgICA6IFwiNXB4XCIsXG4gICAgICAgICAgICBcInBhZGRpbmctcmlnaHRcIiAgICA6IFwiNXB4XCIsXG4gICAgICAgICAgICBcInBhZGRpbmctdG9wXCIgICAgICA6IFwiMXB4XCIsXG4gICAgICAgICAgICBcInBhZGRpbmctYm90dG9tXCIgICA6IFwiMXB4XCIsXG4gICAgICAgICAgICBcImJvcmRlclwiICAgICAgICAgICA6IGRhdGF0aXBzLmJvcmRlcigpICsgXCJweCBzb2xpZCBcIiArIGJvcmRlcmNvbG9yLFxuICAgICAgICAgICAgXCJib3JkZXItcmFkaXVzXCIgICAgOiBcIjVweFwiXG4gICAgICAgIH0pLFxuXG4gICAgICAgIGFycm93LmNzcyh7XG4gICAgICAgICAgICBcImhlaWdodFwiICAgICA6IFwiMHB4XCIsXG4gICAgICAgICAgICBcIndpZHRoXCIgICAgICA6IFwiMHB4XCIsXG4gICAgICAgICAgICBcInBvc2l0aW9uXCIgICA6IFwicmVsYXRpdmVcIixcbiAgICAgICAgICAgIFwidGV4dC1hbGlnblwiIDogXCJsZWZ0XCIsXG4gICAgICAgICAgICBcIm1hcmdpblwiICAgICA6IFwiMHB4XCIsXG4gICAgICAgICAgICBcInBhZGRpbmdcIiAgICA6IFwiMHB4XCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGF0aXA7XG4gICAgfSk7XG5cbiAgICB2YXIgZGV0ZXJtaW5lT2Zmc2V0cyA9IGZ1bmN0aW9uICh0eXBlLCB4LCB5LCB3LCBoLCBhcnJvd0xlbmd0aCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBEYXRhdGlwcy5ET1dOOlxuICAgICAgICAgICAgcmV0dXJuIFt4IC0gdy8yLCB5XTtcbiAgICAgICAgY2FzZSBEYXRhdGlwcy5SSUdIVDpcbiAgICAgICAgICAgIHJldHVybiBbeCwgeSAtIGgvMl07XG4gICAgICAgIGNhc2UgRGF0YXRpcHMuVVA6XG4gICAgICAgICAgICByZXR1cm4gW3ggLSB3LzIsIHkgLSBoIC0gYXJyb3dMZW5ndGhdO1xuICAgICAgICBjYXNlIERhdGF0aXBzLkxFRlQ6XG4gICAgICAgICAgICByZXR1cm4gW3ggLSB3IC0gYXJyb3dMZW5ndGgsIHkgLSBoLzJdO1xuICAgICAgICB9XG4gICAgfTtcblxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhUGxvdDtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxuLypcbiAqIERhdGFWYWx1ZSBpcyBhIFBPSlNPIChwbGFpbiBvbGQgamF2YXNjcmlwdCBvYmplY3QpIHRoYXQgc2ltcGx5XG4gKiBzZXJ2ZXMgYXMgYW4gZWNhcHN1bGF0aW9uIGZvciBzZXZlcmFsIGdlbmVyaWNcbiAqIGRhdGEtdmFsdWUtcmVsYXRlZCBjb25zdGFudHMgYW5kIGZ1bmN0aW9ucy4gIFRoZXJlIGlzIG5vIGFjdHVhbFxuICogRGF0YVZhbHVlIG1vZGVsIHRoYXQgY2FuIGJlIGluc3RhbnRpYXRlZDsgYWxsIGRhdGEgdmFsdWVzIGFyZVxuICogaW5zdGFuY2VzIG9mIGVpdGhlciB0aGUgTnVtYmVyVmFsdWUgb3IgRGF0ZXRpbWVWYWx1ZSBtb2RlbC5cbiAqL1xuXG52YXIgRGF0YVZhbHVlID0ge307XG5cbkRhdGFWYWx1ZS5OVU1CRVIgPSBcIm51bWJlclwiO1xuRGF0YVZhbHVlLkRBVEVUSU1FID0gXCJkYXRldGltZVwiO1xuRGF0YVZhbHVlLlVOS05PV04gPSBcInVua25vd25cIjtcblxuLypcbiAqIFJldHVybiBhIGxpc3Qgb2YgdGhlIHR5cGUgY29uc3RhbnRzIGFib3ZlXG4gKi9cbkRhdGFWYWx1ZS50eXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gWyBEYXRhVmFsdWUuTlVNQkVSLCBEYXRhVmFsdWUuREFURVRJTUUsIERhdGFWYWx1ZS5VTktOT1dOIF07XG59O1xuXG4vKlxuICogQ3JlYXRlIGEgbmV3IERhdGFWYWx1ZSBzdWJ0eXBlIG9mIGEgZ2l2ZW4gdHlwZSBieSBwYXJzaW5nIGEgc3RyaW5nXG4gKi9cbkRhdGFWYWx1ZS5wYXJzZVR5cGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKHN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBEYXRhVmFsdWUuTlVNQkVSKSB7IHJldHVybiBEYXRhVmFsdWUuTlVNQkVSOyB9XG4gICAgaWYgKHN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBEYXRhVmFsdWUuREFURVRJTUUpIHsgcmV0dXJuIERhdGFWYWx1ZS5EQVRFVElNRTsgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gRGF0YVZhbHVlIHR5cGU6IFwiICsgc3RyaW5nKTtcbn07XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGEgXCJ0eXBlXCIgZW51bSBvYmplY3QgdG8gYSBzdHJpbmcuICBJbiByZWFsaXR5LCB0aGUgb2JqZWN0cyBBUkVcbiAqIHRoZSBzdHJpbmdzLCBzbyB3ZSBqdXN0IHJldHVybiB0aGUgb2JqZWN0LlxuICovXG5EYXRhVmFsdWUuc2VyaWFsaXplVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGU7XG59O1xuXG4vKlxuICogUmV0dXJuIHRydWUgb3IgZmFsc2UgZGVwZW5kaW5nIG9uIHdoZXRoZXIgb2JqIGlzIGFuIGluc3RhbmNlIG9mIGEgRGF0YVZhbHVlIHR5cGVcbiAqL1xuRGF0YVZhbHVlLmlzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIChvYmogJiYgKHR5cGVvZihvYmouZ2V0UmVhbFZhbHVlKSA9PT0gXCJmdW5jdGlvblwiKSAmJiAodHlwZW9mKG9iai5jb21wYXJlVG8pID09PSBcImZ1bmN0aW9uXCIpKTtcbn07XG5cbi8qXG4gKiBTYW1lIGFzIERhdGFWYWx1ZS5pc0luc3RhbmNlLCBidXQgYWxzbyBhbGxvd3MgdGhlIG51bGwgdmFsdWVcbiAqL1xuRGF0YVZhbHVlLmlzSW5zdGFuY2VPck51bGwgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuICgob2JqPT09bnVsbCkgfHwgRGF0YVZhbHVlLmlzSW5zdGFuY2Uob2JqKSk7XG59O1xuXG4vKlxuICogQ3JlYXRlIGEgbmV3IERhdGFWYWx1ZSBzdWJ0eXBlIG9mIGEgZ2l2ZW4gdHlwZSBmcm9tIGEgcmVhbCB2YWx1ZVxuICovXG5EYXRhVmFsdWUuY3JlYXRlID0gZnVuY3Rpb24gKHR5cGUsIHJlYWxWYWx1ZSkge1xuICAgIHZhciBOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vbnVtYmVyX3ZhbHVlLmpzJyksXG4gICAgICAgIERhdGV0aW1lVmFsdWUgPSByZXF1aXJlKCcuL2RhdGV0aW1lX3ZhbHVlLmpzJyk7XG5cbiAgICBpZiAodHlwZSA9PT0gRGF0YVZhbHVlLk5VTUJFUikge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlclZhbHVlKHJlYWxWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBEYXRhVmFsdWUuREFURVRJTUUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRldGltZVZhbHVlKHJlYWxWYWx1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImF0dGVtcHQgdG8gcGFyc2UgYW4gdW5rbm93biBEYXRhVmFsdWUgdHlwZVwiKTtcbn07XG5cbi8qXG4gKiBDcmVhdGUgYSBuZXcgRGF0YVZhbHVlIHN1YnR5cGUgb2YgYSBnaXZlbiB0eXBlIGJ5IHBhcnNpbmcgYSBzdHJpbmdcbiAqL1xuRGF0YVZhbHVlLnBhcnNlID0gZnVuY3Rpb24gKHR5cGUsIHN0cmluZykge1xuICAgIHZhciBOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vbnVtYmVyX3ZhbHVlLmpzJyksXG4gICAgICAgIERhdGV0aW1lVmFsdWUgPSByZXF1aXJlKCcuL2RhdGV0aW1lX3ZhbHVlLmpzJyk7XG5cbiAgICBpZiAodHlwZSA9PT0gRGF0YVZhbHVlLk5VTUJFUikge1xuICAgICAgICByZXR1cm4gTnVtYmVyVmFsdWUucGFyc2Uoc3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IERhdGFWYWx1ZS5EQVRFVElNRSkge1xuICAgICAgICByZXR1cm4gRGF0ZXRpbWVWYWx1ZS5wYXJzZShzdHJpbmcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0IHRvIHBhcnNlIGFuIHVua25vd24gRGF0YVZhbHVlIHR5cGVcIik7XG59O1xuXG4vKlxuICogRW51bSB2YWx1ZXMgZm9yIGNvbXBhcmlzb24gb3BlcmF0b3JzLiAgVGhlc2Ugc2hvdWxkIGJlIGxvd2VyY2FzZSBzdHJpbmdzIC0tLSB0aGV5J3JlIHVzZWQgYXNcbiAqIGFjdHVhbCBtZXRob2QgbmFtZXMgYmVsb3cuXG4gKi9cbkRhdGFWYWx1ZS5MVCA9IFwibHRcIjtcbkRhdGFWYWx1ZS5MRSA9IFwibGVcIjtcbkRhdGFWYWx1ZS5FUSA9IFwiZXFcIjtcbkRhdGFWYWx1ZS5HRSA9IFwiZ2VcIjtcbkRhdGFWYWx1ZS5HVCA9IFwiZ3RcIjtcbkRhdGFWYWx1ZS5ORSA9IFwibmVcIjtcblxudmFyIGNvbXBhcmF0b3JGdW5jcyA9IHt9O1xuY29tcGFyYXRvckZ1bmNzW0RhdGFWYWx1ZS5MVF0gPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdGhpcy5jb21wYXJlVG8oeCkgICA8IDA7IH07XG5jb21wYXJhdG9yRnVuY3NbRGF0YVZhbHVlLkxFXSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0aGlzLmNvbXBhcmVUbyh4KSAgPD0gMDsgfTtcbmNvbXBhcmF0b3JGdW5jc1tEYXRhVmFsdWUuRVFdID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRoaXMuY29tcGFyZVRvKHgpID09PSAwOyB9O1xuY29tcGFyYXRvckZ1bmNzW0RhdGFWYWx1ZS5HRV0gPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdGhpcy5jb21wYXJlVG8oeCkgID49IDA7IH07XG5jb21wYXJhdG9yRnVuY3NbRGF0YVZhbHVlLkdUXSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0aGlzLmNvbXBhcmVUbyh4KSAgID4gMDsgfTtcbmNvbXBhcmF0b3JGdW5jc1tEYXRhVmFsdWUuTkVdID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRoaXMuY29tcGFyZVRvKHgpICE9PSAwOyB9O1xuXG4vKlxuICogTWl4IHRoZSA1IGNvbXBhcmF0b3IgZnVuY3Rpb24gaW50byBhbm90aGVyIG9iamVjdDpcbiAqL1xuRGF0YVZhbHVlLm1peGluQ29tcGFyYXRvcnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgb2JqW0RhdGFWYWx1ZS5MVF0gPSBjb21wYXJhdG9yRnVuY3NbRGF0YVZhbHVlLkxUXTtcbiAgICBvYmpbRGF0YVZhbHVlLkxFXSA9IGNvbXBhcmF0b3JGdW5jc1tEYXRhVmFsdWUuTEVdO1xuICAgIG9ialtEYXRhVmFsdWUuRVFdID0gY29tcGFyYXRvckZ1bmNzW0RhdGFWYWx1ZS5FUV07XG4gICAgb2JqW0RhdGFWYWx1ZS5HRV0gPSBjb21wYXJhdG9yRnVuY3NbRGF0YVZhbHVlLkdFXTtcbiAgICBvYmpbRGF0YVZhbHVlLkdUXSA9IGNvbXBhcmF0b3JGdW5jc1tEYXRhVmFsdWUuR1RdO1xuICAgIG9ialtEYXRhVmFsdWUuTkVdID0gY29tcGFyYXRvckZ1bmNzW0RhdGFWYWx1ZS5ORV07XG59O1xuXG4vKlxuICogVGhlIGNvbXBhcmF0b3JzIGZ1bmN0aW9uIHJldHVybnMgYSBsaXN0IG9mIHRoZSA1IGNvbXBhcmF0b3JcbiAqIGZ1bmN0aW9ucywgdG8gYmUgdXNlZCBsaWtlIGFuIGVudW0gdHlwZS5cbiAqL1xuRGF0YVZhbHVlLmNvbXBhcmF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbIERhdGFWYWx1ZS5MVCwgRGF0YVZhbHVlLkxFLCBEYXRhVmFsdWUuRVEsIERhdGFWYWx1ZS5HRSwgRGF0YVZhbHVlLkdULCBEYXRhVmFsdWUuTkUgXTtcbn07XG5cbi8qXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgY29tcGFyYXRvciBlbnVtIG9iamVjdDpcbiAqL1xuRGF0YVZhbHVlLnBhcnNlQ29tcGFyYXRvciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mKHN0cmluZykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3dpdGNoIChzdHJpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlIFwibHRcIjogcmV0dXJuIERhdGFWYWx1ZS5MVDtcbiAgICAgICAgY2FzZSBcImxlXCI6IHJldHVybiBEYXRhVmFsdWUuTEU7XG4gICAgICAgIGNhc2UgXCJlcVwiOiByZXR1cm4gRGF0YVZhbHVlLkVRO1xuICAgICAgICBjYXNlIFwiZ2VcIjogcmV0dXJuIERhdGFWYWx1ZS5HRTtcbiAgICAgICAgY2FzZSBcImd0XCI6IHJldHVybiBEYXRhVmFsdWUuR1Q7XG4gICAgICAgIGNhc2UgXCJuZVwiOiByZXR1cm4gRGF0YVZhbHVlLk5FO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihzdHJpbmcgKyBcIiBzaG91bGQgYmUgb25lIG9mICdsdCcsICdsZScsICdlcScsICdnZScsICdndCcsICduZScuXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmFsdWU7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBEYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKTtcblxudmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5kYXRhLnZhcmlhYmxlcy52YXJpYWJsZSk7XG5cbnZhciBEYXRhVmFyaWFibGUgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJEYXRhVmFyaWFibGVcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcImlkXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcbiAgICB0aGlzLmhhc0EoXCJjb2x1bW5cIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJ0eXBlXCIpLndoaWNoLmlzT25lT2YoRGF0YVZhbHVlLnR5cGVzKCkpLmFuZC5kZWZhdWx0c1RvKERhdGFWYWx1ZS5OVU1CRVIpO1xuICAgIHRoaXMuaGFzQShcImRhdGFcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgRGF0YSA9IHJlcXVpcmUoJy4vZGF0YS5qcycpO1xuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIERhdGE7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwibWlzc2luZ3ZhbHVlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YVZhbHVlLmlzSW5zdGFuY2UpO1xuXG4gICAgdGhpcy5oYXNBKFwibWlzc2luZ29wXCIpLndoaWNoLmlzT25lT2YoRGF0YVZhbHVlLmNvbXBhcmF0b3JzKCkpO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJpZFwiLCBcIiVjb2x1bW5cIiwgXCIldHlwZVwiKTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5kYXRhLnZhcmlhYmxlcy52YXJpYWJsZSwgYXR0cmlidXRlcyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmFyaWFibGU7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBEYXRhdGlwc1ZhcmlhYmxlID0gcmVxdWlyZSgnLi9kYXRhdGlwc192YXJpYWJsZS5qcycpLFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBEYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKSxcbiAgICBEYXRhRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9kYXRhX2Zvcm1hdHRlci5qcycpLFxuICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90LmRhdGF0aXBzKTtcblxudmFyIERhdGF0aXBzID0gbmV3IGplcm1haW5lLk1vZGVsKFwiRGF0YXRpcHNcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzTWFueShcInZhcmlhYmxlc1wiKS5lYWNoT2ZXaGljaC52YWxpZGF0ZVdpdGgoZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZSBpbnN0YW5jZW9mIERhdGF0aXBzVmFyaWFibGU7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiZm9ybWF0U3RyaW5nXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcbiAgICB0aGlzLmhhc0EoXCJiZ2NvbG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGJnY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGJnY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJiZ2FscGhhXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJib3JkZXJcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJib3JkZXJjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChib3JkZXJjb2xvcikge1xuICAgICAgICByZXR1cm4gYm9yZGVyY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJwYWRcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImZvcm1hdFwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZm9ybWF0dGVkRGF0YSA9IFtdLFxuICAgICAgICAgICAgcmVwbGFjZW1lbnRQYXR0ZXJucyA9IFtdLFxuICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5mb3JtYXRTdHJpbmcoKSxcbiAgICAgICAgICAgIGksIGwgPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWREYXRhLnB1c2godGhpcy52YXJpYWJsZXMoKS5hdChpKS5mb3JtYXR0ZXIoKS5mb3JtYXQoZGF0YVtpXSkpO1xuICAgICAgICAgICAgcmVwbGFjZW1lbnRQYXR0ZXJucy5wdXNoKG5ldyBSZWdFeHAoXCJcXFxce1wiICsgaSArIFwiXFxcXH1cIiwgXCJnXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKHJlcGxhY2VtZW50UGF0dGVybnNbaV0sIGZvcm1hdHRlZERhdGFbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1tcXG58XFxyXS9nLCBcIjxici8+XCIpO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJjb21wdXRlRGltZW5zaW9uc1wiLCBmdW5jdGlvbiAoY29udGVudCwgZWxlbSkge1xuICAgICAgICB2YXIgcGFkZGluZ1dpZHRoICA9IHBhcnNlSW50KGVsZW0uY3NzKFwicGFkZGluZy1sZWZ0XCIpLCAxMCkgKyBwYXJzZUludChlbGVtLmNzcyhcInBhZGRpbmctcmlnaHRcIiksIDEwKSxcbiAgICAgICAgICAgIHBhZGRpbmdIZWlnaHQgPSBwYXJzZUludChlbGVtLmNzcyhcInBhZGRpbmctdG9wXCIpLCAxMCkgICsgcGFyc2VJbnQoZWxlbS5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiKSwgMTApLFxuICAgICAgICAgICAgYm9yZGVyICAgICAgICA9IDIgKiB0aGlzLmJvcmRlcigpO1xuXG4gICAgICAgIGVsZW0uaHRtbChjb250ZW50KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJ3aWR0aFwiICA6IGVsZW0ud2lkdGgoKSAgKyBib3JkZXIgKyBwYWRkaW5nV2lkdGgsXG4gICAgICAgICAgICBcImhlaWdodFwiIDogZWxlbS5oZWlnaHQoKSArIGJvcmRlciArIHBhZGRpbmdIZWlnaHRcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImNvbXB1dGVPcmllbnRhdGlvblwiLCBmdW5jdGlvbiAoZGF0YSwgZ3JhcGhXaWR0aCwgZ3JhcGhIZWlnaHQpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgICAgPSBkYXRhLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICBwaXhlbHAgICAgICAgID0gZGF0YS5waXhlbHAsXG4gICAgICAgICAgICBkYXRhdGlwV2lkdGggID0gZGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICAgIGRhdGF0aXBIZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgICAgIGJhc2VYICAgICAgICAgPSBwaXhlbHBbMF0sXG4gICAgICAgICAgICBiYXNlWSAgICAgICAgID0gcGl4ZWxwWzFdLFxuICAgICAgICAgICAgb2Zmc2V0ICAgICAgICA9IDIwLFxuICAgICAgICAgICAgb2Zmc2V0V2lkdGggICA9IGRhdGF0aXBXaWR0aCAgKyBvZmZzZXQsXG4gICAgICAgICAgICBvZmZzZXRIZWlnaHQgID0gZGF0YXRpcEhlaWdodCArIG9mZnNldDtcblxuICAgICAgICBiYXNlWSA9IGdyYXBoSGVpZ2h0IC0gYmFzZVk7IC8vIHJlbW92ZSB0aGlzIGxpbmUgd2hlbiBiYXNlWSBpcyB0YWtlbiBmcm9tIHRoZSBsb3dlciBsZWZ0IGNvcm5lciBiZWluZyB0aGUgb3JpZ2luXG5cbiAgICAgICAgaWYgKCAvLyBjZW50ZXJcbiAgICAgICAgICAgIGJhc2VYICAgICAgIC0gb2Zmc2V0V2lkdGggID49IDAgJiZcbiAgICAgICAgICAgICAgICBncmFwaFdpZHRoICAtIGJhc2VYICAgICAgICA+PSBvZmZzZXRXaWR0aCAmJlxuICAgICAgICAgICAgICAgIGJhc2VZICAgICAgIC0gb2Zmc2V0SGVpZ2h0ID49IDAgJiZcbiAgICAgICAgICAgICAgICBncmFwaEhlaWdodCAtIGJhc2VZICAgICAgICA+PSBvZmZzZXRIZWlnaHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gW0RhdGF0aXBzLlVQLCBEYXRhdGlwcy5ET1dOLCBEYXRhdGlwcy5SSUdIVCwgRGF0YXRpcHMuTEVGVF07XG4gICAgICAgIH0gZWxzZSBpZiAoIC8vIHRvcFxuICAgICAgICAgICAgYmFzZVggICAgICAgLSBvZmZzZXRXaWR0aCAgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGdyYXBoV2lkdGggIC0gYmFzZVggICAgICAgID49IG9mZnNldFdpZHRoICYmXG4gICAgICAgICAgICAgICAgYmFzZVkgICAgICAgICAgICAgICAgICAgICAgPj0gZ3JhcGhIZWlnaHQgLSBvZmZzZXRIZWlnaHQgJiZcbiAgICAgICAgICAgICAgICBncmFwaEhlaWdodCAgICAgICAgICAgICAgICA+PSBiYXNlWVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBbRGF0YXRpcHMuRE9XTiwgRGF0YXRpcHMuUklHSFQsIERhdGF0aXBzLkxFRlQsIERhdGF0aXBzLlVQXTtcbiAgICAgICAgfSBlbHNlIGlmICggLy8gYm90dG9tXG4gICAgICAgICAgICBiYXNlWCAgICAgIC0gb2Zmc2V0V2lkdGggPj0gMCAmJlxuICAgICAgICAgICAgICAgIGdyYXBoV2lkdGggLSBiYXNlWCAgICAgICA+PSBvZmZzZXRXaWR0aCAmJlxuICAgICAgICAgICAgICAgIG9mZnNldEhlaWdodCAgICAgICAgICAgICA+PSBiYXNlWSAmJlxuICAgICAgICAgICAgICAgIGJhc2VZICAgICAgICAgICAgICAgICAgICA+PSAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIFtEYXRhdGlwcy5VUCwgRGF0YXRpcHMuUklHSFQsIERhdGF0aXBzLkxFRlQsIERhdGF0aXBzLkRPV05dO1xuICAgICAgICB9IGVsc2UgaWYgKCAvLyBsZWZ0XG4gICAgICAgICAgICBiYXNlWCAgICAgICAgICAgICAgICAgICAgICA+PSAwICYmXG4gICAgICAgICAgICAgICAgb2Zmc2V0V2lkdGggICAgICAgICAgICAgICAgPj0gYmFzZVggJiZcbiAgICAgICAgICAgICAgICBiYXNlWSAgICAgICAtIG9mZnNldEhlaWdodCA+PSAwICYmXG4gICAgICAgICAgICAgICAgZ3JhcGhIZWlnaHQgLSBiYXNlWSAgICAgICAgPj0gb2Zmc2V0SGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIFtEYXRhdGlwcy5SSUdIVCwgRGF0YXRpcHMuVVAsIERhdGF0aXBzLkRPV04sIERhdGF0aXBzLkxFRlRdO1xuICAgICAgICB9IGVsc2UgaWYgKCAvLyByaWdodFxuICAgICAgICAgICAgZ3JhcGhXaWR0aCAgICAgICAgICAgICAgICAgPj0gYmFzZVggJiZcbiAgICAgICAgICAgICAgICBvZmZzZXRXaWR0aCAgICAgICAgICAgICAgICA+PSBncmFwaFdpZHRoIC0gYmFzZVggJiZcbiAgICAgICAgICAgICAgICBiYXNlWSAgICAgICAtIG9mZnNldEhlaWdodCA+PSAwICYmXG4gICAgICAgICAgICAgICAgZ3JhcGhIZWlnaHQgLSBiYXNlWSAgICAgICAgPj0gb2Zmc2V0SGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIFtEYXRhdGlwcy5MRUZULCBEYXRhdGlwcy5VUCwgRGF0YXRpcHMuRE9XTiwgRGF0YXRpcHMuUklHSFRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZWZlcmVuY2VzID0gW107XG4gICAgICAgICAgICBpZiAoYmFzZVggPCBncmFwaFdpZHRoIC8gMikgeyAvLyBsZWZ0IHNpZGUgb2YgZ3JhcGhcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVkgPiBncmFwaEhlaWdodCAvIDIpIHsgLy8gdG9wLWxlZnQgY29ybmVyIG9mIGdyYXBoXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlWCAtIGRhdGF0aXBXaWR0aC8yIDwgKGdyYXBoSGVpZ2h0IC0gYmFzZVkpIC0gZGF0YXRpcEhlaWdodC8yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGlzIGxvc3Qgb2ZmIHRoZSBob3Jpem9udGFsIHNpZGUgdGhhbiB0aGUgdmVydGljYWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5SSUdIVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLkRPV04pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgdmVydGljYWwgc2lkZSB0aGFuIHRoZSBob3Jpem9udGFsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuRE9XTik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLlJJR0hUKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVggLSBvZmZzZXRXaWR0aCA8IChncmFwaEhlaWdodCAtIGJhc2VZKSAtIG9mZnNldEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgaG9yaXpvbnRhbCBzaWRlIHRoYW4gdGhlIHZlcnRpY2FsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuVVApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5MRUZUKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgaXMgbG9zdCBvZmYgdGhlIHZlcnRpY2FsIHNpZGUgdGhhbiB0aGUgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLkxFRlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5VUCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBib3R0b20tbGVmdCBjb3JuZXIgb2YgZ3JhcGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VYIC0gZGF0YXRpcFdpZHRoLzIgPCBiYXNlWSAtIGRhdGF0aXBIZWlnaHQvMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgaG9yaXpvbnRhbCBzaWRlIHRoYW4gdGhlIHZlcnRpY2FsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuUklHSFQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5VUCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGlzIGxvc3Qgb2ZmIHRoZSB2ZXJ0aWNhbCBzaWRlIHRoYW4gdGhlIGhvcml6b250YWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5VUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLlJJR0hUKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVggLSBvZmZzZXRXaWR0aCA8IGJhc2VZIC0gb2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGlzIGxvc3Qgb2ZmIHRoZSBob3Jpem9udGFsIHNpZGUgdGhhbiB0aGUgdmVydGljYWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5ET1dOKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuTEVGVCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGlzIGxvc3Qgb2ZmIHRoZSB2ZXJ0aWNhbCBzaWRlIHRoYW4gdGhlIGhvcml6b250YWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5MRUZUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuRE9XTik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyByaWdodCBzaWRlIG9mIGdyYXBoXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VZID4gZ3JhcGhIZWlnaHQgLyAyKSB7IC8vIHRvcC1yaWdodCBjb3JuZXIgb2YgZ3JhcGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKChncmFwaFdpZHRoIC0gYmFzZVgpIC0gZGF0YXRpcFdpZHRoLzIgPCAoZ3JhcGhIZWlnaHQgLSBiYXNlWSkgLSBkYXRhdGlwSGVpZ2h0LzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgaXMgbG9zdCBvZmYgdGhlIGhvcml6b250YWwgc2lkZSB0aGFuIHRoZSB2ZXJ0aWNhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLkxFRlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5ET1dOKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgaXMgbG9zdCBvZmYgdGhlIHZlcnRpY2FsIHNpZGUgdGhhbiB0aGUgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLkRPV04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5MRUZUKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGdyYXBoV2lkdGggLSBiYXNlWCkgLSBvZmZzZXRXaWR0aCA8IChncmFwaEhlaWdodCAtIGJhc2VZKSAtIG9mZnNldEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgaG9yaXpvbnRhbCBzaWRlIHRoYW4gdGhlIHZlcnRpY2FsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuVVApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5SSUdIVCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGlzIGxvc3Qgb2ZmIHRoZSB2ZXJ0aWNhbCBzaWRlIHRoYW4gdGhlIGhvcml6b250YWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5SSUdIVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLlVQKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGJvdHRvbS1yaWdodCBjb3JuZXIgb2YgZ3JhcGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKChncmFwaFdpZHRoIC0gYmFzZVgpIC0gZGF0YXRpcFdpZHRoLzIgPCBiYXNlWSAtIGRhdGF0aXBIZWlnaHQvMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgaG9yaXpvbnRhbCBzaWRlIHRoYW4gdGhlIHZlcnRpY2FsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuTEVGVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLlVQKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgaXMgbG9zdCBvZmYgdGhlIHZlcnRpY2FsIHNpZGUgdGhhbiB0aGUgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLlVQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuTEVGVCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChncmFwaFdpZHRoIC0gYmFzZVgpIC0gb2Zmc2V0V2lkdGggPCBiYXNlWSAtIG9mZnNldFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGlzIGxvc3Qgb2ZmIHRoZSBob3Jpem9udGFsIHNpZGUgdGhhbiB0aGUgdmVydGljYWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5ET1dOKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuUklHSFQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgdmVydGljYWwgc2lkZSB0aGFuIHRoZSBob3Jpem9udGFsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuUklHSFQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5ET1dOKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmVmZXJlbmNlcztcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuICAgIHRoaXMucmVzcG9uZHNUbyhcIm5vcm1hbGl6ZVwiLCBmdW5jdGlvbiAocGxvdCkge1xuICAgICAgICB2YXIgZGF0YXRpcHNWYXJpYWJsZXMgPSB0aGlzLnZhcmlhYmxlcygpLFxuICAgICAgICAgICAgcGxvdFZhcmlhYmxlcyAgICAgPSBwbG90LnZhcmlhYmxlKCksXG4gICAgICAgICAgICB2YXJpYWJsZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGNyZWF0ZXMgbWlzc2luZyB2YXJpYWJsZXMgZm9yIHRoZSBkYXRhdGlwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBpZiAoZGF0YXRpcHNWYXJpYWJsZXMuc2l6ZSgpIDwgcGxvdFZhcmlhYmxlcy5zaXplKCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGRhdGF0aXBzVmFyaWFibGVzLnNpemUoKTsgaSA8IHBsb3RWYXJpYWJsZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhdGlwc1ZhcmlhYmxlcy5hZGQobmV3IERhdGF0aXBzVmFyaWFibGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXRzIHVwIGZvcm1hdHRlcnMgZm9yIGRhdGF0aXBzIHZhcmlhYmxlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGF0aXBzVmFyaWFibGVzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICB2YXJpYWJsZSA9IGRhdGF0aXBzVmFyaWFibGVzLmF0KGkpO1xuICAgICAgICAgICAgdHlwZSA9IHBsb3RWYXJpYWJsZXMuYXQoaSkudHlwZSgpO1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmZvcm1hdFN0cmluZygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gRGF0YVZhbHVlLk5VTUJFUikge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZS5mb3JtYXRTdHJpbmcoZGVmYXVsdFZhbHVlc1tcImZvcm1hdFN0cmluZy1udW1iZXJcIl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlLmZvcm1hdFN0cmluZyhkZWZhdWx0VmFsdWVzW1wiZm9ybWF0U3RyaW5nLWRhdGV0aW1lXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXJpYWJsZS5mb3JtYXR0ZXIoRGF0YUZvcm1hdHRlci5jcmVhdGUodHlwZSwgdmFyaWFibGUuZm9ybWF0U3RyaW5nKCkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMucGxvdC5kYXRhdGlwcywgYXR0cmlidXRlcyk7XG59KTtcblxuRGF0YXRpcHMuVVAgICAgPSBcInVcIjtcbkRhdGF0aXBzLkRPV04gID0gXCJkXCI7XG5EYXRhdGlwcy5MRUZUICA9IFwibFwiO1xuRGF0YXRpcHMuUklHSFQgPSBcInJcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhdGlwcztcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90LmRhdGF0aXBzLnZhcmlhYmxlKSxcbiAgICBEYXRhRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9kYXRhX2Zvcm1hdHRlci5qcycpO1xuXG52YXIgRGF0YXRpcHNWYXJpYWJsZSA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkRhdGF0aXBzVmFyaWFibGVcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcImZvcm1hdFN0cmluZ1wiKS53aGljaC5pc0EoXCJzdHJpbmdcIik7XG4gICAgdGhpcy5oYXNBKFwiZm9ybWF0dGVyXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YUZvcm1hdHRlci5pc0luc3RhbmNlKTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5wbG90LmRhdGF0aXBzLnZhcmlhYmxlLCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGF0aXBzVmFyaWFibGU7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBzcHJpbnRmID0gcmVxdWlyZSgnc3ByaW50ZicpO1xuXG52YXIgRGF0ZXRpbWVGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgdmFyIHRlc3RTdHJpbmc7XG4gICAgaWYgKHR5cGVvZihmb3JtYXQpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1hdCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdFN0cmluZyA9IGZvcm1hdDtcbiAgICB0ZXN0U3RyaW5nID0gRGF0ZXRpbWVGb3JtYXR0ZXIuZm9ybWF0SW50ZXJuYWxseShmb3JtYXQsIG5ldyBEYXRlKDApKTtcbiAgICB0aGlzLmxlbmd0aCA9IHRlc3RTdHJpbmcubGVuZ3RoO1xufTtcblxuRGF0ZXRpbWVGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBEYXRldGltZUZvcm1hdHRlci5mb3JtYXRJbnRlcm5hbGx5KHRoaXMuZm9ybWF0U3RyaW5nLCB2YWx1ZS52YWx1ZSk7XG59O1xuXG5EYXRldGltZUZvcm1hdHRlci5wcm90b3R5cGUuZ2V0TWF4TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbkRhdGV0aW1lRm9ybWF0dGVyLnByb3RvdHlwZS5nZXRGb3JtYXRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0U3RyaW5nO1xufTtcblxuRGF0ZXRpbWVGb3JtYXR0ZXIuZm9ybWF0SW50ZXJuYWxseSA9IGZ1bmN0aW9uIChmb3JtYXRTdHJpbmcsIGRhdGUpIHtcbiAgICB2YXIgZGF5TmFtZXMgPSB7XG4gICAgICAgIFwic2hvcnROYW1lc1wiOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgICAgIFwibG9uZ05hbWVzXCI6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdXG4gICAgfSxcbiAgICAgICAgbW9udGhOYW1lcyA9IHtcbiAgICAgICAgICAgIFwic2hvcnROYW1lc1wiOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG4gICAgICAgICAgICBcImxvbmdOYW1lc1wiOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXVxuICAgICAgICB9LFxuICAgICAgICBzdGF0ZSA9IDAsXG4gICAgICAgIGMsXG4gICAgICAgIGksXG4gICAgICAgIHQsXG4gICAgICAgIG91dHB1dCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZm9ybWF0U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGMgPSBmb3JtYXRTdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChjID09PSBcIiVcIikge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIFwiWVwiOlxuICAgICAgICAgICAgICAgIC8vIGZvdXIgZGlnaXQgeWVhclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAgICAgLy8gdHdvIGRpZ2l0IHllYXJcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAvLyAyLWRpZ2l0IG1vbnRoIG51bWJlciB3aXRoIGxlYWRpbmcgemVyb1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzcHJpbnRmKFwiJTAyc1wiLCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgICAgIC8vIG1vbnRoIG51bWJlciB3aXRob3V0IGxlYWRpbmcgemVyb1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJOXCI6XG4gICAgICAgICAgICAgICAgLy8gbW9udGggbmFtZSwgc3BlbGxlZCBvdXRcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gbW9udGhOYW1lcy5sb25nTmFtZXNbZGF0ZS5nZXRVVENNb250aCgpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgICAgICAgICAgLy8gbW9udGggbmFtZSwgMyBsZXR0ZXIgYWJicmV2aWF0aW9uXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IG1vbnRoTmFtZXMuc2hvcnROYW1lc1tkYXRlLmdldFVUQ01vbnRoKCldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgICAgICAvLyB0d28tZGlnaXQgZGF5IG9mIG1vbnRoIHdpdGggbGVhZGluZyB6ZXJvXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHNwcmludGYoXCIlMDJzXCIsIGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgICAgICAvLyBkYXkgb2YgbW9udGggd2l0aG91dCBsZWFkaW5nIHplcm9cbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZGF0ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSBuYW1lLCBzcGVsbGVkIG91dFxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBkYXlOYW1lcy5sb25nTmFtZXNbZGF0ZS5nZXRVVENEYXkoKV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgbmFtZSwgMy1sZXR0ZXIgYWJicmV2aWF0aW9uXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGRheU5hbWVzLnNob3J0TmFtZXNbZGF0ZS5nZXRVVENEYXkoKV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICAgIC8vIGhvdXIgb2YgZGF5LCAyNCBob3VyIGNsb2NrXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHNwcmludGYoXCIlMDJzXCIsIGRhdGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICAgICAgLy8gaG91ciBvZiBkYXksIDEyIGhvdXIgY2xvY2tcbiAgICAgICAgICAgICAgICB0ID0gZGF0ZS5nZXRVVENIb3VycygpICUgMTI7XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IFwiMTJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpXCI6XG4gICAgICAgICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzcHJpbnRmKFwiJTAyc1wiLCBkYXRlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzcHJpbnRmKFwiJTAyc1wiLCBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgLy8gZGVjaXNlY29uZHMgKDEwdGhzIG9mIGEgc2Vjb25kKVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzcHJpbnRmKFwiJTAzc1wiLCBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCkpLnN1YnN0cigwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgLy8gY2VudGlzZWNvbmRzICgxMDB0aHMgb2YgYSBzZWNvbmQpXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHNwcmludGYoXCIlMDNzXCIsIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKSkuc3Vic3RyKDAsIDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICAgICAgICAvLyBtaWxsaXNlY29uZHMgKDEwMDB0aHMgb2YgYSBzZWNvbmQpXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHNwcmludGYoXCIlMDNzXCIsIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUFwiOlxuICAgICAgICAgICAgICAgIC8vIEFNIG9yIFBNXG4gICAgICAgICAgICAgICAgdCA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICBpZiAodCA8IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBcIkFNXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IFwiUE1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICAgICAgICAgIC8vIGFtIG9yIHBtXG4gICAgICAgICAgICAgICAgdCA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICBpZiAodCA8IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBcImFtXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IFwicG1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgICAgIC8vIG5ld2xpbmVcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgICAgICAgLy8gJVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBcIiVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXIgY29kZSBmb3IgZGF0ZXRpbWUgZm9ybWF0dGluZyBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRldGltZUZvcm1hdHRlcjtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIERhdGV0aW1lVmFsdWUgPSByZXF1aXJlKCcuL2RhdGV0aW1lX3ZhbHVlLmpzJyksXG4gICAgRW51bSA9IHJlcXVpcmUoJy4uL21hdGgvZW51bS5qcycpO1xuXG52YXIgRGF0ZXRpbWVVbml0ID0gcmVxdWlyZSgnLi9kYXRldGltZV91bml0LmpzJyk7XG5cbnZhciBEYXRldGltZU1lYXN1cmUgPSBmdW5jdGlvbiAobWVhc3VyZSwgdW5pdCkge1xuICAgIGlmICh0eXBlb2YobWVhc3VyZSkgIT09IFwibnVtYmVyXCIgfHwgRGF0ZXRpbWVNZWFzdXJlLmlzVW5pdCh1bml0KSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbXByb3BlciBpbnB1dCBmb3IgRGF0ZXRpbWUgTWVhc3VyZSdzIGNvbnN0cnVjdG9yXCIpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRldGltZSBNZWFzdXJlJ3MgY29udHJ1Y3RvciByZXF1aXJlcyBleGFjdGx5IHR3byBhcmd1bWVudHNcIik7XG4gICAgfVxuICAgIHRoaXMubWVhc3VyZSA9IG1lYXN1cmU7XG4gICAgdGhpcy51bml0ICAgID0gdW5pdDtcbn07XG5cbkRhdGV0aW1lTWVhc3VyZS5pc1VuaXQgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIHJldHVybiBEYXRldGltZVVuaXQuaXNJbnN0YW5jZSh1bml0KTtcbn07XG5cbkRhdGV0aW1lTWVhc3VyZS5wcm90b3R5cGUubmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRldGltZU1lYXN1cmUoLXRoaXMubWVhc3VyZSwgdGhpcy51bml0KTtcbn07XG5cbkRhdGV0aW1lTWVhc3VyZS5wcm90b3R5cGUuZ2V0UmVhbFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmYWN0b3I7XG4gICAgc3dpdGNoICh0aGlzLnVuaXQpIHtcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5NSUxMSVNFQ09ORDpcbiAgICAgICAgZmFjdG9yID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuU0VDT05EOlxuICAgICAgICBmYWN0b3IgPSAxMDAwO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5NSU5VVEU6XG4gICAgICAgIGZhY3RvciA9IDYwMDAwO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5IT1VSOlxuICAgICAgICBmYWN0b3IgPSAzNjAwMDAwO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5EQVk6XG4gICAgICAgIGZhY3RvciA9IDg2NDAwMDAwO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5XRUVLOlxuICAgICAgICBmYWN0b3IgPSA2MDQ4MDAwMDA7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0ZXRpbWVVbml0Lk1PTlRIOlxuICAgICAgICBmYWN0b3IgPSAyNTkyMDAwMDAwO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5ZRUFSOlxuICAgICAgICBmYWN0b3IgPSAzMTUzNjAwMDAwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lYXN1cmUgKiBmYWN0b3I7XG59O1xuXG5EYXRldGltZU1lYXN1cmUucGFyc2UgPSBmdW5jdGlvbiAocykge1xuICAgIHZhciByZSwgbWVhc3VyZSwgdW5pdDtcblxuICAgIGlmICh0eXBlb2YocykgIT09IFwic3RyaW5nXCIgfHwgcy5tYXRjaCgvXFxzKi0/KChbMC05XStcXC4/WzAtOV0qKXwoWzAtOV0qXFwuP1swLTldKykpXFxzKihtc3xzfG18SHxEfFd8TXxZKXsxfVxccyokLykgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW1wcm9wZXIgaW5wdXQgZm9yIERhdGV0aW1lIE1lYXN1cmUncyBwYXJzZSBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgcmUgICAgICA9IC9tc3xzfG18SHxEfFd8TXxZLztcbiAgICBtZWFzdXJlID0gcGFyc2VGbG9hdChzLnJlcGxhY2UocmUsIFwiXCIpKTtcbiAgICB1bml0ICAgID0gcy5tYXRjaChyZSk7IC8vIHJldHVybnMgYW4gYXJyYXlcblxuICAgIHVuaXQgPSBEYXRldGltZVVuaXQucGFyc2UodW5pdFswXSk7XG5cbiAgICByZXR1cm4gbmV3IERhdGV0aW1lTWVhc3VyZShtZWFzdXJlLCB1bml0KTtcbn07XG5cbkRhdGV0aW1lTWVhc3VyZS5maW5kVGlja21hcmtXaXRoTWlsbGlzZWNvbmRTcGFjaW5nID0gZnVuY3Rpb24gKC8qbnVtYmVyKG1pbGxpc2Vjb25kcykqL3ZhbHVlLCAvKm51bWJlcihtaWxsaXNlY29uZHMpKi9hbGlnbm1lbnQsIC8qbnVtYmVyKG1pbGxpc2Vjb25kcykqL3NwYWNpbmcpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdmFsdWUgLSBhbGlnbm1lbnQsXG4gICAgICAgIGQgICAgICA9IE1hdGguZmxvb3IoIG9mZnNldCAvIHNwYWNpbmcgKTtcbiAgICBpZiAob2Zmc2V0ICUgc3BhY2luZyAhPT0gMCkge1xuICAgICAgICArK2Q7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZXRpbWVWYWx1ZShhbGlnbm1lbnQgKyBkICogc3BhY2luZyk7XG59O1xuXG5EYXRldGltZU1lYXN1cmUuZmluZFRpY2ttYXJrV2l0aE1vbnRoU3BhY2luZyA9IGZ1bmN0aW9uICgvKkRhdGV0aW1lVmFsdWUqL3ZhbHVlLCAvKkRhdGV0aW1lVmFsdWUqL2FsaWdubWVudCwgLypudW1iZXIobW9udGhzKSovbW9udGhTcGFjaW5nKSB7XG4gICAgdmFyIHZhbHVlRCA9IHZhbHVlLnZhbHVlLCAgICAgICAvL05PVEU6IFwiLnZhbHVlXCIgcHJvcGVydHkgb2YgRGF0ZXRpbWVWYWx1ZSBpcyBhIGphdmFzY3JpcHQgRGF0ZSBvYmplY3RcbiAgICAgICAgYWxpZ25EID0gYWxpZ25tZW50LnZhbHVlLCAgIC8vTk9URTogXCIudmFsdWVcIiBwcm9wZXJ0eSBvZiBEYXRldGltZVZhbHVlIGlzIGEgamF2YXNjcmlwdCBEYXRlIG9iamVjdFxuICAgICAgICBtb250aE9mZnNldCA9IDEyICogKHZhbHVlRC5nZXRVVENGdWxsWWVhcigpIC0gYWxpZ25ELmdldFVUQ0Z1bGxZZWFyKCkpICsgKHZhbHVlRC5nZXRVVENNb250aCgpIC0gYWxpZ25ELmdldFVUQ01vbnRoKCkpLFxuICAgICAgICBkID0gTWF0aC5mbG9vciggbW9udGhPZmZzZXQgLyBtb250aFNwYWNpbmcgKTtcblxuICAgIGlmIChtb250aE9mZnNldCAlIG1vbnRoU3BhY2luZyAhPT0gMCkgeyArK2Q7IH1cbiAgICBlbHNlIGlmICh2YWx1ZUQuZ2V0VVRDRGF0ZSgpID4gYWxpZ25ELmdldFVUQ0RhdGUoKSkgeyArK2Q7IH1cbiAgICBlbHNlIGlmICh2YWx1ZUQuZ2V0VVRDRGF0ZSgpID09PSBhbGlnbkQuZ2V0VVRDRGF0ZSgpICYmIHZhbHVlRC5nZXRVVENIb3VycygpID4gYWxpZ25ELmdldFVUQ0hvdXJzKCkpIHsgKytkOyB9XG4gICAgZWxzZSBpZiAodmFsdWVELmdldFVUQ0RhdGUoKSA9PT0gYWxpZ25ELmdldFVUQ0RhdGUoKSAmJiB2YWx1ZUQuZ2V0VVRDSG91cnMoKSA9PT0gYWxpZ25ELmdldFVUQ0hvdXJzKCkgJiYgdmFsdWVELmdldFVUQ01pbnV0ZXMoKSA+IGFsaWduRC5nZXRVVENNaW51dGVzKCkpIHsgKytkOyB9XG4gICAgZWxzZSBpZiAodmFsdWVELmdldFVUQ0RhdGUoKSA9PT0gYWxpZ25ELmdldFVUQ0RhdGUoKSAmJiB2YWx1ZUQuZ2V0VVRDSG91cnMoKSA9PT0gYWxpZ25ELmdldFVUQ0hvdXJzKCkgJiYgdmFsdWVELmdldFVUQ01pbnV0ZXMoKSA9PT0gYWxpZ25ELmdldFVUQ01pbnV0ZXMoKSAmJiB2YWx1ZUQuZ2V0VVRDU2Vjb25kcygpID4gYWxpZ25ELmdldFVUQ1NlY29uZHMoKSkgeyArK2Q7IH1cbiAgICBlbHNlIGlmICh2YWx1ZUQuZ2V0VVRDRGF0ZSgpID09PSBhbGlnbkQuZ2V0VVRDRGF0ZSgpICYmIHZhbHVlRC5nZXRVVENIb3VycygpID09PSBhbGlnbkQuZ2V0VVRDSG91cnMoKSAmJiB2YWx1ZUQuZ2V0VVRDTWludXRlcygpID09PSBhbGlnbkQuZ2V0VVRDTWludXRlcygpICYmIHZhbHVlRC5nZXRVVENTZWNvbmRzKCkgPT09IGFsaWduRC5nZXRVVENTZWNvbmRzKCkgJiYgdmFsdWVELmdldFVUQ01pbGxpc2Vjb25kcygpID4gYWxpZ25ELmdldFVUQ01pbGxpc2Vjb25kcygpKSB7ICsrZDsgfVxuXG4gICAgcmV0dXJuIGFsaWdubWVudC5hZGQoIERhdGV0aW1lTWVhc3VyZS5wYXJzZSgoZCAqIG1vbnRoU3BhY2luZykgKyBcIk1cIikgKTtcbn07XG5cblxuLyoqXG4gKiBDb25zaWRlciB0aGUgcmVndWxhciBsYXR0aWNlIG9mIHBvaW50cyBvbiB0aGUgRGF0ZXRpbWUgbGluZSBzZXBhcmF0ZWQgZnJvbSBlYWNoIG90aGVyXG4gKiBieSBgdGhpc2AgRGF0ZXRpbWVNZWFzdXJlLCBhbmQgYWxpZ25lZCBhdCB0aGUgRGF0ZXRpbWVWYWx1ZSBgYWxpZ25tZW50YC4gIFRoaXMgZnVuY3Rpb25cbiAqIHJldHVybiB0aGUgc21hbGxlc3QgRGF0ZXRpbWVWYWx1ZSBpbiB0aGF0IGxhdHRpY2Ugd2hpY2ggaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gKiBgdmFsdWVgLlxuICogXG4gKiByZXR1cm46IGEgRGF0ZXRpbWVWYWx1ZVxuICovXG5EYXRldGltZU1lYXN1cmUucHJvdG90eXBlLmZpcnN0U3BhY2luZ0xvY2F0aW9uQXRPckFmdGVyID0gZnVuY3Rpb24gKC8qRGF0ZXRpbWVWYWx1ZSovdmFsdWUsIC8qRGF0ZXRpbWVWYWx1ZSovYWxpZ25tZW50KSAge1xuICAgIHN3aXRjaCAodGhpcy51bml0KSB7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuTU9OVEg6XG4gICAgICAgIHJldHVybiBEYXRldGltZU1lYXN1cmUuZmluZFRpY2ttYXJrV2l0aE1vbnRoU3BhY2luZyh2YWx1ZSwgYWxpZ25tZW50LCB0aGlzLm1lYXN1cmUpO1xuICAgIGNhc2UgRGF0ZXRpbWVVbml0LllFQVI6XG4gICAgICAgIHJldHVybiBEYXRldGltZU1lYXN1cmUuZmluZFRpY2ttYXJrV2l0aE1vbnRoU3BhY2luZyh2YWx1ZSwgYWxpZ25tZW50LCB0aGlzLm1lYXN1cmUgKiAxMik7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIERhdGV0aW1lTWVhc3VyZS5maW5kVGlja21hcmtXaXRoTWlsbGlzZWNvbmRTcGFjaW5nKHZhbHVlLmdldFJlYWxWYWx1ZSgpLCBhbGlnbm1lbnQuZ2V0UmVhbFZhbHVlKCksIHRoaXMuZ2V0UmVhbFZhbHVlKCkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBqdXN0IGxpa2UgYGZpcnN0U3BhY2luZ0xvY2F0aW9uQXRPckFmdGVyYCBhYm92ZSwgYnV0IHJldHVybnMgdGhlXG4gKiBncmVhdGVzdCBEYXRldGltZVZhbHVlIGluIHRoZSBsYXR0aWNlIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gKiBcbiAqIHJldHVybjogYSBEYXRldGltZVZhbHVlXG4gKi9cbkRhdGV0aW1lTWVhc3VyZS5wcm90b3R5cGUubGFzdFNwYWNpbmdMb2NhdGlvbkF0T3JCZWZvcmUgPSBmdW5jdGlvbiAoLypEYXRldGltZVZhbHVlKi92YWx1ZSwgLypEYXRldGltZVZhbHVlKi9hbGlnbm1lbnQpICB7XG4gICAgdmFyIHggPSB0aGlzLmZpcnN0U3BhY2luZ0xvY2F0aW9uQXRPckFmdGVyKHZhbHVlLCBhbGlnbm1lbnQpO1xuICAgIGlmICh4LmVxKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgdmFyIHkgPSB4LmFkZCh0aGlzLm5lZ2F0aXZlKCkpO1xuICAgIHJldHVybiB5O1xufTtcblxuRGF0ZXRpbWVNZWFzdXJlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tZWFzdXJlLnRvU3RyaW5nKCkgKyB0aGlzLnVuaXQudG9TdHJpbmcoKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRldGltZU1lYXN1cmU7XG4iLCJ2YXIgRW51bSA9IHJlcXVpcmUoJy4uL21hdGgvZW51bS5qcycpO1xuXG52YXIgRGF0ZXRpbWVVbml0ID0gbmV3IEVudW0oXCJEYXRldGltZVVuaXRcIik7XG5cbkRhdGV0aW1lVW5pdC5NSUxMSVNFQ09ORCA9IG5ldyBEYXRldGltZVVuaXQoXCJtc1wiKTtcbkRhdGV0aW1lVW5pdC5TRUNPTkQgICAgICA9IG5ldyBEYXRldGltZVVuaXQoXCJzXCIpO1xuRGF0ZXRpbWVVbml0Lk1JTlVURSAgICAgID0gbmV3IERhdGV0aW1lVW5pdChcIm1cIik7XG5EYXRldGltZVVuaXQuSE9VUiAgICAgICAgPSBuZXcgRGF0ZXRpbWVVbml0KFwiSFwiKTtcbkRhdGV0aW1lVW5pdC5EQVkgICAgICAgICA9IG5ldyBEYXRldGltZVVuaXQoXCJEXCIpO1xuRGF0ZXRpbWVVbml0LldFRUsgICAgICAgID0gbmV3IERhdGV0aW1lVW5pdChcIldcIik7XG5EYXRldGltZVVuaXQuTU9OVEggICAgICAgPSBuZXcgRGF0ZXRpbWVVbml0KFwiTVwiKTtcbkRhdGV0aW1lVW5pdC5ZRUFSICAgICAgICA9IG5ldyBEYXRldGltZVVuaXQoXCJZXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGV0aW1lVW5pdDtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpLFxuICAgIERhdGV0aW1lVW5pdCA9IHJlcXVpcmUoJy4vZGF0ZXRpbWVfdW5pdC5qcycpLFxuICAgIHNwcmludGYgPSByZXF1aXJlKCdzcHJpbnRmJyk7XG5cbnZhciBEYXRldGltZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0ZXRpbWVWYWx1ZSByZXF1aXJlcyBpdHMgcGFyYW1ldGVyIHRvIGJlIGEgbnVtYmVyXCIpO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xufTtcblxuRGF0ZXRpbWVWYWx1ZS5wcm90b3R5cGUuZ2V0UmVhbFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmdldFRpbWUoKTtcbn07XG5cbkRhdGV0aW1lVmFsdWUucHJvdG90eXBlLnR5cGUgPSBEYXRhVmFsdWUuREFURVRJTUU7XG5cbkRhdGV0aW1lVmFsdWUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRldGltZVZhbHVlKHRoaXMuZ2V0UmVhbFZhbHVlKCkpO1xufTtcblxuRGF0ZXRpbWVWYWx1ZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICB2YXIgWSA9IDAsXG4gICAgICAgIE0gPSAwLFxuICAgICAgICBEID0gMSxcbiAgICAgICAgSCA9IDAsXG4gICAgICAgIG0gPSAwLFxuICAgICAgICBzID0gMCxcbiAgICAgICAgbXMgPSAwO1xuICAgIGlmICh0eXBlb2Yoc3RyaW5nKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvW1xcLlxcLVxcOlxcc10vZywgXCJcIik7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICBZID0gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgICAgWSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMCw0KSwgMTApO1xuICAgICAgICAgICAgTSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoNCw2KSwgMTApIC0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcubGVuZ3RoID09PSA4KSB7XG4gICAgICAgICAgICBZID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZygwLDQpLCAxMCk7XG4gICAgICAgICAgICBNID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZyg0LDYpLCAxMCkgLSAxO1xuICAgICAgICAgICAgRCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoNiw4KSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgICAgICBZID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZygwLDQpLCAxMCk7XG4gICAgICAgICAgICBNID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZyg0LDYpLCAxMCkgLSAxO1xuICAgICAgICAgICAgRCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoNiw4KSwgMTApO1xuICAgICAgICAgICAgSCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoOCwxMCksIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcubGVuZ3RoID09PSAxMikge1xuICAgICAgICAgICAgWSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMCw0KSwgMTApO1xuICAgICAgICAgICAgTSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoNCw2KSwgMTApIC0gMTtcbiAgICAgICAgICAgIEQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDYsOCksIDEwKTtcbiAgICAgICAgICAgIEggPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDgsMTApLCAxMCk7XG4gICAgICAgICAgICBtID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZygxMCwxMiksIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcubGVuZ3RoID09PSAxNCkge1xuICAgICAgICAgICAgWSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMCw0KSwgMTApO1xuICAgICAgICAgICAgTSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoNCw2KSwgMTApIC0gMTtcbiAgICAgICAgICAgIEQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDYsOCksIDEwKTtcbiAgICAgICAgICAgIEggPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDgsMTApLCAxMCk7XG4gICAgICAgICAgICBtID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZygxMCwxMiksIDEwKTtcbiAgICAgICAgICAgIHMgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDEyLDE0KSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZy5sZW5ndGggPT09IDE1IHx8IHN0cmluZy5sZW5ndGggPT09IDE2IHx8IHN0cmluZy5sZW5ndGggPT09IDE3KSB7XG4gICAgICAgICAgICBZICA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMCw0KSwgMTApO1xuICAgICAgICAgICAgTSAgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDQsNiksIDEwKSAtIDE7XG4gICAgICAgICAgICBEICA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoNiw4KSwgMTApO1xuICAgICAgICAgICAgSCAgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDgsMTApLCAxMCk7XG4gICAgICAgICAgICBtICA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMTAsMTIpLCAxMCk7XG4gICAgICAgICAgICBzICA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMTIsMTQpLCAxMCk7XG4gICAgICAgICAgICBtcyA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMTQsMTcpLCAxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nID09PSBcIjBcIikge1xuICAgICAgICAgICAgLy8gaGFuZGxlcyB0aGUgY2FzZSBvZiBcIjBcIiwgd2hpY2ggcGFyc2VyIHNob3VsZCBjb252ZXJ0IHRvIHRoZSBVbml4IGVwb2NoXG4gICAgICAgICAgICBZID0gMTk3MDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBpbnB1dCBmb3JtYXQgZm9yIERhdGV0aW1lIFZhbHVlJ3MgcGFyc2UgbWV0aG9kOlwiICsgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGV0aW1lIFZhbHVlJ3MgcGFyc2UgbWV0aG9kIHJlcXVpcmVzIGl0cyBwYXJhbWV0ZXIgdG8gYmUgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZXRpbWVWYWx1ZShEYXRlLlVUQyhZLCBNLCBELCBILCBtLCBzLCBtcykpO1xufTtcblxuXG5EYXRldGltZVZhbHVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgWSwgTSwgRCwgSCwgbSwgcywgbXM7XG5cbiAgICBZICA9IHNwcmludGYoXCIlMDRzXCIsIHRoaXMudmFsdWUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpKTtcbiAgICBNICA9IHNwcmludGYoXCIlMDJzXCIsICh0aGlzLnZhbHVlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpKTtcbiAgICBEICA9IHNwcmludGYoXCIlMDJzXCIsIHRoaXMudmFsdWUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgIEggID0gc3ByaW50ZihcIiUwMnNcIiwgdGhpcy52YWx1ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkpO1xuICAgIG0gID0gc3ByaW50ZihcIiUwMnNcIiwgdGhpcy52YWx1ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKSk7XG4gICAgcyAgPSBzcHJpbnRmKFwiJTAyc1wiLCB0aGlzLnZhbHVlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpKTtcbiAgICBtcyA9IFwiLlwiICsgc3ByaW50ZihcIiUwM3NcIiwgdGhpcy52YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKS50b1N0cmluZygpKTtcblxuICAgIGlmIChtcyA9PT0gXCIuMDAwXCIpIHtcbiAgICAgICAgbXMgPSBcIlwiO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gWSArIE0gKyBEICsgSCArIG0gKyBzICsgbXM7XG59O1xuXG5cbkRhdGV0aW1lVmFsdWUucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHRoaXMuZ2V0UmVhbFZhbHVlKCkgPCB4LmdldFJlYWxWYWx1ZSgpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0UmVhbFZhbHVlKCkgPiB4LmdldFJlYWxWYWx1ZSgpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbkRhdGV0aW1lVmFsdWUucHJvdG90eXBlLmFkZFJlYWxWYWx1ZSA9IGZ1bmN0aW9uICggcmVhbFZhbHVlSW5jciApIHtcbiAgICByZXR1cm4gbmV3IERhdGV0aW1lVmFsdWUodGhpcy52YWx1ZS5nZXRUaW1lKCkgKyByZWFsVmFsdWVJbmNyKTtcbn07XG5cbkRhdGV0aW1lVmFsdWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggLypEYXRhTWVhc3VyZSovIG1lYXN1cmUpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRldGltZVZhbHVlKHRoaXMuZ2V0UmVhbFZhbHVlKCkpO1xuICAgIHN3aXRjaCAobWVhc3VyZS51bml0KSB7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuTUlMTElTRUNPTkQ6XG4gICAgICAgIGRhdGUudmFsdWUuc2V0VVRDTWlsbGlzZWNvbmRzKGRhdGUudmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgKyBtZWFzdXJlLm1lYXN1cmUpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5TRUNPTkQ6XG4gICAgICAgIGRhdGUudmFsdWUuc2V0VVRDU2Vjb25kcyhkYXRlLnZhbHVlLmdldFVUQ1NlY29uZHMoKSArIG1lYXN1cmUubWVhc3VyZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0ZXRpbWVVbml0Lk1JTlVURTpcbiAgICAgICAgZGF0ZS52YWx1ZS5zZXRVVENNaW51dGVzKGRhdGUudmFsdWUuZ2V0VVRDTWludXRlcygpICsgbWVhc3VyZS5tZWFzdXJlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuSE9VUjpcbiAgICAgICAgZGF0ZS52YWx1ZS5zZXRVVENIb3VycyhkYXRlLnZhbHVlLmdldFVUQ0hvdXJzKCkgKyBtZWFzdXJlLm1lYXN1cmUpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5EQVk6XG4gICAgICAgIGRhdGUudmFsdWUuc2V0VVRDRGF0ZShkYXRlLnZhbHVlLmdldFVUQ0RhdGUoKSArIG1lYXN1cmUubWVhc3VyZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0ZXRpbWVVbml0LldFRUs6XG4gICAgICAgIGRhdGUudmFsdWUuc2V0VVRDRGF0ZShkYXRlLnZhbHVlLmdldFVUQ0RhdGUoKSArIG1lYXN1cmUubWVhc3VyZSAqIDcpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5NT05USDpcbiAgICAgICAgZGF0ZS52YWx1ZS5zZXRVVENNb250aChkYXRlLnZhbHVlLmdldFVUQ01vbnRoKCkgKyBtZWFzdXJlLm1lYXN1cmUpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5ZRUFSOlxuICAgICAgICBkYXRlLnZhbHVlLnNldFVUQ0Z1bGxZZWFyKGRhdGUudmFsdWUuZ2V0VVRDRnVsbFllYXIoKSArIG1lYXN1cmUubWVhc3VyZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn07XG5cbkRhdGFWYWx1ZS5taXhpbkNvbXBhcmF0b3JzKERhdGV0aW1lVmFsdWUucHJvdG90eXBlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRldGltZVZhbHVlO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG4vKipcbiAqIEV2ZW50RW1pdHRlciBpcyBhIEplcm1haW5lIG1vZGVsIHRoYXQgc3VwcG9ydHMgYmFzaWMgZXZlbnQgZW1pdHRpbmcgL1xuICogaGFuZGxpbmcgZm9yIEplcm1haW5lIG9iamVjdHMuXG4gKlxuICogRXZlbnRzIGFyZSByZXByZXNlbnRlZCBhcyBwbGFpbiBvbGQgSmF2YVNjcmlwdCBvYmplY3RzIHdpdGggYXQgbGVhc3RcbiAqIHRoZSBmb2xsb3dpbmcgdHdvIHByb3BlcnRpZXM6XG4gKlxuICogICAqKnR5cGUqKlxuICpcbiAqICAgPiBhIHN0cmluZyBnaXZpbmcgdGhlIHR5cGUgb2YgdGhlIGV2ZW50OyB0aGlzIGNhbiBiZSBhbnlcbiAqICAgICBhcmJpdHJhcnkgc3RyaW5nLiAgVGhlIGV2ZW50IHR5cGUgaXMgbm90IHJlc3RyaWN0ZWQgdG8gYmVcbiAqICAgICBmcm9tIHNvbWUgcHJlZGV0ZXJtaW5lZCBsaXN0OyBhcHBsaWNhdGlvbnMgYXJlIGZyZWUgdG9cbiAqICAgICB1c2Ugd2hhdGV2ZXIgc3RyaW5ncyB0aGV5IHdhbnQgZm9yIHRoZWlyIGV2ZW50IHR5cGVzLlxuICpcbiAqICAgKip0YXJnZXQqKlxuICpcbiAqICAgPiBhIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IHRoYXQgZW1pdHRlZCB0aGUgZXZlbnRcbiAqXG4gKiBFdmVudCBvYmplY3RzIG1heSBhbHNvIGNvbnRhaW4gYXJiaXRyYXJ5IG90aGVyIHByb3BlcnRpZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG9cbiAqIGEgcGFydGljdWxhciBldmVudCB0eXBlLlxuICpcbiAqIEFueSBKZXJtYWluZSBtb2RlbCBjYW4gZGVjbGFyZSBpdHNlbGYgdG8gYmUgYW4gZXZlbnQgZW1pdHRlciBieSBzYXlpbmdcbiAqIFwidGhpcy5pc0EoRXZlbnRFbWl0dGVyKVwiIGluIGl0cyBtb2RlbCBkZWNsYXJhdGlvbi5cbiAqXG4gKiBUaGlzIGFkZHMgdGhyZWUgbWV0aG9kcyB0byB0aGUgbW9kZWw6XG4gKiAgXG4gKiAgICoqYWRkTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lckZ1bmN0aW9uKSoqXG4gKlxuICogICA+IFJlZ2lzdGVycyBsaXN0ZW5lckZ1bmN0aW9uIGFzIGEgbGlzdGVuZXIgZm9yIGV2ZW50cyBvZiB0eXBlXG4gKiAgICAgZXZlbnRUeXBlIChhIHN0cmluZykuICBsaXN0ZW5lckZ1bmN0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uXG4gKiAgICAgdGhhdCBhY2NlcHRzIGEgc2luZ2xlIGFyZ3VtZW50IHdoaWNoIHdpbGwgYmUgYSByZWZlcmVuY2UgdG8gYW5cbiAqICAgICBldmVudCBvYmplY3QgYXMgZGVzY3JpYmVkIGFib3ZlLiAgV2hlbiB0aGUgb2JqZWN0IGVtaXRzIHRoZVxuICogICAgIGV2ZW50LCB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGluIHRoZSBjb250ZXh0XG4gKiAgICAgd2hlcmUgaXRzIFwidGhpc1wiIGtleXdvcmQgcmVmZXJzIHRvIHRoZSBvYmplY3QgdGhhdCBlbWl0dGVkIHRoZVxuICogICAgIGV2ZW50ICh0aGUgZXZlbnQgdGFyZ2V0KS4gIElmIGxpc3RlbmVyRnVuY3Rpb24gaXMgYWxyZWFkeVxuICogICAgIHJlZ2lzdGVyZWQgYXMgYSBsaXN0ZW5lciBmb3IgZXZlbnRUeXBlLCB0aGlzIGZ1bmN0aW9uIGRvZXNcbiAqICAgICBub3RoaW5nIC0tLSBlYWNoIGxpc3RlbmVyIGZ1bmN0aW9uIGNhbiBiZSByZWdpc3RlcmVkIG9ubHkgb25jZS5cbiAqXG4gKiAgICoqcmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lckZ1bmN0aW9uKSoqXG4gKlxuICogICA+IFJlbW92ZXMgdGhlIGdpdmVuIGxpc3RlbmVyRnVuY3Rpb24gZnJvbSB0aGUgbGlzdCBvZiBsaXN0ZW5lcnNcbiAqICAgICBmb3IgdGhpcyBvYmplY3QgZm9yIGV2ZW50cyBvZiB0eXBlIGV2ZW50VHlwZS5cbiAqXG4gKiAgICoqZW1pdChldmVudCkqKlxuICpcbiAqICAgPiBDYXVzZXMgdGhlIG9iamVjdCB0byBlbWl0IHRoZSBnaXZlbiBldmVudC4gIFRoZSBhcmd1bWVudCBjYW4gYmVcbiAqICAgICBlaXRoZXIgYSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgaXQgaXMgYXNzdW1lZCB0byBiZSBhbiBldmVudCB0eXBlXG4gKiAgICAgYW5kIGlzIGNvbnZlcnRlZCB0byBhbiBldmVudCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gJ3R5cGUnXG4gKiAgICAgcHJvcGVydHksIG9yIGFuIGV2ZW50IG9iamVjdCB3aXRoIGEgJ3R5cGUnIHByb3BlcnR5IGFuZCBhbnlcbiAqICAgICBvdGhlciBkZXNpcmVkIHByb3BlcnRpZXMuICBUaGUgZW1pdCgpIG1ldGhvZCBhdXRvbWF0aWNhbGx5IGFkZHNcbiAqICAgICBhICd0YXJnZXQnIHByb3BlcnR5IHRvIHRoZSBldmVudCBvYmplY3QsIHdob3NlIHZhbHVlIGlzIGFcbiAqICAgICByZWZlcmVuY2UgdG8gdGhlIG9iamVjdCBlbWl0dGluZyB0aGUgZXZlbnQuXG4gKlxuICogSW4gbW9zdCBjYXNlcyB0aGUgZW1pdCgpIG1ldGhvZCBpcyBvbmx5IGNhbGxlZCBmcm9tIHdpdGhpbiB0aGVcbiAqIGltcGxlbWVudGF0aW9uIG9mIGFuIEV2ZW50RW1pdHRlciBvYmplY3QsIGFuZCBjb2RlIGV4dGVybmFsIHRvIHRoZVxuICogb2JqZWN0J3MgbW9kZWwgd2lsbCB1c2UgaXRzIGFkZExpc3RlbmVyKCkgYW5kIHJlbW92ZUxpc3RlbmVyKCkgbWV0aG9kc1xuICogdG8gcHJvY2VzcyBldmVudHMgdGhhdCB0aGUgb2JqZWN0IGVtaXRzLiAgQWxsIHRocmVlIG9mIHRoZXNlIG1ldGhvZHNcbiAqIGFyZSBwdWJsaWMgbWV0aG9kcywgdGhvdWdoLCBzbyBpdCdzIGFsc28gcG9zc2libGUgZm9yIGNvZGUgb3V0c2lkZSBvZlxuICogYW4gb2JqZWN0J3MgaW1wbGVtZW50YXRpb24gdG8gY2F1c2UgaXQgdG8gZW1pdCBhbiBldmVudCwgb3IgZm9yIHRoZVxuICogb2JqZWN0J3Mgb3duIGNvZGUgdG8gbGlzdGVuIGZvciBhbmQgcHJvY2VzcyBpdHMgb3duIGV2ZW50cy5cbiAqXG4gKiBUd28gc3BlY2lhbCB0eXBlcyBvZiBldmVudHMgYXJlIGFsd2F5cyBwcmVzZW50IGZvciBldmVyeSBFdmVudEVtaXR0ZXJcbiAqIG9iamVjdDogdGhlIFwibGlzdGVuZXJBZGRlZFwiIGFuZCBcImxpc3RlbmVyUmVtb3ZlZFwiIGV2ZW50cy4gIFRoZXNlXG4gKiBldmVudHMgbWFrZSBpdCBwb3NzaWJsZSB0byBtb25pdG9yIHRoZSBhZGRpdGlvbiBvciByZW1vdmFsIG9mIGV2ZW50XG4gKiBsaXN0ZW5lcnMuICBUaGUgXCJsaXN0ZW5lckFkZGVkXCIgZXZlbnQgaXMgZW1pdHRlZCB3aGVuZXZlciBhIG5ld1xuICogbGlzdGVuZXIgZnVuY3Rpb24gaXMgYWRkZWQsIGFuZCB0aGUgXCJsaXN0ZW5lclJlbW92ZWRcIiBldmVudCBpcyBlbWl0dGVkXG4gKiB3aGVuZXZlciBhIGxpc3RlbmVyIGlzIHJlbW92ZWQuICBFYWNoIG9mIHRoZXNlIGV2ZW50cyBjb250YWluIHRoZVxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAqKnRhcmdldFR5cGUqKlxuICpcbiAqICAgPiB0aGUgZXZlbnQgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGxpc3RlbmVyXG4gKiAgICAgYmVpbmcgYWRkZWQgb3IgcmVtb3ZlZFxuICpcbiAqICAgKipsaXN0ZW5lcioqXG4gKlxuICogICA+IHRoZSBsaXN0ZW5lciBmdW5jdGlvbiBiZWluZyBhZGRlZCBvciByZW1vdmVkXG4gKlxuICogQGNsYXNzIEV2ZW50RW1pdHRlclxuICogQGZvciBFdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgUGVyc29uID0gbmV3IGplcm1haW5lLk1vZGVsKGZ1bmN0aW9uKCkge1xuICogICAgICAgICB0aGlzLmlzQShFdmVudEVtaXR0ZXIpO1xuICogICAgICAgICB0aGlzLmhhc0EoXCJuYW1lXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcbiAqICAgICAgICAgdGhpcy5yZXNwb25kc1RvKFwic2F5XCIsIGZ1bmN0aW9uKHNvbWV0aGluZykge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5uYW1lKCkgKyAnIHNheXMgJyArIHNvbWV0aGluZyk7XG4gKiAgICAgICAgICAgICB0aGlzLmVtaXQoe3R5cGUgOiBcInNheVwiLCBtZXNzYWdlIDogc29tZXRoaW5nfSk7XG4gKiAgICAgICAgIH0pO1xuICogICAgIH0pO1xuICogICAgIHZhciBwZXJzb24gPSBuZXcgUGVyc29uKCkubmFtZShcIk1hcmtcIik7XG4gKlxuICogICAgIHZhciBzYXlMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldC5uYW1lKCkgKyAnIHNhaWQgJyArIGV2ZW50Lm1lc3NhZ2UpO1xuICogICAgIH07XG4gKlxuICogICAgIHBlcnNvbi5zYXkoJ0hlbGxvJyk7XG4gKiAgICAgcGVyc29uLmFkZExpc3RlbmVyKFwic2F5XCIsIHNheUxpc3RlbmVyKTtcbiAqICAgICBwZXJzb24uc2F5KCdBbHJpZ2h0Jyk7XG4gKiAgICAgcGVyc29uLnJlbW92ZUxpc3RlbmVyKFwic2F5XCIsIHNheUxpc3RlbmVyKTtcbiAqICAgICBwZXJzb24uc2F5KCdHb29kYnllJyk7XG4gKlxuICpcbiAqICAgICBPVVRQVVQ6XG4gKlxuICogICAgICAgICBNYXJrIHNheXMgSGVsbG9cbiAqICAgICAgICAgTWFyayBzYXlzIEFscmlnaHRcbiAqICAgICAgICAgTWFyayBzYWlkIEFscmlnaHRcbiAqICAgICAgICAgTWFyayBzYWlkIEdvb2RieWVcbiAqL1xudmFyIEV2ZW50RW1pdHRlciA9IG5ldyBqZXJtYWluZS5Nb2RlbChmdW5jdGlvbiAoKSB7XG4gICAgLy8gbGlzdGVuZXJzIGlzIGEgcGxhaW4gb2xkIEpTIG9iamVjdCB3aG9zZSBrZXlzIGFyZSBldmVudHNcbiAgICAvLyB0eXBlcyAoc3RyaW5ncyk7IHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggZWFjaCBrZXkgaXMgdGhlXG4gICAgLy8gbGlzdCBvZiByZWdpc3RlcmVkIGxpc3RlbmVyIGZ1bmN0aW9ucyBmb3IgdGhhdCBldmVudCB0eXBlLlxuICAgIHRoaXMuaGFzQShcImxpc3RlbmVyc1wiKS53aGljaC5kZWZhdWx0c1RvKCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXNlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVtcHR5IG9iamVjdCBhcyB0aGVcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZSwgc28gd2UgZ2V0IGEgbmV3IGxpc3RlbmVycyBvYmplY3RcbiAgICAgICAgLy8gY3JlYXRlZCBmb3IgZWFjaCBFdmVudEVtaXR0ZXIgaW5zdGFuY2UuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiBmb3IgZXZlbnRzIG9mIGEgc3BlY2lmaWMgdHlwZVxuICAgICAqIGVtaXR0ZWQgYnkgdGhpcyBvYmplY3QuXG4gICAgICogXG4gICAgICogQG1ldGhvZCBhZGRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgdGhlIHR5cGUgb2YgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBhIGxpc3RlbmVyIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGxpc3RlbmVyXG4gICAgICogICAgICAgICB3YXMgYWN0dWFsbHkgYWRkZWQgKGEgbGlzdGVuZXIgaXMgbm90IGFkZGVkIGlmIGl0XG4gICAgICogICAgICAgICBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIHRoZSBldmVudFR5cGUpXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiYWRkTGlzdGVuZXJcIiwgZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKCksXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnNbZXZlbnRUeXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRUeXBlXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaT0wOyBpPGxpc3RlbmVyc1tldmVudFR5cGVdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2V2ZW50VHlwZV1baV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVyc1tldmVudFR5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmVtaXQoeyB0eXBlICAgICAgIDogXCJsaXN0ZW5lckFkZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFR5cGUgOiBldmVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyICAgOiBsaXN0ZW5lcn0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmdW5jdGlvbiBmb3IgZXZlbnRzIG9mIGEgc3BlY2lmaWMgdHlwZVxuICAgICAqIGVtaXR0ZWQgYnkgdGhpcyBvYmplY3QuXG4gICAgICogXG4gICAgICogQG1ldGhvZCByZW1vdmVMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgdGhlIHR5cGUgb2YgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGxpc3RlbmVyXG4gICAgICogICAgICAgICB3YXMgYWN0dWFsbHkgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZW1vdmVMaXN0ZW5lclwiLCBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMoKSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyc1tldmVudFR5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGxpc3RlbmVyc1tldmVudFR5cGVdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tldmVudFR5cGVdW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRUeXBlXVtpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh7IHR5cGUgICAgICAgOiBcImxpc3RlbmVyUmVtb3ZlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRUeXBlIDogZXZlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciAgIDogbGlzdGVuZXJ9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyBvYmplY3RzIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBldmVudC4gIElmIHRoZSBcImV2ZW50XCJcbiAgICAgKiBhcmd1bWVudCBpcyBhIHN0cmluZywgaXQgaXMgY29udmVydGVkIHRvIGFuIE9iamVjdCBoYXZpbmdcbiAgICAgKiB0aGF0IHN0cmluZyBhcyB0aGUgdmFsdWUgb2YgaXRzIFwidHlwZVwiIGF0dHJpYnV0ZTsgb3RoZXJ3aXNlXG4gICAgICogdGhlIFwiZXZlbnRcIiBhcmd1bWVudCBzaG91bGQgYmUgYW4gZXZlbnQgT2JqZWN0IGhhdmluZyBhXG4gICAgICogXCJ0eXBlXCIgYXR0cmlidXRlIGFuZCBhbnkgb3RoZXIgYXR0cmlidXRlcyBhcHByb3JpYXRlIGZvclxuICAgICAqIHRoYXQgZXZlbnQgdHlwZS4gIEluIGVpdGhlciBjYXNlLCBhbGwgKGlmIHRoZXJlIGFyZSBhbnkpIG9mXG4gICAgICogdGhlIGN1cnJlbnQgbGlzdGVuZXJzIG9uIHRoaXMgb2JqZWN0IGZvciBldmVudHMgb2YgdGhlXG4gICAgICogZ2l2ZW4gdHlwZSB3aWxsIGJlIGludm9rZWQsIGJlaW5nIHBhc3NlZCBhbiBldmVudCBvYmplY3QuXG4gICAgICogXG4gICAgICogQG1ldGhvZCBlbWl0XG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBldmVudCBlaXRoZXIgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV2ZW50IHR5cGUsIG9yIGFuIGV2ZW50XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Qgd2l0aCBhICd0eXBlJyBhdHRyaWJ1dGUuXG4gICAgICogQHJldHVybiAobm90aGluZylcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJlbWl0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG51bGxzID0gW107XG5cbiAgICAgICAgaWYgKHR5cGVvZihldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50ID0geyB0eXBlIDogZXZlbnQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG9iamVjdCBtaXNzaW5nICd0eXBlJyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKClbZXZlbnQudHlwZV07XG5cbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIC8vIG5vIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50IHR5cGVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGwgYWxsIHRoZSBsaXN0ZW5lcnMgZm9yIHRoaXMgZXZlbnQgdHlwZSwgZXhjZXB0IGZvclxuICAgICAgICAvLyBudWxscywgd2hpY2ggd2Uga2VlcCB0cmFjayBvZlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBudWxscy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFueSBudWxscyBmcm9tIHRoZSBsaXN0ZW5lcnMgbGlzdDsgd29yayBmcm9tIHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIGxpc3QgYmFja3dhcmRzIHNvIHRoYXQgcmVtb3ZpbmcgYW4gaXRlbSBkb2Vzbid0IGNoYW5nZVxuICAgICAgICAvLyB0aGUgaW5kZXggb2Ygb3RoZXIgaXRlbXMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICBpZiAobnVsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpPW51bGxzLmxlbmd0aC0xOyBpPj0wOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKG51bGxzW2ldLDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBGaWx0ZXJPcHRpb24gPSByZXF1aXJlKCcuL2ZpbHRlcl9vcHRpb24uanMnKTtcblxudmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90LmZpbHRlcik7XG5cbnZhciBGaWx0ZXIgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJGaWx0ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzTWFueShcIm9wdGlvbnNcIikuZWFjaE9mV2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBvcHRpb24gaW5zdGFuY2VvZiBGaWx0ZXJPcHRpb247XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwidHlwZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YodHlwZSkgPT09IFwic3RyaW5nXCI7XG4gICAgfSk7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMucGxvdC5maWx0ZXIsIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLnBsb3QuZmlsdGVyLm9wdGlvbik7XG5cbnZhciBGaWx0ZXJPcHRpb24gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJGaWx0ZXJPcHRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcIm5hbWVcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKG5hbWUpID09PSBcInN0cmluZ1wiO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcInZhbHVlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiO1xuICAgIH0pO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLnBsb3QuZmlsdGVyLm9wdGlvbiwgYXR0cmlidXRlcyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJPcHRpb247XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBBeGlzID0gcmVxdWlyZSgnLi9heGlzLmpzJyksXG4gICAgQmFja2dyb3VuZCA9IHJlcXVpcmUoJy4vYmFja2dyb3VuZC5qcycpLFxuICAgIERhdGEgPSByZXF1aXJlKCcuL2RhdGEuanMnKSxcbiAgICBMZWdlbmQgPSByZXF1aXJlKCcuL2xlZ2VuZC5qcycpLFxuICAgIFBsb3QgPSByZXF1aXJlKCcuL3Bsb3QuanMnKSxcbiAgICBQbG90YXJlYSA9IHJlcXVpcmUoJy4vcGxvdGFyZWEuanMnKSxcbiAgICBUaXRsZSA9IHJlcXVpcmUoJy4vdGl0bGUuanMnKSxcbiAgICBXaW5kb3cgPSByZXF1aXJlKCcuL3dpbmRvdy5qcycpLFxuICAgIEJveCA9IHJlcXVpcmUoJy4uL21hdGgvYm94LmpzJyksXG4gICAgRGF0YVBsb3QgPSByZXF1aXJlKCcuLi9jb3JlL2RhdGFfcGxvdC5qcycpLFxuICAgIEF4aXNCaW5kaW5nID0gcmVxdWlyZSgnLi4vY29yZS9heGlzX2JpbmRpbmcuanMnKSxcbiAgICB2YXJhaWJsZV9pZF9yZWdleCA9IC9eKFteXFwuXSspXFwuKC4rKSQvO1xuXG5cbi8qKlxuICogVGhlIEdyYXBoIEplcm1haW5lIG1vZGVsIGNvbnRyb2xzIHRoZSBwcm9wZXJ0aWVzIGZvciBhbiBpbmRpdmlkdWFsIEdyYXBoLlxuICpcbiAqIEBjbGFzcyBHcmFwaFxuICogQGZvciBHcmFwaFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMpO1xuXG52YXIgR3JhcGggPSBuZXcgamVybWFpbmUuTW9kZWwoXCJHcmFwaFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ2hpbGQgbW9kZWwgd2hpY2ggY29udHJvbHMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIEdyYXBoJ3MgV2luZG93LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdpbmRvd1xuICAgICAqIEB0eXBlIHtXaW5kb3d9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcIndpbmRvd1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgIHJldHVybiB3IGluc3RhbmNlb2YgV2luZG93O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENoaWxkIG1vZGVsIHdoaWNoIGNvbnRyb2xzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBHcmFwaCdzIFBsb3RhcmVhLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBsb3RhcmVhXG4gICAgICogQHR5cGUge1Bsb3RhcmVhfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJwbG90YXJlYVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChwbG90YXJlYSkge1xuICAgICAgICByZXR1cm4gcGxvdGFyZWEgaW5zdGFuY2VvZiBQbG90YXJlYTtcbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogQ2hpbGQgbW9kZWwgd2hpY2ggY29udHJvbHMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIEdyYXBoJ3MgTGVnZW5kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxlZ2VuZFxuICAgICAqIEB0eXBlIHtMZWdlbmR9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImxlZ2VuZFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChsZWdlbmQpIHtcbiAgICAgICAgcmV0dXJuIGxlZ2VuZCBpbnN0YW5jZW9mIExlZ2VuZDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDaGlsZCBtb2RlbCB3aGljaCBjb250cm9scyB0aGUgcHJvcGVydGllcyBvZiB0aGUgR3JhcGgncyBCYWNrZ3JvdW5kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJhY2tncm91bmRcbiAgICAgKiBAdHlwZSB7QmFja2dyb3VuZH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYmFja2dyb3VuZFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChiYWNrZ3JvdW5kKSB7XG4gICAgICAgIHJldHVybiBiYWNrZ3JvdW5kIGluc3RhbmNlb2YgQmFja2dyb3VuZDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoaWxkIG1vZGVsIHdoaWNoIGNvbnRyb2xzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBHcmFwaCdzIFRpdGxlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpdGxlXG4gICAgICogQHR5cGUge1RpdGxlfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJ0aXRsZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICByZXR1cm4gdGl0bGUgaW5zdGFuY2VvZiBUaXRsZTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBKZXJtYWluZSBBdHRyX0xpc3Qgb2YgdGhlIEdyYXBoJ3MgQXhlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBheGVzXG4gICAgICogQHR5cGUge0F4aXN9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzTWFueShcImF4ZXNcIikuZWFjaE9mV2hpY2gudmFsaWRhdGVXaXRoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHJldHVybiBheGlzIGluc3RhbmNlb2YgQXhpcztcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBKZXJtaWFuZSBBdHRyX0xpc3Qgb2YgdGhlIEdyYXBoJ3MgUGxvdHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGxvdHNcbiAgICAgKiBAdHlwZSB7UGxvdH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNNYW55KFwicGxvdHNcIikuZWFjaE9mV2hpY2gudmFsaWRhdGVXaXRoKGZ1bmN0aW9uIChwbG90KSB7XG4gICAgICAgIHJldHVybiBwbG90IGluc3RhbmNlb2YgUGxvdDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBKZXJtaWFuZSBBdHRyX0xpc3Qgb2YgdGhlIEdyYXBoJ3MgRGF0YSBzZXRzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRhdGFcbiAgICAgKiBAdHlwZSB7RGF0YX1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNNYW55KFwiZGF0YVwiKS5lYWNoT2ZXaGljaC52YWxpZGF0ZVdpdGgoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBEYXRhO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBjb21wdXRlZCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBHcmFwaCdzIHdpbmRvd0JveC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aW5kb3dCb3hcbiAgICAgKiBAdHlwZSB7fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJ3aW5kb3dCb3hcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBCb3g7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBjb21wdXRlZCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBHcmFwaCdzIHBhZGRpbmdCb3guXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGFkZGluZ0JveFxuICAgICAqIEB0eXBlIHt9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInBhZGRpbmdCb3hcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBCb3g7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBjb21wdXRlZCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBHcmFwaCdzIHBsb3RCb3guXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGxvdEJveFxuICAgICAqIEB0eXBlIHt9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInBsb3RCb3hcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBCb3g7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGFpbmluZyBNdWx0aWdyYXBoIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG11bHRpZ3JhcGhcbiAgICAgKiBAdHlwZSB7fVxuICAgICAqIEBhdXRob3IgbWJwXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwibXVsdGlncmFwaFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgLy9hdm9pZCB1c2luZyBpbnN0YW5jZW9mLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHJlcXVpcmUoJ211bHRpZ3JhcGguanMnKSBhYm92ZSEhIVxuICAgICAgICAvL3JldHVybiB2YWwgaW5zdGFuY2VvZiBNdWx0aWdyYXBoO1xuICAgICAgICAvL0p1c3QgY2hlY2sgZm9yIGJ1c3lTcGlubmVyTGV2ZWwgZnVuY3Rpb24sIHNpbmNlIHRoYXQncyB0aGUgcGFydCBvZiB0aGVcbiAgICAgICAgLy9tdWx0aWdyYXBoIHRoYXQgd2UgdXNlIChkdWNrIHR5cGluZykuXG4gICAgICAgIHJldHVybiAodHlwZW9mKHZhbC5idXN5U3Bpbm5lckxldmVsKSA9PSBcImZ1bmN0aW9uXCIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNBKFwieDBcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQShcInkwXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIHRoaXMuaGFzQShcImZpbHRlclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YoZmlsdGVyKSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICAoKHR5cGVvZihmaWx0ZXIucmVzZXQpID09PSAnZnVuY3Rpb24nKSAmJiAodHlwZW9mKGZpbHRlci5maWx0ZXIpID09PSAnZnVuY3Rpb24nKSkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pc0J1aWx0V2l0aChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud2luZG93KCBuZXcgV2luZG93KCkgKTtcbiAgICAgICAgdGhpcy5wbG90YXJlYSggbmV3IFBsb3RhcmVhKCkgKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kKCBuZXcgQmFja2dyb3VuZCgpICk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJwb3N0UGFyc2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgaGFuZGxlQWpheEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuYWN0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm11bHRpZ3JhcGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tdWx0aWdyYXBoKCkuYnVzeVNwaW5uZXJMZXZlbCgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuYWN0aW9uID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm11bHRpZ3JhcGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5tdWx0aWdyYXBoKCkuYnVzeVNwaW5uZXJMZXZlbCgtMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaT0wOyBpPHRoaXMuZGF0YSgpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEoKS5hdChpKS5hZGRMaXN0ZW5lcihcImFqYXhFdmVudFwiLCBoYW5kbGVBamF4RXZlbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgR3JhcGgncyBnZW9tZXRyeS4gRGV0ZXJtaW5lcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgR3JhcGgncyBgd2luZG93Qm94YCxcbiAgICAgKiBgcGFkZGluZ0JveGAgYW5kIGBwbG90Qm94YDsgY2FsbHMgaXRzIEF4ZXMnIGFuZCBMZWdlbmQncyBpbXBsZW1lbnRhdGlvbnMgb2ZcbiAgICAgKiBgaW5pdGlhbGl6ZUdlb21ldHJ5YC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZUdlb21ldHJ5XG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB3aWR0aCBXaWR0aCBvZiB0aGUgbXVsdGlncmFwaCdzIGRpdlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgbXVsdGlncmFwaCdzIGRpdlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGljc0NvbnRleHRcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaW5pdGlhbGl6ZUdlb21ldHJ5XCIsIGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgdmFyIHcgICAgICAgICAgICAgID0gdGhpcy53aW5kb3coKSxcbiAgICAgICAgICAgIHdpbmRvd0JvcmRlciAgID0gdy5ib3JkZXIoKSxcbiAgICAgICAgICAgIHdpbmRvd01hcmdpbiAgID0gdy5tYXJnaW4oKSxcbiAgICAgICAgICAgIHdpbmRvd1BhZGRpbmcgID0gdy5wYWRkaW5nKCksXG4gICAgICAgICAgICBwbG90YXJlYSAgICAgICA9IHRoaXMucGxvdGFyZWEoKSxcbiAgICAgICAgICAgIHBsb3RhcmVhQm9yZGVyID0gcGxvdGFyZWEuYm9yZGVyKCksXG4gICAgICAgICAgICBwbG90YXJlYU1hcmdpbiA9IHBsb3RhcmVhLm1hcmdpbigpLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICB0aGlzLndpbmRvd0JveCggbmV3IEJveCh3aWR0aCwgaGVpZ2h0KSApO1xuICAgICAgICB0aGlzLnBhZGRpbmdCb3goIG5ldyBCb3goXG4gICAgICAgICAgICAoIHdpZHRoIC1cbiAgICAgICAgICAgICAgKCB3aW5kb3dNYXJnaW4ubGVmdCgpICArIHdpbmRvd0JvcmRlciArIHdpbmRvd1BhZGRpbmcubGVmdCgpICkgLVxuICAgICAgICAgICAgICAoIHdpbmRvd01hcmdpbi5yaWdodCgpICsgd2luZG93Qm9yZGVyICsgd2luZG93UGFkZGluZy5yaWdodCgpIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoIGhlaWdodCAtXG4gICAgICAgICAgICAgICggd2luZG93TWFyZ2luLnRvcCgpICAgICsgd2luZG93Qm9yZGVyICsgd2luZG93UGFkZGluZy50b3AoKSApIC1cbiAgICAgICAgICAgICAgKCB3aW5kb3dNYXJnaW4uYm90dG9tKCkgKyB3aW5kb3dCb3JkZXIgKyB3aW5kb3dQYWRkaW5nLmJvdHRvbSgpIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICB0aGlzLnBsb3RCb3goIG5ldyBCb3goXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nQm94KCkud2lkdGgoKSAtXG4gICAgICAgICAgICAgICAgICAgICggcGxvdGFyZWFNYXJnaW4ubGVmdCgpICsgcGxvdGFyZWFNYXJnaW4ucmlnaHQoKSArICgyICogcGxvdGFyZWFCb3JkZXIpKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICB0aGlzLnBhZGRpbmdCb3goKS5oZWlnaHQoKSAtXG4gICAgICAgICAgICAgICAgICAgICggcGxvdGFyZWFNYXJnaW4udG9wKCkgKyBwbG90YXJlYU1hcmdpbi5ib3R0b20oKSArICgyICogcGxvdGFyZWFCb3JkZXIpKVxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmF4ZXMoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5heGVzKCkuYXQoaSkuaW5pdGlhbGl6ZUdlb21ldHJ5KHRoaXMsIGdyYXBoaWNzQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGVnZW5kKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kKCkuaW5pdGlhbGl6ZUdlb21ldHJ5KHRoaXMsIGdyYXBoaWNzQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGl0bGUoKSkge1xuICAgICAgICAgICAgdGhpcy50aXRsZSgpLmluaXRpYWxpemVHZW9tZXRyeShncmFwaGljc0NvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54MCggd2luZG93TWFyZ2luLmxlZnQoKSAgICsgd2luZG93Qm9yZGVyICsgd2luZG93UGFkZGluZy5sZWZ0KCkgICArIHBsb3RhcmVhTWFyZ2luLmxlZnQoKSAgICsgcGxvdGFyZWFCb3JkZXIgKTtcbiAgICAgICAgdGhpcy55MCggd2luZG93TWFyZ2luLmJvdHRvbSgpICsgd2luZG93Qm9yZGVyICsgd2luZG93UGFkZGluZy5ib3R0b20oKSArIHBsb3RhcmVhTWFyZ2luLmJvdHRvbSgpICsgcGxvdGFyZWFCb3JkZXIgKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZpZW5jZSBmdW5jdGlvbiBmb3IgcmVnaXN0ZXJpbmcgY2FsbGJhY2sgZnVuY3Rpb25zIG9uIHRoZSBHcmFwaCdzIGBEYXRhYCBtb2RlbHMuIEFkZHNcbiAgICAgKiBgZGF0YVJlYWR5YCBldmVudCBsaXN0ZW5lcnMgdG8gZWFjaCBvZiB0aGUgR3JhcGgncyBgRGF0YWAgbW9kZWxzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZWdpc3RlckNvbW1vbkRhdGFDYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInJlZ2lzdGVyQ29tbW9uRGF0YUNhbGxiYWNrXCIsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YSgpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEoKS5hdChpKS5hZGRMaXN0ZW5lcihcImRhdGFSZWFkeVwiLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQG1ldGhvZCBwYXVzZUFsbERhdGFcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwicGF1c2VBbGxEYXRhXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIC8vIHBhdXNlIGFsbCB0aGlzIGdyYXBoJ3MgZGF0YSBzb3VyY2VzOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhKCkuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSgpLmF0KGkpLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQG1ldGhvZCByZXN1bWVBbGxEYXRhXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInJlc3VtZUFsbERhdGFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgLy8gcmVzdW1lIGFsbCB0aGlzIGdyYXBoJ3MgZGF0YSBzb3VyY2VzOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhKCkuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSgpLmF0KGkpLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGZpbmROZWFyZXN0QXhpc1xuICAgICAqIEBwYXJhbSB7fSB4XG4gICAgICogQHBhcmFtIHt9IHlcbiAgICAgKiBAcGFyYW0ge30gb3JpZW50YXRpb25cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZmluZE5lYXJlc3RBeGlzXCIsIGZ1bmN0aW9uICh4LCB5LCBvcmllbnRhdGlvbikge1xuICAgICAgICB2YXIgZm91bmRBeGlzID0gbnVsbCxcbiAgICAgICAgICAgIG1pbmRpc3QgPSA5OTk5LFxuICAgICAgICAgICAgYXhlcyA9IHRoaXMuYXhlcygpLFxuICAgICAgICAgICAgbmF4ZXMgPSB0aGlzLmF4ZXMoKS5zaXplKCksXG4gICAgICAgICAgICBheGlzLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuYXhlczsgKytpKSB7XG4gICAgICAgICAgICBheGlzID0gYXhlcy5hdChpKTtcbiAgICAgICAgICAgIGlmICghYXhpcy52aXNpYmxlKCkpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgIGlmICgob3JpZW50YXRpb24gPT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgICAgICAgICAob3JpZW50YXRpb24gPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgKGF4aXMub3JpZW50YXRpb24oKSA9PT0gb3JpZW50YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgZCA9IGF4aXMuZGlzdGFuY2VUb1BvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZEF4aXMgPT09IG51bGwgfHwgZCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRBeGlzID0gYXhpcztcbiAgICAgICAgICAgICAgICAgICAgbWluZGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZEF4aXM7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJheGlzQnlJZFwiLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgcG9pbnRlciB0byB0aGUgYXhpcyBmb3IgdGhpcyBncmFwaCB0aGF0IGhhcyB0aGUgZ2l2ZW4gaWQsIGlmIGFueVxuICAgICAgICB2YXIgYXhlcyA9IHRoaXMuYXhlcygpLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF4ZXMuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChheGVzLmF0KGkpLmlkKCkgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4ZXMuYXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcblxuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZGF0YUJ5SWRcIiwgZnVuY3Rpb24oaWQpIHsgLy8gJ2lkJyBpcyBhIHN0cmluZyBpZCBvZiBhIGRhdGEgb2JqZWN0XG4gICAgICAgIC8vIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgZGF0YSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBncmFwaCBoYXZpbmcgdGhlIGdpdmVuIGlkXG4gICAgICAgIHZhciBkYXRhcyA9IHRoaXMuZGF0YSgpLFxuICAgICAgICAgICAgZGF0YTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGFzLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YXMuYXQoaSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5pZCgpID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJ2YXJpYWJsZUJ5SWRcIiwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIC8vIHJldHVybiBhIHBvaW50ZXIgdG8gdGhlIHZhcmlhYmxlIGZvciB0aGlzIGdyYXBoIHRoYXQgaGFzIHRoZSBnaXZlbiBpZCwgaWYgYW55XG4gICAgICAgIHZhciBkYXRhcyxcbiAgICAgICAgICAgIHJlID0gL14oW15cXC5dKylcXC4oLispJC8sXG4gICAgICAgICAgICBtID0gaWQubWF0Y2gocmUpLFxuICAgICAgICAgICAgZGF0YV9pZCxcbiAgICAgICAgICAgIHZhcl9pZCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgaSwgajtcblxuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgZGF0YV9pZCA9IG1bMV07XG4gICAgICAgICAgICB2YXJfaWQgPSBtWzJdO1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YUJ5SWQoZGF0YV9pZCk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5jb2x1bW5JZFRvRGF0YVZhcmlhYmxlKHZhcl9pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhcyA9IHRoaXMuZGF0YSgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGFzLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IGRhdGFzLmF0KGkpLmNvbHVtbnMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1ucy5zaXplKCk7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1ucy5hdChqKS5pZCgpID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbnMuYXQoaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJkZXN0cm95XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYXhlcygpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmF4ZXMoKS5hdChpKS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcIm5vcm1hbGl6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBIT1JJWk9OVEFMID0gQXhpcy5IT1JJWk9OVEFMLFxuICAgICAgICAgICAgVkVSVElDQUwgICA9IEF4aXMuVkVSVElDQUwsXG4gICAgICAgICAgICBheGVzICA9IHRoaXMuYXhlcygpLFxuICAgICAgICAgICAgcGxvdHMgPSB0aGlzLnBsb3RzKCksXG4gICAgICAgICAgICBpLCBqLFxuICAgICAgICAgICAgaGF4aXNDb3VudCA9IDAsXG4gICAgICAgICAgICB2YXhpc0NvdW50ID0gMCxcbiAgICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgICBheGlzaWQsXG4gICAgICAgICAgICBwbG90O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIG5vcm1hbGl6ZXMgdGhlIGRhdGEgc2VjdGlvbnNcbiAgICAgICAgLy9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YSgpLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEoKS5hdChpKS5ub3JtYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhhbmRsZXMgbWlzc2luZyBob3Jpem9udGFsYXhpcyBhbmQgdmVydGljYWwgYXhpcyB0YWdzXG4gICAgICAgIC8vXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBheGVzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXhlcy5hdChpKS5vcmllbnRhdGlvbigpID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgaGF4aXNDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChheGVzLmF0KGkpLm9yaWVudGF0aW9uKCkgPT09IFZFUlRJQ0FMKSB7XG4gICAgICAgICAgICAgICAgdmF4aXNDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhheGlzQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGF4ZXMuYWRkKG5ldyBBeGlzKEhPUklaT05UQUwpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmF4aXNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgYXhlcy5hZGQobmV3IEF4aXMoVkVSVElDQUwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhhbmRsZXMgbWlzc2luZyBpZCdzIGZvciBheGVzXG4gICAgICAgIC8vXG4gICAgICAgIGhheGlzQ291bnQgPSAwO1xuICAgICAgICB2YXhpc0NvdW50ID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF4ZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgIGF4aXMgPSBheGVzLmF0KGkpO1xuICAgICAgICAgICAgaWYgKGF4aXMub3JpZW50YXRpb24oKSA9PT0gSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGF4aXNpZCA9IFwieFwiO1xuICAgICAgICAgICAgICAgIGlmIChoYXhpc0NvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBheGlzaWQgKz0gaGF4aXNDb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGF4aXNDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChheGlzLm9yaWVudGF0aW9uKCkgPT09IFZFUlRJQ0FMKSB7XG4gICAgICAgICAgICAgICAgYXhpc2lkID0gXCJ5XCI7XG4gICAgICAgICAgICAgICAgaWYgKHZheGlzQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNpZCArPSB2YXhpc0NvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXhpc0NvdW50Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChheGlzLmlkKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGF4aXMuaWQoYXhpc2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIG5vcm1hbGl6ZXMgdGhlIHJlc3Qgb2YgdGhlIGF4aXMgcHJvcGVydGllc1xuICAgICAgICAvL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXhlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgYXhlcy5hdChpKS5ub3JtYWxpemUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBoYW5kbGVzIG1pc3NpbmcgcGxvdCB0YWdzXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChwbG90cy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHBsb3RzLmFkZChuZXcgRGF0YVBsb3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBub3JtYWxpemVzIHRoZSBwbG90c1xuICAgICAgICAvL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGxvdHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgIHBsb3RzLmF0KGkpLm5vcm1hbGl6ZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIG5vcm1hbGl6ZXMgdGhlIGxlZ2VuZFxuICAgICAgICAvL1xuICAgICAgICBpZiAodGhpcy5sZWdlbmQoKSkge1xuICAgICAgICAgICAgdGhpcy5sZWdlbmQoKS5ub3JtYWxpemUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBleGVjdXRlIHRoZSBzZXREYXRhUmFuZ2UgbWV0aG9kIGZvciBlYWNoIGF4aXMgYmluZGluZywgdG8gc3luYyB1cCBhbGwgYXhlc1xuICAgICAgICAvLyB0aGF0IHBhcnRpY2lwYXRlIGluIHRoZSBiaW5kaW5nICh0aGlzIHRha2VzIGNhcmUgb2Ygc2V0dGluZyBkYXRhTWluL2RhdGFNYXhcbiAgICAgICAgLy8gZm9yIGFueSBheGVzIHRoYXQgZG9uJ3QgaGF2ZSB0aGVtIGFscmVhZHkgYnV0IHdoaWNoIGFyZSBib3VuZCB0byBheGVzIHRoYXRcbiAgICAgICAgLy8gZG8gaGF2ZSB0aGVtKVxuICAgICAgICAvLyBcbiAgICAgICAgQXhpc0JpbmRpbmcuc3luY0FsbEJpbmRpbmdzKCk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gYXJyYW5nZSB0byBzZXQgbWlzc2luZyBheGlzIG1pbi9tYXggdmFsdWVzIHdoZW4gZGF0YSBpcyByZWFkeSwgaWYgbmVjZXNzYXJ5XG4gICAgICAgIC8vIFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXhlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggYXhpcy4uLlxuICAgICAgICAgICAgYXhpcyA9IGF4ZXMuYXQoaSk7XG4gICAgICAgICAgICBpZiAoIWF4aXMuaGFzRGF0YU1pbigpIHx8ICFheGlzLmhhc0RhdGFNYXgoKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgYXhpcyBpcyBtaXNpbmcgZWl0aGVyIGEgZGF0YU1pbigpIG9yIGRhdGFNYXgoKSB2YWx1ZS4uLlxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwbG90cy5zaXplKCk7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGEgRGF0YVBsb3QgdGhhdCByZWZlcmVuY2VzIHRoaXMgYXhpcy4uLlxuICAgICAgICAgICAgICAgICAgICBwbG90ID0gcGxvdHMuYXQoaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbG90IGluc3RhbmNlb2YgRGF0YVBsb3QgJiYgKHBsb3QuaG9yaXpvbnRhbGF4aXMoKSA9PT0gYXhpcyB8fCBwbG90LnZlcnRpY2FsYXhpcygpID09PSBheGlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGFuZCB0aGVuIHJlZ2lzdGVyIGEgZGF0YVJlYWR5IGxpc3RlbmVyIGZvciB0aGlzIHBsb3QncyBkYXRhIHNlY3Rpb24gd2hpY2ggc2V0cyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pc3NpbmcgYm91bmQocykgb24gdGhlIGF4aXMgb25jZSB0aGUgZGF0YSBpcyByZWFkeS4gIERvIHRoaXMgaW5zaWRlIGEgY2xvc3VyZSBzbyB0aGF0IHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gcmVmZXIgdG8gYSBwb2ludGVyIHRvIG91ciBkeW5hbWljYWxseS1kZWZpbmVkIGxpc3RlbmVyIGZ1bmN0aW9uIGZyb20gaW5zaWRlIGl0c2VsZixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIGRlLXJlZ2lzdGVyIGl0IG9uY2UgaXQgaXMgY2FsbGVkOyB0aGlzIGlzIGRvbmUgdmlhIHRoZSB0aGUgbG9jYWwgdmFyaWFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF4aXNCb3VuZHNTZXR0ZXIuICBUaGUgY2xvc3VyZSBhbHNvIHNlcnZlcyB0byBjYXB0dXJlIHRoZSBjdXJyZW50IHZhbHVlcywgdmlhIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBheGlzIHBvaW50ZXIsIGEgcG9pbnRlciB0byB0aGUgZGF0YSBvYmplY3QsIGFuZCBhIGJvb2xlYW4gKGlzSG9yaXpvbnRhbCkgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGF4aXMgaXMgdGhlIHBsb3QncyBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGF4aXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGF4aXMsIGRhdGEsIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzQm91bmRzU2V0dGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBpc0hvcml6b250YWwgPyAwIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcyA9IGRhdGEuZ2V0Qm91bmRzKGNvbHVtbk51bWJlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBheGlzLmRhdGFNaW4oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IGF4aXMuZGF0YU1heCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWF4aXMuaGFzRGF0YU1pbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBib3VuZHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzLmhhc0RhdGFNYXgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gYm91bmRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXhpcy5oYXNEYXRhTWluKCkgfHwgIWF4aXMuaGFzRGF0YU1heCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnNldERhdGFSYW5nZShtaW4sIG1heCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yZW1vdmVMaXN0ZW5lcignZGF0YVJlYWR5JywgYXhpc0JvdW5kc1NldHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmFkZExpc3RlbmVyKCdkYXRhUmVhZHknLCBheGlzQm91bmRzU2V0dGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oYXhpcywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF4aXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5kYXRhKCksICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5ob3Jpem9udGFsYXhpcygpID09PSBheGlzICAgIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGZvciAoaj0wOyBqIDwgdGhpcy5wbG90cygpLnNpemUoKTsgKytqKS4uLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuXG4gICAgfSk7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMsIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGg7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBSR0JDb2xvciA9IHJlcXVpcmUoJy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzLmdyaWQpO1xuXG52YXIgR3JpZCA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkdyaWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcImNvbG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvciBpbnN0YW5jZW9mIFJHQkNvbG9yO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcInZpc2libGVcIikud2hpY2guaXNBKFwiYm9vbGVhblwiKTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcy5ncmlkLCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWQ7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMubGVnZW5kLmljb24pO1xuXG52YXIgSWNvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkljb25cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcImhlaWdodFwiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuICAgIHRoaXMuaGFzQShcIndpZHRoXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG4gICAgdGhpcy5oYXNBKFwiYm9yZGVyXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMubGVnZW5kLmljb24sIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSWNvbjtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vbWF0aC9wb2ludC5qcycpO1xuXG52YXIgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLmJhY2tncm91bmQuaW1nKTtcblxudmFyIEltZyA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkltZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXNBKFwic3JjXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcbiAgICB0aGlzLmhhc0EoXCJhbmNob3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBhbmNob3IgaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJiYXNlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGJhc2UgaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJwb3NpdGlvblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJmcmFtZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICByZXR1cm4gZnJhbWUgPT09IEltZy5QQURESU5HIHx8IGZyYW1lID09PSBJbWcuUExPVDtcbiAgICB9KTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwic3JjXCIpO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLmJhY2tncm91bmQuaW1nLCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5JbWcuUEFERElORyA9IFwicGFkZGluZ1wiO1xuSW1nLlBMT1QgICAgPSBcInBsb3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWc7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBEYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKSxcbiAgICBEYXRhRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9kYXRhX2Zvcm1hdHRlci5qcycpLFxuICAgIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi9kYXRhX21lYXN1cmUuanMnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICBSR0JDb2xvciA9IHJlcXVpcmUoJy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzLmxhYmVscy5sYWJlbCk7XG5cbnZhciBMYWJlbGVyID0gbmV3IGplcm1haW5lLk1vZGVsKFwiTGFiZWxlclwiLCBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZ2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWVPckZ1bmN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YodmFsdWVPckZ1bmN0aW9uKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVPckZ1bmN0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVPckZ1bmN0aW9uO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaGFzQShcImF4aXNcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB2YXIgQXhpcyA9IHJlcXVpcmUoJy4vYXhpcy5qcycpO1xuICAgICAgICByZXR1cm4gYXhpcyBpbnN0YW5jZW9mIEF4aXM7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiZm9ybWF0dGVyXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YUZvcm1hdHRlci5pc0luc3RhbmNlKTtcbiAgICB0aGlzLmhhc0EoXCJmb250XCIpLndoaWNoLmlzQShcInN0cmluZ1wiKS5hbmQud2hpY2guZGVmYXVsdHNUbyhcIlwiKTtcbiAgICB0aGlzLmhhc0EoXCJzdGFydFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFWYWx1ZS5pc0luc3RhbmNlKTtcbiAgICB0aGlzLmhhc0EoXCJhbmdsZVwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5oYXNBKFwicG9zaXRpb25cIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uIGluc3RhbmNlb2YgUG9pbnQ7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiYW5jaG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGFuY2hvcikge1xuICAgICAgICByZXR1cm4gYW5jaG9yIGluc3RhbmNlb2YgUG9pbnQ7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwic3BhY2luZ1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFNZWFzdXJlLmlzSW5zdGFuY2UpO1xuICAgIHRoaXMuaGFzQShcImRlbnNpdHlmYWN0b3JcIikud2hpY2guaXNBKFwibnVtYmVyXCIpLmFuZC53aGljaC5kZWZhdWx0c1RvKDEuMCk7XG5cbiAgICB0aGlzLmhhc0EoXCJjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KTtcblxuICAgIHRoaXMuaGFzQShcInZpc2libGVcIikud2hpY2guaXNBKFwiYm9vbGVhblwiKS5hbmQud2hpY2guZGVmYXVsdHNUbyh0cnVlKTtcblxuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJheGlzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhYmVsc0RlZmF1bHRzID0gZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcy5sYWJlbHM7XG4gICAgICAgIGlmICh0aGlzLmF4aXMoKS50eXBlKCkgPT09IERhdGFWYWx1ZS5EQVRFVElNRSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCggZ2V0VmFsdWUobGFiZWxzRGVmYXVsdHNbJ3N0YXJ0LWRhdGV0aW1lJ10pICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCBnZXRWYWx1ZShsYWJlbHNEZWZhdWx0c1snc3RhcnQtbnVtYmVyJ10pICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImluaXRpYWxpemVHZW9tZXRyeVwiLCBmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgICAgICAgdmFyIGF4aXMgICAgPSB0aGlzLmF4aXMoKSxcbiAgICAgICAgICAgIHBsb3RCb3ggPSBncmFwaC5wbG90Qm94KCksXG4gICAgICAgICAgICBsYWJlbERlZmF1bHRzID0gZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcy5sYWJlbHMubGFiZWwsXG4gICAgICAgICAgICBBeGlzID0gcmVxdWlyZSgnLi9heGlzLmpzJyk7XG5cbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24oKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXhpcy5vcmllbnRhdGlvbigpID09PSBBeGlzLkhPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5wZXJwT2Zmc2V0KCkgPiBwbG90Qm94LmhlaWdodCgpLzIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiggZ2V0VmFsdWUobGFiZWxEZWZhdWx0c1tcInBvc2l0aW9uLWhvcml6b250YWwtdG9wXCJdKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24oIGdldFZhbHVlKGxhYmVsRGVmYXVsdHNbXCJwb3NpdGlvbi1ob3Jpem9udGFsLWJvdHRvbVwiXSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChheGlzLnBlcnBPZmZzZXQoKSA+IHBsb3RCb3gud2lkdGgoKS8yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24oIGdldFZhbHVlKGxhYmVsRGVmYXVsdHNbXCJwb3NpdGlvbi12ZXJ0aWNhbC1yaWdodFwiXSkgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCBnZXRWYWx1ZShsYWJlbERlZmF1bHRzW1wicG9zaXRpb24tdmVydGljYWwtbGVmdFwiXSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmNob3IoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXhpcy5vcmllbnRhdGlvbigpID09PSBBeGlzLkhPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5wZXJwT2Zmc2V0KCkgPiBwbG90Qm94LmhlaWdodCgpLzIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmNob3IoIGdldFZhbHVlKGxhYmVsRGVmYXVsdHNbXCJhbmNob3ItaG9yaXpvbnRhbC10b3BcIl0pICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmNob3IoIGdldFZhbHVlKGxhYmVsRGVmYXVsdHNbXCJhbmNob3ItaG9yaXpvbnRhbC1ib3R0b21cIl0pICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5wZXJwT2Zmc2V0KCkgPiBwbG90Qm94LndpZHRoKCkvMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvciggZ2V0VmFsdWUobGFiZWxEZWZhdWx0c1tcImFuY2hvci12ZXJ0aWNhbC1yaWdodFwiXSkgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvciggZ2V0VmFsdWUobGFiZWxEZWZhdWx0c1tcImFuY2hvci12ZXJ0aWNhbC1sZWZ0XCJdKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaXNFcXVhbEV4Y2VwdEZvclNwYWNpbmdcIiwgZnVuY3Rpb24gKGxhYmVsZXIpIHtcbiAgICAgICAgLy8gcmV0dXJuIHRydWUgaWZmIHRoZSBnaXZlbiBsYWJlbGVyIGFuZCB0aGlzIGxhYmVsZXIgYXJlIGVxdWFsIGluIGV2ZXJ5IHdheVxuICAgICAgICAvLyBleGNlcHQgZm9yIHRoZWlyIHNwYWNpbmcgdmFsdWVzXG4gICAgICAgIHJldHVybiAoKHRoaXMuYXhpcygpICAgICAgICAgICAgICAgICAgICAgICAgID09PSAgIGxhYmVsZXIuYXhpcygpICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5mb3JtYXR0ZXIoKS5nZXRGb3JtYXRTdHJpbmcoKSAgPT09ICAgbGFiZWxlci5mb3JtYXR0ZXIoKS5nZXRGb3JtYXRTdHJpbmcoKSAgICAgKSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnN0YXJ0KCkgICAgICAgICAgICAgICAgICAgICAgICAuZXEoICBsYWJlbGVyLnN0YXJ0KCkgICAgICAgICAgICAgICAgICAgICAgICAgKSApICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuYW5nbGUoKSAgICAgICAgICAgICAgICAgICAgICAgID09PSAgIGxhYmVsZXIuYW5nbGUoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5wb3NpdGlvbigpICAgICAgICAgICAgICAgICAgICAgLmVxKCAgbGFiZWxlci5wb3NpdGlvbigpICAgICAgICAgICAgICAgICAgICAgICkgKSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmFuY2hvcigpICAgICAgICAgICAgICAgICAgICAgICAuZXEoICBsYWJlbGVyLmFuY2hvcigpICAgICAgICAgICAgICAgICAgICAgICAgKSApICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuZGVuc2l0eWZhY3RvcigpICAgICAgICAgICAgICAgID09PSAgIGxhYmVsZXIuZGVuc2l0eWZhY3RvcigpICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICk7XG4gICAgfSk7XG5cblxuICAgIHRoaXMuaGFzQShcIml0ZXJhdG9yTmV4dFZhbHVlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YVZhbHVlLmlzSW5zdGFuY2VPck51bGwpLmFuZC53aGljaC5kZWZhdWx0c1RvKG51bGwpO1xuICAgIHRoaXMuaGFzQShcIml0ZXJhdG9yTWluVmFsdWVcIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhVmFsdWUuaXNJbnN0YW5jZSk7XG4gICAgdGhpcy5oYXNBKFwiaXRlcmF0b3JNYXhWYWx1ZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFWYWx1ZS5pc0luc3RhbmNlKTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcInByZXBhcmVcIiwgZnVuY3Rpb24gKG1pbkRhdGFWYWx1ZSwgbWF4RGF0YVZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0b3JNaW5WYWx1ZShtaW5EYXRhVmFsdWUpO1xuICAgICAgICB0aGlzLml0ZXJhdG9yTWF4VmFsdWUobWF4RGF0YVZhbHVlKTtcbiAgICAgICAgdGhpcy5pdGVyYXRvck5leHRWYWx1ZSggdGhpcy5zcGFjaW5nKCkuZmlyc3RTcGFjaW5nTG9jYXRpb25BdE9yQWZ0ZXIobWluRGF0YVZhbHVlLCB0aGlzLnN0YXJ0KCkpICk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJoYXNOZXh0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5pdGVyYXRvck5leHRWYWx1ZSgpO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZSh0aGlzLml0ZXJhdG9yTWF4VmFsdWUoKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJwZWVrTmV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSAgICA9IHRoaXMuaXRlcmF0b3JOZXh0VmFsdWUoKSxcbiAgICAgICAgICAgIG1heFZhbHVlID0gdGhpcy5pdGVyYXRvck1heFZhbHVlKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmd0KG1heFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJuZXh0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5pdGVyYXRvck5leHRWYWx1ZSgpLFxuICAgICAgICAgICAgbWF4VmFsdWUgPSB0aGlzLml0ZXJhdG9yTWF4VmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuZ3QobWF4VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlcmF0b3JOZXh0VmFsdWUoIHZhbHVlLmFkZCggdGhpcy5zcGFjaW5nKCkgKSApO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJnZXRMYWJlbERlbnNpdHlcIiwgZnVuY3Rpb24gKGdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgICB2YXIgYXhpcyAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMuYXhpcygpLFxuICAgICAgICAgICAgcGl4ZWxTcGFjaW5nICAgICAgICAgICAgICA9IHRoaXMuc3BhY2luZygpLmdldFJlYWxWYWx1ZSgpICogYXhpcy5heGlzVG9EYXRhUmF0aW8oKSxcbiAgICAgICAgICAgIG1pblJlYWxWYWx1ZSAgICAgICAgICAgICAgPSBheGlzLmRhdGFNaW4oKS5nZXRSZWFsVmFsdWUoKSxcbiAgICAgICAgICAgIG1heFJlYWxWYWx1ZSAgICAgICAgICAgICAgPSBheGlzLmRhdGFNYXgoKS5nZXRSZWFsVmFsdWUoKSxcbiAgICAgICAgICAgIHJlcHJlc2VudGF0aXZlUmVhbFZhbHVlICAgPSBtaW5SZWFsVmFsdWUgKyAwLjUxMjM0NTY3ICogKG1heFJlYWxWYWx1ZSAtIG1pblJlYWxWYWx1ZSksXG4gICAgICAgICAgICByZXByZXNlbnRhdGl2ZVZhbHVlICAgICAgID0gRGF0YVZhbHVlLmNyZWF0ZShheGlzLnR5cGUoKSwgcmVwcmVzZW50YXRpdmVSZWFsVmFsdWUgKSxcbiAgICAgICAgICAgIHJlcHJlc2VudGF0aXZlVmFsdWVTdHJpbmcgPSB0aGlzLmZvcm1hdHRlcigpLmZvcm1hdChyZXByZXNlbnRhdGl2ZVZhbHVlKSxcbiAgICAgICAgICAgIEF4aXMgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2F4aXMuanMnKTtcblxuICAgICAgICAvLyBsZW5ndGggb2YgdGhlIGZvcm1hdHRlZCBheGlzIHJlcHJlc2VudGF0aXZlIHZhbHVlLCBpbiBwaXhlbHNcbiAgICAgICAgdmFyIHBpeGVsRm9ybWF0dGVkVmFsdWUgPSAoXG4gICAgICAgICAgICAoYXhpcy5vcmllbnRhdGlvbigpID09PSBBeGlzLkhPUklaT05UQUwpID9cbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVTdHJpbmdXaWR0aChncmFwaGljc0NvbnRleHQsIHJlcHJlc2VudGF0aXZlVmFsdWVTdHJpbmcpIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVTdHJpbmdIZWlnaHQoZ3JhcGhpY3NDb250ZXh0LCByZXByZXNlbnRhdGl2ZVZhbHVlU3RyaW5nKVxuICAgICAgICApO1xuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdGlvIC0tIHRoZSBmcmFjdGlvbiBvZiB0aGUgc3BhY2luZyB0YWtlbiB1cCBieSB0aGUgZm9ybWF0dGVkIHN0cmluZ1xuICAgICAgICByZXR1cm4gcGl4ZWxGb3JtYXR0ZWRWYWx1ZSAvICggcGl4ZWxTcGFjaW5nICogdGhpcy5kZW5zaXR5ZmFjdG9yKCkgKTtcbiAgICB9KTtcblxuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwibWVhc3VyZVN0cmluZ1dpZHRoXCIsIGZ1bmN0aW9uIChncmFwaGljc0NvbnRleHQsIHN0cmluZykge1xuICAgICAgICAvLyBHcmFwaGljcyBkcml2ZXJzIHNob3VsZCByZXBsYWNlIHRoaXMgbWV0aG9kIHdpdGggYW4gYWN0dWFsIGltcGxlbWVudGF0aW9uOyB0aGlzXG4gICAgICAgIC8vIGlzIGp1c3QgYSBwbGFjZWhvbGRlci4gIFRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgcmV0dXJuIHRoZSB3aWR0aCwgaW4gcGl4ZWxzLFxuICAgICAgICAvLyBvZiB0aGUgZ2l2ZW4gc3RyaW5nLiAgT2YgY291cnNlIHRoaXMgaXMgZGVwZW5kZW50IG9uIGZvbnQgY2hvaWNlLCBzaXplLCBldGMsXG4gICAgICAgIC8vIGJ1dCB3ZSBnbG9zcyBvdmVyIHRoYXQgYXQgdGhlIG1vbWVudC4gIEp1c3QgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgc3RyaW5nXG4gICAgICAgIC8vIHVzaW5nIHNvbWUgcmVhc29uYWJsZSBkZWZhdWx0IGZvbnQgZm9yIG5vdy4gIExhdGVyIG9uLCB3ZSdsbCBtb2RpZnkgdGhpc1xuICAgICAgICAvLyBmdW5jdGlvbiB0byB1c2UgZm9udCBpbmZvcm1hdGlvbi5cbiAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGgqMzA7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwibWVhc3VyZVN0cmluZ0hlaWdodFwiLCBmdW5jdGlvbiAoZ3JhcGhpY3NDb250ZXh0LCBzdHJpbmcpIHtcbiAgICAgICAgLy8gc2VlIGNvbW1lbnQgZm9yIG1lYXN1cmVTdHJpbmdXaWR0aCgpIGFib3ZlXG4gICAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoKjMwO1xuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInJlbmRlckxhYmVsXCIsIGZ1bmN0aW9uIChncmFwaGljc0NvbnRleHQsIHZhbHVlKSB7XG4gICAgICAgIC8vIEdyYXBoaWNzIGRyaXZlcnMgc2hvdWxkIHJlcGxhY2UgdGhpcyBtZXRob2Qgd2l0aCBhbiBhY3R1YWwgaW1wbGVtZW50YXRpb247IHRoaXNcbiAgICAgICAgLy8gaXMganVzdCBhIHBsYWNlaG9sZGVyLiAgVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCBkcmF3IHRoZSBzdHJpbmcgZm9yIHRoZSBnaXZlblxuICAgICAgICAvLyB2YWx1ZSwgZm9ybWF0dGVkIGJ5IHRoZSBsYWJlbGVyJ3MgRGF0YUZvcm1hdHRlciwgaW4gdGhlIGxvY2F0aW9uIGFsb25nIHRoZSBheGlzXG4gICAgICAgIC8vIGRldGVybWluZWQgYnkgdGhlIHZhbHVlIGl0c2VsZiwgYW5kIHRoZSBsYWJlbGVyJ3MgcG9zaXRpb24sIGFuY2hvciwgYW5kIGFuZ2xlXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMuXG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJub3JtYWxpemVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVmYXVsdE51bWJlckZvcm1hdCAgID0gXCIlLjFmXCIsXG4gICAgICAgICAgICBkZWZhdWx0RGF0ZXRpbWVGb3JtYXQgPSBcIiVZLSVNLSVEICVIOiVpXCIsXG4gICAgICAgICAgICBsYWJlbGVyRm9ybWF0LFxuICAgICAgICAgICAgdHlwZSA9IHRoaXMuYXhpcygpLnR5cGUoKTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBEZXRlcm1pbmVzIGRlZmF1bHQgdmFsdWVzIG9mIGxhYmVsZXIgYXR0cmlidXRlcyBiYXNlZCBvbiBheGlzIHR5cGVcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHR5cGUgPT09IERhdGFWYWx1ZS5EQVRFVElNRSkge1xuICAgICAgICAgICAgbGFiZWxlckZvcm1hdCA9IGRlZmF1bHREYXRldGltZUZvcm1hdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsZXJGb3JtYXQgPSBkZWZhdWx0TnVtYmVyRm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW5zZXJ0cyBsYWJlbGVyIGRlZmF1bHRzXG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0aGlzLmZvcm1hdHRlcigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVyKERhdGFGb3JtYXR0ZXIuY3JlYXRlKHR5cGUsIGxhYmVsZXJGb3JtYXQpKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMuaG9yaXpvbnRhbGF4aXMubGFiZWxzLmxhYmVsLCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhYmVsZXI7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICBSR0JDb2xvciA9IHJlcXVpcmUoJy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgSWNvbiA9IHJlcXVpcmUoJy4vaWNvbi5qcycpLFxuICAgIFBsb3QgPSByZXF1aXJlKCcuL3Bsb3QuanMnKSxcbiAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgdmFsaWRhdGlvbkZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLmxlZ2VuZCk7XG5cbi8qKlxuICogTGVnZW5kIGlzIGEgSmVybWFpbmUgbW9kZWwgdGhhdCBzdXBwb3J0cyB0aGUgcmVuZGVyaW5nIG9mIE11bHRpZ3JhcGggTGVnZW5kcy5cbiAqIFxuICogVGhlIG1ldGhvZHMgZm9yIHRoaXMgb2JqZWN0IHRha2UgYSBwYXJhbWV0ZXIgY2FsbGVkIGBncmFwaGljc0NvbnRleHRgLCB3aGljaCBpcyBhXG4gKiBkcml2ZXItc3BlY2lmaWMgb2JqZWN0IHRoYXQgc3RvcmVzIHdoYXRldmVyIHN0YXRlL2NvbmZpZ3VyYXRpb24gaXMgbmVlZGVkIGJ5IHRoZVxuICogZHJpdmVyLiAgRWFjaCBkcml2ZXIgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGl0cyBvd24gZ3JhcGhpY3NDb250ZXh0IG9iamVjdCBhbmRcbiAqIHBhc3NpbmcgaXQgdG8gdGhlc2UgbWV0aG9kcywgd2hpY2ggaW4gdHVybiBwYXNzIHRoYXQgb2JqZWN0IG9uIHRvIHRoZSBkcml2ZXItc3BlY2lmaWNcbiAqIG1ldGhvZHMgdGhhdCB0aGV5IGNhbGwuXG4gKiBcbiAqIEBjbGFzcyBMZWdlbmRcbiAqIEBmb3IgTGVnZW5kXG4gKiBAY29uc3RydWN0b3JcbiAqIEByZXF1aXJlcyBQb2ludCxSR0JDb2xvcixQbG90LEljb25cbiAqL1xudmFyIExlZ2VuZCA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkxlZ2VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIGxlZ2VuZCB3aWxsIGJlIHJlbmRlcmVkOyBhIHZhbHVlIG9mIGB0cnVlYCBtZWFucyB0aGUgTGVnZW5kIHdpbGxcbiAgICAgKiBiZSBkcmF3biB3aGlsZSBgZmFsc2VgIG1lYW5zIHRoYXQgaXQgd2lsbCBub3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJ2aXNpYmxlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2aXNpYmxlID09PSBcImJvb2xlYW5cIiB8fCB2aXNpYmxlID09PSBudWxsO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGdpdmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgYmFzZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgTGVnZW5kJ3MgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYmFzZVxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYmFzZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChiYXNlKSB7XG4gICAgICAgIHJldHVybiBiYXNlIGluc3RhbmNlb2YgUG9pbnQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggZ2l2ZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBMZWdlbmQncyBhbmNob3IgcG9pbnQgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIGJhc2UgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYW5jaG9yXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0FuKFwiYW5jaG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGFuY2hvcikge1xuICAgICAgICByZXR1cm4gYW5jaG9yIGluc3RhbmNlb2YgUG9pbnQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGNvb3JkaW5hdGUgcGFpciBvZiBwaXhlbCBvZmZzZXRzIGZvciB0aGUgYmFzZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwicG9zaXRpb25cIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uIGluc3RhbmNlb2YgUG9pbnQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBsZWdlbmQgaXMgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgcGxvdCBhcmVhIG9yIHRoZSBwYWRkaW5nXG4gICAgICogYm94LiBBIHZhbHVlIG9mIGBwbG90YCBtZWFucyB0aGUgTGVnZW5kIHdpbGwgYmUgZHJhd24gcmVsYXRpdmUgdG8gdGhlIHBsb3QgYXJlYSB3aGlsZSBgcGFkZGluZ2AgbWVhbnNcbiAgICAgKiB0aGF0IGl0IHdpbGwgdGhlIHBhZGRpbmcgYm94LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyYW1lXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiZnJhbWVcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIGZyYW1lID09PSBcInBsb3RcIiB8fCBmcmFtZSA9PT0gXCJwYWRkaW5nXCI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgTGVnZW5kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbG9yXG4gICAgICogQHR5cGUge1JHQkNvbG9yfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB3aGljaCBkZXRlcm1pbmVzIHRoZSBib3JkZXJjb2xvciBvZiB0aGUgTGVnZW5kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvcmRlcmNvbG9yXG4gICAgICogQHR5cGUge1JHQkNvbG9yfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJib3JkZXJjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChib3JkZXJjb2xvcikge1xuICAgICAgICByZXR1cm4gYm9yZGVyY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB3aGljaCBkZXRlcm1pbmVzIHRoZSBvcGFjaXR5IG9mIHRoZSBMZWdlbmQ7IGRlcGVuZGluZyBvbiB3aGVyZSB0aGUgTGVnZW5kIGlzIHBvc2l0aW9uZWQgaXRcbiAgICAgKiBtYXkgb2JzY3VyZSBwYXJ0cyBvZiB0aGUgcGxvdCBkYXRhLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wYWNpdHlcbiAgICAgKiBAdHlwZSB7RmxvYXR9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcIm9wYWNpdHlcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAob3BhY2l0eSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkZ1bmN0aW9ucy52YWxpZGF0ZU51bWJlclJhbmdlKG9wYWNpdHksIDAuMCwgMS4wKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB3aGljaCBkZXRlcm1pbmVzIHRoZSB0aGlja25lc3Mgb2YgdGhlIGJvcmRlciBkcmF3biBhcm91bmQgdGhlIExlZ2VuZDsgYSB2YWx1ZSBvZiBgMGAgdHVybnNcbiAgICAgKiB0aGUgYm9yZGVyIG9mZi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBib3JkZXJcbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYm9yZGVyXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gYmUgdXNlZCBmb3IgUGxvdCBlbnRyaWVzIGluIHRoZSBMZWdlbmQuIElmIGxlZnRcbiAgICAgKiB1bnNwZWNpZmllZCB0aGVuIHJvd3Mgd2lsbCBiZSBpbnNlcnRlZCB0byBhY2NvdW50IGZvciBlYWNoIFBsb3QgZW50cnkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcm93c1xuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJyb3dzXCIpLndoaWNoLmlzQShcImludGVnZXJcIikuYW5kLmlzR3JlYXRlclRoYW4oMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgdG8gYmUgdXNlZCBmb3IgUGxvdCBlbnRyaWVzIGluIHRoZSBMZWdlbmQuIElmIHJvd3NcbiAgICAgKiBpcyBzZXQgd2hpbGUgY29sdW1ucyBpcyBsZWZ0IHVuc3BlY2lmaWVkIHRoZW4gY29sdW1ucyB3aWxsIGJlIGluc2VydGVkIHRvIGFjY291bnQgZm9yIGVhY2ggUGxvdFxuICAgICAqIGVudHJ5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbHVtbnNcbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiY29sdW1uc1wiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpLmFuZC5pc0dyZWF0ZXJUaGFuKDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGRldGVybWluZXMgd2hldGhlciB0aGUgY29ybmVycyBvZiB0aGUgbGVnZW5kIGJveCBhcmUgcm91bmRlZCB3aGVuIGRyYXduLiBBIHZhbHVlIG9mXG4gICAgICogYDBgIG1lYW5zIHRoYXQgdGhlIGNvcm5lcnMgd2lsbCBiZSBkcmF3biBzcXVhcmUgd2hpbGUgdmFsdWVzIGdyZWF0ZXIgdGhhbiBgMGAgbWVhbiB0aGF0IHRoZSBjb3JuZXJzXG4gICAgICogYXJlIHJvdW5kZWQgb2ZmIHdpdGggY2lyY2xlcyB3aG9zZSByYWRpdXMgaW4gcGl4ZWxzIGlzIHRoaXMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29ybmVycmFkaXVzXG4gICAgICogQHR5cGUge0ludGVnZXJ9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImNvcm5lcnJhZGl1c1wiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGRldGVybWluZXMgdGhlIHBpeGVsIHdpZHRoIG9mIHRoZSBwYWRkaW5nIGJldHdlZW4gdGhlIExlZ2VuZCBib3JkZXIgYW5kIGl0cyBlbnRyaWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBhZGRpbmdcbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwicGFkZGluZ1wiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuXG4gICAgLyoqXG4gICAgICogQSBvcHRpb25hbCBzdWItbW9kZWwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgSWNvbnMgZm9yIHRoZSBQbG90IGVudHJpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaWNvblxuICAgICAqIEB0eXBlIHtJY29ufVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0FuKFwiaWNvblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChpY29uKSB7XG4gICAgICAgIHJldHVybiBpY29uIGluc3RhbmNlb2YgSWNvbjtcbiAgICB9KTtcblxuICAgIHRoaXMuaXNCdWlsdFdpdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmljb24oIG5ldyBJY29uKCkgKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFBvaW50ZXJzIHRvIFBsb3QgbW9kZWxzIHRoYXQgaGF2ZSBlbnRyaWVzIGluIHRoZSBMZWdlbmQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGxvdHNcbiAgICAgKiBAdHlwZSB7UGxvdH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNNYW55KFwicGxvdHNcIikuZWFjaE9mV2hpY2gudmFsaWRhdGVXaXRoKGZ1bmN0aW9uIChwbG90KSB7XG4gICAgICAgIHJldHVybiBwbG90IGluc3RhbmNlb2YgUGxvdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHZhbHVlIHdoaWNoIGRldGVybWluZXMgdGhlIG51bWJlciBvZiBwaXhlbHMgYmV0d2VlbiBhbiBlbnRyaWVzIGljb24gYW5kIGl0cyBib3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaWNvbk9mZnNldFxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqIEBkZWZhdWx0IDVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmaW5hbFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJpY29uT2Zmc2V0XCIpLndoaWNoLmlzQW4oXCJpbnRlZ2VyXCIpLmFuZC5kZWZhdWx0c1RvKDUpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgdmFsdWUgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIHBpeGVscyBiZXR3ZWVuIGFuIGVudHJpZXMgbGFiZWwgYW5kIGl0cyBpY29uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxhYmVsT2Zmc2V0XG4gICAgICogQHR5cGUge0ludGVnZXJ9XG4gICAgICogQGRlZmF1bHQgNVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZpbmFsXG4gICAgICogQHR5cGUge31cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwibGFiZWxPZmZzZXRcIikud2hpY2guaXNBbihcImludGVnZXJcIikuYW5kLmRlZmF1bHRzVG8oNSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB2YWx1ZSB3aGljaCBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIHJpZ2h0IGVuZCBvZiBhbiBlbnRyaWVzIGxhYmVsIGFuZFxuICAgICAqIGl0cyBib3JkZXJcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsYWJlbEVuZGluZ1xuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqIEBkZWZhdWx0IDE1XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZmluYWxcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwibGFiZWxFbmRpbmdcIikud2hpY2guaXNBbihcImludGVnZXJcIikuZGVmYXVsdHNUbygxNSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlZCB2YWx1ZSBvZiB0aGUgd2lkdGggb2YgdGhlIExlZ2VuZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIHtGbG9hdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmaW5hbFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJ3aWR0aFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlZCB2YWx1ZSBvZiB0aGUgaGVpZ2h0IG9mIHRoZSBMZWdlbmQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAgICogQHR5cGUge0Zsb2F0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZpbmFsXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImhlaWdodFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlZCBgeGAgdmFsdWUgb2YgdGhlIExlZ2VuZCdzIGxvd2VyIGxlZnQgY29ybmVyIHJlbGF0aXZlIHRvIGl0cyBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB4XG4gICAgICogQHR5cGUge0Zsb2F0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZpbmFsXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInhcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZWQgYHlgIHZhbHVlIG9mIHRoZSBMZWdlbmQncyBsb3dlciBsZWZ0IGNvcm5lciByZWxhdGl2ZSB0byBpdHMgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgeVxuICAgICAqIEB0eXBlIHtGbG9hdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmaW5hbFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJ5XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVkIHdpZHRoIG9mIGFuIGluZGl2aWR1YWwgcGxvdCBlbnRyeS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBibG9ja1dpZHRoXG4gICAgICogQHR5cGUge0Zsb2F0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZpbmFsXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImJsb2NrV2lkdGhcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZWQgaGVpZ2h0IG9mIGFuIGluZGl2aWR1YWwgcGxvdCBlbnRyeS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBibG9ja0hlaWdodFxuICAgICAqIEB0eXBlIHtGbG9hdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmaW5hbFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJibG9ja0hlaWdodFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlZCB3aWR0aCBvZiB0aGUgbG9uZ2VzdCBsYWJlbCBvZiBhbGwgcGxvdCBlbnRyaWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG1heExhYmVsV2lkdGhcbiAgICAgKiBAdHlwZSB7RmxvYXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZmluYWxcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwibWF4TGFiZWxXaWR0aFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIHZhbHVlIG9mIHRoZSBJY29uJ3MgaGVpZ2h0IGFuZCB0aGUgY29tcHV0ZWQgaGVpZ2h0IG9mIHRoZSB0YWxsZXN0IGxhYmVsIG9mIGFsbCBwbG90IGVudHJpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbWF4TGFiZWxIZWlnaHRcbiAgICAgKiBAdHlwZSB7RmxvYXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZmluYWxcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwibWF4TGFiZWxIZWlnaHRcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZGV0ZXJtaW5lVmlzaWJpbGl0eVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy52aXNpYmxlKCkpIHtcbiAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgIGlmICh0aGlzLnBsb3RzKCkuc2l6ZSgpID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBMZWdlbmQncyBnZW9tZXRyeS4gRGV0ZXJtaW5lcyB2YWx1ZXMgZm9yIHRoZSBpbnRlcm5hbCBhdHRyaWJ1dGVzIGBtYXhMYWJlbFdpZHRoYCxcbiAgICAgKiBgbWF4TGFiZWxIZWlnaHRgLCBgYmxvY2tXaWR0aGAsIGBibG9ja0hlaWdodGAsIGB3aWR0aGAsIGBoZWlnaHRgLCBgeGAgYW5kIGB5YDsgdGhlc2UgdmFsdWVzXG4gICAgICogZGV0ZXJtaW5lIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGFuZCBpdHMgdmFyaW91cyBpbnRlcm5hbCBjb21wb25lbnRzLCBhbmQgbmVlZFxuICAgICAqIHRvIGJlIHJlY29tcHV0ZWQgd2hlbmV2ZXIgdGhlIGdlb21ldHJ5IG9mIHRoZSBjb250YWluaW5nIGdyYXBoIGNoYW5nZXM7ICB0aGlzIG1ldGhvZCBpc1xuICAgICAqIGNhbGxlZCBieSBHcmFwaC5pbml0aWFsaXplR2VvbWV0cnkoKS5cbiAgICAgKiBcbiAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVHZW9tZXRyeVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcGFyYW0ge0dyYXBofSBncmFwaCBKZXJtYWluZSBHcmFwaCBtb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGljc0NvbnRleHQgZHJpdmVyLXNwZWNpZmljIGdyYXBoaWNzIGNvbnRleHQgb2JqZWN0XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqIEB0b2RvIEZpbmQgb3V0IHdoZXRoZXIgb3Igbm90IHBhZGRpbmcgbmVlZHMgdG8gYmUgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uLlxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImluaXRpYWxpemVHZW9tZXRyeVwiLCBmdW5jdGlvbiAoZ3JhcGgsIGdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgICB2YXIgYW5jaG9yICAgICA9IHRoaXMuYW5jaG9yKCksXG4gICAgICAgICAgICBiYXNlICAgICAgID0gdGhpcy5iYXNlKCksXG4gICAgICAgICAgICBwb3NpdGlvbiAgID0gdGhpcy5wb3NpdGlvbigpLFxuICAgICAgICAgICAgaWNvbk9mZnNldCA9IHRoaXMuaWNvbk9mZnNldCgpLFxuICAgICAgICAgICAgd2lkdGhzICA9IFtdLFxuICAgICAgICAgICAgaGVpZ2h0cyA9IFtdLFxuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmICh0aGlzLmRldGVybWluZVZpc2liaWxpdHkoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucGxvdHMoKS5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgbGFiZWwgPSB0aGlzLnBsb3RzKCkuYXQoaSkubGVnZW5kKCkubGFiZWwoKTtcbiAgICAgICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwuaW5pdGlhbGl6ZUdlb21ldHJ5KGdyYXBoaWNzQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgd2lkdGhzLnB1c2gobGFiZWwub3JpZ1dpZHRoKCkpO1xuICAgICAgICAgICAgICAgIGhlaWdodHMucHVzaChsYWJlbC5vcmlnSGVpZ2h0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2lkdGhzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiIC0gYTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhlaWdodHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgLSBhO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhMYWJlbFdpZHRoKHdpZHRoc1swXSk7XG4gICAgICAgIHRoaXMubWF4TGFiZWxIZWlnaHQoTWF0aC5tYXgoaGVpZ2h0c1swXSwgdGhpcy5pY29uKCkuaGVpZ2h0KCkpKTtcblxuICAgICAgICB0aGlzLmJsb2NrV2lkdGgoaWNvbk9mZnNldCArIHRoaXMuaWNvbigpLndpZHRoKCkgKyB0aGlzLmxhYmVsT2Zmc2V0KCkgKyB0aGlzLm1heExhYmVsV2lkdGgoKSArIHRoaXMubGFiZWxFbmRpbmcoKSk7XG4gICAgICAgIHRoaXMuYmxvY2tIZWlnaHQoaWNvbk9mZnNldCArIHRoaXMubWF4TGFiZWxIZWlnaHQoKSk7XG5cbiAgICAgICAgLy8gVE9ETzogZmluZCBvdXQgd2hldGhlciBvciBub3QgcGFkZGluZyBuZWVkcyB0byBiZSB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb25cbiAgICAgICAgdGhpcy53aWR0aCgoMiAqIHRoaXMuYm9yZGVyKCkpICsgKHRoaXMuY29sdW1ucygpICogdGhpcy5ibG9ja1dpZHRoKCkpKTtcbiAgICAgICAgdGhpcy5oZWlnaHQoKDIgKiB0aGlzLmJvcmRlcigpKSArICh0aGlzLnJvd3MoKSAqIHRoaXMuYmxvY2tIZWlnaHQoKSkgKyBpY29uT2Zmc2V0KTtcblxuICAgICAgICBpZiAodGhpcy5mcmFtZSgpID09PSBcInBhZGRpbmdcIikge1xuICAgICAgICAgICAgdGhpcy54KCgoYmFzZS54KCkgKyAxKSAqIGdyYXBoLnBhZGRpbmdCb3goKS53aWR0aCgpLzIpICAtICgoYW5jaG9yLngoKSArIDEpICogdGhpcy53aWR0aCgpLzIpICArIHBvc2l0aW9uLngoKSk7XG4gICAgICAgICAgICB0aGlzLnkoKChiYXNlLnkoKSArIDEpICogZ3JhcGgucGFkZGluZ0JveCgpLmhlaWdodCgpLzIpIC0gKChhbmNob3IueSgpICsgMSkgKiB0aGlzLmhlaWdodCgpLzIpICsgcG9zaXRpb24ueSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueCgoKGJhc2UueCgpICsgMSkgKiBncmFwaC5wbG90Qm94KCkud2lkdGgoKS8yKSAgICAgLSAoKGFuY2hvci54KCkgKyAxKSAqIHRoaXMud2lkdGgoKS8yKSAgKyBwb3NpdGlvbi54KCkpO1xuICAgICAgICAgICAgdGhpcy55KCgoYmFzZS55KCkgKyAxKSAqIGdyYXBoLnBsb3RCb3goKS5oZWlnaHQoKS8yKSAgICAtICgoYW5jaG9yLnkoKSArIDEpICogdGhpcy5oZWlnaHQoKS8yKSArIHBvc2l0aW9uLnkoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGxlZ2VuZDsgY2FsbHMgdmFyaW91cyBkcml2ZXItc3BlY2lmaWMgZ3JhcGhpY3MgZnVuY3Rpb25zIHRvIGRvIHRoZVxuICAgICAqIGFjdHVhbCBkcmF3aW5nIG9mIHRoZSB2YXJpb3VzIHBhcnRzIG9mIHRoZSBsZWdlbmQgKGJhY2tncm91bmQsIGJvcmRlcnMsIGljb25zLFxuICAgICAqIHRleHQpLlxuICAgICAqIFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGljc0NvbnRleHQgZHJpdmVyLXNwZWNpZmljIGdyYXBoaWNzIGNvbnRleHQgb2JqZWN0XG4gICAgICogXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInJlbmRlclwiLCBmdW5jdGlvbiAoZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIHZhciBwbG90cyA9IHRoaXMucGxvdHMoKSxcbiAgICAgICAgICAgIGljb24gID0gdGhpcy5pY29uKCksXG4gICAgICAgICAgICBibG9ja3gsIGJsb2NreSxcbiAgICAgICAgICAgIGljb254LCBpY29ueSxcbiAgICAgICAgICAgIGxhYmVseCwgbGFiZWx5LFxuICAgICAgICAgICAgcGxvdENvdW50ID0gMCxcbiAgICAgICAgICAgIHIsIGM7XG5cbiAgICAgICAgaWYgKHRoaXMuZGV0ZXJtaW5lVmlzaWJpbGl0eSgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIGFueSBuZWNjZXNhcnkgc2V0dXBcbiAgICAgICAgdGhpcy5iZWdpbihncmFwaGljc0NvbnRleHQpO1xuXG4gICAgICAgIC8vIERyYXcgdGhlIGxlZ2VuZCBib3hcbiAgICAgICAgdGhpcy5yZW5kZXJMZWdlbmQoZ3JhcGhpY3NDb250ZXh0KTtcblxuICAgICAgICBmb3IgKHIgPSAwOyByIDwgdGhpcy5yb3dzKCk7IHIrKykge1xuICAgICAgICAgICAgaWYgKHBsb3RDb3VudCA+PSBwbG90cy5zaXplKCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NreSA9IHRoaXMuYm9yZGVyKCkgKyAoKHRoaXMucm93cygpIC0gciAtIDEpICogdGhpcy5ibG9ja0hlaWdodCgpKTtcbiAgICAgICAgICAgIGljb255ICA9IGJsb2NreSArIHRoaXMuaWNvbk9mZnNldCgpO1xuICAgICAgICAgICAgbGFiZWx5ID0gaWNvbnk7XG4gICAgICAgICAgICBmb3IgKGMgPSAwOyBjIDwgdGhpcy5jb2x1bW5zKCk7IGMrKykge1xuICAgICAgICAgICAgICAgIGlmIChwbG90Q291bnQgPj0gcGxvdHMuc2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBibG9ja3ggPSB0aGlzLmJvcmRlcigpICsgKGMgKiB0aGlzLmJsb2NrV2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgaWNvbnggID0gYmxvY2t4ICsgdGhpcy5pY29uT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgbGFiZWx4ID0gaWNvbnggKyBpY29uLndpZHRoKCkgKyB0aGlzLmxhYmVsT2Zmc2V0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBpY29uXG4gICAgICAgICAgICAgICAgcGxvdHMuYXQocGxvdENvdW50KS5yZW5kZXJlcigpLnJlbmRlckxlZ2VuZEljb24oZ3JhcGhpY3NDb250ZXh0LCBpY29ueCwgaWNvbnksIGljb24sIHRoaXMub3BhY2l0eSgpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBpY29uIGJvcmRlclxuICAgICAgICAgICAgICAgIGlmIChpY29uLmJvcmRlcigpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpY29uLnJlbmRlckJvcmRlcihncmFwaGljc0NvbnRleHQsIGljb254LCBpY29ueSwgdGhpcy5vcGFjaXR5KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSB0aGUgdGV4dFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWwocGxvdHMuYXQocGxvdENvdW50KS5sZWdlbmQoKS5sYWJlbCgpLCBncmFwaGljc0NvbnRleHQsIGxhYmVseCwgbGFiZWx5KTtcblxuICAgICAgICAgICAgICAgIHBsb3RDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlZm9ybSBhbnkgbmVjY2VzYXJ5IHN0ZXBzIGF0IHRoZSBlbmQgb2YgcmVuZGVyaW5nXG4gICAgICAgIHRoaXMuZW5kKGdyYXBoaWNzQ29udGV4dCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJub3JtYWxpemVcIiwgZnVuY3Rpb24gKGdyYXBoKSB7XG4gICAgICAgIHZhciBsZWdlbmRQbG90cyA9IHRoaXMucGxvdHMoKSxcbiAgICAgICAgICAgIGdyYXBoUGxvdHMgID0gZ3JhcGgucGxvdHMoKSxcbiAgICAgICAgICAgIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMsXG4gICAgICAgICAgICByb3dzICAgID0gdGhpcy5yb3dzLFxuICAgICAgICAgICAgaSwgaixcbiAgICAgICAgICAgIGZsYWc7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gc3RvcmVzIHBvaW50ZXJzIHRvIHBsb3RzIHdpdGggbGVnZW5kcyBpbiB0aGUgTGVnZW5kIG9iamVjdFxuICAgICAgICAvL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JhcGhQbG90cy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgLy8gZG9lc24ndCBhZGQgYSBwbG90IGlmIGl0IGRvZXNuJ3QgaGF2ZSBhIHZpc2libGUgbGVnZW5kXG4gICAgICAgICAgICBpZiAoIWdyYXBoUGxvdHMuYXQoaSkubGVnZW5kKCkgfHwgZ3JhcGhQbG90cy5hdChpKS5sZWdlbmQoKS52aXNpYmxlKCkgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG9lc24ndCBhZGQgYSBwbG90IGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWRkZWRcbiAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZWdlbmRQbG90cy5zaXplKCk7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChncmFwaFBsb3RzLmF0KGkpID09PSBsZWdlbmRQbG90cy5hdChqKSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVnZW5kUGxvdHMuYWRkKGdyYXBoUGxvdHMuYXQoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBsb3RzIGluIHRoZSBsZWdlbmQgZGVmYXVsdCB0byAxIHJvdyBhbmQgY29sdW1uIGlmIHRoZXkgYXJlbid0IHNwZWNpZmllZFxuICAgICAgICAvL1xuICAgICAgICBpZiAobGVnZW5kUGxvdHMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1ucygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvd3MoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcm93cygxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmIG5laXRoZXIgcm93cyBub3IgY29scyBpcyBzcGVjaWZpZWQsIGRlZmF1bHQgdG8gMSBjb2xcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHJvd3MoKSA9PT0gdW5kZWZpbmVkICYmIGNvbHVtbnMoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2x1bW5zKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaWYgb25seSBvbmUgb2Ygcm93cy9jb2xzIGlzIHNwZWNpZmllZCwgY29tcHV0ZSB0aGUgb3RoZXJcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGNvbHVtbnMoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2x1bW5zKHBhcnNlSW50KGxlZ2VuZFBsb3RzLnNpemUoKSAvIHJvd3MoKSArICggKGxlZ2VuZFBsb3RzLnNpemUoKSAlIHJvd3MoKSkgPiAwID8gMSA6IDAgKSwgMTApKTtcbiAgICAgICAgfSBlbHNlIGlmIChyb3dzKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcm93cyhwYXJzZUludChsZWdlbmRQbG90cy5zaXplKCkgLyBjb2x1bW5zKCkgKyAoIChsZWdlbmRQbG90cy5zaXplKCkgJSBjb2x1bW5zKCkpID4gMCA/IDEgOiAwICksIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5sZWdlbmQsIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGVnZW5kO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG4vKipcbiAqIFRoZSBNaXhpbiBtb2RlbCBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IGZvciBKZXJtYWluZVxuICogYXBwbGljYXRpb25zIHRvIFwibWl4IGluXCIgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IHRvIGEgbW9kZWwsXG4gKiBmcm9tIG91dHNpZGUgdGhlIG1vZGVsJ3MgaW5pdGlhbCBkZWZpbml0aW9uLlxuICogXG4gKiBUaGUgYWJpbGl0eSB0byBhZGQgZmVhdHVyZXMgKG1ldGhvZHMgYW5kL29yIGF0dHJpYnV0ZXMpIHRvIGFcbiAqIEplcm1haW5lIG1vZGVsIG91dHNpZGUgaXRzIGluaXRpYWwgZGVmaW5pdGlvbiBhbHJlYWR5IGV4aXN0cyBpblxuICogSmVybWFpbmUgLS0gdGhpcyBNaXhpbiBtb2RlbCBkb2VzIG5vdCBhY3R1YWxseSBhZGQgbmV3XG4gKiBmdW5jdGlvbmFsaXR5IHRvIEplcm1haW5lOyBpdCBqdXN0IHByb3ZpZGVzIGEgY29udmVuaWVudFxuICogcGF0dGVybiBmb3IgZ3JvdXBpbmcgYWRkaXRpb25hbCBmZWF0dXJlcyB0b2dldGhlciBhbmQgYXBwbHlpbmdcbiAqIHRoZW0gdG8gYSBtb2RlbCBhcyBhIGdyb3VwLlxuICogXG4gKiBUaGUgTWl4aW4gbW9kZWwgbWFpbnRhaW5zIGFuIGludGVybmFsIGxpc3Qgb2YgZnVuY3Rpb25zLCBjYWxsZWRcbiAqIG1peGluIGZ1bmN0aW9ucywgYW5kIHByb3ZpZGVzIGFuIGFkZCgpIG1ldGhvZCBmb3IgYWRkaW5nIGFcbiAqIGZ1bmN0aW9uIHRvIHRoYXQgbGlzdC5cbiAqIFxuICogVGhlIGFwcGx5KCkgbWV0aG9kIGNhbGxzIGFsbCBvZiB0aGUgbWl4aW5mdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW5cbiAqIGFkZGVkIHRvIHRoZSBsaXN0LCBwYXNzaW5nIGVhY2ggb25lIHRoZSBzYW1lIGFyZ3VtZW50c1xuICogdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgYXBwbHkoKSBmdW5jdGlvbiBpdHNlbGYuXG4gKiBcbiAqIFRoYXQncyBpdC4gIFRoYXQncyBhbGwgdGhlIE1peGluIGNsYXNzIGRvZXMuICBJdCdzIHVwIHRvIHlvdSB0b1xuICogcHV0IHdoYXRldmVyIGplcm1haW5lLW1vZGVsLWV4dGVuZGluZyBjb2RlIHlvdSB3YW50IGluIHRoZVxuICogbWl4aW4gZnVuY3Rpb25zIHlvdSBhZGQgdG8gdGhlIE1peGluOyB0aGUgTWl4aW4gc2ltcGx5IHNlcnZlc1xuICogYXMgYSBwbGFjZSB0byBob2xkIHRoZW0gYWxsLCBhbmQgYSBjb252ZW5pZW50IHdheSB0byBleGVjdXRlXG4gKiB0aGVtIGFsbCBhdCBvbmNlLlxuICpcbiAqIEBjbGFzcyBNaXhpblxuICogQGZvciBNaXhpblxuICogQGF1dGhvciBtYnBcbiAqL1xudmFyIE1peGluID0gbmV3IGplcm1haW5lLk1vZGVsKFwiTWl4aW5cIiwgZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGJlIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbWl4aW5mdW5jc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge31cbiAgICAgKiBAYXV0aG9yIG1icFxuICAgICAqL1xuICAgIHRoaXMuaGFzTWFueShcIm1peGluZnVuY3NcIik7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB2YWx1ZSBmb3IgdHJhY2tpbmcgd2hldGhlciBhcHBseSgpIGhhcyBiZWVuIGNhbGxlZFxuICAgICAqIGZvciB0aGlzIE1peGluLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFwcGxpZWRcbiAgICAgKiBAdHlwZSB7fVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGF1dGhvciBtYnBcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJhcHBsaWVkXCIpLndoaWNoLmlzQShcImJvb2xlYW5cIikuZGVmYXVsdHNUbyhmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZnVuY3Rpb24gdG8gdGhpcyBNaXhpbidzIG1peGluIGxpc3QuICBEb2VzIG5vdCBjaGVja1xuICAgICAqIHRvIHNlZSBpZiB0aGUgZnVuY3Rpb24gaXMgYWxyZWFkeSBvbiB0aGUgbGlzdCAtLSBqdXN0IGJsaW5kbHlcbiAgICAgKiBhcHBlbmRzIHRoZSBnaXZlbiBmdW5jdGlvbiB0byB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkXG4gICAgICogQHBhcmFtIHt9IGZ1bmNcbiAgICAgKiBAYXV0aG9yIG1icFxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImFkZFwiLCBmdW5jdGlvbiAobWl4aW5mdW5jKSB7XG4gICAgICAgIHRoaXMubWl4aW5mdW5jcygpLmFkZChtaXhpbmZ1bmMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbCBlYWNoIG9mIHRoaXMgTWl4aW4ncyBtaXhpbiBmdW5jdGlvbnMuICBBbnlcbiAgICAgKiBhcmd1bWVudHMgcGFzc2VkIHRvIGFwcGx5KCkgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0byBlYWNoXG4gICAgICogbWl4aW4gZnVuY3Rpb24gY2FsbGVkLlxuICAgICAqIFxuICAgICAqIGFwcGx5KCkgY2hlY2tzIHRvIHNlZSB3aGV0aGVyIGl0IGhhcyBldmVyIGJlZW4gY2FsbGVkXG4gICAgICogYmVmb3JlIGZvciB0aGlzIE1peGluLCBhbmQgb25seSBleGVjdXRlcyB0aGUgbWl4aW5cbiAgICAgKiBmdW5jdGlvbnMgaWYgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCB0byBhcHBseSgpOyBjYWxscyB0b1xuICAgICAqIGFwcGx5KCkgYWZ0ZXIgdGhlIGZpcnN0IG9uZSB3aWxsIGhhdmUgbm8gZWZmZWN0LiAgKFRoaXMgaXNcbiAgICAgKiB0cnVlIGV2ZW4gaWYgYWRkaXRpb25hbCBtaXhpbiBmdW5jdGlvbnMgYXJlIGFkZGVkIGFmdGVyXG4gICAgICogYXBwbHkoKSBpcyBjYWxsZWQ7IHRoZSBNaXhpbiBtYWludGFpbnMgYSBzaW5nbGUgaW50ZXJuYWxcbiAgICAgKiBCb29sZWFuIHZhbHVlIHRoYXQgdHJhY2tzIHdoZXRoZXIgYXBwbHkoKSBoYXMgYmVlbiBjYWxsZWQuKVxuICAgICAqXG4gICAgICogQG1ldGhvZCBhcHBseVxuICAgICAqIEBhdXRob3IgbWJwXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiYXBwbHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoISB0aGlzLmFwcGxpZWQoKSkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTx0aGlzLm1peGluZnVuY3MoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWl4aW5mdW5jcygpLmF0KGkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBsaWVkKHRydWUpO1xuICAgIH0pO1xuXG5cbiAgICAvKipcbiAgICAgKiBKdXN0IGxpa2UgYXBwbHkoKSwgYnV0IGZvcmNlcyB0aGUgbWl4aW4gZnVuY3Rpb25zIHRvIGJlIGNhbGxlZFxuICAgICAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBhcHBseSgpIHdhcyBwcmV2aW91c2x5IGNhbGxlZCBmb3IgdGhpc1xuICAgICAqIE1peGluLlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZWFwcGx5XG4gICAgICogQGF1dGhvciBtYnBcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZWFwcGx5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hcHBsaWVkKGZhbHNlKTtcbiAgICAgICAgdGhpcy5hcHBseS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWl4aW47XG4iLCIvLyBUaGlzIGZpbGUgdXNlcyBqUXVlcnkuICBBIHZhbGlkIGpRdWVyeSBvYmplY3QgbXVzdCBiZSBwYXNzZWQgdG8gdGhlXG4vLyBmdW5jdGlvbiByZXR1cm5lZCBieSByZXF1aXJpbmcgdGhpcyBmaWxlLlxudmFyIE11bHRpZ3JhcGg7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICBpZiAodHlwZW9mKE11bHRpZ3JhcGgpICE9PSBcInVuZGVmaW5lZFwiKSB7IHJldHVybiBNdWx0aWdyYXBoOyB9XG5cbiAgICB2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgTXVsdGlncmFwaCBKZXJtYWluZSBtb2RlbCBpcyB0aGUgcm9vdCBjbGFzcyBmb3IgdGhlIGpzLW11bHRpZ3JhcGggcHJvamVjdC5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBNdWx0aWdyYXBoXG4gICAgICogQGZvciBNdWx0aWdyYXBoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgTXVsdGlncmFwaCA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIk11bHRpZ3JhcGhcIiwgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBKZXJtaWFuZSBBdHRyX0xpc3Qgb2YgYWxsIHRoZSBncmFwaHMgaW4gYSBNdWx0aWdyYXBoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgZ3JhcGhzXG4gICAgICAgICAqIEB0eXBlIHtHcmFwaH1cbiAgICAgICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNNYW55KFwiZ3JhcGhzXCIpLmVhY2hPZldoaWNoLnZhbGlkYXRlV2l0aChmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgICAgICAgICAgIHZhciBHcmFwaCA9IHJlcXVpcmUoJy4vZ3JhcGguanMnKTtcbiAgICAgICAgICAgIHJldHVybiBncmFwaCBpbnN0YW5jZW9mIEdyYXBoO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpdiB0aGUgbXVsdGlncmFwaCBpcyByZW5kZXJlZCBpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGRpdlxuICAgICAgICAgKiBAdHlwZSB7SFRNTCBFbGVtZW50fVxuICAgICAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0EoXCJkaXZcIik7IC8vIHRoZSBhY3R1YWwgZGl2IGVsZW1lbnRcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVybCBmb3IgdGhlIG11Z2wgZmlsZSB0aGlzIGdyYXBoIHdhcyBjcmVhdGVkIGZyb20sIGlmIGFueVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgbXVnbFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAYXV0aG9yIG1icFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNBKFwibXVnbFwiKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSmF2YVNjcmlwdCBhcnJheSBvZiBhamF4IHRocm90dGxlczsgZWFjaCBlbnRyeSBpbiB0aGlzIGFycmF5IGlzIGFuXG4gICAgICAgICAqIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogICAgcmVnZXggICAgICAgIDogcmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyBVUkxzXG4gICAgICAgICAqICAgIGFqYXh0aHJvdHRsZSA6IGluc3RhbmNlIG9mICQuYWpheHRocm90dGxlXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcHJvcGVydHkgYWpheHRocm90dGxlc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqIEBhdXRob3IgbWJwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0EoXCJhamF4dGhyb3R0bGVzXCIpO1xuXG4gICAgICAgIHRoaXMuaXNCdWlsdFdpdGgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmFqYXh0aHJvdHRsZXMoW10pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJhZGRBamF4VGhyb3R0bGVcIiwgZnVuY3Rpb24gKHBhdHRlcm4sIHJlcXVlc3RzLCBwZXJpb2QsIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYWpheHRocm90dGxlcygpLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlZ2V4ICAgICAgICA6IHBhdHRlcm4gPyBuZXcgUmVnRXhwKHBhdHRlcm4pIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGFqYXh0aHJvdHRsZSA6ICQuYWpheHRocm90dGxlKHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUmVxdWVzdHNQZXJUaW1lUGVyaW9kIDogcGFyc2VJbnQocmVxdWVzdHMsMTApLFxuICAgICAgICAgICAgICAgICAgICB0aW1lUGVyaW9kICAgICAgICAgICAgICAgOiBwYXJzZUludChwZXJpb2QsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4Q29uY3VycmVudCAgICAgICAgICAgIDogcGFyc2VJbnQoY29uY3VycmVudCwgMTApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJnZXRBamF4VGhyb3R0bGVcIiwgZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgdmFyIHRocm90dGxlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgJC5lYWNoKHRoaXMuYWpheHRocm90dGxlcygpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVnZXggfHwgdGhpcy5yZWdleC50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUgPSB0aGlzLmFqYXh0aHJvdHRsZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRocm90dGxlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyYW5zZm9ybXMgYSBnaXZlbiBVUkwgc28gdGhhdCBpdFxuICAgICAgICAgKiBpcyByZWxhdGl2ZSB0byB0aGUgc2FtZSBiYXNlIGFzIHRoZSBVUkwgZnJvbSB3aGljaCB0aGUgTVVHTFxuICAgICAgICAgKiBmaWxlIHdhcyBsb2FkZWQuICBJZiB0aGlzIGdyYXBoIHdhcyBub3QgY3JlYXRlZCBmcm9tIGEgTVVHTFxuICAgICAgICAgKiBmaWxlIChlaXRoZXIgaXQgY2FtZSBmcm9tIGEgTVVHTCBzdHJpbmcsIG9yIHdhcyBjcmVhdGVkIHByb2dyYW1tYXRpY2FsbHkpLFxuICAgICAgICAgKiB0aGUgVVJMIGlzIHJldHVybmVkIHVuY2hhbmdlZC5cbiAgICAgICAgICogXG4gICAgICAgICAqIElmIHRoZSBVUkwgdG8gYmUgcmViYXNlZCBpcyBhYnNvbHV0ZSAoY29udGFpbnMgJzovLycpXG4gICAgICAgICAqIG9yIHJvb3QtcmVsYXRpdmUgKHN0YXJ0cyB3aXRoIGEgJy8nKSwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgICAgICAgKiBcbiAgICAgICAgICogT3RoZXJpc2UsIHRoZSBnaXZlbiBVUkwgaXMgcmVsYXRpdmUsIGFuZCB3aGhhdCBpcyByZXR1cm5lZCBpcyBhXG4gICAgICAgICAqIG5ldyBVUkwgb2J0YWluZWQgYnkgaW50ZXJwcmV0aW5nIGl0IHJlbGF0aXZlIHRvIHRoZSBVUkxcbiAgICAgICAgICogZnJvbSB3aGljaCB0aGUgTVVHTCB3YXMgbG9hZGVkLiBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcInJlYmFzZVVybFwiLCBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIHZhciBiYXNldXJsID0gdGhpcy5tdWdsKCk7XG4gICAgICAgICAgICBpZiAoISBiYXNldXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvXlxcLy8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgLy8gdXJsIGlzIHJvb3QtcmVsYXRpdmUgKHN0YXJ0cyB3aXRoIGEgJy8nKTsgcmV0dXJuIGl0IHVubW9kaWZpZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC86XFwvXFwvLy50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cmwgY29udGFpbnMgJzovLycsIHNvIGFzc3VtZSBpdCdzIGEgZnVsbCB1cmwsIHJldHVybiBpdCB1bm1vZGlmaWVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgYmFzZXVybCB0byBhIHJlYWwgYmFzZSBwYXRoLCBieSBlbGltaW5hdGluZyBhbnkgdXJsIGFyZ3MgYW5kXG4gICAgICAgICAgICAvLyBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaW5hbCAnLydcbiAgICAgICAgICAgIGlmICghL15cXC8vLnRlc3QoYmFzZXVybCkgICYmICEvOlxcL1xcLy8udGVzdChiYXNldXJsKSAmJiAhL15cXC5cXC8vLnRlc3QoYmFzZXVybCkpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBtYWtlIHN1cmUgdGhhdCBpZiBiYXNldXJsIGlzIHJlbGF0aXZlLCBpdCBzdGFydHMgd2l0aCAnLi8nXG4gICAgICAgICAgICAgICAgYmFzZXVybCA9ICcuLycgKyBiYXNldXJsOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2V1cmwgPSBiYXNldXJsLnJlcGxhY2UoL1xcPy4qJC8sICcnKTsgLy8gcmVtb3ZlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0ICc/J1xuICAgICAgICAgICAgYmFzZXVybCA9IGJhc2V1cmwucmVwbGFjZSgvXFwvW15cXC9dKiQvLCAnLycpOyAvLyByZW1vdmUgZXZlcnl0aGluZyBhZnRlciB0aGUgbGFzdCAnLydcbiAgICAgICAgICAgIHJldHVybiBiYXNldXJsICsgdXJsO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJ1c3kgc3Bpbm5lclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgYnVzeVNwaW5uZXJcbiAgICAgICAgICogQHR5cGUge0hUTUwgRWxlbWVudH1cbiAgICAgICAgICogQGF1dGhvciBtYnBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQShcImJ1c3lTcGlubmVyXCIpOyAvLyB0aGUgYnVzeV9zcGlubmVyIGRpdlxuXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcImJ1c3lTcGlubmVyTGV2ZWxcIiwgZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5idXN5U3Bpbm5lcigpKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLmJ1c3lTcGlubmVyKCkpLmJ1c3lfc3Bpbm5lcignbGV2ZWwnLCBkZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBNdWx0aWdyYXBoJ3MgZ2VvbWV0cnkgYnkgY2FsbGluZyB0aGUgYGluaXRpYWxpemVHZW9tZXRyeWAgZnVuY3Rpb24gb2ZcbiAgICAgICAgICogZWFjaCBvZiBpdHMgZ3JhcGggY2hpbGRyZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZUdlb21ldHJ5XG4gICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gd2lkdGggV2lkdGggb2YgdGhlIG11bHRpZ3JhcGgncyBkaXYuXG4gICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgbXVsdGlncmFwaCdzIGRpdi5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoaWNzQ29udGV4dFxuICAgICAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJpbml0aWFsaXplR2VvbWV0cnlcIiwgZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5ncmFwaHMoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhzKCkuYXQoaSkuaW5pdGlhbGl6ZUdlb21ldHJ5KHdpZHRoLCBoZWlnaHQsIGdyYXBoaWNzQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252aWVuY2UgZnVuY3Rpb24gZm9yIHJlZ2lzdGVyaW5nIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgZGF0YSBiZWNvbWluZyByZWFkeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3RlckNvbW1vbkRhdGFDYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSByZWdpc3RlcmVkLlxuICAgICAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZWdpc3RlckNvbW1vbkRhdGFDYWxsYmFja1wiLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZ3JhcGhzKCkuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBocygpLmF0KGkpLnJlZ2lzdGVyQ29tbW9uRGF0YUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXNwb25kc1RvKFwibm9ybWFsaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZ3JhcGhzKCkuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBocygpLmF0KGkpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJkZXN0cm95XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5ncmFwaHMoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhzKCkuYXQoaSkuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGNhbnZhcyBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnJvd3Nlckhhc0NhbnZhc1N1cHBvcnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgTXVsdGlncmFwaC5icm93c2VySGFzQ2FudmFzU3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2FybmluZzogdGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBnbG9iYWwgdmFyaWFibGVzIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgXG4gICAgICAgIC8vIC0tLSBpdCBkb2VzIG5vdCByZWx5IG9uIHRoZXNlIHZhcmlhYmxlcyBiZWluZyBwYXNzZWQgaW4gYXMgaXMgdGhlXG4gICAgICAgIC8vIGNhc2Ugd2l0aCAnJCcgYWJvdmUuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKCEhd2luZG93LkhUTUxDYW52YXNFbGVtZW50KSAmJlxuICAgICAgICAgICAgICAgICghIXdpbmRvdy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpICYmXG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIShlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KCcyZCcpKTtcbiAgICAgICAgICAgICAgICB9KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKSlcbiAgICAgICAgICAgICk7XG4gICAgfTtcbiAgICBcbiAgICBNdWx0aWdyYXBoLmJyb3dzZXJIYXNTVkdTdXBwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXYXJuaW5nOiB0aGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdsb2JhbCB2YXJpYWJsZSBgZG9jdW1lbnRgXG4gICAgICAgIC8vIC0tLSBpdCBkb2VzIG5vdCByZWx5IG9uIHRoaXMgdmFyaWFibGUgYmVpbmcgcGFzc2VkIGluIGFzIGlzIHRoZVxuICAgICAgICAvLyBjYXNlIHdpdGggJyQnIGFib3ZlLlxuICAgICAgICByZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiZcbiAgICAgICAgICAgICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIFwic3ZnXCIpLmNyZWF0ZVNWR1JlY3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBNdWx0aWdyYXBoIGFjY29yZGluZyB0byBzcGVjaWZpZWQgb3B0aW9ucy4gUmV0dXJucyBhXG4gICAgICogalF1ZXJ5IGBwcm9taXNlYCB3aGljaCBpbnRlcmFjdHMgd2l0aCB0aGUgbXVsdGlncmFwaCB0aHJvdWdoIGl0c1xuICAgICAqIGBkb25lYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlR3JhcGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SFRNTCBFbGVtZW50fGpRdWVyeSBPYmplY3R9IG9wdGlvbnMuZGl2IChSRVFVSVJFRClcbiAgICAgKiAgICAgIFRoZSBET00gZWxlbWVudCBkaXYgaW50byB3aGljaCB0aGUgbXVsdGlncmFwaCBzaG91bGQgYmVcbiAgICAgKiAgICAgIHBsYWNlZDsgdGhpcyB2YWx1ZSBtYXkgYmUgZWl0aGVyIChhKSBhIHN0cmluZyB3aGljaCBpcyB0YWtlblxuICAgICAqICAgICAgdG8gYmUgdGhlIGlkIGF0dHJpYnV0ZSBvZiBhIGRpdiBpbiB0aGUgcGFnZSwgKGIpIGEgcmVmZXJlbmNlXG4gICAgICogICAgICB0byB0aGUgZGl2IERPTSBlbGVtZW50IGl0c2VsZiwgb3IgKGMpIGEgalF1ZXJ5IG9iamVjdFxuICAgICAqICAgICAgY29ycmVzcG9uZGluZyB0byB0aGUgZGl2IERPTSBlbGVtZW50LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7VVJJfSBvcHRpb25zLm11Z2wgKFJFUVVJUkVELCB1bmxlc3MgbXVnbFN0cmluZyBpcyBwcmVzZW50KVxuICAgICAqICAgICAgIHRoZSBVUkwgZnJvbSB3aGljaCB0aGUgTVVHTFxuICAgICAqICAgICAgIGZpbGUgZm9yIHRoZSBNdWx0aWdyYXBoIGNhbiBiZSBsb2FkZWRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5tdWdsU3RyaW5nIChSRVFVSVJFRCwgdW5sZXNzIG11Z2wgaXMgcHJlc2VudClcbiAgICAgKiAgICAgICBhIHN0cmluZyBjb250YWluaW5nIHRoZSBNVUdMIFhNTCBmb3IgdGhlIGdyYXBoXG4gICAgICogXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZHJpdmVyIChPUFRJT05BTCkgSW5kaWNhdGVzIHdoaWNoXG4gICAgICogICAgICAgZ3JhcGhpY3MgZHJpdmVyIHRvIHVzZTsgc2hvdWxkIGJlIG9uZSBvZiB0aGUgc3RyaW5nc1xuICAgICAqICAgICAgIFwiY2FudmFzXCIsIFwicmFwaGFlbFwiLCBvciBcImF1dG9cIi4gIFRoZSBkZWZhdWx0ICh3aGljaCBpc1xuICAgICAqICAgICAgIHVzZWQgaWYgdGhlICdkcml2ZXInIHRhZyBpcyBhYnNlbnQpIGlzIFwiYXV0b1wiLCB3aGljaFxuICAgICAqICAgICAgIGNhdXNlcyBNdWx0aWdyYXBoIHRvIGNoZWNrIHRoZSBmZWF0dXJlcyBvZiB0aGUgYnJvd3NlclxuICAgICAqICAgICAgIGl0IGlzIHJ1bm5pbmcgaW4gYW5kIGNob29zZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBkcml2ZXIuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5lcnJvciAoT1BUSU9OQUwpIEEgZnVuY3Rpb24gZm9yXG4gICAgICogICAgICAgZGlzcGxheWluZyBlcnJvciBtZXNzYWdlcyB0byB0aGUgdXNlci4gIE11bHRpZ3JhcGggd2lsbFxuICAgICAqICAgICAgIGNhbGwgdGhpcyBmdW5jdGlvbiBpZiBhbmQgd2hlbiBpdCBlbmNvdW50ZXJzIGFuIGVycm9yLiAgVGhlXG4gICAgICogICAgICAgZnVuY3Rpb24gc2hvdWxkIHJlY2VpdmUgYSBzaW5nbGUgYXJndW1lbnQgd2hpY2ggaXMgYW5cbiAgICAgKiAgICAgICBpbnN0YW5jZSBvZiB0aGUgSmF2YVNjcmlwdCBFcnJvciBvYmplY3QuICBUaGUgZGVmYXVsdCBpcyB0b1xuICAgICAqICAgICAgIHVzZSBNdWx0aWdyYXBoJ3Mgb3duIGludGVybmFsIG1lY2hhbmlzbSBmb3IgZGlzcGxheWluZyB1c2VyXG4gICAgICogICAgICAgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLndhcm5pbmcgKE9QVElPTkFMKSBBIGZ1bmN0aW9uIGZvclxuICAgICAqICAgICAgIGRpc3BsYXlpbmcgd2FybmluZyBtZXNzYWdlcyB0byB0aGUgdXNlci4gIE11bHRpZ3JhcGggd2lsbFxuICAgICAqICAgICAgIGNhbGwgdGhpcyBmdW5jdGlvbiBpZiBhbmQgd2hlbiBpdCBuZWVkcyB0byBkaXNwbGF5IGFcbiAgICAgKiAgICAgICB3YXJuaW5nIG1lc3NhZ2UuIFRoZSBmdW5jdGlvbiBzaG91bGQgcmVjZWl2ZSBhIHNpbmdsZVxuICAgICAqICAgICAgIGFyZ3VtZW50IHdoaWNoIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBKYXZhU2NyaXB0IEVycm9yXG4gICAgICogICAgICAgb2JqZWN0LiAgVGhlIGRlZmF1bHQgaXMgdG8gdXNlIE11bHRpZ3JhcGgncyBvd24gaW50ZXJuYWxcbiAgICAgKiAgICAgICBtZWNoYW5pc20gZm9yIGRpc3BsYXlpbmcgdXNlciBtZXNzYWdlcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBqUXVlcnkgcHJvbWlzZSB3aGljaCBwcm92aWRlcyBpbnRlcmFjdGlvbiB3aXRoXG4gICAgICogICAgIHRoZSBncmFwaCB0aHJvdWdoIGl0cyBgZG9uZWAgZnVuY3Rpb24uXG4gICAgICogQGF1dGhvciBtYnBcbiAgICAgKi9cbiAgICBNdWx0aWdyYXBoLmNyZWF0ZUdyYXBoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRpdiA9IG9wdGlvbnMuZGl2LFxuICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIsXG4gICAgICAgICAgICBkZWZhdWx0TWVzc2FnZUhhbmRsZXI7XG5cbiAgICAgICAgLy8gLy8gaWYgZHJpdmVyIHdhc24ndCBzcGVjaWZpZWQsIGNob29zZSB0aGUgYmVzdCBiYXNlZCBvbiBicm93c2VyIGNhcGFiaWxpdHlcbiAgICAgICAgLy8gaWYgKCFvcHRpb25zLmRyaXZlcikge1xuICAgICAgICAvLyAgICAgaWYgKG5zLmJyb3dzZXJIYXNDYW52YXNTdXBwb3J0KCkpIHtcbiAgICAgICAgLy8gICAgICAgICBvcHRpb25zLmRyaXZlciA9IFwiY2FudmFzXCI7XG4gICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgICAgIG9wdGlvbnMuZHJpdmVyID0gXCJyYXBoYWVsXCI7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gRm9yY2UgY2FudmFzIGRyaXZlciBmcm9tIG5vdyBvbjpcbiAgICAgICAgb3B0aW9ucy5kcml2ZXIgPSBcImNhbnZhc1wiO1xuXG4gICAgICAgIC8vIGlmIGRpdiBpcyBhIHN0cmluZywgYXNzdW1lIGl0J3MgYW4gaWQsIGFuZCBjb252ZXJ0IGl0IHRvIHRoZSBkaXYgZWxlbWVudCBpdHNlbGZcbiAgICAgICAgaWYgKHR5cGVvZihkaXYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkaXYgPSAkKFwiI1wiICsgZGl2KVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvcmNlIHRoZSBkaXYgdG8gaGF2ZSB0aGUgc3BlY2lmaWMgd2lkdGggb3IgaGVpZ2h0IGdpdmVuIGluIHRoZSBvcHRpb25zLCBpZiBhbnkuXG4gICAgICAgIC8vIEknbSBhZGRpbmcgdGhpcyBjb2RlIHRvIHJlc29sdmUgYSBwcm9ibGVtIHdpdGggdGhlIGRpdiBzaXplIHNvbWV0aW1lcyBub3QgYmVpbmdcbiAgICAgICAgLy8gYXZhaWxhYmxlIHdoZW4gc3JjL2dyYXBoaWNzL2NhbnZhcy9tdWx0aWdyYXBoLmpzOmNyZWF0ZUNhbnZhc0dyYXBoRnJvbVN0cmluZygpXG4gICAgICAgIC8vIGlzIHVzZWQ7IHNlZSB0aGUgbm90ZXMgaW4gdGhhdCBmaWxlLlxuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMud2lkdGggPiAwKSB7XG4gICAgICAgICAgICAkKGRpdikud2lkdGgob3B0aW9ucy53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAkKGRpdikuaGVpZ2h0KG9wdGlvbnMuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5PVEU6IGVhY2ggb2YgdGhlIE11bHRpZ3JhcGguY3JlYXRle0RSSVZFUn1HcmFwaCBmdW5jdGlvbnMgYmVsb3cgdGFrZXMgYW5cbiAgICAgICAgLy8gXCJvcHRpb25zXCIgb2JqZWN0IGFyZ3VtZW50IGp1c3QgbGlrZSBNdWx0aWdyYXBoLmNyZWF0ZUdyYXBoIGRvZXMuICBJbiBnZW5lcmFsIHRoaXNcbiAgICAgICAgLy8gXCJvcHRpb25zXCIgb2JqZWN0IGlzIHRoZSBzYW1lIGFzIHRoZSBvbmUgcGFzc2VkIHRvIHRoaXMgTXVsdGlncmFwaC5jcmVhdGVHcmFwaFxuICAgICAgICAvLyBmdW5jdGlvbiwgYnV0IGl0IGRpZmZlcnMgaW4gb25lIHdheTogSW5zdGVhZCBvZiBjb250YWluaW5nIHNlcGFyYXRlIFwiZXJyb3JcIiBhbmRcbiAgICAgICAgLy8gXCJ3YXJuaW5nXCIgcHJvcGVydGllcyB3aGljaCBhcmUgb3B0aW9uYWwsIHRoZSBcIm9wdGlvbnNcIiBvYmplY3QgcGFzc2VkIHRvIHRoZVxuICAgICAgICAvLyBNdWx0aWdyYXBoLmNyZWF0ZXtEUklWRVJ9R3JhcGggZnVuY3Rpb25zIHJlcXVpcmVzIGEgc2luZ2xlIChub24tb3B0aW9uYWwhKVxuICAgICAgICAvLyBcIm1lc3NhZ2VIYW5kbGVyXCIgcHJvcGVydHksIHdoaWNoIGluIHR1cm4gY29udGFpbnMgXCJlcnJvclwiIGFuZCBcIndhcm5pbmdcIiBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIHdoaWNoIGFyZSBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGVycm9ycyBhbmQgd2FybmluZ3MsIHJlc3BlY3RpdmVseS4gIEJvdGggdGhlXG4gICAgICAgIC8vIFwiZXJyb3JcIiBhbmQgYSBcIndhcm5pbmdcIiBwcm9wZXJ0aWVzIG11c3QgYmUgcHJlc2VudCBpbiB0aGUgXCJtZXNzYWdlSGFuZGxlclwiIG9iamVjdFxuICAgICAgICAvLyBhbmQgbXVzdCBwb2ludCB0byB2YWxpZCBmdW5jdGlvbnMuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBUaGUgcmF0aW9uYWxlIGJlaGluZCB0aGlzIGlzIHRvIGFsbG93IGNvbnZlbmllbmNlIGZvciBjYWxsZXJzIG9mIHRoZSBtb3JlIFwicHVibGljXCJcbiAgICAgICAgLy8gTXVsdGlncmFwaC5jcmVhdGVHcmFwaCBmdW5jdGlvbiwgc28gdGhhdCB0aGV5IGRvbid0IGhhdmUgdG8gc3BlY2lmeSBhbiBlcnJvciBvclxuICAgICAgICAvLyB3YXJuaW5nIGhhbmRsZXIgZnVuY3Rpb24gdW5sZXNzIHRoZXkgd2FudCB0byB1c2UgY3VzdG9tIG9uZXMuICBUaGUgaW50ZXJuYWxcbiAgICAgICAgLy8gTXVsdGlncmFwaC5jcmVhdGV7RFJJVkVSfUdyYXBoIGZ1bmN0aW9ucywgaG93ZXZlciwgYWx3YXlzIG5lZWQgYWNjZXNzIHRvIGVycm9yIGFuZFxuICAgICAgICAvLyB3YXJuaW5nIGZ1bmN0aW9ucywgYW5kIG9mdGVuIG5lZWQgdG8gcGFzcyBib3RoIG9mIHRoZW0gb24gdG8gb3RoZXIgZnVuY3Rpb25zLCBzb1xuICAgICAgICAvLyB0aGV5J3JlIGVuY2Fwc3VsYXRlZCB0b2dldGhlciBpbnRvIGEgc2luZ2xlIG1lc3NhZ2VIYW5kbGVyIG9iamVjdCB0byBtYWtlIHRoaXNcbiAgICAgICAgLy8gZWFzaWVyLlxuICAgICAgICAvL1xuICAgICAgICAvLyBCdWlsZCB0aGUgbWVzc2FnZUhhbmRsZXIgb2JqZWN0OlxuICAgICAgICBtZXNzYWdlSGFuZGxlciA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mKG9wdGlvbnMuZXJyb3IpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLmVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKG9wdGlvbnMud2FybmluZykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIud2FybmluZyA9IG9wdGlvbnMud2FybmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghIG1lc3NhZ2VIYW5kbGVyLmVycm9yICB8fCAhIG1lc3NhZ2VIYW5kbGVyLndhcm5pbmcpIHtcbiAgICAgICAgICAgIGRlZmF1bHRNZXNzYWdlSGFuZGxlciA9IE11bHRpZ3JhcGguY3JlYXRlRGVmYXVsdE1lc3NhZ2VIYW5kbGVycyhkaXYpO1xuICAgICAgICAgICAgaWYgKCEgbWVzc2FnZUhhbmRsZXIuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5lcnJvciA9IGRlZmF1bHRNZXNzYWdlSGFuZGxlci5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghIG1lc3NhZ2VIYW5kbGVyLndhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci53YXJuaW5nID0gZGVmYXVsdE1lc3NhZ2VIYW5kbGVyLndhcm5pbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuXG4gICAgICAgIGlmIChvcHRpb25zLm11Z2xTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZGVsZWdhdGUgdG8gdGhlIGRyaXZlci1zcGVjaWZpYyBjcmVhdGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRyaXZlciA9PT0gXCJjYW52YXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNdWx0aWdyYXBoLmNyZWF0ZUNhbnZhc0dyYXBoRnJvbVN0cmluZyhvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5kcml2ZXIgPT09IFwicmFwaGFlbFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpZ3JhcGguY3JlYXRlUmFwaGFlbEdyYXBoRnJvbVN0cmluZyhvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlSGFubGRlci5lcnJvcihuZXcgRXJyb3IoXCJpbnZhbGlkIGdyYXBoaWMgZHJpdmVyICdcIiArIG9wdGlvbnMuZHJpdmVyICsgXCInIHNwZWNpZmllZCB0byBNdWx0aWdyYXBoLmNyZWF0ZUdyYXBoXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVsZWdhdGUgdG8gdGhlIGRyaXZlci1zcGVjaWZpYyBjcmVhdGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKG9wdGlvbnMuZHJpdmVyID09PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gTXVsdGlncmFwaC5jcmVhdGVDYW52YXNHcmFwaChvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmRyaXZlciA9PT0gXCJyYXBoYWVsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBNdWx0aWdyYXBoLmNyZWF0ZVJhcGhhZWxHcmFwaChvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZUhhbmxkZXIuZXJyb3IobmV3IEVycm9yKFwiaW52YWxpZCBncmFwaGljIGRyaXZlciAnXCIgKyBvcHRpb25zLmRyaXZlciArIFwiJyBzcGVjaWZpZWQgdG8gTXVsdGlncmFwaC5jcmVhdGVHcmFwaFwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGB3aW5kb3cubXVsdGlncmFwaC5jcmVhdGVgIGlzIGFuIGFsaWFzIGZvciBgd2luZG93Lm11bHRpZ3JhcGguY29yZS5NdWx0aWdyYXBoLmNyZWF0ZUdyYXBoYC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgd2luZG93Lm11bHRpZ3JhcGguY3JlYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEhUTUwgRWxlbWVudHxqUXVlcnkgT2JqZWN0fSBvcHRpb25zLmRpdiAoUkVRVUlSRUQpXG4gICAgICogICAgICBUaGUgRE9NIGVsZW1lbnQgZGl2IGludG8gd2hpY2ggdGhlIG11bHRpZ3JhcGggc2hvdWxkIGJlXG4gICAgICogICAgICBwbGFjZWQ7IHRoaXMgdmFsdWUgbWF5IGJlIGVpdGhlciAoYSkgYSBzdHJpbmcgd2hpY2ggaXMgdGFrZW5cbiAgICAgKiAgICAgIHRvIGJlIHRoZSBpZCBhdHRyaWJ1dGUgb2YgYSBkaXYgaW4gdGhlIHBhZ2UsIChiKSBhIHJlZmVyZW5jZVxuICAgICAqICAgICAgdG8gdGhlIGRpdiBET00gZWxlbWVudCBpdHNlbGYsIG9yIChjKSBhIGpRdWVyeSBvYmplY3RcbiAgICAgKiAgICAgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGRpdiBET00gZWxlbWVudC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1VSSX0gb3B0aW9ucy5tdWdsIChSRVFVSVJFRCkgdGhlIFVSTCBmcm9tIHdoaWNoIHRoZSBNVUdMXG4gICAgICogICAgICAgZmlsZSBmb3IgdGhlIE11bHRpZ3JhcGggY2FuIGJlIGxvYWRlZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmRyaXZlciAoT1BUSU9OQUwpIEluZGljYXRlcyB3aGljaFxuICAgICAqICAgICAgIGdyYXBoaWNzIGRyaXZlciB0byB1c2U7IHNob3VsZCBiZSBvbmUgb2YgdGhlIHN0cmluZ3NcbiAgICAgKiAgICAgICBcImNhbnZhc1wiLCBcInJhcGhhZWxcIiwgb3IgXCJhdXRvXCIuICBUaGUgZGVmYXVsdCAod2hpY2ggaXNcbiAgICAgKiAgICAgICB1c2VkIGlmIHRoZSAnZHJpdmVyJyB0YWcgaXMgYWJzZW50KSBpcyBcImF1dG9cIiwgd2hpY2hcbiAgICAgKiAgICAgICBjYXVzZXMgTXVsdGlncmFwaCB0byBjaGVjayB0aGUgZmVhdHVyZXMgb2YgdGhlIGJyb3dzZXJcbiAgICAgKiAgICAgICBpdCBpcyBydW5uaW5nIGluIGFuZCBjaG9vc2UgdGhlIG1vc3QgYXBwcm9wcmlhdGUgZHJpdmVyLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuZXJyb3IgKE9QVElPTkFMKSBBIGZ1bmN0aW9uIGZvclxuICAgICAqICAgICAgIGRpc3BsYXlpbmcgZXJyb3IgbWVzc2FnZXMgdG8gdGhlIHVzZXIuICBNdWx0aWdyYXBoIHdpbGxcbiAgICAgKiAgICAgICBjYWxsIHRoaXMgZnVuY3Rpb24gaWYgYW5kIHdoZW4gaXQgZW5jb3VudGVycyBhbiBlcnJvci4gIFRoZVxuICAgICAqICAgICAgIGZ1bmN0aW9uIHNob3VsZCByZWNlaXZlIGEgc2luZ2xlIGFyZ3VtZW50IHdoaWNoIGlzIGFuXG4gICAgICogICAgICAgaW5zdGFuY2Ugb2YgdGhlIEphdmFTY3JpcCBFcnJvciBvYmplY3QuICBUaGUgZGVmYXVsdCBpcyB0b1xuICAgICAqICAgICAgIHVzZSBNdWx0aWdyYXBoJ3Mgb3duIGludGVybmFsIG1lY2hhbmlzbSBmb3IgZGlzcGxheWluZyB1c2VyXG4gICAgICogICAgICAgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLndhcm5pbmcgKE9QVElPTkFMKSBBIGZ1bmN0aW9uIGZvclxuICAgICAqICAgICAgIGRpc3BsYXlpbmcgd2FybmluZyBtZXNzYWdlcyB0byB0aGUgdXNlci4gIE11bHRpZ3JhcGggd2lsbFxuICAgICAqICAgICAgIGNhbGwgdGhpcyBmdW5jdGlvbiBpZiBhbmQgd2hlbiBpdCBuZWVkcyB0byBkaXNwbGF5IGFcbiAgICAgKiAgICAgICB3YXJuaW5nIG1lc3NhZ2UuIFRoZSBmdW5jdGlvbiBzaG91bGQgcmVjZWl2ZSBhIHNpbmdsZVxuICAgICAqICAgICAgIGFyZ3VtZW50IHdoaWNoIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBKYXZhU2NyaXB0IEVycm9yXG4gICAgICogICAgICAgb2JqZWN0LiAgVGhlIGRlZmF1bHQgaXMgdG8gdXNlIE11bHRpZ3JhcGgncyBvd24gaW50ZXJuYWxcbiAgICAgKiAgICAgICBtZWNoYW5pc20gZm9yIGRpc3BsYXlpbmcgdXNlciBtZXNzYWdlcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBqUXVlcnkgcHJvbWlzZSB3aGljaCBwcm92aWRlcyBpbnRlcmFjdGlvbiB3aXRoXG4gICAgICogICAgIHRoZSBncmFwaCB0aHJvdWdoIGl0cyBgZG9uZWAgZnVuY3Rpb24uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICBNdWx0aWdyYXBoLmNyZWF0ZSA9IE11bHRpZ3JhcGguY3JlYXRlR3JhcGg7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGRlZmF1bHQgZXJyb3IgYW5kIHdhcm5pbmcgZnVuY3Rpb25zIGZvciBtdWx0aWdyYXBoLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVEZWZhdWx0TWVzc2FnZUhhbmRsZXJzXG4gICAgICogQHBhcmFtIHtIVE1MIEVsZW1lbnR9IGRpdlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBrZXllZCBieSBgZXJyb3JgIGFuZCBgd2FybmluZ2Agd2hpY2ggcmVzcGVjdGl2ZWx5IHBvaW50IHRvXG4gICAgICogICAgIHRoZSBnZW5lcmF0ZWQgZGVmYXVsdCBlcnJvciBhbmQgd2FybmluZyBmdW5jdGlvbnMuXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIE11bHRpZ3JhcGguY3JlYXRlRGVmYXVsdE1lc3NhZ2VIYW5kbGVycyA9IGZ1bmN0aW9uIChkaXYpIHtcblxuICAgICAgICAkKGRpdikuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgICAkKGRpdikuZXJyb3JEaXNwbGF5KHt9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3IgOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrVHJhY2UgPSAoZS5zdGFjayAmJiB0eXBlb2YoZS5zdGFjaykgPT09IFwic3RyaW5nXCIpID8gZS5zdGFjay5yZXBsYWNlKC9cXG4vZywgXCI8L2xpPjxsaT5cIikgOiBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgJChkaXYpLmVycm9yRGlzcGxheShcImRpc3BsYXlFcnJvclwiLCBzdGFja1RyYWNlLCBlLm1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udENvbG9yICAgICAgIDogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgOiAnI2ZmMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvckNvbG9yICA6ICcjZmYwMDAwJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgd2FybmluZyA6IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICAgICAgLy8gdyBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nLCBvciBhIFdhcm5pbmcgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSAgICA9IFwiV2FybmluZzogXCIgKyAoKHR5cGVvZih3KSA9PT0gXCJzdHJpbmdcIikgPyB3IDogdy5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tUcmFjZSA9ICh0eXBlb2YodykgIT09IFwic3RyaW5nXCIgJiYgdy5zdGFjayAmJiB0eXBlb2Yody5zdGFjaykgPT09IFwic3RyaW5nXCIpID8gdy5zdGFjay5yZXBsYWNlKC9cXG4vZywgXCI8L2xpPjxsaT5cIikgOiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICQoZGl2KS5lcnJvckRpc3BsYXkoXCJkaXNwbGF5RXJyb3JcIiwgc3RhY2tUcmFjZSwgbWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICBmb250Q29sb3IgICAgICAgOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA6ICcjZTA2YTFiJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yQ29sb3IgIDogJyNlMDZhMWInXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGRlZmluZSBlbXB0eSBvYmplY3QgZm9yIGhvbGRpbmcgZGF0YSBhZHBhdGVyc1xuICAgIE11bHRpZ3JhcGguX2RhdGFBZGFwdGVycyA9IHt9O1xuXG4gICAgTXVsdGlncmFwaC5pbnN0YWxsRGF0YUFkYXB0ZXIgPSBmdW5jdGlvbihuYW1lLCBhZGFwdGVyKSB7XG4gICAgICAgIE11bHRpZ3JhcGguX2RhdGFBZGFwdGVyc1tuYW1lXSA9IGFkYXB0ZXI7XG4gICAgfTtcblxuICAgIE11bHRpZ3JhcGguZ2V0RGF0YUFkYXB0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBNdWx0aWdyYXBoLl9kYXRhQWRhcHRlcnNbbmFtZV07XG4gICAgfTtcblxuICAgIC8vIHNvIHRoYXQgZGF0YSBhZHBhdGVycywgb3Igb3RoZXIgSlMgY29kZSBpbnRlcmFjdGluZyB3aXRoIE11bHRpZ3JhcGgsXG4gICAgLy8gbWF5IGhhdmUgYWNjZXNzIHRvIHNwcmludGY6XG4gICAgTXVsdGlncmFwaC5zcHJpbnRmID0gcmVxdWlyZSgnc3ByaW50ZicpO1xuXG4gICAgcmV0dXJuIE11bHRpZ3JhcGg7XG59O1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgc3ByaW50ZiA9IHJlcXVpcmUoJ3NwcmludGYnKTtcblxudmFyIE51bWJlckZvcm1hdHRlciA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICB2YXIgdGVzdFN0cmluZztcbiAgICBpZiAodHlwZW9mKGZvcm1hdCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybWF0IG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIHRoaXMuZm9ybWF0U3RyaW5nID0gZm9ybWF0O1xuICAgIHRlc3RTdHJpbmcgPSBzcHJpbnRmKGZvcm1hdCwgMCk7XG4gICAgdGhpcy5sZW5ndGggPSB0ZXN0U3RyaW5nLmxlbmd0aDtcbn07XG5cbk51bWJlckZvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHNwcmludGYodGhpcy5mb3JtYXRTdHJpbmcsIHZhbHVlLmdldFJlYWxWYWx1ZSgpKTtcbn07XG5cbk51bWJlckZvcm1hdHRlci5wcm90b3R5cGUuZ2V0TWF4TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbk51bWJlckZvcm1hdHRlci5wcm90b3R5cGUuZ2V0Rm9ybWF0U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdFN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyRm9ybWF0dGVyO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG5OdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vbnVtYmVyX3ZhbHVlLmpzJyk7XG5cbi8vIEZ1ZGdlIGZhY3RvciBmb3IgZmxvYXRpbmcgcG9pbnQgY29tcGFyaXNvbnM6XG52YXIgZXBzaWxvbiA9IDFFLTEyO1xuXG52YXIgTnVtYmVyTWVhc3VyZSA9IGZ1bmN0aW9uIChtZWFzdXJlKSB7XG4gICAgdGhpcy5tZWFzdXJlID0gbWVhc3VyZTtcbn07XG5cbk51bWJlck1lYXN1cmUucHJvdG90eXBlLmdldFJlYWxWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tZWFzdXJlO1xufTtcblxuTnVtYmVyTWVhc3VyZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVhc3VyZS50b1N0cmluZygpO1xufTtcblxuTnVtYmVyTWVhc3VyZS5wcm90b3R5cGUuZmlyc3RTcGFjaW5nTG9jYXRpb25BdE9yQWZ0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGFsaWdubWVudCkgIHtcbiAgICB2YXIgZixcbiAgICAgICAgbixcbiAgICAgICAgbSxcbiAgICAgICAgYSA9IGFsaWdubWVudC52YWx1ZSxcbiAgICAgICAgdiA9IHZhbHVlLnZhbHVlLFxuICAgICAgICBzID0gTWF0aC5hYnModGhpcy5tZWFzdXJlKTtcbiAgICBmID0gKHYgLSBhKSAvIHM7XG4gICAgbiA9IE1hdGguZmxvb3IoZik7XG4gICAgbSA9IG4gKyAxO1xuICAgIC8vaWYgKChNYXRoLmFicyhuIC0gZikgPCBlcHNpbG9uKSB8fCAoTWF0aC5hYnMobSAtIGYpIDwgZXBzaWxvbikpIHtcbiAgICAvL05PVEU6IGJ5IGRlZmluaXRpb24gb2Ygbj1mbG9vcihmKSwgd2Uga25vdyBmID49IG4sIHNvIE1hdGguYWJzKG4gLSBmKSBpcyB0aGUgc2FtZSBhcyAoZiAtIG4pXG4gICAgLy9BbHNvIGJ5IGRlZmluaXRpb24sIGZsb29yKGYpKzEgPj0gZiwgc28gTWF0aC5hYnMobSAtIGYpIGlzIHRoZSBzYW1lIGFzIChtIC0gZilcbiAgICBpZiAoKGYgLSBuIDwgZXBzaWxvbikgfHwgKG0gLSBmIDwgZXBzaWxvbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJWYWx1ZSh2KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJWYWx1ZShhICsgcyAqIG0pO1xufTtcblxuLy8gQ29uc2lkZXIgYSBsYXR0aWNlIG9mIHZhbHVlcyBzcGFjZWQgYHNgIGFwYXJ0LCBhbGlnbmVkIHdpdGggYGFgXG4vLyAgICBpLmUuIGFsbCB2YWx1ZXMgYSArIHoqcywgd2hlcmUgeiBpcyBhbnkgaW50ZWdlclxuLy8gUmV0dXJuIHRoZSBsYXJnZXN0IHZhbHVlIGluIHRoaXMgbGF0dGljZSB0aGF0IGlzIDw9IGB2YFxuZnVuY3Rpb24gbGFzdFNwYWNpbmdMb2NhdGlvbkF0T3JCZWZvcmUocywgdiwgYSkge1xuICAgIHZhciBuLCBuLCBmO1xuICAgIHYgPSB2IC0gYTtcbiAgICBpZiAodiA+PSAwKSB7XG4gICAgICAgIGYgPSB2IC8gcztcbiAgICAgICAgbiA9IE1hdGguZmxvb3IoZik7XG4gICAgICAgIGlmIChmIC0gbiA8IGVwc2lsb24pIHsgcmV0dXJuIHY7IH1cbiAgICAgICAgcmV0dXJuIGEgKyBuKnM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZiA9IC12IC8gcztcbiAgICAgICAgbiA9IE1hdGguY2VpbChmKTtcbiAgICAgICAgaWYgKG4gLSBmIDwgZXBzaWxvbikgeyByZXR1cm4gdjsgfVxuICAgICAgICByZXR1cm4gYSAtIG4qcztcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBqdXN0IGxpa2UgYGZpcnN0U3BhY2luZ0xvY2F0aW9uQXRPckFmdGVyYCBhYm92ZSwgYnV0IHJldHVybnMgdGhlXG4gKiBncmVhdGVzdCBOdW1iZXJWYWx1ZSBpbiB0aGUgbGF0dGljZSB0aGF0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICogXG4gKiByZXR1cm46IGEgTnVtYmVyVmFsdWVcbiAqL1xuTnVtYmVyTWVhc3VyZS5wcm90b3R5cGUubGFzdFNwYWNpbmdMb2NhdGlvbkF0T3JCZWZvcmUgPSBmdW5jdGlvbiAoLypOdW1iZXJWYWx1ZSovdmFsdWUsIC8qTnVtYmVyVmFsdWUqL2FsaWdubWVudCkgIHtcbiAgICByZXR1cm4gbmV3IE51bWJlclZhbHVlKGxhc3RTcGFjaW5nTG9jYXRpb25BdE9yQmVmb3JlKHRoaXMubWVhc3VyZSwgdmFsdWUudmFsdWUsIGFsaWdubWVudC52YWx1ZSkpO1xufTtcblxuLy8gICAgdmFyIGYsXG4vLyAgICAgICAgbixcbi8vICAgICAgICBtLFxuLy8gICAgICAgIGEgPSBhbGlnbm1lbnQudmFsdWUsXG4vLyAgICAgICAgdiA9IHZhbHVlLnZhbHVlLFxuLy8gICAgICAgIHMgPSBNYXRoLmFicyh0aGlzLm1lYXN1cmUpO1xuLy8gICAgZiA9ICh2IC0gYSkgLyBzO1xuLy8gICAgaWYgKGYgPiAwKSB7XG4vLyAgICAgICAgbiA9IE1hdGguZmxvb3IoZik7XG4vLyAgICB9IGVsc2Uge1xuLy8gICAgICAgIG4gPSBNYXRoLmNlaWwoZik7XG4vLyAgICB9XG4vLyAgICBtID0gbiArIDE7XG4vLyAgICBpZiAoKGYgLSBuIDwgZXBzaWxvbikgfHwgKG0gLSBmIDwgZXBzaWxvbikpIHtcbi8vICAgICAgICBjb25zb2xlLmxvZygnYXQgMScpO1xuLy8gICAgICAgIGNvbnNvbGUubG9nKGYpO1xuLy8gICAgICAgIGNvbnNvbGUubG9nKGYtbik7XG4vLyAgICAgICAgY29uc29sZS5sb2cobS1mKTtcbi8vICAgICAgICBjb25zb2xlLmxvZyhlcHNpbG9uKTtcbi8vICAgICAgICByZXR1cm4gbmV3IE51bWJlclZhbHVlKHYpO1xuLy8gICAgfVxuLy8gICAgY29uc29sZS5sb2coJ2F0IDInKTtcbi8vICAgIHJldHVybiBuZXcgTnVtYmVyVmFsdWUoYSArIHMgKiBuKTtcbi8vfTtcblxuTnVtYmVyTWVhc3VyZS5wYXJzZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJNZWFzdXJlKHBhcnNlRmxvYXQocykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJNZWFzdXJlO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG5EYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKTtcblxudmFyIE51bWJlclZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufTtcblxuTnVtYmVyVmFsdWUucHJvdG90eXBlLmdldFJlYWxWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cbk51bWJlclZhbHVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZygpO1xufTtcblxuTnVtYmVyVmFsdWUucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPCB4LnZhbHVlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgPiB4LnZhbHVlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbk51bWJlclZhbHVlLnByb3RvdHlwZS5hZGRSZWFsVmFsdWUgPSBmdW5jdGlvbiAoIHJlYWxWYWx1ZUluY3IgKSB7XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJWYWx1ZSh0aGlzLnZhbHVlICsgcmVhbFZhbHVlSW5jcik7XG59O1xuXG5OdW1iZXJWYWx1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKC8qRGF0YU1lYXN1cmUqLyBtZWFzdXJlKSB7XG4gICAgLy8gTk9URTogZGVsaWJlcmF0ZWx5IGFjY2Vzc2luZyB0aGUgJ21lYXN1cmUnIHByb3BlcnR5IG9mIGEgTnVtYmVyTWVhc3VyZSBoZXJlLCByYXRoZXJcbiAgICAvLyB0aGFuIGNhbGxpbmcgaXRzIGdldFJlYWxWYWx1ZSgpIG1ldGhvZCwgZm9yIGNvbnZlbmllbmNlIGFuZCBlZmZpY2llbmN5OlxuICAgIHJldHVybiBuZXcgTnVtYmVyVmFsdWUodGhpcy52YWx1ZSArIG1lYXN1cmUubWVhc3VyZSk7XG59O1xuXG5OdW1iZXJWYWx1ZS5wcm90b3R5cGUudHlwZSA9IERhdGFWYWx1ZS5OVU1CRVI7XG5cbk51bWJlclZhbHVlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTnVtYmVyVmFsdWUodGhpcy52YWx1ZSk7XG59O1xuXG5OdW1iZXJWYWx1ZS5wYXJzZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJWYWx1ZShwYXJzZUZsb2F0KHMpKTtcbn07XG5cbkRhdGFWYWx1ZS5taXhpbkNvbXBhcmF0b3JzKE51bWJlclZhbHVlLnByb3RvdHlwZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyVmFsdWU7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbkRhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpO1xuXG52YXIgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzLnBhbik7XG5cbnZhciBQYW4gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJQYW5cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcImFsbG93ZWRcIikud2hpY2guaXNBKFwiYm9vbGVhblwiKTtcbiAgICB0aGlzLmhhc0EoXCJtaW5cIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhVmFsdWUuaXNJbnN0YW5jZU9yTnVsbCk7XG4gICAgdGhpcy5oYXNBKFwibWF4XCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YVZhbHVlLmlzSW5zdGFuY2VPck51bGwpO1xuXG4gICAgLy9OT1RFOiB0aGUgZGlzdGluY3Rpb24gYmV0d2VlbiBEYXRhVmFsdWUgYW5kIERhdGFNZWFzdXJlIGZvciB0aGUgem9vbSAmIHBhbiBtb2RlbFxuICAgIC8vICAgICAgYXR0cmlidXRlcyBtaWdodCBzZWVtIGNvbmZ1c2luZywgc28gaGVyZSdzIGEgdGFibGUgdG8gY2xhcmlmeSBpdDpcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICBCb29sZWFuICAgICAgRGF0YVZhbHVlICAgICAgRGF0YU1lYXN1cmVcbiAgICAvLyAgICAgICAgICAgICAgLS0tLS0tLSAgICAgIC0tLS0tLS0tLSAgICAgIC0tLS0tLS0tLS0tXG4gICAgLy8gIHpvb206ICAgICAgIGFsbG93ZWQgICAgICBhbmNob3IgICAgICAgICBtaW4sbWF4XG4gICAgLy8gICBwYW46ICAgICAgIGFsbG93ZWQgICAgICBtaW4sbWF4XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMuaG9yaXpvbnRhbGF4aXMucGFuLCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhbjtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIEFycmF5RGF0YSA9IHJlcXVpcmUoJy4vYXJyYXlfZGF0YS5qcycpLFxuICAgIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi9kYXRhX21lYXN1cmUuanMnKSxcbiAgICBEYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKTtcblxudmFyIFBlcmlvZGljQXJyYXlEYXRhID0gbmV3IGplcm1haW5lLk1vZGVsKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgUGVyaW9kaWNBcnJheURhdGEgPSB0aGlzLFxuICAgICAgICBlbXB0eUl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgXCJuZXh0XCIgICAgOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgIFwiaGFzTmV4dFwiIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgfTtcblxuICAgIHRoaXMuaXNBKEFycmF5RGF0YSk7XG4gICAgdGhpcy5oYXNBKFwicGVyaW9kXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YU1lYXN1cmUuaXNJbnN0YW5jZSk7XG4gICAgLy90aGlzLmhhc0EoXCJjb2x1bW4wUmVsYXRpdmVSZWFsVmFsdWVzXCIpLndoaWNoLmRlZmF1bHRzVG8obnVsbCk7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcImNvbHVtbnNcIiwgXCJzdHJpbmdBcnJheVwiLCBcInBlcmlvZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLmFkZExpc3RlbmVyKFwibGlzdGVuZXJBZGRlZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5hcnJheSgpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldFR5cGUgPT09IFwiZGF0YVJlYWR5XCIpIHtcbiAgICAgICAgICAgICAgICBldmVudC5saXN0ZW5lcihkYXRhWzBdWzBdLCBkYXRhW2RhdGEubGVuZ3RoLTFdWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICB0aGlzLnJlc3BvbmRzVG8oXCJpbml0aWFsaXplQ29sdW1uMFJlbGF0aXZlUmVhbFZhbHVlc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSgpLFxuICAgICBjb2x1bW4wUmVsYXRpdmVSZWFsVmFsdWVzID0gW10sXG4gICAgIGk7XG4gICAgIGZvciAoaT0wOyBpPGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgIGNvbHVtbjBSZWxhdGl2ZVJlYWxWYWx1ZXNbaV0gPSBhcnJheVtpXVswXSAtIGFycmF5WzBdWzBdO1xuICAgICB9XG4gICAgIHRoaXMuY29sdW1uMFJlbGF0aXZlUmVhbFZhbHVlcyhjb2x1bW4wUmVsYXRpdmVSZWFsVmFsdWVzKTtcbiAgICAgfSk7XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGdldEl0ZXJhdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmcgYXJyYXl9IGNvbHVtbklEc1xuICAgICAqIEBwYXJhbSB7RGF0YVZhbHVlfSBtaW5cbiAgICAgKiBAcGFyYW0ge0RhdGFWYWx1ZX0gbWF4XG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBidWZmZXJcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZ2V0SXRlcmF0b3JcIiwgZnVuY3Rpb24gKGNvbHVtbklkcywgbWluLCBtYXgsIGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUGVyaW9kaWNBcnJheURhdGEuZ2V0QXJyYXlEYXRhSXRlcmF0b3IodGhpcywgY29sdW1uSWRzLCBtaW4sIG1heCwgYnVmZmVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZ2V0QXJyYXlEYXRhSXRlcmF0b3JcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheURhdGF9IGFycmF5RGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIGFycmF5fSBjb2x1bW5JRHNcbiAgICAgKiBAcGFyYW0ge0RhdGFWYWx1ZX0gbWluXG4gICAgICogQHBhcmFtIHtEYXRhVmFsdWV9IG1heFxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gYnVmZmVyXG4gICAgICogQHJldHVybiBpdGVyXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIFBlcmlvZGljQXJyYXlEYXRhLmdldEFycmF5RGF0YUl0ZXJhdG9yID0gZnVuY3Rpb24gKHBlcmlvZGljQXJyYXlEYXRhLCBjb2x1bW5JZHMsIG1pbiwgbWF4LCBidWZmZXIpIHtcbiAgICAgICAgdmFyIGl0ZXIgPSB7fSxcbiAgICAgICAgICAgIGFycmF5U2xpY2UgPSBbXSxcbiAgICAgICAgICAgIGN1cnIgPSAwLFxuICAgICAgICAgICAgaSwgaixcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgIGNvbHVtbkluZGljZXMsXG4gICAgICAgICAgICBhcnJheSA9IHBlcmlvZGljQXJyYXlEYXRhLmFycmF5KCk7XG5cbiAgICAgICAgYnVmZmVyID0gYnVmZmVyIHx8IDA7XG5cbiAgICAgICAgLy8gY29sdW1uSWRzIGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KGNvbHVtbklkcykgIT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlEYXRhOiBnZXRJdGVyYXRvciBtZXRob2QgcmVxdWlyZXMgdGhhdCB0aGUgZmlyc3QgcGFyYW1ldGVyIGJlIGFuIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uSWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjb2x1bW5JZHNbaV0pICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5RGF0YTogZ2V0SXRlcmF0b3IgbWV0aG9kIHJlcXVpcmVzIHRoYXQgdGhlIGZpcnN0IHBhcmFtZXRlciBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vbWluLG1heCBhcmd1bWVudHMgc2hvdWxkIGJlIGRhdGEgdmFsdWVzXG4gICAgICAgIGlmICghRGF0YVZhbHVlLmlzSW5zdGFuY2UobWluKSB8fCAhRGF0YVZhbHVlLmlzSW5zdGFuY2UobWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlEYXRhOiBnZXRJdGVyYXRvciBtZXRob2QgcmVxdWlyZXMgdGhlIHNlY29uZCBhbmQgdGhpcmQgYXJndW1lbnQgdG8gYmUgbnVtYmVyIHZhbHVlc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYnVmZmVyIGFyZ3VtZW50IHNob3VsZCBiZSBhbiBpbnRlZ2VyXG4gICAgICAgIGlmICh0eXBlb2YoYnVmZmVyKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlEYXRhOiBnZXRJdGVyYXRvciBtZXRob2QgcmVxdWlyZXMgbGFzdCBhcmd1bWVudCB0byBiZSBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBubyBkYXRhLCByZXR1cm4gYW4gZW1wdHkgaXRlcmF0b3JcbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5SXRlcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgLy8gcG9wdWxhdGUgdGhlIGNvbHVtbjBSZWxhdGl2ZVJlYWxWYWx1ZXMgYXJyYXkgaWYgaXQgaGFzbid0IHlldCBiZWVuIHBvcHVsYXRlZFxuICAgICAgICAgaWYgKHRoaXMuY29sdW1uMFJlbGF0aXZlUmVhbFZhbHVlcygpID09PSBudWxsKSB7XG4gICAgICAgICB0aGlzLmluaXRpYWxpemVDb2x1bW4wUmVsYXRpdmVSZWFsVmFsdWVzKCk7XG4gICAgICAgICB9XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIExldCBgYmFzZVZhbHVlYCBiZSB0aGUgbG9jYXRpb24gb2YgdGhlIGZpcnN0IGRhdGEgcG9pbnQgaW4gdGhlIGFycmF5XG4gICAgICAgIHZhciBiYXNlVmFsdWUgPSBhcnJheVswXVswXTtcblxuICAgICAgICAvLyBJbiB0aGUgcmVndWxhciBsYXR0aWNlIG9mIHNwYWNpbmcgYHBlcmlvZGAgYWxpZ25lZCB3aXRoIGJhc2VWYWx1ZSxcbiAgICAgICAgLy8gZmluZCB0aGUgbGFzdCBwb2ludCB0aGF0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgbWluYC4gIENhbGwgdGhpcyBwb2ludCBgYmAuXG4gICAgICAgIHZhciBiID0gcGVyaW9kaWNBcnJheURhdGEucGVyaW9kKCkubGFzdFNwYWNpbmdMb2NhdGlvbkF0T3JCZWZvcmUobWluLCBiYXNlVmFsdWUpO1xuXG4gICAgICAgIC8vIExldCBgb2Zmc2V0UmVhbFZhbHVlYCBiZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGIgYW5kIGJhc2VWYWx1ZSwgYXMgYSByZWFsIHZhbHVlOlxuICAgICAgICB2YXIgb2Zmc2V0UmVhbFZhbHVlID0gYi5nZXRSZWFsVmFsdWUoKSAtIGJhc2VWYWx1ZS5nZXRSZWFsVmFsdWUoKTtcblxuICAgICAgICAvLyBMZXQgYGJhc2VNaW5gIGJlIGBtaW5gIHNoaWZ0ZWQgJ2JhY2t3YXJkJyBieSBvZmZzZXRSZWFsVmFsdWU7IHRoaXMgaXMgYG1pbmBcbiAgICAgICAgLy8gcmVsYXRpdmUgdG8gdGhlIHNhbWUgcGVyaW9kIGN5Y2xlIGFzIGJhc2VWYWx1ZTpcbiAgICAgICAgdmFyIGJhc2VNaW4gPSBEYXRhVmFsdWUuY3JlYXRlKG1pbi50eXBlLCBtaW4uZ2V0UmVhbFZhbHVlKCkgLSBvZmZzZXRSZWFsVmFsdWUpO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCByb3cgaW4gdGhlIGFycmF5IHdob3NlIGNvbHVtbjAgdmFsdWUgaXMgPj0gYmFzZU1pbjtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZGF0YSBwb2ludCB3ZSBzdGFydCB3aXRoXG4gICAgICAgIGZvciAoY3VycmVudEluZGV4ID0gMDsgY3VycmVudEluZGV4IDwgYXJyYXkubGVuZ3RoOyArK2N1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgaWYgKGFycmF5W2N1cnJlbnRJbmRleF1bMF0uZ2UoYmFzZU1pbikpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvL1RPRE8gbGF0ZXI6IGJhY2sgdXAgJ2J1ZmZlcicgc3RlcHNcbiAgICAgICAgLy9cblxuICAgICAgICAvLyBzZXQgdGhlIGN1cnJlbnQgdmFsdWUgdG8gYmUgdGhlIGNvbHVtbjAgdmFsdWUgYXQgdGhpcyBmaXJzdCBpbmRleCwgc2hpZnRlZFxuICAgICAgICAvLyAnZm9yd2FyZCcgYnkgb2Zmc2V0UmVhbFZhbHVlXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBEYXRhVmFsdWUuY3JlYXRlKGFycmF5W2N1cnJlbnRJbmRleF1bMF0udHlwZSwgYXJyYXlbY3VycmVudEluZGV4XVswXS5nZXRSZWFsVmFsdWUoKSArIG9mZnNldFJlYWxWYWx1ZSk7XG5cbiAgICAgICAgY29sdW1uSW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1uSWRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgayA9IHBlcmlvZGljQXJyYXlEYXRhLmNvbHVtbklkVG9Db2x1bW5OdW1iZXIoY29sdW1uSWRzW2pdKTtcbiAgICAgICAgICAgIGNvbHVtbkluZGljZXMucHVzaCggayApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2plY3Rpb24gPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaSwgeDtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbkluZGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbkluZGljZXNbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3Rpb24ucHVzaChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbi5wdXNoKGFycmF5W2N1cnJlbnRJbmRleF1bY29sdW1uSW5kaWNlc1tpXV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBiLmFkZChwZXJpb2RpY0FycmF5RGF0YS5wZXJpb2QoKSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFJlYWxWYWx1ZSA9IGIuZ2V0UmVhbFZhbHVlKCkgLSBiYXNlVmFsdWUuZ2V0UmVhbFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IERhdGFWYWx1ZS5jcmVhdGUoYXJyYXlbY3VycmVudEluZGV4XVswXS50eXBlLCBhcnJheVtjdXJyZW50SW5kZXhdWzBdLmdldFJlYWxWYWx1ZSgpICsgb2Zmc2V0UmVhbFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlLmd0KG1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBhY3R1YWxseSBuZWVkIHRvIGZpZ3VyZSBvdXQgaG93IHRvIG1vdmUgZm9yd2FyZCBgYnVmZmVyYCBzdGVwcywgYnV0IGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBub3cgc2tpcCB0aGF0IHBhcnQuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNOZXh0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3VycmVudEluZGV4ID49IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICB9O1xuXG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcmlvZGljQXJyYXlEYXRhO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgUGxvdExlZ2VuZCA9IHJlcXVpcmUoJy4vcGxvdF9sZWdlbmQuanMnKSxcbiAgICBBeGlzID0gcmVxdWlyZSgnLi9heGlzLmpzJyksXG4gICAgUmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVyLmpzJyk7XG5cbnZhciBQbG90ID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUGxvdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXNBKFwibGVnZW5kXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGxlZ2VuZCkge1xuICAgICAgICByZXR1cm4gbGVnZW5kIGluc3RhbmNlb2YgUGxvdExlZ2VuZDtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJob3Jpem9udGFsYXhpc1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHJldHVybiBheGlzIGluc3RhbmNlb2YgQXhpcztcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJ2ZXJ0aWNhbGF4aXNcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICByZXR1cm4gYXhpcyBpbnN0YW5jZW9mIEF4aXM7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwicmVuZGVyZXJcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAocmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyIGluc3RhbmNlb2YgUmVuZGVyZXI7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwidmlzaWJsZVwiKS53aGljaC5pc0EoXCJib29sZWFuXCIpLmFuZC5kZWZhdWx0c1RvKHRydWUpO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwibm9ybWFsaXplXCIsIGZ1bmN0aW9uKGdyYXBoKSB7XG4gICAgICAgIHZhciBncmFwaEF4ZXMgPSBncmFwaC5heGVzKCksXG4gICAgICAgICAgICByZW5kZXJlclR5cGUsXG4gICAgICAgICAgICBudW1iZXJPZlZhcmlhYmxlcyxcbiAgICAgICAgICAgIGZpbmROZXh0VmFyaWFibGVBdE9yQWZ0ZXIsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgRGF0YVBsb3QgPSByZXF1aXJlKCcuLi9jb3JlL2RhdGFfcGxvdC5qcycpO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhhbmRsZXMgbWlzc2luZyB2YXJpYWJsZXNcbiAgICAgICAgLy9cbiAgICAgICAgZmluZE5leHRWYXJpYWJsZUF0T3JBZnRlciA9IGZ1bmN0aW9uIChwbG90LCBkYXRhLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIG92ZXJsYXBGbGFnID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFyaWFibGVJblBsb3RGbGFnLFxuICAgICAgICAgICAgICAgIGkgPSBpbmRleCxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlO1xuXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBpbmRleCAmJiBvdmVybGFwRmxhZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbG90IE5vcm1hbGl6ZXI6IFRoZXJlIGRvZXMgbm90IGV4aXN0IGFuIHVudXNlZCB2YXJpYWJsZVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gZGF0YS5jb2x1bW5zKCkuc2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBvdmVybGFwRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyaWFibGVJblBsb3RGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSBkYXRhLmNvbHVtbnMoKS5hdChpKTtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwbG90LnZhcmlhYmxlKCkuc2l6ZSgpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsb3QudmFyaWFibGUoKS5hdChqKSA9PT0gdmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlSW5QbG90RmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZUluUGxvdEZsYWcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBIYW5kbGVzIG1pc3NpbmcgaG9yaXpvbnRhbGF4aXMgdGFnc1xuICAgICAgICAvL1xuICAgICAgICBpZiAodGhpcy5ob3Jpem9udGFsYXhpcygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBncmFwaEF4ZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JhcGhBeGVzLmF0KGkpLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvcml6b250YWxheGlzKGdyYXBoQXhlcy5hdChpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhhbmRsZXMgbWlzc2luZyB2ZXJ0aWNhbGF4aXMgdGFnc1xuICAgICAgICAvL1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbGF4aXMoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JhcGhBeGVzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyYXBoQXhlcy5hdChpKS5vcmllbnRhdGlvbigpID09PSBBeGlzLlZFUlRJQ0FMKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmVydGljYWxheGlzKGdyYXBoQXhlcy5hdChpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhhbmRsZXMgbWlzc2luZyByZW5kZXJlciB0YWdzXG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvYWxsX3JlbmRlcmVycy5qcycpO1xuICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gUmVuZGVyZXIuVHlwZS5wYXJzZShcImxpbmVcIik7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyKFJlbmRlcmVyLmNyZWF0ZShyZW5kZXJlclR5cGUpKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIoKS5wbG90KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtYmVyT2ZWYXJpYWJsZXMgPSB0aGlzLnJlbmRlcmVyKCkubnVtYmVyT2ZWYXJpYWJsZXMoKTtcblxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIERhdGFQbG90KSB7XG4gICAgICAgICAgICB2YXIgcGxvdERhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICAgICAgcGxvdFZhcmlhYmxlcyA9IHRoaXMudmFyaWFibGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHBsb3REYXRhKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBsb3REYXRhKGdyYXBoLmRhdGEoKS5hdCgwKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwbG90VmFyaWFibGVzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBsb3RWYXJpYWJsZXMuYWRkKGZpbmROZXh0VmFyaWFibGVBdE9yQWZ0ZXIodGhpcywgcGxvdERhdGEoKSwgMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGxvdFZhcmlhYmxlcy5hdCgwKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBsb3RWYXJpYWJsZXMucmVwbGFjZSgwLCBmaW5kTmV4dFZhcmlhYmxlQXRPckFmdGVyKHRoaXMsIHBsb3REYXRhKCksIDApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKHBsb3RWYXJpYWJsZXMuc2l6ZSgpIDwgbnVtYmVyT2ZWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICBwbG90VmFyaWFibGVzLmFkZChmaW5kTmV4dFZhcmlhYmxlQXRPckFmdGVyKHRoaXMsIHBsb3REYXRhKCksIDEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMS4gZ2V0IHZhcmlhYmxlcyBmcm9tIGEgZGF0YSBzZWN0aW9uLCBzb21lIHdpbGwgYmUgdXNlZCwgb3RoZXJzIHdvbid0IGJlLlxuICAgICAgICAgICAgLy8gMi4gY2hlY2sgaWYgaG9yaXpvbnRhbCBheGlzIG5lZWRzIGEgdmFyaWFibGVcbiAgICAgICAgICAgIC8vICAgICAgIGlmIGl0IGRvZXMgLSBmaW5kIGZpcnN0IHVudXNlZCB2YXJpYWJsZSwgc3RhcnRpbmcgYXQgcG9zaXRpb24gMFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAtIGlmIG5vIHVudXNlZCB2YXJpYWJsZXMgZXhpc3QgLSB0aHJvdyBlcnJvclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAtIENPTlRJTlVFXG4gICAgICAgICAgICAvLyAgICAgICBpZiBpdCBkb2VzIG5vdCAtIENPTlRJTlVFXG4gICAgICAgICAgICAvLyAzLiBjaGVjayBpZiB2ZXJ0aWNhbCBheGlzIG5lZWRzIHZhcmlhYmxlKHMpXG4gICAgICAgICAgICAvLyAgICAgICBpZiBpdCBkb2VzIC0gZmluZCBmaXJzdCB1bnVzZWQgdmFyaWFibGUsIHN0YXJ0aW5nIGF0IHRoZSBwb3NpdGlvbiBvZlxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIHRoZSB4IHZhcmlhYmxlXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgIC0gaWYgbm8gdW51c2VkIHZhcmlhYmxlcyBleGlzdCAtIHRocm93IGVycm9yXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgIC0gY2hlY2sgaWYgdmVydGljYWwgYXhpcyBuZWVkcyBhbm90aGVyIHZhcmlhYmxlXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIGlmIGl0IGRvZXMgLSBSZXBlYXQgc3RlcCAzXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGF0aXBzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGF0aXBzKCkubm9ybWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGxvdDtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIFRleHQgPSByZXF1aXJlKCcuL3RleHQuanMnKSxcbiAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMucGxvdC5sZWdlbmQpO1xuXG52YXIgUGxvdExlZ2VuZCA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlBsb3RMZWdlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcInZpc2libGVcIikud2hpY2guaXNBKFwiYm9vbGVhblwiKTtcbiAgICB0aGlzLmhhc0EoXCJsYWJlbFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICByZXR1cm4gbGFiZWwgaW5zdGFuY2VvZiBUZXh0O1xuICAgIH0pO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLnBsb3QubGVnZW5kLCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsb3RMZWdlbmQ7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBSR0JDb2xvciA9IHJlcXVpcmUoJy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgSW5zZXRzID0gcmVxdWlyZSgnLi4vbWF0aC9pbnNldHMuanMnKSxcbiAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMucGxvdGFyZWEpO1xuXG52YXIgUGxvdGFyZWEgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJQbG90YXJlYVwiLCBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmhhc0EoXCJtYXJnaW5cIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgIHJldHVybiBtYXJnaW4gaW5zdGFuY2VvZiBJbnNldHM7XG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc0EoXCJib3JkZXJcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcblxuICAgIHRoaXMuaGFzQShcImNvbG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvciA9PT0gbnVsbCB8fCBjb2xvciBpbnN0YW5jZW9mIFJHQkNvbG9yO1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNBKFwiYm9yZGVyY29sb3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYm9yZGVyY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGJvcmRlcmNvbG9yIGluc3RhbmNlb2YgUkdCQ29sb3I7XG4gICAgfSk7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMucGxvdGFyZWEsIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGxvdGFyZWE7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBXYXJuaW5nID0gcmVxdWlyZSgnLi93YXJuaW5nLmpzJyksXG4gICAgRW51bSA9IHJlcXVpcmUoJy4uL21hdGgvZW51bS5qcycpLFxuICAgIHJlbmRlcmVyTGlzdCxcbiAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMucGxvdC5yZW5kZXJlciksXG4gICAgVHlwZSA9IG5ldyBFbnVtKFwiUmVuZGVyZXJUeXBlXCIpLFxuICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vbWF0aC9yZ2JfY29sb3IuanMnKTtcblxudmFyIFJlbmRlcmVyID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUmVuZGVyZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcInR5cGVcIikud2hpY2gudmFsaWRhdGVzV2l0aChUeXBlLmlzSW5zdGFuY2UpO1xuICAgIHRoaXMuaGFzQShcInBsb3RcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAocGxvdCkge1xuICAgICAgICB2YXIgUGxvdCA9IHJlcXVpcmUoJy4vcGxvdC5qcycpO1xuICAgICAgICByZXR1cm4gcGxvdCBpbnN0YW5jZW9mIFBsb3Q7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwibnVtYmVyT2ZWYXJpYWJsZXNcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuXG4gICAgdGhpcy5oYXNBKFwiZmlsdGVyXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiAoKHR5cGVvZihmaWx0ZXIpID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgICgodHlwZW9mKGZpbHRlci5yZXNldCkgPT09ICdmdW5jdGlvbicpICYmICh0eXBlb2YoZmlsdGVyLmZpbHRlcikgPT09ICdmdW5jdGlvbicpKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJzZXRVcE1pc3NpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBIGNhbGwgdG8gdGhpcyBtZXRob2QgcmVzdWx0cyBpbiB0aGUgYWRkaXRpb24gKG9yIHJlcGxhY2VtZW50KSBvZiBhIG1ldGhvZCBjYWxsZWQgXCJpc01pc3NpbmcoKVwiXG4gICAgICAgIC8vIHRoYXQgY2FuIGJlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIGEgdmFsdWUgbWVldHMgdGhlIFwibWlzc2luZ1wiIGNyaXRlcmlhIG9mIG9uZSBvZiB0aGlzIHJlbmRlcmVyJ3NcbiAgICAgICAgLy8gcGxvdCdzIGRhdGEgY29sdW1ucy4gIFRoZSBwb2ludCBvZiBoYXZpbmcgdGhpcyBcInNldFVwTWlzc2luZygpXCIgbWV0aG9kIGNyZWF0ZSB0aGUgXCJpc01pc3NpbmcoKVwiXG4gICAgICAgIC8vIG1ldGhvZCwgcmF0aGVyIHRoYW4ganVzdCBjb2RpbmcgdGhlIFwiaXNNaXNzaW5nKClcIiBtZXRob2QgZGlyZWN0bHkgaGVyZSwgaXMgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZVxuICAgICAgICAvLyBhIHBvaW50ZXIgdG8gdGhlIHBsb3QncyBkYXRhIG9iamVjdCB2aWEgYSBjbG9zdXJlLCBmb3IgZmFzdGVyIGFjY2VzcywgcmF0aGVyIHRoYW4gY29kaW5nXG4gICAgICAgIC8vIHRoaXMucGxvdCgpLmRhdGEoKSBpbiBcImlzTWlzc2luZygpXCIsIHdoaWNoIGFkZHMgdGhlIG92ZXJoZWFkIG9mIDIgZ2V0dGVyIGNhbGxzIHRvIGVhY2ggaW52b2NhdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBhd2t3YXJkLiAgV2hhdCB3ZSByZWFsbHkgd2FudCBpcyBmb3IgdGhpcyBzdHVmZiB0byBoYXBwZW4gYXV0b21hdGljYWxseSB3aGVuXG4gICAgICAgIC8vIHRoZSByZW5kZXJlcidzIFwicGxvdFwiIGF0dHJpYnV0ZSBpcyBzZXQuICBDYW4gSmVybWFpbmUgYmUgbW9kaWZpZWQgdG8gYWxsb3cgdXMgdG8gd3JpdGVcbiAgICAgICAgLy8gYSBjdXN0b20gc2V0dGVyLCBzbyB0aGF0IHdlIGNhbiBleGVjdXRlIHRoaXMgY29kZSBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHJlbmRlcidzIFwicGxvdFwiXG4gICAgICAgIC8vIGF0dHJpYnV0ZSBpcyBzZXQgPz8/XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90KCksXG4gICAgICAgICAgICBkYXRhO1xuICAgICAgICBpZiAoIXBsb3QpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogcmVuZGVyZXIuc2V0VXBNaXNzaW5nKCkgY2FsbGVkIGZvciByZW5kZXJlciB0aGF0IGhhcyBubyBwbG90IHJlZlwiKTtcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIHJlYWxseSBldmVudHVhbGx5IHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3IgQ29uc3RhbnRQbG90LCBjcmVhdGUgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBmYWxzZSwgc2luY2UgaXQgaGFzIG5vIGRhdGFcbiAgICAgICAgdmFyIENvbnN0YW50UGxvdCA9IHJlcXVpcmUoJy4vY29uc3RhbnRfcGxvdC5qcycpO1xuICAgICAgICBpZiAocGxvdCBpbnN0YW5jZW9mIENvbnN0YW50UGxvdCkge1xuICAgICAgICAgICAgdGhpcy5pc01pc3NpbmcgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICghcGxvdC5kYXRhKCkpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogcmVuZGVyZXIuc2V0VXBNaXNzaW5nKCkgY2FsbGVkIGZvciByZW5kZXJlciB3aG9zZSBwbG90IGhhcyBubyBkYXRhIHJlZlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gcGxvdC5kYXRhKCk7XG4gICAgICAgIHRoaXMuaXNNaXNzaW5nID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5pc01pc3NpbmcocFtpXSwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInR5cGVcIik7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMucGxvdC5yZW5kZXJlciwgYXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJ0cmFuc2Zvcm1Qb2ludFwiLCBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgaGF4aXMgPSB0aGlzLnBsb3QoKS5ob3Jpem9udGFsYXhpcygpLFxuICAgICAgICAgICAgdmF4aXMgPSB0aGlzLnBsb3QoKS52ZXJ0aWNhbGF4aXMoKSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgb3V0cHV0WzBdID0gaGF4aXMuZGF0YVZhbHVlVG9BeGlzVmFsdWUoaW5wdXRbMF0pO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW5wdXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IHZheGlzLmRhdGFWYWx1ZVRvQXhpc1ZhbHVlKGlucHV0W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuXG4gICAgdmFyIGVxdWFsT3JVbmRlZmluZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gKChhPT09YikgfHwgKChhPT09dW5kZWZpbmVkKSAmJiAoYj09PXVuZGVmaW5lZCkpKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwic2V0T3B0aW9uXCIsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyT3B0LFxuICAgICAgICAgICAgcmVuZGVyZXJPcHRzLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNNZXRhZGF0YVtuYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdCB0byBzZXQgdW5rbm93biByZW5kZXJlciBvcHRpb24gJ1wiK25hbWUrXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyT3B0cyA9IHRoaXMub3B0aW9ucygpW25hbWVdKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW5kZXJlck9wdHMuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbE9yVW5kZWZpbmVkKHJlbmRlcmVyT3B0cy5hdChpKS5taW4oKSwgbWluKSAmJlxuICAgICAgICAgICAgICAgIGVxdWFsT3JVbmRlZmluZWQocmVuZGVyZXJPcHRzLmF0KGkpLm1heCgpLCBtYXgpKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPcHRzLmF0KGkpLnZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IHRoaXMgZmFyLCBpdCBtZWFucyB3ZSBkaWRuJ3QgZmluZCBhbiBleGlzdGluZyBvcHRpb24gaW4gdGhlIGxpc3Qgd2l0aCBtYXRjaGluZyBtaW4vbWF4XG4gICAgICAgIC8vIHNldHRpbmdzLCBzbyB3ZSBjcmVhdGUgYSBuZXcgb25lIGFuZCBhcHBlbmQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdDpcbiAgICAgICAgcmVuZGVyZXJPcHQgPSBuZXcgKHRoaXMub3B0aW9uc01ldGFkYXRhW25hbWVdLnR5cGUpKCk7XG4gICAgICAgIHJlbmRlcmVyT3B0LnZhbHVlKHZhbHVlKTtcbiAgICAgICAgcmVuZGVyZXJPcHQubWluKG1pbik7XG4gICAgICAgIHJlbmRlcmVyT3B0Lm1heChtYXgpO1xuICAgICAgICByZW5kZXJlck9wdHMuYWRkKHJlbmRlcmVyT3B0KTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcInNldE9wdGlvbkZyb21TdHJpbmdcIiwgZnVuY3Rpb24gKG5hbWUsIHN0cmluZ1ZhbHVlLCBzdHJpbmdNaW4sIHN0cmluZ01heCkge1xuICAgICAgICB2YXIgcGxvdCA9IHRoaXMucGxvdCgpLFxuICAgICAgICAgICAgdHlwZSA9IHRoaXMudHlwZSgpLFxuICAgICAgICAgICAgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVHdvIGJsb2NrcyBvZiBjb2RlIGJlbG93IHByb3ZpZGVzIHN1cHBvcnQgZm9yIHRoZSBkZXByZWNhdGVkIFwiZG90c2l6ZVwiIGFuZCBcImRvdGNvbG9yXCJcbiAgICAgICAgLy8gb3B0aW9ucywgd2hpY2ggaGF2ZSBiZWVuIHJlcGxhY2VkIGJ5IFwicG9pbnRzaXplXCIgYW5kIFwicG9pbnRjb2xvclwiLiAgRGVsZXRlIHRoZXNlIGJsb2Nrc1xuICAgICAgICAvLyB3aGVuIHJlbW92aW5nIHN1cHBvcnQgZm9yIHRoaXMuXG4gICAgICAgIC8vIFxuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBGaXJzdCBibG9jayBpbiBzdXBwb3J0IG9mIGRlcHJlY2F0ZWQgZG90c2l6ZS9kb3Rjb2xvciBvcHRpb25zOlxuICAgICAgICAvL1xuICAgICAgICB2YXIgd2FybmluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwiZG90c2l6ZVwiKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJwb2ludHNpemVcIjtcbiAgICAgICAgICAgIHdhcm5pbmcgPSBuZXcgV2FybmluZygnZGVwcmVjYXRlZCBcImRvdHNpemVcIiBvcHRpb24gdXNlZCBmb3IgXCInICsgdHlwZSArICdcIiByZW5kZXJlcjsgdXNlIFwicG9pbnRzaXplXCIgaW5zdGVhZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiZG90Y29sb3JcIikge1xuICAgICAgICAgICAgbmFtZSA9IFwicG9pbnRjb2xvclwiO1xuICAgICAgICAgICAgd2FybmluZyA9IG5ldyBXYXJuaW5nKCdkZXByZWNhdGVkIFwiZG90Y29sb3JcIiBvcHRpb24gdXNlZCBmb3IgXCInICsgdHlwZSArICdcIiByZW5kZXJlcjsgdXNlIFwicG9pbnRjb2xvclwiIGluc3RlYWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcbiAgICAgICAgLy8gRW5kIG9mIGZpcnN0IGJsb2NrIGluIHN1cHBvcnQgb2YgZGVwcmVjYXRlZCBkb3RzaXplL2RvdGNvbG9yIG9wdGlvbnNcbiAgICAgICAgLy9cblxuICAgICAgICB2YXIgcmVuZGVyZXJPcHQ7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zTWV0YWRhdGFbbmFtZV0pIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgcmVuZGVyZXIgaGFzIG5vIG9wdGlvbiBuYW1lZCBcIm5hbWVcIiwgYmFpbCBvdXQgaW1tZWRpYXRlbHkuICBUaGlzIHNob3VsZCBldmVudHVhbGx5XG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciwgYnV0IGZvciBub3cgd2UganVzdCBxdWlldGx5IGlnbm9yZSBpdCwgdG8gZWxpbWluYXRlIGVycm9yIGNvbmRpdGlvbnMgY29taW5nXG4gICAgICAgICAgICAvLyBmcm9tIHVuaW1wbGVtZW50ZWQgb3B0aW9ucy5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJXQVJOSU5HOiByZW5kZXJlciBoYXMgbm8gb3B0aW9uIG5hbWVkICdcIiArIG5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FybmluZygnXCInICsgdHlwZSArICdcIicgKyAnIHJlbmRlcmVyIGhhcyBubyBvcHRpb24gbmFtZWQgXCInICsgbmFtZSArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyT3B0ID0gbmV3ICh0aGlzLm9wdGlvbnNNZXRhZGF0YVtuYW1lXS50eXBlKSgpO1xuICAgICAgICByZW5kZXJlck9wdC5wYXJzZVZhbHVlKHN0cmluZ1ZhbHVlLCB0aGlzKTtcbiAgICAgICAgaWYgKHBsb3QgJiYgcGxvdC52ZXJ0aWNhbGF4aXMoKSkge1xuICAgICAgICAgICAgaWYgKHN0cmluZ01pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPcHQubWluKCBEYXRhVmFsdWUucGFyc2UoIHBsb3QudmVydGljYWxheGlzKCkudHlwZSgpLCBzdHJpbmdNaW4gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyaW5nTWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlck9wdC5tYXgoIERhdGFWYWx1ZS5wYXJzZSggcGxvdC52ZXJ0aWNhbGF4aXMoKS50eXBlKCksIHN0cmluZ01heCApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE9wdGlvbihuYW1lLCByZW5kZXJlck9wdC52YWx1ZSgpLCByZW5kZXJlck9wdC5taW4oKSwgcmVuZGVyZXJPcHQubWF4KCkpO1xuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBTZWNvbmQgYmxvY2sgaW4gc3VwcG9ydCBvZiBkZXByZWNhdGVkIGRvdHNpemUvZG90Y29sb3Igb3B0aW9uczpcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHdhcm5pbmcpIHtcbiAgICAgICAgICAgIHRocm93IHdhcm5pbmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIEVuZCBvZiBzZWNvbmQgYmxvY2sgaW4gc3VwcG9ydCBvZiBkZXByZWNhdGVkIGRvdHNpemUvZG90Y29sb3Igb3B0aW9uczpcbiAgICAgICAgLy9cbiAgICB9KTtcblxuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZ2V0T3B0aW9uVmFsdWVcIiwgZnVuY3Rpb24gKG9wdGlvbk5hbWUsIC8qb3B0aW9uYWw6Ki92YWx1ZSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25MaXN0O1xuXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMoKTtcbiAgICAgICAgaWYgKHR5cGVvZihvcHRpb25zW29wdGlvbk5hbWVdKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gb3B0aW9uIFwiJytvcHRpb25OYW1lKydcIicpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbkxpc3QgPSBvcHRpb25zW29wdGlvbk5hbWVdKCk7XG4gICAgICAgIGlmICghb3B0aW9uTGlzdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIG9wdGlvbiBcIicrb3B0aW9uTmFtZSsnXCInKTtcbiAgICAgICAgfVxuICAgICAgICAvL05PVEU6IG9wdGlvbnMgYXJlIHN0b3JlZCBpbiByZXZlcnNlIG9yZGVyOyBkZWZhdWx0IG9uZSBpcyBhbHdheXMgaW4gdGhlICcwJyBwb3NpdGlvbi5cbiAgICAgICAgLy8gIFNlYXJjaCB0aHJvdWdoIHRoZW0gc3RhcnRpbmcgYXQgdGhlIEVORCBvZiB0aGUgbGlzdCwgZ29pbmcgYmFja3dhcmRzIVxuICAgICAgICBmb3IgKGkgPSBvcHRpb25MaXN0LnNpemUoKS0xOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbkxpc3QuYXQoaSk7XG4gICAgICAgICAgICBpZiAoKChvcHRpb24ubWluKCk9PT11bmRlZmluZWQpIHx8ICh2YWx1ZT09PXVuZGVmaW5lZCkgfHwgb3B0aW9uLm1pbigpLmxlKHZhbHVlKSkgJiZcbiAgICAgICAgICAgICAgICAoKG9wdGlvbi5tYXgoKT09PXVuZGVmaW5lZCkgfHwgKHZhbHVlPT09dW5kZWZpbmVkKSB8fCBvcHRpb24ubWF4KCkuZ3QodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb24udmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9KTtcblxuICAgIC8vIG1ldGhvZCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3M6XG4gICAgdGhpcy5yZXNwb25kc1RvKFwiYmVnaW5cIiwgZnVuY3Rpb24gKCkge1xuICAgIH0pO1xuICAgIC8vIG1ldGhvZCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3M6XG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZGF0YVBvaW50XCIsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgIH0pO1xuICAgIC8vIG1ldGhvZCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3M6XG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB9KTtcblxufSk7XG5cbi8qXG4gKiBQcml2YXRlIGxpc3Qgb2Yga25vd24gcmVuZGVyZXJzLiAgVGhpcyBsaXN0IGlzIHBvcHVsYXRlZCBmcm9tIHdpdGhpbiBpbmRpdmlkdWFsXG4gKiByZW5kZXJlciBzdWJtb2RlbCBpbXBsZW1lbnRhdGlvbnMgYnkgY2FsbHMgdG8gUmVuZGVyZXIuYWRkVHlwZS5cbiAqL1xucmVuZGVyZXJMaXN0ID0gW107XG5cbi8qXG4gKiBBZGQgYSByZW5kZXJlciBzdWJtb2RlbCB0byB0aGUgbGlzdCBvZiBrbm93biByZW5kZXJzLiAgcmVuZGVyZXJPYmogc2hvdWxkIGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczpcbiAqICAgICd0eXBlJyAgOiB0aGUgdHlwZSBvZiB0aGUgcmVuZGVyZXIgLS0gYSBzdHJpbmcsIHdoaWNoIGlzIHRoZSB2YWx1ZSBleHBlY3RlZFxuICogICAgICAgICAgICAgIGZvciB0aGUgdHlwZSBhdHRyaWJ1dGUgb2YgdGhlIG11Z2wgPHJlbmRlcmVyPiB0YWcuXG4gKiAgICAnbW9kZWwnIDogdGhlIHJlbmRlcmVyIHN1Ym1vZGVsXG4gKi9cblJlbmRlcmVyLmFkZFR5cGUgPSBmdW5jdGlvbiAocmVuZGVyZXJPYmopIHtcbiAgICByZW5kZXJlckxpc3QucHVzaChyZW5kZXJlck9iaik7XG59O1xuXG4vKlxuICogRmFjdG9yeSBtZXRob2Q6IGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhIHJlbmRlcmVyIHN1Ym1vZGVsIGJhc2VkIG9uIGl0cyB0eXBlIChhIHN0cmluZykuXG4gKi9cblJlbmRlcmVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHJlbmRlcmVyO1xuICAgIGZvciAoaSA9IDA7IGkgPCByZW5kZXJlckxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHJlbmRlcmVyTGlzdFtpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZW5kZXJlciA9IG5ldyAocmVuZGVyZXJMaXN0W2ldLm1vZGVsKSgpO1xuICAgICAgICAgICAgcmVuZGVyZXIudHlwZSh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZW5kZXJlci5jcmVhdGU6ICdcIiArIHR5cGUgKyBcIicgaXMgbm90IGEga25vd24gcmVuZGVyZXIgdHlwZVwiKTtcbiAgICAvLyAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlci5jcmVhdGU6IGF0dGVtcHQgdG8gY3JlYXRlIGEgcmVuZGVyZXIgb2YgdW5rbm93biB0eXBlJyk7XG59O1xuXG5SZW5kZXJlci5kZWNsYXJlT3B0aW9ucyA9IGZ1bmN0aW9uIChyZW5kZXJlciwgT3B0aW9uc01vZGVsTmFtZSwgb3B0aW9ucykge1xuICAgIHZhciBpLFxuICAgICAgICBPcHRpb25zTW9kZWwsXG4gICAgICAgIG9wdGlvbnNNZXRhZGF0YSxcbiAgICAgICAgZGVjbGFyZU9wdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbk5hbWUsIG9wdGlvblR5cGUpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHRoaXMgY2FsbCB0byBoYXNNYW55KCkgaGFzIHRvIGJlIGluIGEgZnVuY3Rpb24gaGVyZSwgcmF0aGVyIHRoYW4ganVzdFxuICAgICAgICAgICAgLy8gYmVpbmcgd3JpdHRlbiBpbmxpbmUgd2hlcmUgaXQgaXMgdXNlZCBiZWxvdywgYmVjYXVzZSB3ZSBuZWVkIGEgY2xvc3VyZSB0b1xuICAgICAgICAgICAgLy8gY2FwdHVyZSB2YWx1ZSBvZiBvcHRpb25zW2ldLnR5cGUgYXMgb3B0aW9uVHlwZSwgZm9yIHVzZSBpbiB0aGUgdmFsaWRhdGlvblxuICAgICAgICAgICAgLy8gZnVuY3Rpb24uICBPdGhlcndpc2UsIHRoZSB2YWxpZGF0b3IgY2FwdHVyZXMgdGhlICdvcHRpb25zJyBhcnJheSBhbmQgdGhlXG4gICAgICAgICAgICAvLyBsb2NhbCBsb29wIHZhcmlhYmxlIGkgaW5zdGVhZCwgYW5kIGV2YWx1YXRlcyBvcHRpb25zW2ldLnR5cGUgd2hlbiB2YWxpZGF0aW9uXG4gICAgICAgICAgICAvLyBpcyBwZXJmb3JtZWQhXG4gICAgICAgICAgICBPcHRpb25zTW9kZWwuaGFzTWFueShvcHRpb25OYW1lKS5lYWNoT2ZXaGljaC52YWxpZGF0ZVdpdGgoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdiBpbnN0YW5jZW9mIG9wdGlvblR5cGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgIE9wdGlvbnNNb2RlbCAgICA9IG5ldyBqZXJtYWluZS5Nb2RlbChPcHRpb25zTW9kZWxOYW1lLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgb3B0aW9uc01ldGFkYXRhID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZGVjbGFyZU9wdGlvbihvcHRpb25zW2ldLm5hbWUsIG9wdGlvbnNbaV0udHlwZSk7XG4gICAgICAgIG9wdGlvbnNNZXRhZGF0YVtvcHRpb25zW2ldLm5hbWVdID0ge1xuICAgICAgICAgICAgXCJ0eXBlXCIgICAgOiBvcHRpb25zW2ldLnR5cGUsXG4gICAgICAgICAgICBcImRlZmF1bHRcIiA6IG9wdGlvbnNbaV1bXCJkZWZhdWx0XCJdXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcmVyLmhhc0EoXCJvcHRpb25zXCIpLmlzSW1tdXRhYmxlKCkuZGVmYXVsdHNUbyhmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgT3B0aW9uc01vZGVsKCk7IH0pO1xuICAgIHJlbmRlcmVyLnByb3RvdHlwZS5vcHRpb25zTWV0YWRhdGEgPSBvcHRpb25zTWV0YWRhdGE7XG5cbiAgICByZW5kZXJlci5pc0J1aWx0V2l0aChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHBvcHVsYXRlIG9wdGlvbnMgd2l0aCBkZWZhdWx0IHZhbHVlcyBzdG9yZWQgaW4gb3B0aW9ucyBtZXRhZGF0YSAod2hpY2ggd2FzIHBvcHVsYXRlZCBieSBkZWNsYXJlT3B0aW9ucyk6XG4gICAgICAgIHZhciBvcHRpb25zTWV0YWRhdGEgPSB0aGlzLm9wdGlvbnNNZXRhZGF0YSxcbiAgICAgICAgICAgIG9wdCwgcm9wdDtcbiAgICAgICAgZm9yIChvcHQgaW4gb3B0aW9uc01ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uc01ldGFkYXRhLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICAgICAgICByb3B0ID0gbmV3IChvcHRpb25zTWV0YWRhdGFbb3B0XS50eXBlKShvcHRpb25zTWV0YWRhdGFbb3B0XVtcImRlZmF1bHRcIl0pO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucygpW29wdF0oKS5hZGQoIHJvcHQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59O1xuXG5cblJlbmRlcmVyLk9wdGlvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlJlbmRlcmVyLk9wdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpO1xuICAgIHRoaXMuaGFzQShcIm1pblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFWYWx1ZS5pc0luc3RhbmNlKTtcbiAgICB0aGlzLmhhc0EoXCJtYXhcIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhVmFsdWUuaXNJbnN0YW5jZSk7XG59KTtcblxuXG5SZW5kZXJlci5SR0JDb2xvck9wdGlvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzQShSZW5kZXJlci5PcHRpb24pO1xuICAgIHRoaXMuaGFzQShcInZhbHVlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgaW5zdGFuY2VvZiBSR0JDb2xvciB8fCB2ID09PSBudWxsO1xuICAgIH0pO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJ2YWx1ZVwiKTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJzZXJpYWxpemVWYWx1ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlKCkuZ2V0SGV4U3RyaW5nKCk7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwicGFyc2VWYWx1ZVwiLCBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHRoaXMudmFsdWUoIFJHQkNvbG9yLnBhcnNlKHN0cmluZykgKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJ2YWx1ZUVxXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSgpLmVxKHZhbHVlKTtcbiAgICB9KTtcblxufSk7XG5cblJlbmRlcmVyLk51bWJlck9wdGlvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlJlbmRlcmVyLk51bWJlck9wdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIuT3B0aW9uKTtcbiAgICB0aGlzLmhhc0EoXCJ2YWx1ZVwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInZhbHVlXCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInNlcmlhbGl6ZVZhbHVlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKS50b1N0cmluZygpO1xuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInBhcnNlVmFsdWVcIiwgZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICB0aGlzLnZhbHVlKCBwYXJzZUZsb2F0KHN0cmluZykgKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJ2YWx1ZUVxXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUoKT09PXZhbHVlKTtcbiAgICB9KTtcbn0pO1xuXG5SZW5kZXJlci5EYXRhVmFsdWVPcHRpb24gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJSZW5kZXJlci5EYXRhVmFsdWVPcHRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFJlbmRlcmVyLk9wdGlvbik7XG4gICAgdGhpcy5oYXNBKFwidmFsdWVcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpO1xuICAgICAgICByZXR1cm4gRGF0YVZhbHVlLmlzSW5zdGFuY2UodmFsdWUpIHx8IHZhbHVlID09PSBudWxsO1xuICAgIH0pO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJ2YWx1ZVwiKTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJzZXJpYWxpemVWYWx1ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwidmFsdWVFcVwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKS5lcSh2YWx1ZSk7XG4gICAgfSk7XG59KTtcblxuUmVuZGVyZXIuVmVydGljYWxEYXRhVmFsdWVPcHRpb24gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJSZW5kZXJlci5EYXRhVmFsdWVPcHRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFJlbmRlcmVyLkRhdGFWYWx1ZU9wdGlvbik7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInZhbHVlXCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInBhcnNlVmFsdWVcIiwgZnVuY3Rpb24gKHN0cmluZywgcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpO1xuICAgICAgICB0aGlzLnZhbHVlKCBEYXRhVmFsdWUucGFyc2UocmVuZGVyZXIucGxvdCgpLnZlcnRpY2FsYXhpcygpLnR5cGUoKSwgc3RyaW5nKSApO1xuICAgIH0pO1xuICAgIFxufSk7XG5cblJlbmRlcmVyLkhvcml6b250YWxEYXRhVmFsdWVPcHRpb24gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJSZW5kZXJlci5EYXRhVmFsdWVPcHRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFJlbmRlcmVyLkRhdGFWYWx1ZU9wdGlvbik7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInZhbHVlXCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInBhcnNlVmFsdWVcIiwgZnVuY3Rpb24gKHN0cmluZywgcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpO1xuICAgICAgICB0aGlzLnZhbHVlKCBEYXRhVmFsdWUucGFyc2UocmVuZGVyZXIucGxvdCgpLmhvcml6b250YWxheGlzKCkudHlwZSgpLCBzdHJpbmcpICk7XG4gICAgfSk7XG4gICAgXG59KTtcblxuUmVuZGVyZXIuRGF0YU1lYXN1cmVPcHRpb24gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJSZW5kZXJlci5EYXRhTWVhc3VyZU9wdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIuT3B0aW9uKTtcbiAgICB0aGlzLmhhc0EoXCJ2YWx1ZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgRGF0YU1lYXN1cmUgPSByZXF1aXJlKCcuL2RhdGFfbWVhc3VyZS5qcycpO1xuICAgICAgICByZXR1cm4gRGF0YU1lYXN1cmUuaXNJbnN0YW5jZSh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInZhbHVlXCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInNlcmlhbGl6ZVZhbHVlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJ2YWx1ZUVxXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSgpLmVxKHZhbHVlKTtcbiAgICB9KTtcbn0pO1xuXG5SZW5kZXJlci5WZXJ0aWNhbERhdGFNZWFzdXJlT3B0aW9uID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUmVuZGVyZXIuRGF0YU1lYXN1cmVPcHRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFJlbmRlcmVyLkRhdGFNZWFzdXJlT3B0aW9uKTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJwYXJzZVZhbHVlXCIsIGZ1bmN0aW9uIChzdHJpbmcsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBEYXRhTWVhc3VyZSA9IHJlcXVpcmUoJy4vZGF0YV9tZWFzdXJlLmpzJyk7XG4gICAgICAgIHRoaXMudmFsdWUoIERhdGFNZWFzdXJlLnBhcnNlKHJlbmRlcmVyLnBsb3QoKS52ZXJ0aWNhbGF4aXMoKS50eXBlKCksIHN0cmluZykgKTtcbiAgICB9KTtcbiAgICBcbn0pO1xuXG5SZW5kZXJlci5Ib3Jpem9udGFsRGF0YU1lYXN1cmVPcHRpb24gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJSZW5kZXJlci5EYXRhTWVhc3VyZU9wdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIuRGF0YU1lYXN1cmVPcHRpb24pO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJ2YWx1ZVwiKTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJwYXJzZVZhbHVlXCIsIGZ1bmN0aW9uIChzdHJpbmcsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBEYXRhTWVhc3VyZSA9IHJlcXVpcmUoJy4vZGF0YV9tZWFzdXJlLmpzJyk7XG4gICAgICAgIHRoaXMudmFsdWUoIERhdGFNZWFzdXJlLnBhcnNlKHJlbmRlcmVyLnBsb3QoKS5ob3Jpem9udGFsYXhpcygpLnR5cGUoKSwgc3RyaW5nKSApO1xuICAgIH0pO1xuICAgIFxufSk7XG5cblJlbmRlcmVyLlR5cGUgPSBUeXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuIiwicmVxdWlyZSgnLi9iYW5kX3JlbmRlcmVyLmpzJyk7XG5yZXF1aXJlKCcuL2Jhcl9yZW5kZXJlci5qcycpO1xucmVxdWlyZSgnLi9maWxsX3JlbmRlcmVyLmpzJyk7XG5yZXF1aXJlKCcuL3BvaW50bGluZV9yZW5kZXJlci5qcycpO1xucmVxdWlyZSgnLi9yYW5nZWJhcl9yZW5kZXJlci5qcycpO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG4vLyBUaGUgQmFuZCByZW5kZXJlciBpcyBhIDItdmFyaWFibGUgcmVuZGVyZXIgd2hpY2ggZmlsbHMgdGhlIHJlZ2lvblxuLy8gYmV0d2VlbiB0d28gZGF0YSBsaW5lcyB3aXRoIGEgc29saWQgY29sb3IsIGFuZCBkcmF3cyBhIGxpbmUgc2VnbWVudFxuLy8gYmV0d2VlbiBjb25zZWN1dGl2ZSBkYXRhIHBvaW50cyBpbiBlYWNoIGxpbmUuXG4vLyBcbi8vIEl0IGlzIHZlcnkgc2ltaWxhciB0byB0aGUgZmlsbCByZW5kZXJlciBleGNlcHQgdGhhdCB0aGUgZmlsbGVkIHJlZ2lvblxuLy8gZXh0ZW5kcyBiZXR3ZWVuIHRoZSB0d28gKHZlcnRpY2FsIGF4aXMpIGRhdGEgdmFsdWVzIGF0IGVhY2ggZGF0YSBwb2ludCwgaW5zdGVhZFxuLy8gb2YgYmV0d2VlbiBhIHNpbmdsZSAodmVydGljYWwgYXhpcykgdmFsdWUgYW5kIGEgaG9yaXpvbnRhbCBiYXNlIGxpbmUuXG4vLyBcbi8vIFRoZSBsaW5lIHNlZ2VtZW50cyBzaG91bGQgb2NjbHVkZSB0aGUgc29saWQgZmlsbC5cbi8vIFxuLy8gVGhpcyByZW5kZXJlciBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBsaW5lY29sb3Jcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgUkdCQ29sb3Jcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMHgwMDAwMDAgKGJsYWNrKVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBDb2xvciB1c2VkIGZvciBsaW5lIHNlZ21lbnRzLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGxpbmV3aWR0aFxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBXaWR0aCwgaW4gcGl4ZWxzLCBvZiBsaW5lIHNlZ21lbnRzLiAgQVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBvZiAwIG1lYW5zIGRvIG5vdCBkcmF3IGxpbmUgc2VnbWVudHMuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZTFjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICBub25lIChsaW5lY29sb3IgaXMgdXNlZClcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgQ29sb3IgdXNlZCBmb3IgbGluZSBzZWdtZW50cyBjb25uZWN0aW5nIHRoZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgb2YgdmFyaWFibGUgMS4gICBJZiBib3RoIGxpbmVjb2xvciBhbmRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTFjb2xvciBhcmUgc3BlY2lmaWVkLCBsaW5lMWNvbG9yIGlzIHVzZWQuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZTF3aWR0aFxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgLTEgKGxpbmV3aWR0aCBpcyB1c2VkKVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBXaWR0aCwgaW4gcGl4ZWxzLCBvZiBsaW5lIHNlZ21lbnRzIGNvbm5lY3RpbmcgdGhlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBvZiB2YXJpYWJsZSAxLiAgQSB2YWx1ZSBvZiAwIG1lYW5zIGRvIG5vdFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3IGxpbmUgc2VnbWVudHMuICAgSWYgYm90aCBsaW5ld2lkdGggYW5kXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUxd2lkdGggYXJlIHNwZWNpZmllZCwgbGluZTF3aWR0aCBpcyB1c2VkLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGxpbmUyY29sb3Jcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgUkdCQ29sb3Jcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgbm9uZSAobGluZWNvbG9yIGlzIHVzZWQpXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIENvbG9yIHVzZWQgZm9yIGxpbmUgc2VnbWVudHMgY29ubmVjdGluZyB0aGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIG9mIHZhcmlhYmxlIDIuICAgSWYgYm90aCBsaW5lY29sb3IgYW5kXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUyY29sb3IgYXJlIHNwZWNpZmllZCwgbGluZTJjb2xvciBpcyB1c2VkLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGxpbmUyd2lkdGhcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgbnVtYmVyXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIC0xIChsaW5ld2lkdGggaXMgdXNlZClcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgV2lkdGgsIGluIHBpeGVscywgb2YgbGluZSBzZWdtZW50cyBjb25uZWN0aW5nIHRoZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgb2YgdmFyaWFibGUgMi4gIEEgdmFsdWUgb2YgMCBtZWFucyBkbyBub3Rcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhdyBsaW5lIHNlZ21lbnRzLiAgIElmIGJvdGggbGluZXdpZHRoIGFuZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lMndpZHRoIGFyZSBzcGVjaWZpZWQsIGxpbmUyd2lkdGggaXMgdXNlZC5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBmaWxsY29sb3Jcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgUkdCQ29sb3Jcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMHg4MDgwODAgKGRhcmsgZ3JheSlcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgQ29sb3IgdXNlZCBmb3IgdGhlIGZpbGwgYXJlYS5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBmaWxsb3BhY2l0eVxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBPcGFjaXR5IHVzZWQgZm9yIHRoZSBmaWxsIGFyZWEuXG4vL1xuXG52YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlci5qcycpLFxuICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKTtcblxudmFyIEJhbmRSZW5kZXJlciA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkJhbmRSZW5kZXJlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIpO1xuICAgIHRoaXMuaGFzQShcIm51bWJlck9mVmFyaWFibGVzXCIpLndoaWNoLmRlZmF1bHRzVG8oMyk7XG59KTtcblxuQmFuZFJlbmRlcmVyLkdSQVkgPSBwYXJzZUludChcIjgwXCIsIDE2KSAvIDI1NTtcblxuUmVuZGVyZXIuZGVjbGFyZU9wdGlvbnMoQmFuZFJlbmRlcmVyLCBcIkJhbmRSZW5kZXJlck9wdGlvbnNcIiwgW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImxpbmVjb2xvclwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG5ldyBSR0JDb2xvcigwLDAsMClcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImxpbmV3aWR0aFwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAxXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJsaW5lMWNvbG9yXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuUkdCQ29sb3JPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbnVsbFxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwibGluZTF3aWR0aFwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAtMVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwibGluZTJjb2xvclwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG51bGxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImxpbmUyd2lkdGhcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5OdW1iZXJPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogLTFcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImZpbGxjb2xvclwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG5ldyBSR0JDb2xvcihCYW5kUmVuZGVyZXIuR1JBWSxCYW5kUmVuZGVyZXIuR1JBWSxCYW5kUmVuZGVyZXIuR1JBWSlcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImZpbGxvcGFjaXR5XCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IDEuMFxuICAgIH1cbl0pO1xuXG5SZW5kZXJlci5CQU5EID0gbmV3IFJlbmRlcmVyLlR5cGUoXCJiYW5kXCIpO1xuXG5SZW5kZXJlci5hZGRUeXBlKHtcInR5cGVcIiAgOiBSZW5kZXJlci5UeXBlLnBhcnNlKFwiYmFuZFwiKSxcbiAgICAgICAgICAgICAgICAgIFwibW9kZWxcIiA6IEJhbmRSZW5kZXJlcn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhbmRSZW5kZXJlcjtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxuLy8gVGhlIEJhciByZW5kZXJlciBpcyBhIDEtdmFyaWFibGUgcmVuZGVyZXIgd2hpY2ggZHJhd3MgYSBiYXIgYXQgZWFjaFxuLy8gbm9uLW1pc3NpbmcgZGF0YSBwb2ludCB3aXRoIGFuIG91dGxpbmUgYXJvdW5kIHRoZSBiYXIgYW5kIGEgc29saWRcbi8vIGZpbGwgYmV0d2VlbiB0aGUgYmFyIGFuZCB0aGUgaG9yaXpvbnRhbCBheGlzLlxuLy8gXG4vLyBUaGlzIHJlbmRlcmVyIGFjY2VwdHMgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGJhcndpZHRoXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIERhdGFNZWFzdXJlXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgID8/P1xuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBXaWR0aCwgaW4gcmVsYXRpdmUgdGVybXMgdG8gdGhlIHR5cGUgb2YgdGhlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMgdGhlIHBsb3QgaXMgb24sIG9mIHRoZSBiYXJzLlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgYmFyb2Zmc2V0XG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAwXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFRoZSBvZmZzZXQsIGluIHBpeGVscywgb2YgdGhlIGxlZnQgZWRnZSBvZlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIGJhciBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIGRhdGEgdmFsdWUuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBiYXJiYXNlXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIERhdGFWYWx1ZVxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICBudWxsXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFRoZSBsb2NhdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHBsb3Qnc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbCBheGlzLCBvZiB0aGUgYm90dG9tIG9mIHRoZSBiYXI7IGlmXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vIGJhcmJhc2UgaXMgc3BlY2lmaWVkLCB0aGUgYmFycyB3aWxsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZCBkb3duIHRvIHRoZSBib3R0b20gb2YgdGhlIHBsb3QgYXJlYS5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGxpbmVjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAweDAwMDAwMCAoYmxhY2spXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFRoZSBjb2xvciB0byBiZSB1c2VkIGZvciB0aGUgb3V0bGluZSBhcm91bmRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBiYXIuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgZmlsbGNvbG9yXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIFJHQkNvbG9yXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDB4MDAwMDAwIChibGFjaylcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgVGhlIGNvbG9yIHRvIGJlIHVzZWQgZm9yIHRoZSBmaWxsIGluc2lkZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIGJhcjsgaWYgYmFyYmFzZSBpcyBzcGVjaWZpZWQsIHRoaXNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgaXMgdXNlZCBvbmx5IGZvciBiYXJzIHRoYXQgZXh0ZW5kXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3ZlIHRoZSBiYXNlLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGZpbGxvcGFjaXR5XG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAxXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIE9wYWNpdHkgdXNlZCBmb3IgdGhlIGZpbGwgaW5zaWRlIGVhY2ggYmFyLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGhpZGVsaW5lc1xuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMlxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBCYXJzIHdoaWNoIGFyZSBsZXNzIHdpZGUsIGluIHBpeGVscywgdGhhblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIG51bWJlciBkbyBub3QgcmVuZGVyIHRoZWlyIG91dGxpbmVzLlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBcbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyLmpzJyksXG4gICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi4vZGF0YV9tZWFzdXJlLmpzJyksXG4gICAgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLnBsb3QucmVuZGVyZXIpO1xuXG52YXIgQmFyUmVuZGVyZXIgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJCYXJSZW5kZXJlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIpO1xuICAgIHRoaXMuaGFzQShcIm51bWJlck9mVmFyaWFibGVzXCIpLndoaWNoLmRlZmF1bHRzVG8oMik7XG59KTtcblxuUmVuZGVyZXIuZGVjbGFyZU9wdGlvbnMoQmFyUmVuZGVyZXIsIFwiQmFyUmVuZGVyZXJPcHRpb25zXCIsIFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJiYXJ3aWR0aFwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLkhvcml6b250YWxEYXRhTWVhc3VyZU9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBuZXcgRGF0YU1lYXN1cmUucGFyc2UoXCJudW1iZXJcIiwgMClcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImJhcm9mZnNldFwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJiYXJiYXNlXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuVmVydGljYWxEYXRhVmFsdWVPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbnVsbFxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwiZmlsbGNvbG9yXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuUkdCQ29sb3JPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbmV3IFJHQkNvbG9yKDAsMCwwKVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwiZmlsbG9wYWNpdHlcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5OdW1iZXJPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogMS4wXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJsaW5lY29sb3JcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5SR0JDb2xvck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBuZXcgUkdCQ29sb3IoMCwwLDApXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJoaWRlbGluZXNcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5OdW1iZXJPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogMlxuICAgIH1cbl0pO1xuXG5SZW5kZXJlci5CQVIgPSBuZXcgUmVuZGVyZXIuVHlwZShcImJhclwiKTtcblxuUmVuZGVyZXIuYWRkVHlwZSh7XCJ0eXBlXCIgIDogUmVuZGVyZXIuVHlwZS5wYXJzZShcImJhclwiKSxcbiAgICAgICAgICAgICAgICAgIFwibW9kZWxcIiA6IEJhclJlbmRlcmVyfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFyUmVuZGVyZXI7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbi8vIFRoZSBGaWxsIHJlbmRlcmVyIGlzIGEgMS12YXJpYWJsZSByZW5kZXJlciB3aGljaCBjb25uZWN0cyBjb25zZWN1dGl2ZVxuLy8gbm9uLW1pc3NpbmcgZGF0YSBwb2ludHMgd2l0aCBsaW5lIHNlZ21lbnRzIHdpdGggYSBzb2xpZCBmaWxsIGJldHdlZW5cbi8vIHRoZSBsaW5lcyBhbmQgdGhlIGhvcml6b250YWwgYXhpcy5cbi8vIFxuLy8gVGhlIGxpbmUgc2VnZW1lbnRzIHNob3VsZCBvY2NsdWRlIHRoZSBzb2xpZCBmaWxsLlxuLy8gXG4vLyBUaGlzIHJlbmRlcmVyIGFjY2VwdHMgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGxpbmVjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAweDAwMDAwMCAoYmxhY2spXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIENvbG9yIHVzZWQgZm9yIGxpbmUgc2VnbWVudHNcbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBsaW5ld2lkdGhcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgbnVtYmVyXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDFcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgV2lkdGgsIGluIHBpeGVscywgb2YgbGluZSBzZWdtZW50cy4gIEFcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgb2YgMCBtZWFucyBkbyBub3QgZHJhdyBsaW5lIHNlZ21lbnRzLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGZpbGxjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAweDgwODA4MCAoZGFyayBncmF5KVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBDb2xvciB1c2VkIGZvciB0aGUgZmlsbCBhcmVhLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGRvd25maWxsY29sb3Jcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgUkdCQ29sb3Jcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgbnVsbFxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBDb2xvciB1c2VkIGZvciBmaWxsIGFyZWEgdGhhdCBpcyBiZWxvdyB0aGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbGJhc2UsIGlmIGEgZmlsbGJhc2UgaXMgc3BlY2lmaWVkLiBJZiBub1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBkb3duZmlsbGNvbG9yIGlzIHNwZWNpZmVkLCBmaWxsY29sb3Igd2lsbFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBiZSB1c2VkIGZvciBhbGwgZmlsbCBhcmVhcy5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBmaWxsb3BhY2l0eVxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBPcGFjaXR5IHVzZWQgZm9yIHRoZSBmaWxsIGFyZWEuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgZmlsbGJhc2Vcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgRGF0YVZhbHVlXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIG51bGxcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgVGhlIGxvY2F0aW9uIGFsb25nIHRoZSBwbG90J3MgdmVydGljYWwgYXhpc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgaG9yaXpvbnRhbCBsaW5lIHRoYXQgZGVmaW5lcyB0aGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tIChvciB0b3ApIG9mIHRoZSBmaWxsZWQgcmVnaW9uOyBpZiBub1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsYmFzZSBpcyBzcGVjaWZpZWQsIHRoZSBmaWxsIHdpbGwgZXh0ZW5kXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd24gdG8gdGhlIGJvdHRvbSBvZiB0aGUgcGxvdCBhcmVhLlxuLy8gXG52YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlci5qcycpLFxuICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMucGxvdC5yZW5kZXJlciksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMucGxvdC5yZW5kZXJlcik7XG5cbnZhciBGaWxsUmVuZGVyZXIgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJGaWxsUmVuZGVyZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFJlbmRlcmVyKTtcbiAgICB0aGlzLmhhc0EoXCJudW1iZXJPZlZhcmlhYmxlc1wiKS53aGljaC5kZWZhdWx0c1RvKDIpO1xufSk7XG5cbkZpbGxSZW5kZXJlci5HUkFZID0gcGFyc2VJbnQoXCI4MFwiLCAxNikgLyAyNTU7XG5cblJlbmRlcmVyLmRlY2xhcmVPcHRpb25zKEZpbGxSZW5kZXJlciwgXCJGaWxsUmVuZGVyZXJPcHRpb25zXCIsIFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJsaW5lY29sb3JcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5SR0JDb2xvck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBuZXcgUkdCQ29sb3IoMCwwLDApXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJsaW5ld2lkdGhcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5OdW1iZXJPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogMVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwiZmlsbGNvbG9yXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuUkdCQ29sb3JPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbmV3IFJHQkNvbG9yKEZpbGxSZW5kZXJlci5HUkFZLEZpbGxSZW5kZXJlci5HUkFZLEZpbGxSZW5kZXJlci5HUkFZKVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwiZG93bmZpbGxjb2xvclwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG51bGxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImZpbGxvcGFjaXR5XCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IDEuMFxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwiZmlsbGJhc2VcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5WZXJ0aWNhbERhdGFWYWx1ZU9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBudWxsXG4gICAgfVxuXSk7XG5cblJlbmRlcmVyLkZJTEwgPSBuZXcgUmVuZGVyZXIuVHlwZShcImZpbGxcIik7XG5cblJlbmRlcmVyLmFkZFR5cGUoe1widHlwZVwiICA6IFJlbmRlcmVyLlR5cGUucGFyc2UoXCJmaWxsXCIpLFxuICAgICAgICAgICAgICAgICAgXCJtb2RlbFwiIDogRmlsbFJlbmRlcmVyfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsbFJlbmRlcmVyO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG4vLyBUaGUgUG9pbnRsaW5lIHJlbmRlcmVyIGlzIGEgMS12YXJpYWJsZSByZW5kZXJlciB3aGljaCBkcmF3cyBhIHNoYXBlXG4vLyBhdCBlYWNoIG5vbi1taXNzaW5nIGRhdGEgcG9pbnQsIGFuZCBjb25uZWN0cyBjb25zZWN1dGl2ZVxuLy8gbm9uLW1pc3NpbmcgZGF0YSBwb2ludHMgd2l0aCBsaW5lIHNlZ21lbnRzLiAgVGhlIGRyYXdpbmcgb2YgYm90aFxuLy8gdGhlIHBvaW50cywgYW5kIHRoZSBsaW5lcywgaXMgb3B0aW9uYWwsIHNvIHRoaXMgcmVuZGVyZXIgY2FuIGJlXG4vLyB1c2VkIHRvIGRyYXcganVzdCBwb2ludHMsIGp1c3QgbGluZSBzZWdtZW50cywgb3IgYm90aC5cbi8vIFxuLy8gV2hlbiBib3RoIHBvaW50cyBhbmQgbGluZSBzZWdtZW50cyBhcmUgZHJhd24sIHRoZSBwb2ludHMgc2hvdWxkXG4vLyBiZSBkcmF3biBvbiBcInRvcCBvZlwiIHRoZSBsaW5lIHNlZ21lbnRzLlxuLy8gXG4vLyBUaGlzIHJlbmRlcmVyIGFjY2VwdHMgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGxpbmV3aWR0aFxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBXaWR0aCwgaW4gcGl4ZWxzLCBvZiBsaW5lIHNlZ21lbnRzLiAgQVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBvZiAwIG1lYW5zIGRvIG5vdCBkcmF3IGxpbmUgc2VnbWVudHMuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZWNvbG9yXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIFJHQkNvbG9yXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDB4MDAwMDAwIChibGFjaylcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgQ29sb3IgdXNlZCBmb3IgbGluZSBzZWdtZW50c1xuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIHBvaW50c2l6ZVxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMFxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBUaGUgcmFkaXVzIG9mIGRyYXduIHBvaW50cy4gIEEgdmFsdWVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgMCBtZWFucyBkbyBub3QgZHJhdyBwb2ludHMuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgcG9pbnRjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAweDAwMDAwMCAoYmxhY2spXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIENvbG9yIHVzZWQgZm9yIGRyYXdpbmcgcG9pbnRzXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgcG9pbnRzaGFwZVxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBPbmUgb2YgdGhlIGNvbnN0YW50cyBQb2ludGxpbmVSZW5kZXJlci5DSVJDTEUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50bGluZVJlbmRlcmVyLlNRVUFSRSwgUG9pbnRsaW5lUmVuZGVyZXIuVFJJQU5HTEUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50bGluZVJlbmRlcmVyLkRJQU1PTkQsIFBvaW50bGluZVJlbmRlcmVyLlNUQVIsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50bGluZVJlbmRlcmVyLlBMVVMsIG9yIFBvaW50bGluZVJlbmRlcmVyLlguICBUaGVzZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kIHRvIHRoZSBzdHJpbmdzIFwiY2lyY2xlXCIsIFwic3F1YXJlXCIsIFwidHJpYW5nbGVcIixcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaWFtb25kXCIsIFwic3RhclwiLCBcInBsdXNcIiwgYW5kIFwieFwiIGluIE1VR0wgZmlsZXMuXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIFBvaW50bGluZVJlbmRlcmVyLkNJUkNMRVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBUaGUgc2hhcGUgdG8gdXNlIGZvciBkcmF3aW5nIHBvaW50cy5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBsaW5lc3Ryb2tlXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIE9uZSBvZiB0aGUgY29uc3RhbnRzIFBvaW50bGluZVJlbmRlcmVyLlNPTElELFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBQb2ludGxpbmVSZW5kZXJlci5EQVNIRUQuICBUaGVzZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kIHRvIHRoZSBzdHJpbmdzIFwic29saWRcIiwgXCJkYXNoZWRcIiBpbiBNVUdMIGZpbGVzLlxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICBQb2ludGxpbmVSZW5kZXJlci5TT0xJRFxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBXaGV0aGVyIHRvIGRyYXcgc29saWQgb3IgZGFzaGVkIGxpbmVzXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgcG9pbnRvcGFjaXR5XG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAxLjBcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgVGhlIG9wYWN0aXkgb2YgdGhlIGRyYXduIHBvaW50cywgaW4gdGhlIHJhbmdlIDAtMS5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgQSB2YWx1ZSBvZiAxIG1lYW5zIGNvbXBsZXRlbHkgb3BhcXVlOyBhIHZhbHVlIG9mIDBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhbnMgY29tcGxldGVseSBpbnZpc2libGUuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgcG9pbnRvdXRsaW5ld2lkdGhcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgbnVtYmVyXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDBcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgVGhlIHdpZHRoLCBpbiBwaXhlbHMsIG9mIHRoZSBvdXRsaW5lIHRvIGJlIGRyYXduXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyb3VuZCBlYWNoIHBvaW50LiAgQSB2YWx1ZSBvZiAwIG1lYW5zIGRyYXcgbm9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZS5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBwb2ludG91dGxpbmVjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAweDAwMDAwMCAoYmxhY2spXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFRoZSBjb2xvciB0byB1c2UgZm9yIHRoZSBvdXRsaW5lIGFyb3VuZCBlYWNoIHBvaW50LlxuLy9cbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyLmpzJyksXG4gICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90LnJlbmRlcmVyKTtcblxudmFyIFBvaW50bGluZVJlbmRlcmVyID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUG9pbnRsaW5lUmVuZGVyZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFJlbmRlcmVyKTtcbiAgICB0aGlzLmhhc0EoXCJudW1iZXJPZlZhcmlhYmxlc1wiKS53aGljaC5kZWZhdWx0c1RvKDIpO1xuICAgIC8vXG4gICAgLy90aGlzLmlzQnVpbHRXaXRoKC4uLikgIE5PIE5PIE5PISEhXG4gICAgLy9cbiAgICAvLyBETyBOT1QgQ0FMTCBpc0J1aWx0V2l0aCBmb3IgYSByZW5kZXJlciBzdWJjbGFzczsgUmVuZGVyZXIuZGVjbGFyZU9wdGlvbnMgY2FsbHMgaXNCdWlsdFdpdGgoKSwgYW5kIGl0XG4gICAgLy8gd2lsbCBicmVhayBpZiB5b3UgYWxzbyBjYWxsIGl0IGhlcmUhISFcbn0pO1xuXG5cblBvaW50bGluZVJlbmRlcmVyLkNJUkNMRSAgID0gXCJjaXJjbGVcIjtcblBvaW50bGluZVJlbmRlcmVyLlNRVUFSRSAgID0gXCJzcXVhcmVcIjtcblBvaW50bGluZVJlbmRlcmVyLlRSSUFOR0xFID0gXCJ0cmlhbmdsZVwiO1xuUG9pbnRsaW5lUmVuZGVyZXIuRElBTU9ORCAgPSBcImRpYW1vbmRcIjtcblBvaW50bGluZVJlbmRlcmVyLlNUQVIgICAgID0gXCJzdGFyXCI7XG5Qb2ludGxpbmVSZW5kZXJlci5QTFVTICAgICA9IFwicGx1c1wiO1xuUG9pbnRsaW5lUmVuZGVyZXIuWCAgICAgICAgPSBcInhcIjtcblxuUG9pbnRsaW5lUmVuZGVyZXIuc2hhcGVzID0gWyBcbiAgICBQb2ludGxpbmVSZW5kZXJlci5DSVJDTEUsXG4gICAgUG9pbnRsaW5lUmVuZGVyZXIuU1FVQVJFLFxuICAgIFBvaW50bGluZVJlbmRlcmVyLlRSSUFOR0xFLFxuICAgIFBvaW50bGluZVJlbmRlcmVyLkRJQU1PTkQsXG4gICAgUG9pbnRsaW5lUmVuZGVyZXIuU1RBUixcbiAgICBQb2ludGxpbmVSZW5kZXJlci5QTFVTLFxuICAgIFBvaW50bGluZVJlbmRlcmVyLlhcbl07XG5cblBvaW50bGluZVJlbmRlcmVyLmlzU2hhcGUgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGk9MDsgaTxQb2ludGxpbmVSZW5kZXJlci5zaGFwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKFBvaW50bGluZVJlbmRlcmVyLnNoYXBlc1tpXSA9PT0gc2hhcGUpIHsgcmV0dXJuIHRydWU7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUG9pbnRsaW5lUmVuZGVyZXIucGFyc2VTaGFwZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICBpZiAoc3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IFBvaW50bGluZVJlbmRlcmVyLkNJUkNMRSkgICB7IHJldHVybiBQb2ludGxpbmVSZW5kZXJlci5DSVJDTEU7ICAgfVxuICAgIGlmIChzdHJpbmcudG9Mb3dlckNhc2UoKSA9PT0gUG9pbnRsaW5lUmVuZGVyZXIuU1FVQVJFKSAgIHsgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyLlNRVUFSRTsgICB9XG4gICAgaWYgKHN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBQb2ludGxpbmVSZW5kZXJlci5UUklBTkdMRSkgeyByZXR1cm4gUG9pbnRsaW5lUmVuZGVyZXIuVFJJQU5HTEU7IH1cbiAgICBpZiAoc3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IFBvaW50bGluZVJlbmRlcmVyLkRJQU1PTkQpICB7IHJldHVybiBQb2ludGxpbmVSZW5kZXJlci5ESUFNT05EOyAgfVxuICAgIGlmIChzdHJpbmcudG9Mb3dlckNhc2UoKSA9PT0gUG9pbnRsaW5lUmVuZGVyZXIuU1RBUikgICAgIHsgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyLlNUQVI7ICAgICB9XG4gICAgaWYgKHN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBQb2ludGxpbmVSZW5kZXJlci5QTFVTKSAgICAgeyByZXR1cm4gUG9pbnRsaW5lUmVuZGVyZXIuUExVUzsgICAgIH1cbiAgICBpZiAoc3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IFBvaW50bGluZVJlbmRlcmVyLlgpICAgICAgICB7IHJldHVybiBQb2ludGxpbmVSZW5kZXJlci5YOyAgICAgICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gcG9pbnQgc2hhcGU6IFwiICsgc3RyaW5nKTtcbn07XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGEgXCJzaGFwZVwiIGVudW0gb2JqZWN0IHRvIGEgc3RyaW5nLiAgSW4gcmVhbGl0eSwgdGhlIG9iamVjdHMgQVJFXG4gKiB0aGUgc3RyaW5ncywgc28gd2UganVzdCByZXR1cm4gdGhlIG9iamVjdC5cbiAqL1xuUG9pbnRsaW5lUmVuZGVyZXIuc2VyaWFsaXplU2hhcGUgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICByZXR1cm4gc2hhcGU7XG59O1xuXG5Qb2ludGxpbmVSZW5kZXJlci5TaGFwZU9wdGlvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlBvaW50bGluZVJlbmRlcmVyLlNoYXBlT3B0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzQShSZW5kZXJlci5PcHRpb24pO1xuICAgIHRoaXMuaGFzQShcInZhbHVlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoUG9pbnRsaW5lUmVuZGVyZXIuaXNTaGFwZSk7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInZhbHVlXCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInNlcmlhbGl6ZVZhbHVlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyLnNlcmlhbGl6ZVNoYXBlKHRoaXMudmFsdWUoKSk7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwicGFyc2VWYWx1ZVwiLCBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHRoaXMudmFsdWUoIFBvaW50bGluZVJlbmRlcmVyLnBhcnNlU2hhcGUoc3RyaW5nKSApO1xuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInZhbHVlRXFcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSgpPT09dmFsdWUpO1xuICAgIH0pO1xufSk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblBvaW50bGluZVJlbmRlcmVyLlNPTElEICAgPSBcInNvbGlkXCI7XG5Qb2ludGxpbmVSZW5kZXJlci5EQVNIRUQgID0gXCJkYXNoZWRcIjtcblxuUG9pbnRsaW5lUmVuZGVyZXIuc3Ryb2tlcyA9IFsgXG4gICAgUG9pbnRsaW5lUmVuZGVyZXIuU09MSUQsXG4gICAgUG9pbnRsaW5lUmVuZGVyZXIuREFTSEVEXG5dO1xuXG5Qb2ludGxpbmVSZW5kZXJlci5pc1N0cm9rZSA9IGZ1bmN0aW9uIChzdHJva2UpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGk9MDsgaTxQb2ludGxpbmVSZW5kZXJlci5zdHJva2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChQb2ludGxpbmVSZW5kZXJlci5zdHJva2VzW2ldID09PSBzdHJva2UpIHsgcmV0dXJuIHRydWU7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUG9pbnRsaW5lUmVuZGVyZXIucGFyc2VTdHJva2UgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKHN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBQb2ludGxpbmVSZW5kZXJlci5TT0xJRCkgICB7IHJldHVybiBQb2ludGxpbmVSZW5kZXJlci5TT0xJRDsgICB9XG4gICAgaWYgKHN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBQb2ludGxpbmVSZW5kZXJlci5EQVNIRUQpICB7IHJldHVybiBQb2ludGxpbmVSZW5kZXJlci5EQVNIRUQ7ICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gbGluZSBzdHJva2U6IFwiICsgc3RyaW5nKTtcbn07XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGEgXCJzdHJva2VcIiBlbnVtIG9iamVjdCB0byBhIHN0cmluZy4gIEluIHJlYWxpdHksIHRoZSBvYmplY3RzIEFSRVxuICogdGhlIHN0cmluZ3MsIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBvYmplY3QuXG4gKi9cblBvaW50bGluZVJlbmRlcmVyLnNlcmlhbGl6ZVN0cm9rZSA9IGZ1bmN0aW9uIChzdHJva2UpIHtcbiAgICByZXR1cm4gc3Ryb2tlO1xufTtcblxuUG9pbnRsaW5lUmVuZGVyZXIuU3Ryb2tlT3B0aW9uID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUG9pbnRsaW5lUmVuZGVyZXIuU3Ryb2tlT3B0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzQShSZW5kZXJlci5PcHRpb24pO1xuICAgIHRoaXMuaGFzQShcInZhbHVlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoUG9pbnRsaW5lUmVuZGVyZXIuaXNTdHJva2UpO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJ2YWx1ZVwiKTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJzZXJpYWxpemVWYWx1ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBQb2ludGxpbmVSZW5kZXJlci5zZXJpYWxpemVTdHJva2UodGhpcy52YWx1ZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJwYXJzZVZhbHVlXCIsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgdGhpcy52YWx1ZSggUG9pbnRsaW5lUmVuZGVyZXIucGFyc2VTdHJva2Uoc3RyaW5nKSApO1xuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInZhbHVlRXFcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSgpPT09dmFsdWUpO1xuICAgIH0pO1xufSk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblJlbmRlcmVyLmRlY2xhcmVPcHRpb25zKFBvaW50bGluZVJlbmRlcmVyLCBcIlBvaW50bGluZVJlbmRlcmVyT3B0aW9uc1wiLCBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwibGluZWNvbG9yXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuUkdCQ29sb3JPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbmV3IFJHQkNvbG9yKDAsMCwwKVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwibGluZXdpZHRoXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IDFcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcInBvaW50c2hhcGVcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBQb2ludGxpbmVSZW5kZXJlci5TaGFwZU9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBQb2ludGxpbmVSZW5kZXJlci5DSVJDTEVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImxpbmVzdHJva2VcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBQb2ludGxpbmVSZW5kZXJlci5TdHJva2VPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogUG9pbnRsaW5lUmVuZGVyZXIuU09MSURcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcInBvaW50c2l6ZVwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJwb2ludGNvbG9yXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuUkdCQ29sb3JPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbmV3IFJHQkNvbG9yKDAsMCwwKVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwicG9pbnRvcGFjaXR5XCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IDEuMFxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwicG9pbnRvdXRsaW5ld2lkdGhcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5OdW1iZXJPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogMFxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwicG9pbnRvdXRsaW5lY29sb3JcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5SR0JDb2xvck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBuZXcgUkdCQ29sb3IoMCwwLDApXG4gICAgfVxuXSk7XG5cblJlbmRlcmVyLlBPSU5UTElORSA9IG5ldyBSZW5kZXJlci5UeXBlKFwicG9pbnRsaW5lXCIpO1xuUmVuZGVyZXIuUE9JTlQgICAgID0gbmV3IFJlbmRlcmVyLlR5cGUoXCJwb2ludFwiKTtcblJlbmRlcmVyLkxJTkUgICAgICA9IG5ldyBSZW5kZXJlci5UeXBlKFwibGluZVwiKTtcblxuUmVuZGVyZXIuYWRkVHlwZSh7XCJ0eXBlXCIgIDogUmVuZGVyZXIuVHlwZS5wYXJzZShcInBvaW50bGluZVwiKSxcbiAgICAgICAgICAgICAgICAgIFwibW9kZWxcIiA6IFBvaW50bGluZVJlbmRlcmVyfSk7XG5SZW5kZXJlci5hZGRUeXBlKHtcInR5cGVcIiAgOiBSZW5kZXJlci5UeXBlLnBhcnNlKFwibGluZVwiKSxcbiAgICAgICAgICAgICAgICAgIFwibW9kZWxcIiA6IFBvaW50bGluZVJlbmRlcmVyfSk7XG5SZW5kZXJlci5hZGRUeXBlKHtcInR5cGVcIiAgOiBSZW5kZXJlci5UeXBlLnBhcnNlKFwicG9pbnRcIiksXG4gICAgICAgICAgICAgICAgICBcIm1vZGVsXCIgOiBQb2ludGxpbmVSZW5kZXJlcn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50bGluZVJlbmRlcmVyO1xuXG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbi8vIFRoZSBSYW5nZUJhciByZW5kZXJlciBpcyBhIDItdmFyaWFibGUgcmVuZGVyZXIgd2hpY2ggZHJhd3MgYVxuLy8gdmVydGljYWwgYmFyIGJldHdlZW4gdHdvIGRhdGEgdmFsdWVzLCBhbmQgb3B0aW9uYWxseSBvdXRsaW5lc1xuLy8gYXJvdW5kIHRoZSBiYXJzLiAgSXQgaXMgdmVyeSBzaW1pbGFyIHRvIHRoZSBCYXIgcmVuZGVyZXIgZXhjZXB0XG4vLyB0aGF0IHRoZSBiYXIgaXMgZHJhd24gYmV0d2VlbiB0d28gZGF0YSB2YWx1ZXMsIGluc3RlYWQgb2YgYmV0d2VlbiBhXG4vLyBzaW5nbGUgZGF0YSB2YWx1ZSBhbmQgYSBiYXNlIGxpbmUuXG4vLyBcbi8vIFRoZSBsaW5lIHNlZ2VtZW50cyBzaG91bGQgb2NjbHVkZSB0aGUgc29saWQgZmlsbC5cbi8vIFxuLy8gVGhpcyByZW5kZXJlciBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBiYXJ3aWR0aFxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBEYXRhTWVhc3VyZVxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICA/Pz9cbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgV2lkdGgsIGluIHJlbGF0aXZlIHRlcm1zIHRvIHRoZSB0eXBlIG9mIHRoZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzIHRoZSBwbG90IGlzIG9uLCBvZiB0aGUgYmFycy5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGJhcm9mZnNldFxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMFxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBUaGUgb2Zmc2V0IG9mIHRoZSBsZWZ0IGVkZ2Ugb2YgZWFjaCBiYXJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBkYXRhIHZhbHVlLCBhcyBhXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uICgwLTEpIG9mIHRoZSBiYXJ3aWR0aC5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBmaWxsY29sb3Jcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgUkdCQ29sb3Jcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMHg4MDgwODAgKGRhcmsgZ3JheSlcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgQ29sb3IgdXNlZCBmb3IgZmlsbGluZyB0aGUgYmFycy5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBmaWxsb3BhY2l0eVxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBPcGFjaXR5IHVzZWQgZm9yIHRoZSBmaWxsIGFyZWEuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZWNvbG9yXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIFJHQkNvbG9yXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDB4MDAwMDAwIChibGFjaylcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgQ29sb3IgdXNlZCBmb3Igb3V0bGluZXMgYXJvdW5kIHRoZSBiYXJzLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGxpbmV3aWR0aFxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMFxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBXaWR0aCwgaW4gcGl4ZWxzLCBvZiBvdXRsaW5lcyBhcm91bmRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGJhcnMuICBBIHZhbHVlIG9mIDAgKHdoaWNoIGlzIHRoZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0KSBtZWFucyBkb24ndCBkcmF3IG91dGxpbmVzLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGhpZGVsaW5lc1xuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMlxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBCYXJzIHdoaWNoIGFyZSBsZXNzIHdpZGUsIGluIHBpeGVscywgdGhhblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIG51bWJlciBkbyBub3QgcmVuZGVyIHRoZWlyIG91dGxpbmVzLlxuLy8gXG52YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlci5qcycpLFxuICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICBEYXRhTWVhc3VyZSA9IHJlcXVpcmUoJy4uL2RhdGFfbWVhc3VyZS5qcycpLFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90LnJlbmRlcmVyKTtcblxudmFyIFJhbmdlQmFyUmVuZGVyZXIgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJSYW5nZUJhclJlbmRlcmVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzQShSZW5kZXJlcik7XG4gICAgdGhpcy5oYXNBKFwibnVtYmVyT2ZWYXJpYWJsZXNcIikud2hpY2guZGVmYXVsdHNUbygzKTtcbn0pO1xuXG5SZW5kZXJlci5kZWNsYXJlT3B0aW9ucyhSYW5nZUJhclJlbmRlcmVyLCBcIlJhbmdlQmFyUmVuZGVyZXJPcHRpb25zXCIsIFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJiYXJ3aWR0aFwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLkhvcml6b250YWxEYXRhTWVhc3VyZU9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBuZXcgRGF0YU1lYXN1cmUucGFyc2UoXCJudW1iZXJcIiwgMClcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImJhcm9mZnNldFwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJmaWxsY29sb3JcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5SR0JDb2xvck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBSR0JDb2xvci5wYXJzZShcIjB4ODA4MDgwXCIpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJmaWxsb3BhY2l0eVwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAxLjBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImxpbmVjb2xvclwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG5ldyBSR0JDb2xvcigwLDAsMClcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImxpbmV3aWR0aFwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAxXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJoaWRlbGluZXNcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5OdW1iZXJPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogMlxuICAgIH1cbl0pO1xuXG5SZW5kZXJlci5SQU5HRUJBUiA9IG5ldyBSZW5kZXJlci5UeXBlKFwicmFuZ2ViYXJcIik7XG5cblJlbmRlcmVyLmFkZFR5cGUoe1widHlwZVwiICA6IFJlbmRlcmVyLlR5cGUucGFyc2UoXCJyYW5nZWJhclwiKSxcbiAgICAgICAgICAgICAgICAgIFwibW9kZWxcIiA6IFJhbmdlQmFyUmVuZGVyZXJ9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZUJhclJlbmRlcmVyO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG4vKipcbiAqIFRleHQgaXMgYSBKZXJtYWluZSBtb2RlbCB0aGF0IHN1cHBvcnRzIHN0b3JpbmcgYW5kIGRldGVybWluaW5nIG1ldHJpY3Mgb2ZcbiAqIHN0cmluZ3MgaW4gZGlmZmVyZW50IGdyYXBoaWNzIGNvbnRleHRzLlxuICpcbiAqIEBjbGFzcyBUZXh0XG4gKiBAZm9yIFRleHRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHN0cmluZyB7U3RyaW5nfSBUaGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgVGV4dCBtb2RlbFxuICovXG52YXIgVGV4dCA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlRleHRcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJzdHJpbmdcIik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgVGV4dCBtb2RlbFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHN0cmluZ1xuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwic3RyaW5nXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bnJvdGF0ZWQgd2lkdGggb2YgdGhlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9yaWdXaWR0aFxuICAgICAqIEB0eXBlIHtmbG9hdH1cbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJvcmlnV2lkdGhcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVucm90YXRlZCBoZWlnaHQgb2YgdGhlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9yaWdIZWlnaHRcbiAgICAgKiBAdHlwZSB7ZmxvYXR9XG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwib3JpZ0hlaWdodFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRlZCB3aWR0aCBvZiB0aGUgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcm90YXRlZFdpZHRoXG4gICAgICogQHR5cGUge2Zsb2F0fVxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInJvdGF0ZWRXaWR0aFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRlZCBoZWlnaHQgb2YgdGhlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJvdGF0ZWRIZWlnaHRcbiAgICAgKiBAdHlwZSB7ZmxvYXR9XG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwicm90YXRlZEhlaWdodFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICB0aGlzLmhhc0EoXCJmb250XCIpLndoaWNoLmlzQShcInN0cmluZ1wiKS5hbmQud2hpY2guZGVmYXVsdHNUbyhcIlwiKTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdW5yb3RhdGVkIGFuZCByb3RhdGVkIHdpZHRocyBhbmQgaGVpZ2h0cyBmb3IgdGhlIHN0b3JlZCBzdHJpbmcuIE92ZXJyaWRkZW4gYnlcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMgaW4gZ3JhcGhpY3MgZHJpdmVycy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZUdlb21ldHJ5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGljc0NvbnRleHRcbiAgICAgKiAgIEBwYXJhbSB7RmxvYXR9IGdyYXBoaWNzQ29udGV4dC5hbmdsZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImluaXRpYWxpemVHZW9tZXRyeVwiLCBmdW5jdGlvbiAoZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIHZhciBvcmlnV2lkdGgsXG4gICAgICAgICAgICBvcmlnSGVpZ2h0LFxuICAgICAgICAgICAgcm90YXRlZFdpZHRoLFxuICAgICAgICAgICAgcm90YXRlZEhlaWdodDtcblxuICAgICAgICBvcmlnV2lkdGggID0gdGhpcy5tZWFzdXJlU3RyaW5nV2lkdGgoZ3JhcGhpY3NDb250ZXh0KTtcbiAgICAgICAgb3JpZ0hlaWdodCA9IHRoaXMubWVhc3VyZVN0cmluZ0hlaWdodChncmFwaGljc0NvbnRleHQpO1xuICAgICAgICByb3RhdGVkV2lkdGggPSBvcmlnV2lkdGg7XG4gICAgICAgIHJvdGF0ZWRIZWlnaHQgPSBvcmlnSGVpZ2h0O1xuXG4gICAgICAgIGlmIChncmFwaGljc0NvbnRleHQgJiYgZ3JhcGhpY3NDb250ZXh0LmFuZ2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IGdyYXBoaWNzQ29udGV4dC5hbmdsZS8xODAgKiBNYXRoLlBJO1xuICAgICAgICAgICAgcm90YXRlZFdpZHRoID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKSAqIG9yaWdXaWR0aCArIE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSkgKiBvcmlnSGVpZ2h0O1xuICAgICAgICAgICAgcm90YXRlZEhlaWdodCA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSkgKiBvcmlnV2lkdGggKyBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpICogb3JpZ0hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3JpZ1dpZHRoKG9yaWdXaWR0aCk7XG4gICAgICAgIHRoaXMub3JpZ0hlaWdodChvcmlnSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5yb3RhdGVkV2lkdGgocm90YXRlZFdpZHRoKTtcbiAgICAgICAgdGhpcy5yb3RhdGVkSGVpZ2h0KHJvdGF0ZWRIZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB1bnJvdGF0ZWQgd2lkdGggZm9yIHRoZSBzdG9yZWQgc3RyaW5nLiBPdmVycmlkZGVuIGJ5IGltcGxlbWVudGF0aW9ucyBpbiBncmFwaGljc1xuICAgICAqIGRyaXZlcnMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG1lYXN1cmVTdHJpbmdXaWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7RmxvYXR9IFVucm90YXRlZCB3aWR0aCBvZiBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoaWNzQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcIm1lYXN1cmVTdHJpbmdXaWR0aFwiLCBmdW5jdGlvbiAoZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIC8vIEdyYXBoaWNzIGRyaXZlcnMgc2hvdWxkIHJlcGxhY2UgdGhpcyBtZXRob2Qgd2l0aCBhbiBhY3R1YWwgaW1wbGVtZW50YXRpb247IHRoaXNcbiAgICAgICAgLy8gaXMganVzdCBhIHBsYWNlaG9sZGVyLiAgVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCByZXR1cm4gdGhlIHdpZHRoLCBpbiBwaXhlbHMsXG4gICAgICAgIC8vIG9mIHRoZSBnaXZlbiBzdHJpbmcuICBPZiBjb3Vyc2UgdGhpcyBpcyBkZXBlbmRlbnQgb24gZm9udCBjaG9pY2UsIHNpemUsIGV0YyxcbiAgICAgICAgLy8gYnV0IHdlIGdsb3NzIG92ZXIgdGhhdCBhdCB0aGUgbW9tZW50LiAgSnVzdCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgLy8gdXNpbmcgc29tZSByZWFzb25hYmxlIGRlZmF1bHQgZm9udCBmb3Igbm93LiAgTGF0ZXIgb24sIHdlJ2xsIG1vZGlmeSB0aGlzXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIHVzZSBmb250IGluZm9ybWF0aW9uLlxuICAgICAgICB2YXIgbGluZXMsXG4gICAgICAgICAgICBtYXhMZW5ndGggPSAxLFxuICAgICAgICAgICAgdGVzdExlbmd0aCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RyaW5nKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWVhc3VyZVN0cmluZ1dpZHRoIHJlcXVpcmVzIHRoZSBzdHJpbmcgYXR0ciB0byBiZSBzZXQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMgPSB0aGlzLnN0cmluZygpLnNwbGl0KC9cXG4vKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZXN0TGVuZ3RoID0gbGluZXNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRlc3RMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGggPSB0ZXN0TGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbWF4TGVuZ3RoICogMTU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHVucm90YXRlZCBoZWlnaHQgZm9yIHRoZSBzdG9yZWQgc3RyaW5nLiBPdmVycmlkZGVuIGJ5IGltcGxlbWVudGF0aW9ucyBpbiBncmFwaGljc1xuICAgICAqIGRyaXZlcnMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG1lYXN1cmVTdHJpbmdIZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Zsb2F0fSBVbnJvdGF0ZWQgaGVpZ2h0IG9mIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhpY3NDb250ZXh0XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwibWVhc3VyZVN0cmluZ0hlaWdodFwiLCBmdW5jdGlvbiAoZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIC8vIEdyYXBoaWNzIGRyaXZlcnMgc2hvdWxkIHJlcGxhY2UgdGhpcyBtZXRob2Qgd2l0aCBhbiBhY3R1YWwgaW1wbGVtZW50YXRpb247IHRoaXNcbiAgICAgICAgLy8gaXMganVzdCBhIHBsYWNlaG9sZGVyLiAgVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCByZXR1cm4gdGhlIGhlaWdodCwgaW4gcGl4ZWxzLFxuICAgICAgICAvLyBvZiB0aGUgZ2l2ZW4gc3RyaW5nLiAgT2YgY291cnNlIHRoaXMgaXMgZGVwZW5kZW50IG9uIGZvbnQgY2hvaWNlLCBzaXplLCBldGMsXG4gICAgICAgIC8vIGJ1dCB3ZSBnbG9zcyBvdmVyIHRoYXQgYXQgdGhlIG1vbWVudC4gIEp1c3QgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHN0cmluZ1xuICAgICAgICAvLyB1c2luZyBzb21lIHJlYXNvbmFibGUgZGVmYXVsdCBmb250IGZvciBub3cuICBMYXRlciBvbiwgd2UnbGwgbW9kaWZ5IHRoaXNcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gdXNlIGZvbnQgaW5mb3JtYXRpb24uXG4gICAgICAgIGlmICh0aGlzLnN0cmluZygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lYXN1cmVTdHJpbmdIZWlnaHQgcmVxdWlyZXMgdGhlIHN0cmluZyBhdHRyIHRvIGJlIHNldC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld2xpbmVDb3VudCA9IHRoaXMuc3RyaW5nKCkubWF0Y2goL1xcbi9nKTtcbiAgICAgICAgcmV0dXJuIChuZXdsaW5lQ291bnQgIT09IG51bGwgPyAobmV3bGluZUNvdW50Lmxlbmd0aCArIDEpIDogMSkgKiAxMjtcbiAgICB9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHQ7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBUZXh0ID0gcmVxdWlyZSgnLi90ZXh0LmpzJyksXG4gICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vbWF0aC9wb2ludC5qcycpLFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy50aXRsZSk7XG5cbi8qKlxuICogVGl0bGUgaXMgYSBKZXJtaWFuZSBtb2RlbCB0aGF0IGNvbnRyb2xzIEdyYXBoIFRpdGxlcy5cbiAqXG4gKiBAY2xhc3MgVGl0bGVcbiAqIEBmb3IgVGl0bGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge0dyYXBofSBncmFwaFxuICogQGF1dGhvciBqcmZyaW1tZVxuICovXG52YXIgVGl0bGUgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJHcmFwaFRpdGxlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQb2ludGVyIHRvIHRoZSBUaXRsZSdzIHBhcmVudCBHcmFwaCBKZXJtYWluZSBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBncmFwaFxuICAgICAqIEB0eXBlIHtHcmFwaH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiZ3JhcGhcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgICAgICAgdmFyIEdyYXBoID0gcmVxdWlyZSgnLi9ncmFwaC5qcycpO1xuICAgICAgICByZXR1cm4gZ3JhcGggaW5zdGFuY2VvZiBHcmFwaDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBvZiB0aGUgdGl0bGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGV4dFxuICAgICAqIEB0eXBlIHtUZXh0fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJ0ZXh0XCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQgaW5zdGFuY2VvZiBUZXh0O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIFRpdGxlIGlzIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhlIEdyYXBocyBgcGxvdGAgb3IgYHBhZGRpbmdgXG4gICAgICogYm94LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyYW1lXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiZnJhbWVcIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgYm9yZGVyIHRvIGJlIGRyYXduIGFyb3VuZCB0aGUgdGl0bGUgaW4gcGl4ZWw7IHVzZSBhIHZhbHVlIG9mIGAwYFxuICAgICAqIHRvIG5vdCBkcmF3IGEgYm9yZGVyLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvcmRlclxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJib3JkZXJcIikud2hpY2guaXNBbihcImludGVnZXJcIik7XG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBmb3IgdGhlIFRpdGxlJ3MgcmVnaW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbG9yXG4gICAgICogQHR5cGUge1JHQkNvbG9yfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDb2xvciBmb3IgdGhlIFRpdGxlJ3MgYm9yZGVyLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvcmRlcmNvbG9yXG4gICAgICogQHR5cGUge1JHQkNvbG9yfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJib3JkZXJjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChib3JkZXJjb2xvcikge1xuICAgICAgICByZXR1cm4gYm9yZGVyY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBPcGFjaXR5IG9mIHRoZSBUaXRsZSdzIHJlZ2lvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcGFjaXR5XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwib3BhY2l0eVwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBwYWRkaW5nIGJldHdlZW4gdGhlIFRpdGxlJ3MgdGV4dCBhbmQgaXRzIGJvcmRlciBpbiBwaXhlbHM7IHVzZSBhXG4gICAgICogdmFsdWUgb2YgYDBgIHRvIG5vdCBkcmF3IHRoZSBwYWRkaW5nLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBhZGRpbmdcbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwicGFkZGluZ1wiKS53aGljaC5pc0FuKFwiaW50ZWdlclwiKTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvcm5lcnMgb2YgdGhlIHRpdGxlIGFwcGVhciByb3VuZGVkLiBJZiBjb3JuZXJyYWRpdXMgaXMgMCxcbiAgICAgKiB3aGljaCBpcyB0aGUgZGVmYXVsdCwgdGhlIGNvcm5lcnMgYXJlIGRyYXduIHNxdWFyZS4gSWYgY29ybmVycmFkaXVzID4gMCwgdGhlbiB0aGVcbiAgICAgKiBjb3JuZXJzIGFyZSByb3VuZGVkIG9mZiB1c2luZyBjaXJjbGVzIHdob3NlIHJhZGl1cyBpcyBjb3JuZXJyYWRpdXMgcGl4ZWxzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvcm5lcnJhZGl1c1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHR5cGUge0ludGVnZXJ9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImNvcm5lcnJhZGl1c1wiKS53aGljaC5pc0FuKFwiaW50ZWdlclwiKTtcbiAgICAvKipcbiAgICAgKiBBIGNvb3JkaW5hdGUgcGFpciB3aGljaCBnaXZlcyB0aGUgcmVsYXRpdmUgbG9jYXRpb24gb2YgdGhlIFRpdGxlJ3MgYW5jaG9yIHBvaW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFuY2hvclxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYW5jaG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGFuY2hvcikge1xuICAgICAgICByZXR1cm4gYW5jaG9yIGluc3RhbmNlb2YgUG9pbnQ7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQSBjb29yZGluYXRlIHBhaXIgd2hpY2ggZ2l2ZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBUaXRsZSdzIGJhc2UgcG9pbnQsIHJlbGF0aXZlIHRvXG4gICAgICogaXRzIEdyYXBoJ3MgcGxvdCBvciBwYWRkaW5nIGJveCAtIGRldGVybWluZWQgYnkgdGhlIGBmcmFtZWAgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJhc2VcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImJhc2VcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICByZXR1cm4gYmFzZSBpbnN0YW5jZW9mIFBvaW50O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEEgY29vcmRpbmF0ZSBwYWlyIG9mIHBpeGVsIG9mZnNldHMgZm9yIHRoZSBiYXNlIHBvaW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJwb3NpdGlvblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgZm9udC1zaXplIG9mIHRoZSB0aXRsZS4gQ3VycmVudGx5IGlzIGEgY29uc3RhbnQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZm9udC1zaXplXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiZm9udFNpemVcIikud2hpY2guaXNBKFwic3RyaW5nXCIpLmFuZC5kZWZhdWx0c1RvKFwiMThweFwiKTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGdlb21ldHJ5IG9mIHRoZSBUaXRsZSdzIHRleHQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVHZW9tZXRyeVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhpY3NDb250ZXh0XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImluaXRpYWxpemVHZW9tZXRyeVwiLCBmdW5jdGlvbiAoZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIGdyYXBoaWNzQ29udGV4dC5mb250U2l6ZSA9IHRoaXMuZm9udFNpemUoKTtcbiAgICAgICAgdGhpcy50ZXh0KCkuaW5pdGlhbGl6ZUdlb21ldHJ5KGdyYXBoaWNzQ29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgR3JhcGggVGl0bGUuIE92ZXJyaWRkZW4gYnkgaW1wbGVtZW50YXRpb25zIGluIGdyYXBoaWNzIGRyaXZlcnMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInJlbmRlclwiLCBmdW5jdGlvbiAoKSB7fSk7XG5cbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwidGV4dFwiLCBcImdyYXBoXCIpO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLnRpdGxlLCBhdHRyaWJ1dGVzKTtcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGl0bGU7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBXYXJuaW5nID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59O1xuXG5XYXJuaW5nLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyAgPSBXYXJuaW5nO1xuIiwiLy8gVGhpcyBmaWxlIHVzZXMgalF1ZXJ5LiAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZVxuLy8gZnVuY3Rpb24gcmV0dXJuZWQgYnkgcmVxdWlyaW5nIHRoaXMgZmlsZS5cbnZhciBXZWJTZXJ2aWNlRGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIGlmICh0eXBlb2YoV2ViU2VydmljZURhdGEpICE9PSBcInVuZGVmaW5lZFwiKSB7IHJldHVybiBXZWJTZXJ2aWNlRGF0YTsgfVxuXG4gICAgdmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG4gICAgdmFyIERhdGEgPSByZXF1aXJlKCcuL2RhdGEuanMnKSxcbiAgICAgICAgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIERhdGFGb3JtYXR0ZXIgPSByZXF1aXJlKCcuL2RhdGFfZm9ybWF0dGVyLmpzJyksXG4gICAgICAgIEFycmF5RGF0YSA9IHJlcXVpcmUoJy4vYXJyYXlfZGF0YS5qcycpLFxuICAgICAgICBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSA9IHJlcXVpcmUoJy4vd2ViX3NlcnZpY2VfZGF0YV9jYWNoZV9ub2RlLmpzJyksXG4gICAgICAgIFdlYlNlcnZpY2VEYXRhSXRlcmF0b3IgPSByZXF1aXJlKCcuL3dlYl9zZXJ2aWNlX2RhdGFfaXRlcmF0b3IuanMnKTtcblxuICAgIFdlYlNlcnZpY2VEYXRhID0gbmV3IGplcm1haW5lLk1vZGVsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0EoRGF0YSk7XG4gICAgICAgIHRoaXMuaGFzQShcInNlcnZpY2VhZGRyZXNzXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcbiAgICAgICAgdGhpcy5oYXNBKFwic2VydmljZWFkZHJlc3NwYXR0ZXJuXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcbiAgICAgICAgdGhpcy5oYXNBKFwiZm9ybWF0XCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcbiAgICAgICAgdGhpcy5oYXNBKFwiZm9ybWF0dGVyXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YUZvcm1hdHRlci5pc0luc3RhbmNlKTtcbiAgICAgICAgdGhpcy5oYXNBKFwibWVzc2FnZUhhbmRsZXJcIik7XG4gICAgICAgIHRoaXMuaGFzQShcImFqYXh0aHJvdHRsZVwiKTtcbiAgICAgICAgdGhpcy5pc0J1aWx0V2l0aChcImNvbHVtbnNcIiwgXCJzZXJ2aWNlYWRkcmVzc1wiLCBcIiVtZXNzYWdlSGFuZGxlclwiLCBcIiVhamF4dGhyb3R0bGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5zKCkuc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4wVHlwZSA9IHRoaXMuY29sdW1ucygpLmF0KDApLnR5cGUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mb3JtYXQoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0KGNvbHVtbjBUeXBlPT09RGF0YVZhbHVlLk5VTUJFUiA/IFwiJWZcIiA6IFwiJVklTSVEJUglaSVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdHRlcihEYXRhRm9ybWF0dGVyLmNyZWF0ZShjb2x1bW4wVHlwZSwgdGhpcy5mb3JtYXQoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYWpheHRocm90dGxlKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWpheHRocm90dGxlKCQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJfZGlzcGxheUVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlcigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcigpLmVycm9yKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJnZXRCb3VuZHNcIiwgZnVuY3Rpb24gKGNvbHVtbk51bWJlcikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB0aGlzIGtsdWRnZVxuICAgICAgICAgICAgcmV0dXJuIFswLCAxMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaGFzQShcImFycmF5ZGF0YVwiKS53aGljaC5kZWZhdWx0c1RvKG51bGwpLmFuZC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChhcnJheWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheWRhdGEgaW5zdGFuY2VvZiBBcnJheURhdGEgfHwgYXJyYXlkYXRhID09PSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBwb2ludGVyIHRvIHRoZSBoZWFkIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlIGluIHRoaXMgV2ViU2VydmllRGF0YSdzIGNhY2hlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgY2FjaGVIZWFkXG4gICAgICAgICAqIEB0eXBlIHtudWxsfFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlfVxuICAgICAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0EoXCJjYWNoZUhlYWRcIikud2hpY2guZGVmYXVsdHNUbyhudWxsKS5hbmQudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHggPT09IG51bGwgfHwgeCBpbnN0YW5jZW9mIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBwb2ludGVyIHRvIHRoZSB0YWlsIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlIGluIHRoaXMgV2ViU2VydmllRGF0YSdzIGNhY2hlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgY2FjaGVUYWlsXG4gICAgICAgICAqIEB0eXBlIHtudWxsfFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlfVxuICAgICAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0EoXCJjYWNoZVRhaWxcIikud2hpY2guZGVmYXVsdHNUbyhudWxsKS5hbmQudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHggPT09IG51bGwgfHwgeCBpbnN0YW5jZW9mIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGEgcG9pbnRlciB0byB0aGUgZmlyc3QgV2ViU2VydmljZURhdGFDYWNoZU5vZGUgaW4gdGhpcyBXZWJTZXJ2aWVEYXRhJ3MgY2FjaGVcbiAgICAgICAgICogdGhhdCBhY3R1YWxseSBjb250YWlucyBkYXRhLCBpZiBhbnkuICBJZiB0aGUgY2FjaGUgZG9lc24ndCBjb250YWluIGFueSBkYXRhLCByZXR1cm4gbnVsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBkYXRhSGVhZFxuICAgICAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICAgICAqIEByZXR1cm4ge251bGx8V2ViU2VydmljZURhdGFDYWNoZU5vZGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJkYXRhSGVhZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGVhZCA9IHRoaXMuY2FjaGVIZWFkKCk7XG4gICAgICAgICAgICBpZiAoaGVhZCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGhlYWQuaGFzRGF0YSgpKSB7IHJldHVybiBoZWFkOyB9XG4gICAgICAgICAgICByZXR1cm4gaGVhZC5kYXRhTmV4dCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGEgcG9pbnRlciB0byB0aGUgbGFzdCBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSBpbiB0aGlzIFdlYlNlcnZpZURhdGEncyBjYWNoZVxuICAgICAgICAgKiB0aGF0IGFjdHVhbGx5IGNvbnRhaW5zIGRhdGEsIGlmIGFueS4gIElmIHRoZSBjYWNoZSBkb2Vzbid0IGNvbnRhaW4gYW55IGRhdGEsIHJldHVybiBudWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGRhdGFUYWlsXG4gICAgICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgICAgICogQHJldHVybiB7bnVsbHxXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcImRhdGFUYWlsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0YWlsID0gdGhpcy5jYWNoZVRhaWwoKTtcbiAgICAgICAgICAgIGlmICh0YWlsID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICBpZiAodGFpbC5oYXNEYXRhKCkpIHsgcmV0dXJuIHRhaWw7IH1cbiAgICAgICAgICAgIHJldHVybiB0YWlsLmRhdGFQcmV2KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnQgYSBXZWJTZXJ2aWNlQ2FjaGVOb2RlIGludG8gdGhpcyBXZWJTZXJ2aWNlJ3MgY2FjaGUuXG4gICAgICAgICAqIElmIHRoaXMgbm9kZSdzIGNvdmVyZWRNaW4gaXMgbGVzcyB0aGFuIHRoZSBjYWNoZSBoZWFkJ3NcbiAgICAgICAgICogY292ZXJlZE1pbiwgaW5zZXJ0IGl0IGF0IHRoZSBoZWFkOyBvdGhlcndpc2UgaW5zZXJ0IGl0IGF0XG4gICAgICAgICAqIHRoZSB0YWlsLiAgTm90ZSB0aGF0IG5vZGVzIGFyZSBvbmx5IGluc2VydGVkIGVpdGhlciBhdCB0aGVcbiAgICAgICAgICogaGVhZCBvciBhdCB0aGUgdGFpbCBvZiB0aGUgY2FjaGUgLS0tIG5vdCBpbiB0aGUgbWlkZGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGluc2VydENhY2hlTm9kZVxuICAgICAgICAgKiBAcGFyYW0ge1dlYlNlcnZpY2VDYWNoZU5vZGV9IG5vZGVcbiAgICAgICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNwb25kc1RvKFwiaW5zZXJ0Q2FjaGVOb2RlXCIsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgaGVhZCA9IHRoaXMuY2FjaGVIZWFkKCksXG4gICAgICAgICAgICAgICAgdGFpbCA9IHRoaXMuY2FjaGVUYWlsKCk7XG4gICAgICAgICAgICBpZiAoaGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVIZWFkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVUYWlsKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jb3ZlcmVkTWluKCkubHQoaGVhZC5jb3ZlcmVkTWluKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmV4dChoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZC5wcmV2KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlSGVhZChub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnByZXYodGFpbCk7XG4gICAgICAgICAgICAgICAgICAgIHRhaWwubmV4dChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZVRhaWwobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJjb25zdHJ1Y3RSZXF1ZXN0VVJMXCIsIGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICAgICAgdmFyIHNlcnZpY2VhZGRyZXNzID0gdGhpcy5zZXJ2aWNlYWRkcmVzcygpLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlciA9IHRoaXMuZm9ybWF0dGVyKCk7XG5cbiAgICAgICAgICAgIGlmIChzZXJ2aWNlYWRkcmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU2VydmljZURhdGEuY29uc3RydWN0UmVxdWVzdFVSTDogdW5kZWZpbmVkIHNlcnZpY2UgYWRkcmVzc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYlNlcnZpY2VEYXRhLmNvbnN0cnVjdFJlcXVlc3RVUkw6IHVuZGVmaW5lZCBmb3JtYXR0ZXIgZm9yIGNvbHVtbiAwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmljZWFkZHJlc3NwYXR0ZXJuKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgoc2VydmljZWFkZHJlc3MuaW5kZXhPZihcIiRtaW5cIikgPCAwKSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VydmljZWFkZHJlc3MuaW5kZXhPZihcIiRtYXhcIikgPCAwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2VhZGRyZXNzcGF0dGVybihzZXJ2aWNlYWRkcmVzcyArIFwiJG1pbiwkbWF4XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZWFkZHJlc3NwYXR0ZXJuKHNlcnZpY2VhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuc2VydmljZWFkZHJlc3NwYXR0ZXJuKClcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCIkbWluXCIsIGZvcm1hdHRlci5mb3JtYXQobWluKSlcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCIkbWF4XCIsIGZvcm1hdHRlci5mb3JtYXQobWF4KSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmhhc0EoXCJjb3ZlcmVkTWluXCIpLndoaWNoLmRlZmF1bHRzVG8obnVsbCkuYW5kLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID09PSBudWxsIHx8IERhdGFWYWx1ZS5pc0luc3RhbmNlKHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYXNBKFwiY292ZXJlZE1heFwiKS53aGljaC5kZWZhdWx0c1RvKG51bGwpLmFuZC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geCA9PT0gbnVsbCB8fCBEYXRhVmFsdWUuaXNJbnN0YW5jZSh4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYXRlIHJlcXVlc3RzIG5lZWRlZCB0byBmZXRjaCBkYXRhIGJldHdlZW4gY292ZXJlZE1pbiBhbmQgY292ZXJlZE1heCwgaWYgYW55LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGluc3VyZUNvdmVyZWRSYW5nZVxuICAgICAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJpbnN1cmVDb3ZlcmVkUmFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhlYWQgPSB0aGlzLmNhY2hlSGVhZCgpLFxuICAgICAgICAgICAgICAgIHRhaWwgPSB0aGlzLmNhY2hlVGFpbCgpLFxuICAgICAgICAgICAgICAgIGNvdmVyZWRNaW4gPSB0aGlzLmNvdmVyZWRNaW4oKSxcbiAgICAgICAgICAgICAgICBjb3ZlcmVkTWF4ID0gdGhpcy5jb3ZlcmVkTWF4KCk7XG5cbiAgICAgICAgICAgIGlmIChjb3ZlcmVkTWluID09PSBudWxsIHx8IGNvdmVyZWRNYXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVhZCA9PT0gbnVsbCB8fCB0YWlsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U2luZ2xlUmFuZ2UoY292ZXJlZE1pbiwgY292ZXJlZE1heCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkTWluLmx0KGhlYWQuY292ZXJlZE1pbigpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGhlYWQncyBtaW4gICAgICAgICAgICAgIHRhaWwncyBtYXhcbiAgICAgICAgICAgICAgICAgICAgLy8gIC0tLS0tfC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBjb3ZlcmVkTWluXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFNpbmdsZVJhbmdlKGNvdmVyZWRNaW4sIGhlYWQuY292ZXJlZE1pbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWRNYXguZ3QodGFpbC5jb3ZlcmVkTWF4KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgaGVhZCdzIG1pbiAgICAgICAgICAgICAgdGFpbCdzIG1heFxuICAgICAgICAgICAgICAgICAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLXwtLS0tXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZE1heFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RTaW5nbGVSYW5nZSh0YWlsLmNvdmVyZWRNYXgoKSwgY292ZXJlZE1heCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZXF1ZXN0U2luZ2xlUmFuZ2VcIiwgZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0VVJMLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIEpRdWVyeVhNTFBhcnNlciA9IHJlcXVpcmUoJy4uL3BhcnNlci94bWwvanF1ZXJ5X3htbF9wYXJzZXIuanMnKSgkKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBjYWNoZSBub2RlIHRoYXQgd2lsbCBob2xkIHRoZSBkYXRhIGluIHRoaXMgcmFuZ2VcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgV2ViU2VydmljZURhdGFDYWNoZU5vZGUobWluLCBtYXgpO1xuXG4gICAgICAgICAgICAvLyBpbnNlcnQgaXQgaW50byB0aGUgY2FjaGUgbGlua2VkIGxpc3RcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0Q2FjaGVOb2RlKG5vZGUpO1xuXG4gICAgICAgICAgICAvLyBjb25zdHJ1Y3QgdGhlIFVSTCBmb3IgZmV0Y2hpbmcgdGhlIGRhdGEgaW4gdGhpcyByYW5nZVxuICAgICAgICAgICAgcmVxdWVzdFVSTCA9IHRoaXMuY29uc3RydWN0UmVxdWVzdFVSTChtaW4sIG1heCk7XG5cbiAgICAgICAgICAgIC8vIGluaXRpYXRlIHRoZSBmZXRjaCByZXF1ZXN0XG4gICAgICAgICAgICB0aGlzLmVtaXQoe3R5cGUgOiAnYWpheEV2ZW50JywgYWN0aW9uIDogJ3N0YXJ0J30pO1xuICAgICAgICAgICAgdGhpcy5hamF4dGhyb3R0bGUoKS5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmwgICAgICA6IHJlcXVlc3RVUkwsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGUgOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICBzdWNjZXNzICA6IGZ1bmN0aW9uIChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBkYXRhIGNvbnRhaW5zIGEgPHZhbHVlcz4gdGFnLCBleHRyYWN0IGl0cyB0ZXh0IHN0cmluZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5pbmRleE9mKFwiPHZhbHVlcz5cIikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlF1ZXJ5WE1MUGFyc2VyLnN0cmluZ1RvSlF1ZXJ5WE1MT2JqKGRhdGEpLmZpbmQoXCJ2YWx1ZXNcIikudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyc2VEYXRhKHRoYXQuZ2V0Q29sdW1ucygpLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmVtaXQoe3R5cGUgOiAnYWpheEV2ZW50JywgYWN0aW9uIDogJ3N1Y2Nlc3MnfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZW1pdCh7dHlwZSA6ICdkYXRhUmVhZHknfSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGVycm9yIDogZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVycm9yVGhyb3duO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanFYSFIuc3RhdHVzQ29kZSgpLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJVUkwgbm90IGZvdW5kOiAnXCIgKyByZXF1ZXN0VVJMICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHRleHRTdGF0dXMgKyBcIjogXCIgKyBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX2Rpc3BsYXlFcnJvcihuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyAnY29tcGxldGUnIGNhbGxiYWNrIGdldHMgY2FsbGVkIGFmdGVyIGVpdGhlciAnc3VjY2Vzcycgb3IgJ2Vycm9yJywgd2hpY2hldmVyOlxuICAgICAgICAgICAgICAgIGNvbXBsZXRlIDogZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZW1pdCh7dHlwZSA6ICdhamF4RXZlbnQnLCBhY3Rpb24gOiAnY29tcGxldGUnfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXNwb25kc1RvKFwiZ2V0SXRlcmF0b3JcIiwgZnVuY3Rpb24gKGNvbHVtbklkcywgbWluLCBtYXgsIGJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxOb2RlLFxuICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgICAgICAgICAgICBuLCBiLCBpLCB0bXAsXG4gICAgICAgICAgICAgICAgZmluYWxOb2RlLFxuICAgICAgICAgICAgICAgIGZpbmFsSW5kZXgsXG4gICAgICAgICAgICAgICAgY29sdW1uSW5kaWNlcztcblxuICAgICAgICAgICAgLy8gaWYgbWluID4gbWF4LCBzd2FwIHRoZW1cbiAgICAgICAgICAgIGlmIChtaW4uZ3QobWF4KSkge1xuICAgICAgICAgICAgICAgIHRtcCA9IG1pbjtcbiAgICAgICAgICAgICAgICBtaW4gPSBtYXg7XG4gICAgICAgICAgICAgICAgbWF4ID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jb3ZlcmVkTWluKCkgPT09IG51bGwgfHwgbWluLmx0KHRoaXMuY292ZXJlZE1pbigpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY292ZXJlZE1pbihtaW4uY2xvbmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb3ZlcmVkTWF4KCkgPT09IG51bGwgfHwgbWF4Lmd0KHRoaXMuY292ZXJlZE1heCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY292ZXJlZE1heChtYXguY2xvbmUoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5wYXVzZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdXJlQ292ZXJlZFJhbmdlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFIZWFkKCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWNoZSBpcyBlbXB0eSwgcmV0dXJuIGVtcHR5IGl0ZXJhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIFwibmV4dFwiICAgIDogZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgICAgICAgICAgIFwiaGFzTmV4dFwiIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udmVydCBjb2x1bW5JZHMgdG8gY29sdW1uSW5kaWNlc1xuICAgICAgICAgICAgY29sdW1uSW5kaWNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbklkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbkluZGljZXMucHVzaCggdGhpcy5jb2x1bW5JZFRvQ29sdW1uTnVtYmVyKGNvbHVtbklkc1tpXSkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgZGF0YSBub2RlIGNvbnRhaW5pbmcgdGhlICdtaW4nIHZhbHVlXG4gICAgICAgICAgICBpbml0aWFsTm9kZSA9IHRoaXMuZGF0YUhlYWQoKTtcbiAgICAgICAgICAgIHdoaWxlICgoaW5pdGlhbE5vZGUgIT09IG51bGwpICYmXG4gICAgICAgICAgICAgICAgICAgKGluaXRpYWxOb2RlLmRhdGFOZXh0KCkgIT09IG51bGwpICYmXG4gICAgICAgICAgICAgICAgICAgKG1pbi5ndChpbml0aWFsTm9kZS5kYXRhTWF4KCkpKSkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxOb2RlID0gaW5pdGlhbE5vZGUuZGF0YU5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGluaXRpYWxOb2RlID09PSBudWxsIHx8ICFpbml0aWFsTm9kZS5oYXNEYXRhKCkpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBpbmRleCB3aXRoaW4gdGhlIGluaXRpYWwgbm9kZSBjb3JyZXNwb25kaW5nIHRvIHRoZSAnbWluJyB2YWx1ZVxuICAgICAgICAgICAgICAgIHdoaWxlICgoaW5pdGlhbEluZGV4IDwgaW5pdGlhbE5vZGUuZGF0YSgpLmxlbmd0aC0xKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbE5vZGUuZGF0YSgpW2luaXRpYWxJbmRleF1bY29sdW1uSW5kaWNlc1swXV0ubHQobWluKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbml0aWFsSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGJhY2sgdXAgJ2J1ZmZlcicgc3RlcHMsIGJlaW5nIGNhcmVmdWwgbm90IHRvIGdvIGZ1cnRoZXIgYmFjayB0aGFuIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBoZWFkIG5vZGVcbiAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobjxidWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1pbml0aWFsSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsSW5kZXg8MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGluaXRpYWxOb2RlLmRhdGFQcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxOb2RlID0gYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSBpbml0aWFsTm9kZS5kYXRhKCkubGVuZ3RoLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBkYXRhIG5vZGUgY29udGFpbmluZyB0aGUgJ21heCcgdmFsdWVcbiAgICAgICAgICAgICAgICBmaW5hbE5vZGUgPSBpbml0aWFsTm9kZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIChtYXguZ3QoZmluYWxOb2RlLmRhdGFNYXgoKSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZmluYWxOb2RlLmRhdGFOZXh0KCkgIT09IG51bGwpICkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbE5vZGUgPSBmaW5hbE5vZGUuZGF0YU5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgaW5kZXggd2l0aGluIHRoZSBmaW5hbCBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlICdtYXgnIHZhbHVlXG4gICAgICAgICAgICAgICAgZmluYWxJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsTm9kZSA9PT0gaW5pdGlhbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxJbmRleCA9IGluaXRpYWxJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKChmaW5hbEluZGV4IDwgZmluYWxOb2RlLmRhdGEoKS5sZW5ndGgtMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgKGZpbmFsTm9kZS5kYXRhKClbZmluYWxJbmRleF1bY29sdW1uSW5kaWNlc1swXV0ubHQobWF4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKytmaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBnbyBmb3J3YXJkICdidWZmZXInIG1vcmUgc3RlcHMsIGJlaW5nIGNhcmVmdWwgbm90IHRvIGdvIGZ1cnRoZXIgdGhhbiB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSB0YWlsXG4gICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgLy93aGlsZSAobjxidWZmZXIgJiYgIShmaW5hbE5vZGU9PT1fdGFpbCAmJiBmaW5hbEluZGV4PGZpbmFsTm9kZS5kYXRhLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICArK2ZpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbEluZGV4ID49IGZpbmFsTm9kZS5kYXRhKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gZmluYWxOb2RlLmRhdGFOZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsTm9kZSA9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5kZXggPSBmaW5hbE5vZGUuZGF0YSgpLmxlbmd0aC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViU2VydmljZURhdGFJdGVyYXRvcihjb2x1bW5JbmRpY2VzLCBpbml0aWFsTm9kZSwgaW5pdGlhbEluZGV4LCBmaW5hbE5vZGUsIGZpbmFsSW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmhhc0EoXCJwYXVzZWRcIikud2hpY2guaXNBKFwiYm9vbGVhblwiKS5hbmQuZGVmYXVsdHNUbyhmYWxzZSk7XG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcInBhdXNlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZWQodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZXN1bWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlZChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoe3R5cGUgOiAnZGF0YVJlYWR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgbWluIDogdGhpcy5jb3ZlcmVkTWluKCksXG4gICAgICAgICAgICAgICAgICAgICAgIG1heCA6IHRoaXMuY292ZXJlZE1heCgpfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gV2ViU2VydmljZURhdGE7XG59O1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG4vKipcbiAqIEEgV2ViU2VydmljZURhdGFDYWNoZU5vZGUgcmVwcmVzZW50cyBhIHNpbmdsZSBub2RlIGluIHRoZVxuICogZG91Ymx5LWxpbmtlZCBsaXN0IGhvbGRpbmcgdGhlIGRhdGEgZm9yIGEgV2ViU2VydmljZURhdGFDYWNoZS5cbiAqIFRoZSBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSBoYXMgYW4gYXJyYXkgb2YgZGF0YSAod2hpY2ggbWF5XG4gKiBhY3R1YWxseSBiZSBudWxsLCBpZiB0aGUgbm9kZSdzIGRhdGEgaGFzIG5vdCB5ZXQgYmVlbiBsb2FkZWQpLFxuICogbmV4dCBhbmQgcHJldiBwb2ludGVycyB0byB0aGUgbmV4dCBhbmQgcHJldmlvdXMgbm9kZXMgaW4gdGhlXG4gKiBsaW5rZWQgbGlzdCwgYW5kIGNvdmVyZWRNaW4gYW5kIGNvdmVyZWRNYXggdmFsdWVzIHRoYXQgaW5kaWNhdGVcbiAqIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgb2YgdGhlIFwiY292ZXJlZFwiIHJhbmdlIG9mIGRhdGEgZm9yIHRoaXNcbiAqIG5vZGUuXG4gKiBcbiAqIFRoZSBcImNvdmVyZWRcIiByYW5nZSBpcyB0aGUgaW50ZXJ2YWwgb2YgdGhlIGRhdGEgbnVtYmVyIGxpbmUgZm9yXG4gKiB3aGljaCB0aGlzIG5vZGUgaXMgcmVzcG9uc2libGUgZm9yIHN0b3JpbmcgZGF0YTsgTXVsdGlncmFwaFxuICogdXNlcyByYW5nZSB0aGlzIHRvIGF2b2lkIHJlcXVlc3RpbmcgdGhlIHNhbWUgZGF0YSB0d2ljZSAtLS0gaXRcbiAqIG5ldmVyIHJlcXVlc3RzIGRhdGEgZm9yIGEgcmFuZ2UgYWxyZWFkeSBjb3ZlcmVkIGJ5IGFuIGV4aXN0aW5nXG4gKiBjYWNoZSBub2RlLlxuICogXG4gKiBJbml0aWFsbHksIHdoZW4gdGhlIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlIGlzIGNyZWF0ZWQsIHRoZVxuICogbGltaXRzIG9mIHRoZSBjb3ZlcmVkIHJhbmdlIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICogTGF0ZXIgb24sIHdoZW4gdGhlIG5vZGUncyBkYXRhIGlzIGFjdHVhbGx5IHBvcHVsYXRlZCwgdGhlXG4gKiBsaW1pdHMgYXJlIHBvdGVudGlhbGx5IGFkanVzdGVkIG91dHdhcmQsIGlmIHRoZSByYW5nZSBvZiBkYXRhXG4gKiByZWNlaXZlZCBpcyBsYXJnZXIgdGhhbiB0aGUgaW5pdGlhbGx5IHNwZWNpZmllZCBjb3ZlcmVkIHJhbmdlLlxuICogU28gaW4gYWxsIGNhc2VzLCB0aGUgY292ZXJlZCByYW5nZSBpbmRpY2F0ZXMgdGhlIHJhbmdlIGZvclxuICogd2hpY2ggbm8gbW9yZSBkYXRhIGlzIG5lZWRlZCwgYmVjYXVzZSBpdCdzIGNvdmVyZWQgYnkgdGhpc1xuICogbm9kZS5cbiAqIFxuICogTm90ZSB0aGF0IHRoZSBjb3ZlcmVkIHJhbmdlIGlzIG5ldmVyIGFkanVzdGVkIHRvIGJlIHNtYWxsZXIuXG4gKiBcbiAqIFRoZSBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSBkb2VzIG5vdCBhY3R1YWxseSBmZXRjaCBhbnkgZGF0YVxuICogLS0tIGl0IGlzIHNpbXBseSBhIHN0b3JhZ2UgY29udGFpbmVyIGZvciBmZXRjaGVkIGRhdGE7IGl0J3MgdXBcbiAqIHRvIG90aGVyIGNvZGUgb3V0c2lkZSBvZiB0aGlzIG9iamVjdCB0byBmZXRjaCBhbmQgcG9wdWxhdGUgdGhlXG4gKiBkYXRhLlxuICpcbiAqIEBjbGFzcyBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZVxuICogQGZvciBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0RhdGFWYWx1ZX0gY292ZXJlZE1pblxuICogQHBhcmFtIHtEYXRhVmFsdWV9IGNvdmVyZWRNYXhcbiAqL1xudmFyIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpLFxuICAgIEFycmF5RGF0YSA9IHJlcXVpcmUoJy4vYXJyYXlfZGF0YS5qcycpO1xuXG52YXIgV2ViU2VydmljZURhdGFDYWNoZU5vZGUgPSBuZXcgamVybWFpbmUuTW9kZWwoZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFjdHVhbCBkYXRhIGZvciB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZGF0YVxuICAgICAqIEB0eXBlIHtBcnJheXxudWxsfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJkYXRhXCIpLndoaWNoLmRlZmF1bHRzVG8obnVsbCkuYW5kLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHZhbGlkYXRpb25GdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKTtcbiAgICAgICAgLy8gYWNjZXB0IG51bGxcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgLy8gb25seSBhY2NlcHQgYXJyYXlzXG4gICAgICAgIGlmICh2YWxpZGF0aW9uRnVuY3Rpb25zLnR5cGVPZihkYXRhKSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIldlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlJ3MgZGF0YSBhdHRyaWJ1dGUgaXMgbm90IGFuIEFycmF5XCI7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGFycmF5IGNvbnRhaW5zIGFueXRoaW5nLCBkbyBhIGN1cnNvcnkgY2hlY2sgdGhhdCBpdCBsb29rc1xuICAgICAgICAvLyBsaWtlIGFuIGFycmF5IG9mIERhdGFWYWx1ZSBhcnJheXMgKGp1c3QgY2hlY2sgdGhlIGZpcnN0IHJvdylcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0Um93ID0gZGF0YVswXSxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25GdW5jdGlvbnMudHlwZU9mKGZpcnN0Um93KSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSdzIGRhdGEgYXR0cmlidXRlIGlzIG5vdCBhbiBBcnJheSBvZiBBcnJheXNcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlyc3RSb3cubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIURhdGFWYWx1ZS5pc0luc3RhbmNlKGZpcnN0Um93W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIldlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlJ3MgZGF0YSBhdHRyaWJ1dGUgaXMgbm90IGFuIEFycmF5IG9mIEFycmF5cyBvZiBEYXRhVmFsdWVzIChiYWQgdmFsdWUgaW4gcG9zaXRpb24gXCIgKyBpICsgXCIgb2YgZmlyc3Qgcm93XCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmV4dCBub2RlIGluIHRoZSBjYWNoZSdzIGxpbmtlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbmV4dFxuICAgICAqIEB0eXBlIHtXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZXxudWxsfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJuZXh0XCIpLndoaWNoLmRlZmF1bHRzVG8obnVsbCkuYW5kLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IG51bGwgfHwgeCBpbnN0YW5jZW9mIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIG5vZGUgaW4gdGhlIGNhY2hlJ3MgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwcmV2XG4gICAgICogQHR5cGUge1dlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlfG51bGx9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInByZXZcIikud2hpY2guZGVmYXVsdHNUbyhudWxsKS5hbmQudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCA9PT0gbnVsbCB8fCB4IGluc3RhbmNlb2YgV2ViU2VydmljZURhdGFDYWNoZU5vZGU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWluIG9mIHRoZSBjb3ZlcmVkIHZhbHVlIHJhbmdlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY292ZXJlZE1pblxuICAgICAqIEB0eXBlIHtEYXRhVmFsdWV9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImNvdmVyZWRNaW5cIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhVmFsdWUuaXNJbnN0YW5jZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4IG9mIHRoZSBjb3ZlcmVkIHZhbHVlIHJhbmdlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY292ZXJlZE1heFxuICAgICAqIEB0eXBlIHtEYXRhVmFsdWV9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImNvdmVyZWRNYXhcIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhVmFsdWUuaXNJbnN0YW5jZSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5leHQgbm9kZSBpbiB0aGUgY2FjaGUgdGhhdCBhY3R1YWxseSBoYXMgZGF0YSxcbiAgICAgKiBvciBudWxsIGlmIG5vbmUgZXhpc3RzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkYXRhTmV4dFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKiBAcmV0dXJuIHtXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImRhdGFOZXh0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgIW5vZGUuaGFzRGF0YSgpKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHByZXZpb3VzIG5vZGUgaW4gdGhlIGNhY2hlIHRoYXQgYWN0dWFsbHkgaGFzIGRhdGEsXG4gICAgICogb3IgbnVsbCBpZiBub25lIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGF0YVByZXZcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICogQHJldHVybiB7V2ViU2VydmljZURhdGFDYWNoZU5vZGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJkYXRhUHJldlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5wcmV2KCk7XG4gICAgICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmICFub2RlLmhhc0RhdGEoKSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJldigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtaW5pbXVtIChjb2x1bW4gMCkgZGF0YSB2YWx1ZSBmb3IgdGhpcyBub2RlLiAgUmV0dXJucyBudWxsXG4gICAgICogaWYgdGhlIG5vZGUgaGFzIG5vIGRhdGEgeWV0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkYXRhTWluXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqIEByZXR1cm4ge0RhdGFWYWx1ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImRhdGFNaW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSgpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgaWYgKGRhdGFbMF0gPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgaWYgKGRhdGFbMF0ubGVuZ3RoID09PSAwKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHJldHVybiBkYXRhWzBdWzBdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtYXhpbXVtIChjb2x1bW4gMCkgZGF0YSB2YWx1ZSBmb3IgdGhpcyBub2RlLiAgICBSZXR1cm5zIG51bGxcbiAgICAgKiBpZiB0aGUgbm9kZSBoYXMgbm8gZGF0YSB5ZXQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRhdGFNYXhcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICogQHJldHVybiB7RGF0YVZhbHVlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZGF0YU1heFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoLTFdID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoLTFdLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4gZGF0YVtkYXRhLmxlbmd0aC0xXVswXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoaXMgbm9kZSBoYXMgZGF0YTsgZmFsc2UgaWYgbm90LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBoYXNEYXRhXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqIEByZXR1cm4gQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImhhc0RhdGFcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKSAhPT0gbnVsbDtcbiAgICB9KTtcblxuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJjb3ZlcmVkTWluXCIsIFwiY292ZXJlZE1heFwiKTtcblxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlIHRoaXMgbm9kZSdzIGRhdGEgYXJyYXkgYnkgcGFyc2luZyB0aGUgdmFsdWVzXG4gICAgICogY29udGFpbmVkIGluIHRoZSAnZGF0YVRleHQnIHN0cmluZywgd2hpY2ggc2hvdWxkIGJlIGFcbiAgICAgKiBzdHJpbmcgb2YgY29tbWEtc2VwYXJhdGVkIHZhbHVlcyBvZiB0aGUgc2FtZSBzb3J0IGV4cGVjdGVkXG4gICAgICogYnkgQXJyYXlEYXRhIGFuZCBDU1ZEYXRhLiAgVGhlIGZpcnN0IGFyZ3VtZW50LCBgY29sdW1uc2AsXG4gICAgICogc2hvdWxkIGJlIGEgcGxhaW4gamF2YXNjcmlwdCBhcnJheSBvZiBEYXRhVmFyaWFibGUgaW5zdGFuY2VzLFxuICAgICAqIG9mIHRoZSBzb3J0IHJldHVybmVkIGJ5IGBEYXRhLmdldENvbHVtbnMoKWAuXG4gICAgICogXG4gICAgICogVGhpcyBtZXRob2QgZXhhbWluZXMgb3RoZXIgbm9kZXMgaW4gdGhlIGNhY2hlIGluIG9yZGVyXG4gICAgICogaW5zdXJlIHRoYXQgdmFsdWVzIGluY2x1ZGVkIGluIHRoaXMgbm9kZSdzIGRhdGEgYXJyYXlcbiAgICAgKiBhcmUgKGEpIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSBwcmVzZW50IGluIHRoZVxuICAgICAqIGNhY2hlIHByaW9yIHRvIHRoaXMgbm9kZSwgYW5kIChiKSBzdHJpY3RseSBsZXNzIHRoYW4gdGhlXG4gICAgICogbWluaW11bSB2YWx1ZSBwcmVzZW50IGluIHRoZSBjYWNoZSBhZnRlciB0aGlzIG5vZGUuXG4gICAgICogVGhpcyBndWFyYW50ZWVzIHRoYXQgdGhlcmUgaXMgbm8gb3ZlcmxhcCBiZXR3ZWVuIHRoZVxuICAgICAqIGRhdGEgaW4gdGhpcyBub2RlIGFuZCBvdGhlciBub2RlcyBpbiB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHBhcnNlRGF0YVxuICAgICAqIEBwYXJhbSB7RGF0YVZhcmlhYmxlIEF0dHJfTGlzdH0gY29sdW1uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhVGV4dFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJwYXJzZURhdGFcIiwgZnVuY3Rpb24gKGNvbHVtbnMsIGRhdGFUZXh0KSB7XG4gICAgICAgIHZhciBpLCBiLFxuICAgICAgICAgICAgbWF4UHJldlZhbHVlID0gbnVsbCxcbiAgICAgICAgICAgIG1pbk5leHRWYWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBhcnJheURhdGFBcnJheSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByb3c7XG5cbiAgICAgICAgLy8gc2V0IG1heFByZXZWYWx1ZSB0byB0aGUgbWF4IHZhbHVlIGluIGNvbHVtbjAgaW4gdGhlIGNhY2hlIHByaW9yIHRvIHRoaXMgYmxvY2ssIGlmIGFueTpcbiAgICAgICAgYiA9IHRoaXMuZGF0YVByZXYoKTtcbiAgICAgICAgaWYgKGIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1heFByZXZWYWx1ZSA9IGIuZGF0YU1heCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IG1pbk5leHRWYWx1ZSB0byB0aGUgbWluIHZhbHVlIGluIGNvbHVtbjAgaW4gdGhlIGNhY2hlIGFmdGVyIHRoaXMgYmxvY2ssIGlmIGFueTpcbiAgICAgICAgYiA9IHRoaXMuZGF0YU5leHQoKTtcbiAgICAgICAgaWYgKGIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1pbk5leHRWYWx1ZSA9IGIuZGF0YU1pbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29udmVydCB0aGUgY3N2IGRhdGFUZXh0IHN0cmluZyB0byBhbiBhcnJheVxuICAgICAgICBhcnJheURhdGFBcnJheSA9IEFycmF5RGF0YS50ZXh0VG9EYXRhVmFsdWVzQXJyYXkoY29sdW1ucywgZGF0YVRleHQpO1xuXG4gICAgICAgIC8vIHBvcHVsYXRlIHRoZSBkYXRhIGFycmF5IGJ5IGNvcHlpbmcgdmFsdWVzIGZyb20gdGhlIGNvbnZlcnRlZCBhcnJheSwgc2tpcHBpbmcgYW55XG4gICAgICAgIC8vIHZhbHVlcyB0aGF0IGFyZSBhbHJlYWR5IHdpdGhpbiB0aGUgcmFuZ2UgY292ZXJlZCBieSB0aGUgcmVzdCBvZiB0aGUgY2FjaGVcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyYXlEYXRhQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJvdyA9IGFycmF5RGF0YUFycmF5W2ldO1xuICAgICAgICAgICAgaWYgKChtYXhQcmV2VmFsdWUgPT09IG51bGwgfHwgcm93WzBdLmd0KG1heFByZXZWYWx1ZSkpICYmXG4gICAgICAgICAgICAgICAgKG1pbk5leHRWYWx1ZSA9PT0gbnVsbCB8fCByb3dbMF0ubHQobWluTmV4dFZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goIHJvdyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhbnkgbmV3IHZhbHVlcywgd2UncmUgZG9uZVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gbG93ZXIgdGhlIGNvdmVyZWRNaW4gdmFsdWUgaWYgdGhlIGFjdHVhbCBkYXRhIHJlY2VpdmVkIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnQgY292ZXJlZE1pbiB2YWx1ZVxuICAgICAgICBpZiAoZGF0YVswXVswXS5sdCh0aGlzLmNvdmVyZWRNaW4oKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY292ZXJlZE1pbihkYXRhWzBdWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhaXNlIHRoZSBjb3ZlcmVkTWF4IHZhbHVlIGlmIHRoZSBhY3R1YWwgZGF0YSByZWNlaXZlZCBpcyBoaWdoZXIgdGhhbiB0aGUgY3VycmVudCBjb3ZlcmVkTWF4IHZhbHVlXG4gICAgICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoLTFdWzBdLmd0KHRoaXMuY292ZXJlZE1heCgpKSkge1xuICAgICAgICAgICAgdGhpcy5jb3ZlcmVkTWF4KGRhdGFbZGF0YS5sZW5ndGgtMV1bMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgZGF0YVxuICAgICAgICB0aGlzLmRhdGEoIGRhdGEgKTtcbiAgICB9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG4vKipcbiAqIEFuIGl0ZXJhdG9yIGZvciBzdGVwcGluZyB0aHJvdWdoIGRhdGEgdmFsdWVzIHN0b3JlZCBpbiBhIGxpbmtlZCBsaXN0IG9mXG4gKiBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZXMuICBUaGUgY29uc3RydWN0b3IgdGFrZXMgNSBhcmd1bWVudHM6XG4gKiBcbiAqIEBjbGFzcyBXZWJTZXJ2aWNlRGF0YUl0ZXJhdG9yXG4gKiBAZm9yIFdlYlNlcnZpY2VEYXRhSXRlcmF0b3JcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbHVtbkluZGljZXNcbiAqICAgICBKYXZhU2NyaXB0IGFycmF5IG9mIHRoZSBpbmRpY2VzIG9mIHRoZSBjb2x1bW5zXG4gKiAgICAgb2YgZGF0YSB0byByZXR1cm5cbiAqIEBwYXJhbSB7V2ViU2VydmljZURhdGFDYWNoZU5vZGV9IGluaXRpYWxOb2RlXG4gKiAgICAgUG9pbnRlciB0byB0aGUgV2ViU2VydmljZURhdGFDYWNoZU5vZGUgY29udGFpbmluZyB0aGUgZmlyc3RcbiAqICAgICB2YWx1ZSB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gaW5pdGlhbEluZGV4XG4gKiAgICAgSW5kZXgsIHdpdGhpbiBpbml0aWFsTm9kZSwgb2YgdGhlIGZpcnN0IHZhbHVlIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZX0gZmluYWxOb2RlXG4gKiAgICAgUG9pbnRlciB0byB0aGUgV2ViU2VydmljZURhdGFDYWNoZU5vZGUgY29udGFpbmluZyB0aGUgbGFzdFxuICogICAgIHZhbHVlIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBmaW5hbEluZGV4XG4gKiAgICAgSW5kZXgsIHdpdGhpbiBmaW5hbE5vZGUsIG9mIHRoZSBsYXN0IHZhbHVlIHRvIGl0ZXJhdGUgb3ZlclxuICovXG52YXIgV2ViU2VydmljZURhdGFDYWNoZU5vZGUgPSByZXF1aXJlKCcuL3dlYl9zZXJ2aWNlX2RhdGFfY2FjaGVfbm9kZS5qcycpLFxuICAgIFZhbGlkYXRpb25GdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKTtcblxudmFyIFdlYlNlcnZpY2VEYXRhSXRlcmF0b3IgPSBuZXcgamVybWFpbmUuTW9kZWwoZnVuY3Rpb24gKCkge1xuICAgIHZhciBXZWJTZXJ2aWNlRGF0YUl0ZXJhdG9yID0gdGhpcztcblxuICAgIHRoaXMuaGFzQShcImN1cnJlbnROb2RlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImN1cnJlbnRJbmRleFwiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuICAgIHRoaXMuaGFzQShcImNvbHVtbkluZGljZXNcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBWYWxpZGF0aW9uRnVuY3Rpb25zLnR5cGVPZih4KSA9PT0gXCJhcnJheVwiO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuaGFzQShcImluaXRpYWxOb2RlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImZpbmFsTm9kZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZTtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJpbml0aWFsSW5kZXhcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJmaW5hbEluZGV4XCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG5cbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwiY29sdW1uSW5kaWNlc1wiLCBcImluaXRpYWxOb2RlXCIsIFwiaW5pdGlhbEluZGV4XCIsIFwiZmluYWxOb2RlXCIsIFwiZmluYWxJbmRleFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSh0aGlzLmluaXRpYWxOb2RlKCkpO1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCh0aGlzLmluaXRpYWxJbmRleCgpKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImhhc05leHRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlKCkgPT09IG51bGwgfHwgdGhpcy5jdXJyZW50SW5kZXgoKSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlKCkgIT09IHRoaXMuZmluYWxOb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJbmRleCgpIDw9IHRoaXMuZmluYWxJbmRleCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwibmV4dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBbXSxcbiAgICAgICAgICAgIGNvbHVtbkluZGljZXMgPSB0aGlzLmNvbHVtbkluZGljZXMoKSxcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IHRoaXMuY3VycmVudEluZGV4KCksXG4gICAgICAgICAgICBmaW5hbEluZGV4ID0gdGhpcy5maW5hbEluZGV4KCksXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMuY3VycmVudE5vZGUoKSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSB0aGlzLmZpbmFsTm9kZSgpKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gZmluYWxJbmRleCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgZm9yIChpPTA7IGk8Y29sdW1uSW5kaWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhbHMucHVzaChjdXJyZW50Tm9kZS5kYXRhKClbY3VycmVudEluZGV4XVtjb2x1bW5JbmRpY2VzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCgrK2N1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gdmFscztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGNvbHVtbkluZGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YWxzLnB1c2goY3VycmVudE5vZGUuZGF0YSgpW2N1cnJlbnRJbmRleF1bY29sdW1uSW5kaWNlc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXgoKytjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+PSBjdXJyZW50Tm9kZS5kYXRhKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm9kZShjdXJyZW50Tm9kZS5kYXRhTmV4dCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWxzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNlcnZpY2VEYXRhSXRlcmF0b3I7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBJbnNldHMgPSByZXF1aXJlKCcuLi9tYXRoL2luc2V0cy5qcycpLFxuICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMud2luZG93KTtcblxudmFyIFdpbmRvdyA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIldpbmRvd1wiLCBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmhhc0EoXCJ3aWR0aFwiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuXG4gICAgdGhpcy5oYXNBKFwiaGVpZ2h0XCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG5cbiAgICB0aGlzLmhhc0EoXCJib3JkZXJcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcblxuICAgIHRoaXMuaGFzQShcIm1hcmdpblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICAgICAgcmV0dXJuIG1hcmdpbiBpbnN0YW5jZW9mIEluc2V0cztcbiAgICB9KTtcblxuICAgIHRoaXMuaGFzQShcInBhZGRpbmdcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAocGFkZGluZykge1xuICAgICAgICByZXR1cm4gcGFkZGluZyBpbnN0YW5jZW9mIEluc2V0cztcbiAgICB9KTtcblxuICAgIHRoaXMuaGFzQShcImJvcmRlcmNvbG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGJvcmRlcmNvbG9yKSB7XG4gICAgICAgIHJldHVybiBib3JkZXJjb2xvciBpbnN0YW5jZW9mIFJHQkNvbG9yO1xuICAgIH0pO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLndpbmRvdywgYXR0cmlidXRlcyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaW5kb3c7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBEYXRhTWVhc3VyZSA9IHJlcXVpcmUoJy4vZGF0YV9tZWFzdXJlLmpzJyksXG4gICAgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyk7XG5cbnZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMuaG9yaXpvbnRhbGF4aXMuem9vbSk7XG5cbnZhciBab29tID0gbmV3IGplcm1haW5lLk1vZGVsKFwiWm9vbVwiLCBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmhhc0EoXCJhbGxvd2VkXCIpLndoaWNoLmlzQShcImJvb2xlYW5cIik7XG4gICAgdGhpcy5oYXNBKFwibWluXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKG1pbikge1xuICAgICAgICByZXR1cm4gRGF0YU1lYXN1cmUuaXNJbnN0YW5jZShtaW4pO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcIm1heFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChtYXgpIHtcbiAgICAgICAgcmV0dXJuIERhdGFNZWFzdXJlLmlzSW5zdGFuY2UobWF4KTtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJhbmNob3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBEYXRhVmFsdWUuaXNJbnN0YW5jZShhbmNob3IpIHx8IGFuY2hvciA9PT0gbnVsbDtcbiAgICB9KTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcy56b29tLCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFpvb207XG4iLCJ2YXIgX0lOQ0xVREVEID0gZmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCwgd2luZG93LCBlcnJvckhhbmRsZXIpIHtcbiAgICBpZiAoIV9JTkNMVURFRCkge1xuICAgICAgICByZXF1aXJlKCcuL2RyYWdnYWJsZS9ncmFwaC5qcycpKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgcmVxdWlyZSgnLi90b3VjaC9ncmFwaC5qcycpKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgcmVxdWlyZSgnLi90b3VjaC9tdWx0aWdyYXBoLmpzJykoJCwgd2luZG93LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICByZXF1aXJlKCcuL21vdXNlL2dyYXBoLmpzJykoJCwgd2luZG93LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICByZXF1aXJlKCcuL21vdXNlL211bHRpZ3JhcGguanMnKSgkLCB3aW5kb3csIGVycm9ySGFuZGxlcik7XG4gICAgICAgIHJlcXVpcmUoJy4vbXVsdGlncmFwaC5qcycpKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgcmVxdWlyZSgnLi9yZXNpemUvbXVsdGlncmFwaC5qcycpKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgX0lOQ0xVREVEID0gdHJ1ZTtcbiAgICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkLCB3aW5kb3csIGVycm9ySGFuZGxlcikge1xuICAgIHZhciBHcmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZ3JhcGguanMnKSxcbiAgICAgICAgQXhpcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpcy5qcycpO1xuXG4gICAgaWYgKHR5cGVvZihHcmFwaC5kcmFnU3RhcnRlZCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIEdyYXBoOyB9XG5cbiAgICBHcmFwaC5oYXNBKFwiZHJhZ1N0YXJ0ZWRcIikud2hpY2guaXNBKFwiYm9vbGVhblwiKTtcbiAgICBHcmFwaC5oYXNBKFwiZHJhZ09yaWVudGF0aW9uXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoQXhpcy5PcmllbnRhdGlvbi5pc0luc3RhbmNlKTtcbiAgICBHcmFwaC5oYXNBKFwiZHJhZ0F4aXNcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gYSBpbnN0YW5jZW9mIEF4aXM7XG4gICAgfSk7XG5cbiAgICBHcmFwaC5yZXNwb25kc1RvKFwiZG9EcmFnUmVzZXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdTdGFydGVkKGZhbHNlKTtcbiAgICAgICAgdGhpcy5wYXVzZUFsbERhdGEoKTtcbiAgICB9KTtcblxuICAgIEdyYXBoLnJlc3BvbmRzVG8oXCJkb0RyYWdEb25lXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXN1bWVBbGxEYXRhKCk7XG4gICAgfSk7XG5cbiAgICBHcmFwaC5yZXNwb25kc1RvKFwiZG9EcmFnXCIsIGZ1bmN0aW9uIChtdWx0aWdyYXBoLCBieCwgYnksIGR4LCBkeSwgc2hpZnRLZXkpIHtcbiAgICAgICAgdmFyIGRyYWdBeGlzICAgICAgICA9IHRoaXMuZHJhZ0F4aXMsXG4gICAgICAgICAgICBkcmFnT3JpZW50YXRpb24gPSB0aGlzLmRyYWdPcmllbnRhdGlvbixcbiAgICAgICAgICAgIEhPUklaT05UQUwgPSBBeGlzLkhPUklaT05UQUwsXG4gICAgICAgICAgICBWRVJUSUNBTCAgID0gQXhpcy5WRVJUSUNBTDtcbiAgICAgICAgLy8gVE9ETzogdGhpcyB0cnkuLi5jYXRjaCBpcyBqdXN0IHRvIHJlbWluZCBteXNlbGYgaG93IHRvIGFwcGx5LCBtYWtlIHN1cmUgdGhpcyBpcyBjb3JyZWN0IGxhdGVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZHJhZ1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeCkgPiBNYXRoLmFicyhkeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ09yaWVudGF0aW9uKEhPUklaT05UQUwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdPcmllbnRhdGlvbihWRVJUSUNBTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRyYWdBeGlzKHRoaXMuZmluZE5lYXJlc3RBeGlzKGJ4LCBieSwgZHJhZ09yaWVudGF0aW9uKCkpKTtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0F4aXMoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT3JpZW50YXRpb24oIChkcmFnT3JpZW50YXRpb24oKSA9PT0gSE9SSVpPTlRBTCkgPyBWRVJUSUNBTCA6IEhPUklaT05UQUwgKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0F4aXMoIHRoaXMuZmluZE5lYXJlc3RBeGlzKGJ4LCBieSwgZHJhZ09yaWVudGF0aW9uKCkpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0ZWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIHRoZSBhY3Rpb25cbiAgICAgICAgICAgIGlmIChzaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGlmIChkcmFnT3JpZW50YXRpb24oKSA9PT0gSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnQXhpcygpLmRvWm9vbShieCwgZHgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdBeGlzKCkuZG9ab29tKGJ5LCBkeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ09yaWVudGF0aW9uKCkgPT09IEhPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0F4aXMoKS5kb1BhbihieCwgZHgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdBeGlzKCkuZG9QYW4oYnksIGR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRyYXcgZXZlcnl0aGluZ1xuICAgICAgICAgICAgbXVsdGlncmFwaC5yZWRyYXcoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gR3JhcGg7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkLCB3aW5kb3csIGVycm9ySGFuZGxlcikge1xuICAgIHZhciBHcmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZ3JhcGguanMnKSxcbiAgICAgICAgQ29uc3RhbnRQbG90ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb25zdGFudF9wbG90LmpzJyksXG4gICAgICAgIEF4aXMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2F4aXMuanMnKTtcblxuICAgIGlmICh0eXBlb2YoR3JhcGgubW91c2VXaGVlbFRpbWVyKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gR3JhcGg7IH1cblxuICAgIEdyYXBoLmhhc0EoXCJtb3VzZVdoZWVsVGltZXJcIikud2hpY2guZGVmYXVsdHNUbyhudWxsKTtcblxuICAgIEdyYXBoLnJlc3BvbmRzVG8oXCJkb1doZWVsWm9vbVwiLCBmdW5jdGlvbiAobXVsdGlncmFwaCwgeCwgeSwgZGVsdGEpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZUFsbERhdGEoKTtcbiAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy5maW5kTmVhcmVzdEF4aXMoeCwgeSk7XG4gICAgICAgICAgICBpZiAoYXhpcy5vcmllbnRhdGlvbigpID09PSBBeGlzLkhPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICBheGlzLmRvWm9vbSh4LCA0KmRlbHRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXhpcy5kb1pvb20oeSwgNCpkZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aWdyYXBoLnJlZHJhdygpO1xuXG4gICAgICAgICAgICAvLyByZXN1bWUgZGF0YSBmZXRjaGluZyBhZnRlciAuNSBzZWNvbmRzIG9mIG5vIG1vdXNlIHdoZWVsIG1vdGlvbjpcbiAgICAgICAgICAgIHZhciBtb3VzZVdoZWVsVGltZXIgPSB0aGlzLm1vdXNlV2hlZWxUaW1lcjtcbiAgICAgICAgICAgIGlmIChtb3VzZVdoZWVsVGltZXIoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQobW91c2VXaGVlbFRpbWVyKCkpO1xuICAgICAgICAgICAgICAgIG1vdXNlV2hlZWxUaW1lcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdXNlV2hlZWxUaW1lcih3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5yZXN1bWVBbGxEYXRhKCk7XG4gICAgICAgICAgICB9LCA1MDApKTsgXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBHcmFwaC5oYXNBKFwiZXhpc3RpbmdEYXRhdGlwc1wiKS53aGljaC5kZWZhdWx0c1RvKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9KTtcbiAgICBHcmFwaC5yZXNwb25kc1RvKFwiaGFuZGxlRGF0YXRpcHNcIiwgZnVuY3Rpb24gKGxvYywgd2lkdGgsIGhlaWdodCwgJHRhcmdldCwgZGl2KSB7XG4gICAgICAgIHZhciBleGlzdGluZ0RhdGF0aXBzID0gdGhpcy5leGlzdGluZ0RhdGF0aXBzKCksXG4gICAgICAgICAgICBwbG90cyAgICAgICAgICAgID0gdGhpcy5wbG90cygpLFxuICAgICAgICAgICAgcGxvdCxcbiAgICAgICAgICAgIGRhdGF0aXBzRGF0YSxcbiAgICAgICAgICAgIGRhdGF0aXBJbmRleCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgdmFyIHRlbXAgPSAkKFwiPHNwYW4+PC9zcGFuPlwiKVxuICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIiAgICAgICAgICA6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWFyZ2luXCIgICAgICAgICAgIDogXCIwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLWxlZnRcIiAgICAgOiBcIjVweFwiLFxuICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctcmlnaHRcIiAgICA6IFwiNXB4XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy10b3BcIiAgICAgIDogXCIxcHhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLWJvdHRvbVwiICAgOiBcIjFweFwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oZGl2KTtcblxuICAgICAgICAvLyBmaW5kIGZpcnN0IGF2YWlsYWJsZSBiaXQgb2YgZGF0YVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGxvdHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgIHBsb3QgPSBwbG90cy5hdChpKTtcbiAgICAgICAgICAgIGlmIChwbG90IGluc3RhbmNlb2YgQ29uc3RhbnRQbG90KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhdGlwc0RhdGEgPSBwbG90LmdldERhdGF0aXBzRGF0YShsb2MsIHdpZHRoLCBoZWlnaHQsIHRoaXMsIHRlbXApO1xuICAgICAgICAgICAgaWYgKGRhdGF0aXBzRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YXRpcEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXAucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlcmUgaXMgbm8gZGF0YVxuICAgICAgICBpZiAoZGF0YXRpcHNEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRGF0YXRpcHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZsYWcgYWxsIGRhdGF0aXBzIGZvciByZW1vdmFsXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleGlzdGluZ0RhdGF0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBleGlzdGluZ0RhdGF0aXBzW2ldLmZsYWcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGZsYWdzIGZyb20gZGF0YXRpcHMgdGhhdCBkb24ndCBuZWVkIHRvIGJlIHJlZHJhd25cbiAgICAgICAgY2hlY2tEYXRhdGlwRXhpc3RlbmNlKGRhdGF0aXBzRGF0YSwgZXhpc3RpbmdEYXRhdGlwcyk7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVGbGFnZ2VkRGF0YXRpcHMoKTtcblxuICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiBkYXRhdGlwIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGlmIChkYXRhdGlwc0RhdGEuZmxhZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcnJvd0xlbmd0aCA9IDEwO1xuICAgICAgICBkYXRhdGlwc0RhdGEuYXJyb3cgPSBhcnJvd0xlbmd0aDtcblxuICAgICAgICB2YXIgZGF0YXRpcCA9IHBsb3RzLmF0KGRhdGF0aXBJbmRleCkuY3JlYXRlRGF0YXRpcChkYXRhdGlwc0RhdGEpO1xuXG4gICAgICAgIGRhdGF0aXAuYXBwZW5kVG8oZGl2KTtcblxuICAgICAgICBkYXRhdGlwLm1vdXNlZG93bihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICR0YXJnZXQudHJpZ2dlcihcIm1vdXNlZG93blwiLCBldmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRhdGF0aXBzRGF0YS5lbGVtID0gZGF0YXRpcDtcbiAgICAgICAgZXhpc3RpbmdEYXRhdGlwcy5wdXNoKGRhdGF0aXBzRGF0YSk7XG4gICAgfSk7XG5cbiAgICB2YXIgY2hlY2tEYXRhdGlwRXhpc3RlbmNlID0gZnVuY3Rpb24gKGRhdGF0aXBEYXRhLCBleGlzdGluZ0RhdGEpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBleGlzdGluZ0RhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZGF0YXRpcERhdGEuY29udGVudCAgID09PSBleGlzdGluZ0RhdGFbaV0uY29udGVudCAgICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGF0aXBEYXRhLnR5cGUgICAgICA9PT0gZXhpc3RpbmdEYXRhW2ldLnR5cGUgICAgICAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRhdGlwRGF0YS5waXhlbHBbMF0gPT09IGV4aXN0aW5nRGF0YVtpXS5waXhlbHBbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YXRpcERhdGEucGl4ZWxwWzFdID09PSBleGlzdGluZ0RhdGFbaV0ucGl4ZWxwWzFdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0RhdGFbaV0uZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRhdGF0aXBEYXRhLmZsYWcgPSBmYWxzZTsgLy8gZG8gbm90IHJlZHJhd1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhdGlwRGF0YS5mbGFnID0gdHJ1ZTsgLy8gbmVlZHMgdG8gYmUgZHJhd25cbiAgICB9O1xuXG4gICAgR3JhcGgucmVzcG9uZHNUbyhcInJlbW92ZURhdGF0aXBzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nRGF0YXRpcHMgPSB0aGlzLmV4aXN0aW5nRGF0YXRpcHMoKSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGlmIChleGlzdGluZ0RhdGF0aXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBleGlzdGluZ0RhdGF0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdEYXRhdGlwc1tpXS5lbGVtLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhpc3RpbmdEYXRhdGlwcyA9IFtdO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBHcmFwaC5yZXNwb25kc1RvKFwicmVtb3ZlRmxhZ2dlZERhdGF0aXBzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nRGF0YXRpcHMgPSB0aGlzLmV4aXN0aW5nRGF0YXRpcHMoKSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGlmIChleGlzdGluZ0RhdGF0aXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBleGlzdGluZ0RhdGF0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YXRpcHNbaV0uZmxhZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0RhdGF0aXBzW2ldLmVsZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRGF0YXRpcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICByZXR1cm4gR3JhcGg7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkLCB3aW5kb3csIGVycm9ySGFuZGxlcikge1xuXG4gICAgdmFyIE11bHRpZ3JhcGggPSByZXF1aXJlKCcuLi8uLi9jb3JlL211bHRpZ3JhcGguanMnKSgkKSxcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKE11bHRpZ3JhcGgucmVnaXN0ZXJNb3VzZUV2ZW50cyk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIE11bHRpZ3JhcGg7IH1cblxuICAgIE11bHRpZ3JhcGgucmVzcG9uZHNUbyhcInJlZ2lzdGVyTW91c2VFdmVudHNcIiwgZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYmFzZSxcbiAgICAgICAgICAgIG1vdXNlTGFzdCxcbiAgICAgICAgICAgIG1vdXNlSXNEb3duID0gZmFsc2UsXG4gICAgICAgICAgICBkcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgICAgICAgICAgbXVsdGlncmFwaCA9IHRoaXMsXG4gICAgICAgICAgICAkdGFyZ2V0ID0gJCh0YXJnZXQpO1xuXG4gICAgICAgIHZhciBldmVudExvY2F0aW9uVG9HcmFwaENvb3JkcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgoZXZlbnQucGFnZVggLSAkdGFyZ2V0Lm9mZnNldCgpLmxlZnQpIC0gbXVsdGlncmFwaC5ncmFwaHMoKS5hdCgwKS54MCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGFyZ2V0LmhlaWdodCgpIC0gKGV2ZW50LnBhZ2VZIC0gJHRhcmdldC5vZmZzZXQoKS50b3ApIC0gbXVsdGlncmFwaC5ncmFwaHMoKS5hdCgwKS55MCgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAkdGFyZ2V0Lm1vdXNlZG93bihmdW5jdGlvbiAoZXZlbnQsIGRhdGF0aXBzRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChkYXRhdGlwc0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGRhdGF0aXBzIG1vdXNlZG93biBoYW5kbGVyIGlzIHRyaWdnZXJlZCB0aHJvdWdoIHRoZSBkYXRhdGlwcyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB0aGUgZGVmYXVsdCBldmVudCBkb2VzIG5vdCBjb250YWluIHBhZ2VYIG9yIHBhZ2VZLiBTbyB0aGUgZGF0YXRpcHMgaGFuZGxlclxuICAgICAgICAgICAgICAgIC8vIHBhc3NlcyBpdHMgZXZlbnQsIHdoaWNoIGRvZXMgY29udGFpbiBwYWdlWCBhbmQgcGFnZVkuXG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkYXRhdGlwc0V2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG11bHRpZ3JhcGguZ3JhcGhzKCkuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KGkpLnJlbW92ZURhdGF0aXBzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdXNlTGFzdCA9IGJhc2UgPSBldmVudExvY2F0aW9uVG9HcmFwaENvb3JkcyhldmVudCk7XG4gICAgICAgICAgICBtb3VzZUlzRG93biA9IHRydWU7XG4gICAgICAgICAgICBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICAkdGFyZ2V0Lm1vdXNldXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBtb3VzZUlzRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgbXVsdGlncmFwaC5ncmFwaHMoKS5hdCgwKS5kb0RyYWdEb25lKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICR0YXJnZXQubW91c2Vtb3ZlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50TG9jID0gZXZlbnRMb2NhdGlvblRvR3JhcGhDb29yZHMoZXZlbnQpLFxuICAgICAgICAgICAgICAgIGdyYXBocyAgID0gbXVsdGlncmFwaC5ncmFwaHMoKTtcbiAgICAgICAgICAgIGlmIChtb3VzZUlzRG93bikge1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50TG9jLngoKSAtIG1vdXNlTGFzdC54KCksXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gZXZlbnRMb2MueSgpIC0gbW91c2VMYXN0LnkoKTtcbiAgICAgICAgICAgICAgICBpZiAobXVsdGlncmFwaC5ncmFwaHMoKS5zaXplKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaHMuYXQoMCkuZG9EcmFnUmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncmFwaHMuYXQoMCkuZG9EcmFnKG11bHRpZ3JhcGgsIGJhc2UueCgpLCBiYXNlLnkoKSwgZHgsIGR5LCBldmVudC5zaGlmdEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGRhdGF0aXBzIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdyYXBocy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBncmFwaHMuYXQoaSkuaGFuZGxlRGF0YXRpcHMoZXZlbnRMb2MsIG11bHRpZ3JhcGgud2lkdGgoKSwgbXVsdGlncmFwaC5oZWlnaHQoKSwgJHRhcmdldCwgbXVsdGlncmFwaC5kaXYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW91c2VMYXN0ID0gZXZlbnRMb2M7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5ub3Njcm9sbCkge1xuICAgICAgICAgICAgJHRhcmdldC5tb3VzZXdoZWVsKGZ1bmN0aW9uIChldmVudCwgZGVsdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRMb2MgPSBldmVudExvY2F0aW9uVG9HcmFwaENvb3JkcyhldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKG11bHRpZ3JhcGguZ3JhcGhzKCkuc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvV2hlZWxab29tKG11bHRpZ3JhcGgsIGV2ZW50TG9jLngoKSwgZXZlbnRMb2MueSgpLCBkZWx0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICR0YXJnZXQubW91c2VsZWF2ZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIG1vdXNlSXNEb3duID0gZmFsc2U7XG4gICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZ0RvbmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChtdWx0aWdyYXBoLmRpdigpKS5tb3VzZWxlYXZlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGdyYXBocyA9IG11bHRpZ3JhcGguZ3JhcGhzKCksXG4gICAgICAgICAgICAgICAgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBncmFwaHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBncmFwaHMuYXQoaSkucmVtb3ZlRGF0YXRpcHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBNdWx0aWdyYXBoO1xufTtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG52YXIgX0lOQ0xVREVEID0gZmFsc2U7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKSB7XG5cbiAgICBpZiAoX0lOQ0xVREVEKSB7IHJldHVybjsgfSBlbHNlIHsgX0lOQ0xVREVEID0gdHJ1ZTsgfVxuICAgIFxuICAgIHZhciBNdWx0aWdyYXBoID0gcmVxdWlyZSgnLi4vY29yZS9tdWx0aWdyYXBoLmpzJykoJCk7XG5cbiAgICB2YXIgbWV0aG9kcyA9IHtcbiAgICAgICAgbXVsdGlncmFwaCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ211bHRpZ3JhcGgnKS5tdWx0aWdyYXBoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRvbmUgOiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZGF0YSgnbXVsdGlncmFwaCcpLm11bHRpZ3JhcGguZG9uZShmdW5jKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlc3Ryb3kgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnbXVsdGlncmFwaCcpLm11bHRpZ3JhcGguZG9uZShmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICAgICAgICAgIG0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICR0aGlzLnJlbW92ZURhdGEoXCJtdWx0aWdyYXBoXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgnbXVsdGlncmFwaCcpO1xuICAgICAgICAgICAgICAgIGlmICghKFwibXVnbFwiIGluIG9wdGlvbnMpICYmICEoXCJtdWdsU3RyaW5nXCIgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgb3B0aW9ucyBjb250YWlucyBuZWlndGhlciBcIm11Z2xcIiBub3IgXCJtdWdsU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZSBpdCdzIGEgSlNPTiBtdWdsIG9iamVjdCwgc28gcGFzcyBpdCBvbiBhc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWUgb2YgXCJtdWdsU3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWdsU3RyaW5nOiBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGl2ID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoICEgZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnbXVsdGlncmFwaCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZ3JhcGggOiBNdWx0aWdyYXBoLmNyZWF0ZUdyYXBoKG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4ubXVsdGlncmFwaCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgaWYgKCBtZXRob2RzW21ldGhvZF0gKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1sgbWV0aG9kIF0uYXBwbHkoIHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnIHx8ICEgbWV0aG9kICkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVycm9yKCAnTWV0aG9kICcgKyAgbWV0aG9kICsgJyBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkubXVsdGlncmFwaCcgKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9ICAgIFxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEluY2x1c2lvbiBvZiB0aGlzIGZpbGUgYWxsb3dzIG1hcmt1cCBsaWtlIHRoZSBmb2xsb3dpbmcgdG8gYmVcbiAgICAgKiB1c2VkIGluIEhUTUw6XG4gICAgICogXG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJtdWx0aWdyYXBoXCJcbiAgICAgKiAgICAgICAgZGF0YS1zcmM9XCJNVUdMX0ZJTEVcIlxuICAgICAqICAgICAgICBkYXRhLXdpZHRoPVwiV0lEVEhcIlxuICAgICAqICAgICAgICBkYXRhLWhlaWdodD1cIkhFSUdIVFwiXG4gICAgICogICAgICAgIGRhdGEtZHJpdmVyPVwiRFJJVkVSXCI+XG4gICAgICogICAgIDwvZGl2PlxuICAgICAqIFxuICAgICAqIFRoZSBkYXRhLWRyaXZlciB0YWcgaXMgb3B0aW9uYWw7IGlmIG5vdCBzcGVjaWZpZWQsIGl0IGN1cnJlbnRseVxuICAgICAqIGRlZmF1bHRzIHRvIFwiY2FudmFzXCIsIGJ1dCB0aGF0IHdpbGwgYmUgY2hhbmdlZCBpbiB0aGUgZnV0dXJlIHRvXG4gICAgICogbWFrZSBhIHNtYXJ0IGNob2ljZSBiYXNlZCBvbiBicm93c2VyIGNhcGFiaWxpdGllcy5cbiAgICAgKiBcbiAgICAgKiBUaGUgZGF0YS13aWR0aCBhbmQgZGF0YS1oZWlnaHQgdGFncyBhcmUgYWxzbyBvcHRpb25hbDsgaWYgdGhleVxuICAgICAqIGFyZSBub3Qgc3BlY2lmaWVkLCBNdWx0aWdyYXBoIHdpbGwgdXNlIHRoZSBkaXYgc2l6ZSBhcyBkZXRlcm1pbmVkXG4gICAgICogYnkgdGhlIGJyb3dzZXIgKHdoaWNoIG1heSBiZSBzZXQgYnkgY3NzIHJ1bGVzLCBmb3IgZXhhbXBsZSkuICBJZlxuICAgICAqIGRhdGEtd2lkdGggb3IgZGF0YS1oZWlnaHQgaXMgcHJlc2VudCwgaXQgd2lsbCBvdmVycmlkZSBhbnkgY3NzXG4gICAgICogd2lkdGggb3IgaGVpZ2h0LlxuICAgICAqIFxuICAgICAqL1xuICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAkKFwiZGl2Lm11bHRpZ3JhcGhcIikuZWFjaChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCAgPSAkKHRoaXMpLmF0dHIoXCJkYXRhLXdpZHRoXCIpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9ICQodGhpcykuYXR0cihcImRhdGEtaGVpZ2h0XCIpLFxuICAgICAgICAgICAgICAgIHNyYyAgICA9ICQodGhpcykuYXR0cihcImRhdGEtc3JjXCIpLFxuICAgICAgICAgICAgICAgIGRyaXZlciA9ICQodGhpcykuYXR0cihcImRhdGEtZHJpdmVyXCIpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM7XG5cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ3dpZHRoJywgd2lkdGggKyAncHgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICQodGhpcykuY3NzKCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAvLyBkb24ndCBkZWZhdWx0IHRvIGNhbnZhcyBoZXJlIGFueSBtb3JlOyBNdWx0aWdyYXBoLmNyZWF0ZUdyYXBoIG5vdyBkb2VzXG4gICAgICAgICAgICAgLy8gYnJvd3NlciBkZXRlY3Rpb24gYW5kIHdpbGwgZGVmYXVsdCB0byBjYW52YXMgaWYgcG9zc2libGUsIG90aGVyd2lzZVxuICAgICAgICAgICAgIC8vIHRvIHJhcGhhZWxcbiAgICAgICAgICAgICBpZiAoZHJpdmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICBkcml2ZXIgPSBcImNhbnZhc1wiO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICdkaXYnICAgIDogdGhpcyxcbiAgICAgICAgICAgICAgICAnbXVnbCcgICA6IHNyYyxcbiAgICAgICAgICAgICAgICAnZHJpdmVyJyA6IGRyaXZlclxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgJCh0aGlzKS5tdWx0aWdyYXBoKG9wdGlvbnMpO1xuICAgICAgICAgICAgJCh0aGlzKS5saWdodGJveCh7XG4gICAgICAgICAgICAgICAgc2NhbGUgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBvc3RvcGVuIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlnaHRib3hEYXRhID0gdGhpcy5kYXRhKFwibGlnaHRib3hcIik7XG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0Ym94RGF0YS5vcmlnaW5hbERpdiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YShcIm11bHRpZ3JhcGhcIikubXVsdGlncmFwaC5kb25lKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmRpdihsaWdodGJveERhdGEuY29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5pbml0aWFsaXplU3VyZmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yZXNpemVTdXJmYWNlKGxpZ2h0Ym94RGF0YS5jb250ZW50V2lkdGgsIGxpZ2h0Ym94RGF0YS5jb250ZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ud2lkdGgobGlnaHRib3hEYXRhLmNvbnRlbnRXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGxpZ2h0Ym94RGF0YS5jb250ZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYnVzeVNwaW5uZXIoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYnVzeVNwaW5uZXIoJCgnPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDo1cHg7IHRvcDo1cHg7XCI+PC9kaXY+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKCQobS5kaXYoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5idXN5X3NwaW5uZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQ9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0Ym94RGF0YS5jb250ZW50cy5saWdodGJveChcInJlc2l6ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBvc3RjbG9zZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpZ2h0Ym94RGF0YSA9IHRoaXMuZGF0YShcImxpZ2h0Ym94XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEoXCJtdWx0aWdyYXBoXCIpLm11bHRpZ3JhcGguZG9uZShmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5kaXYobGlnaHRib3hEYXRhLm9yaWdpbmFsRGl2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aWR0aCgkKG0uZGl2KCkpLndpZHRoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmhlaWdodCgkKG0uZGl2KCkpLmhlaWdodCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5idXN5U3Bpbm5lcigkKCc8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OjVweDsgdG9wOjVweDtcIj48L2Rpdj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oJChtLmRpdigpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmJ1c3lfc3Bpbm5lcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbS5pbml0aWFsaXplU3VyZmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb3N0cmVzaXplIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlnaHRib3hEYXRhID0gdGhpcy5kYXRhKFwibGlnaHRib3hcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YShcIm11bHRpZ3JhcGhcIikubXVsdGlncmFwaC5kb25lKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnJlc2l6ZVN1cmZhY2UobGlnaHRib3hEYXRhLmNvbnRlbnRXaWR0aCwgbGlnaHRib3hEYXRhLmNvbnRlbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS53aWR0aChsaWdodGJveERhdGEuY29udGVudFdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5oZWlnaHQobGlnaHRib3hEYXRhLmNvbnRlbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCwgd2luZG93LCBlcnJvckhhbmRsZXIpIHtcbiAgICB2YXIgTXVsdGlncmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbXVsdGlncmFwaC5qcycpKCQpLFxuICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKTtcblxuICAgIGlmICh0eXBlb2YoTXVsdGlncmFwaC5yZWdpc3RlclJlc2l6ZUV2ZW50cyk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIE11bHRpZ3JhcGg7IH1cblxuICAgIE11bHRpZ3JhcGgucmVzcG9uZHNUbyhcInJlZ2lzdGVyUmVzaXplRXZlbnRzXCIsIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIG11bHRpZ3JhcGggPSB0aGlzO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gJCh0aGlzLmRpdigpKTtcbiAgICAgICAgdmFyIGMgPSAkKHRhcmdldCk7IC8vIHNlbGVjdCBjYW52YXMgaW4gbXVsdGlncmFwaCBkaXZcbiAgICAgICAgJCh3aW5kb3cpLnJlc2l6ZShyZXNwb25kR3JhcGgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlc3BvbmRHcmFwaCgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGMuYXR0cihcIndpZHRoXCIsIGNvbnRhaW5lci53aWR0aCgpICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgYy5hdHRyKFwiaGVpZ2h0XCIsIGNvbnRhaW5lci5oZWlnaHQoKSAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGMuY3NzKFwid2lkdGhcIiwgY29udGFpbmVyLndpZHRoKCkpO1xuICAgICAgICAgICAgYy5jc3MoXCJoZWlnaHRcIiwgY29udGFpbmVyLmhlaWdodCgpKTtcbiAgICAgICAgICAgIG11bHRpZ3JhcGguaW5pdCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gTXVsdGlncmFwaDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKSB7XG4gICAgdmFyIEdyYXBoID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ncmFwaC5qcycpLFxuICAgICAgICBBeGlzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzLmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKEdyYXBoLmRvRmlyc3RQaW5jaFpvb20pPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBHcmFwaDsgfVxuXG4gICAgR3JhcGgucmVzcG9uZHNUbyhcImRvRmlyc3RQaW5jaFpvb21cIiwgZnVuY3Rpb24gKG11bHRpZ3JhcGgsIGJ4LCBieSwgZHgsIGR5LCB0b3RhbHgsIHRvdGFseSkge1xuICAgICAgICB2YXIgZHJhZ0F4aXMgPSB0aGlzLmRyYWdBeGlzLFxuICAgICAgICAgICAgZHJhZ09yaWVudGF0aW9uID0gdGhpcy5kcmFnT3JpZW50YXRpb24sXG4gICAgICAgICAgICBIT1JJWk9OVEFMID0gQXhpcy5IT1JJWk9OVEFMLFxuICAgICAgICAgICAgVkVSVElDQUwgICA9IEF4aXMuVkVSVElDQUw7XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyB0cnkuLi5jYXRjaCBpcyBqdXN0IHRvIHJlbWluZCBteXNlbGYgaG93IHRvIGFwcGx5LCBtYWtlIHN1cmUgdGhpcyBpcyBjb3JyZWN0IGxhdGVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZHJhZ1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbHggPiB0b3RhbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ09yaWVudGF0aW9uKEhPUklaT05UQUwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdPcmllbnRhdGlvbihWRVJUSUNBTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRyYWdBeGlzKHRoaXMuZmluZE5lYXJlc3RBeGlzKGJ4LCBieSwgZHJhZ09yaWVudGF0aW9uKCkpKTtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0F4aXMoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT3JpZW50YXRpb24oIChkcmFnT3JpZW50YXRpb24oKSA9PT0gSE9SSVpPTlRBTCkgPyBWRVJUSUNBTCA6IEhPUklaT05UQUwgKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0F4aXMoIHRoaXMuZmluZE5lYXJlc3RBeGlzKGJ4LCBieSwgZHJhZ09yaWVudGF0aW9uKCkpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0ZWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIHRoZSBhY3Rpb25cbiAgICAgICAgICAgIGlmIChkcmFnT3JpZW50YXRpb24oKSA9PT0gSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGRyYWdBeGlzKCkuZG9ab29tKGJ4LCBkeCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYWdBeGlzKCkuZG9ab29tKGJ5LCBkeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRyYXcgZXZlcnl0aGluZ1xuICAgICAgICAgICAgbXVsdGlncmFwaC5yZWRyYXcoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gR3JhcGg7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkLCB3aW5kb3csIGVycm9ySGFuZGxlcikge1xuICAgIHZhciBNdWx0aWdyYXBoID0gcmVxdWlyZSgnLi4vLi4vY29yZS9tdWx0aWdyYXBoLmpzJykoJCksXG4gICAgICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpO1xuXG4gICAgaWYgKHR5cGVvZihNdWx0aWdyYXBoLnJlZ2lzdGVyVG91Y2hFdmVudHMpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBNdWx0aWdyYXBoOyB9XG5cbiAgICBNdWx0aWdyYXBoLnJlc3BvbmRzVG8oXCJyZWdpc3RlclRvdWNoRXZlbnRzXCIsIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIHRvdWNoU3RhcnRlZCAgICAgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGRyYWdTdGFydGVkICAgICAgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHBpbmNoWm9vbVN0YXJ0ZWQgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHBpbmNoWm9vbURldGVybWluZWQgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHBpbmNoWm9vbUluaXRpYWxEZWx0YXMgPSB7fSxcbiAgICAgICAgICAgIHBpbmNoWm9vbURldGVybWluZWRUaW1lb3V0LFxuICAgICAgICAgICAgcHJldmlvdXN0b3VjaGEsIHByZXZpb3VzdG91Y2hiLFxuICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgIG11bHRpZ3JhcGggPSB0aGlzLFxuICAgICAgICAgICAgJHRhcmdldCA9ICQodGFyZ2V0KTtcblxuICAgICAgICB2YXIgdG91Y2hMb2NhdGlvblRvR3JhcGhDb29yZHMgPSBmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoKHRvdWNoLnBhZ2VYIC0gJHRhcmdldC5vZmZzZXQoKS5sZWZ0KSAtIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoMCkueDAoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRhcmdldC5oZWlnaHQoKSAtICh0b3VjaC5wYWdlWSAtICR0YXJnZXQub2Zmc2V0KCkudG9wKSAtIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoMCkueTAoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoanF1ZXJ5RXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0ganF1ZXJ5RXZlbnQub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gdG91Y2hMb2NhdGlvblRvR3JhcGhDb29yZHMoZS50b3VjaGVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzdG91Y2hhID0gdG91Y2hMb2NhdGlvblRvR3JhcGhDb29yZHMoZS50b3VjaGVzWzBdKTtcblxuICAgICAgICAgICAgLy8gb25lIGZpbmdlciBkcmFnXG4gICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcGluY2ggem9vbVxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBwaW5jaFpvb21TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwaW5jaFpvb21EZXRlcm1pbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJldmlvdXN0b3VjaGIgPSB0b3VjaExvY2F0aW9uVG9HcmFwaENvb3JkcyhlLnRvdWNoZXNbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaW5jaFpvb21TdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcGluY2hab29tRGV0ZXJtaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b3VjaFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoMCkuZG9EcmFnRG9uZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYW5kbGVUb3VjaE1vdmUgPSBmdW5jdGlvbiAoanF1ZXJ5RXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0ganF1ZXJ5RXZlbnQub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgLy8gb25lIGZpbmdlciBkcmFnXG4gICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBkcmFnU3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZURyYWcoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwaW5jaCB6b29tXG4gICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMiAmJiBwaW5jaFpvb21TdGFydGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUGluY2hab29tKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYW5kbGVUb3VjaEVuZCA9IGZ1bmN0aW9uIChqcXVlcnlFdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSBqcXVlcnlFdmVudC5vcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBvbmUgZmluZ2VyIGRyYWdcbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBwaW5jaCB6b29tXG4gICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHBpbmNoWm9vbVN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBpbmNoWm9vbURldGVybWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGluY2hab29tU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBpbmNoWm9vbURldGVybWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG91Y2hTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZ0RvbmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlVG91Y2hMZWF2ZSA9IGZ1bmN0aW9uIChqcXVlcnlFdmVudCkge1xuICAgICAgICAgICAganF1ZXJ5RXZlbnQub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcGluY2hab29tU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcGluY2hab29tRGV0ZXJtaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgdG91Y2hTdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoMCkuZG9EcmFnRG9uZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYW5kbGVEcmFnID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0b3VjaExvYyA9IHRvdWNoTG9jYXRpb25Ub0dyYXBoQ29vcmRzKGUudG91Y2hlc1swXSksXG4gICAgICAgICAgICAgICAgZHggPSB0b3VjaExvYy54KCkgLSBwcmV2aW91c3RvdWNoYS54KCksXG4gICAgICAgICAgICAgICAgZHkgPSB0b3VjaExvYy55KCkgLSBwcmV2aW91c3RvdWNoYS55KCk7XG4gICAgICAgICAgICBpZiAobXVsdGlncmFwaC5ncmFwaHMoKS5zaXplKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b3VjaFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlncmFwaC5ncmFwaHMoKS5hdCgwKS5kb0RyYWdSZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZyhtdWx0aWdyYXBoLCBiYXNlLngoKSwgYmFzZS55KCksIGR4LCBkeSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG91Y2hTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzdG91Y2hhID0gdG91Y2hMb2M7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhbmRsZVBpbmNoWm9vbSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRvdWNoTG9jYXRpb25Ub0dyYXBoQ29vcmRzKGUudG91Y2hlc1swXSksXG4gICAgICAgICAgICAgICAgYiA9IHRvdWNoTG9jYXRpb25Ub0dyYXBoQ29vcmRzKGUudG91Y2hlc1sxXSksXG4gICAgICAgICAgICAgICAgYmFzZXggPSAoYS54KCkgKyBiLngoKSkgLyAyLFxuICAgICAgICAgICAgICAgIGJhc2V5ID0gKGEueSgpICsgYi55KCkpIC8gMixcbiAgICAgICAgICAgICAgICBkeCA9IGNhbGN1bGF0ZUFic29sdXRlRGlzdGFuY2UoYS54KCksIGIueCgpKSAtIGNhbGN1bGF0ZUFic29sdXRlRGlzdGFuY2UocHJldmlvdXN0b3VjaGEueCgpLCBwcmV2aW91c3RvdWNoYi54KCkpLFxuICAgICAgICAgICAgICAgIGR5ID0gY2FsY3VsYXRlQWJzb2x1dGVEaXN0YW5jZShhLnkoKSwgYi55KCkpIC0gY2FsY3VsYXRlQWJzb2x1dGVEaXN0YW5jZShwcmV2aW91c3RvdWNoYS55KCksIHByZXZpb3VzdG91Y2hiLnkoKSk7XG5cbiAgICAgICAgICAgIGlmIChtdWx0aWdyYXBoLmdyYXBocygpLnNpemUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRvdWNoU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZ1Jlc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwaW5jaFpvb21EZXRlcm1pbmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoMCkuZG9EcmFnKG11bHRpZ3JhcGgsIGJhc2V4LCBiYXNleSwgZHgsIGR5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3VjaFN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyB0d28gZmluZ2VyIHNjcm9sbFxuICAgICAgICAgICAgdmFyIGN4ID0gKChhLngoKSAtIHByZXZpb3VzdG91Y2hhLngoKSkgKyAoYi54KCkgLSBwcmV2aW91c3RvdWNoYi54KCkpKSAvIDIsXG4gICAgICAgICAgICAgICAgY3kgPSAoKGEueSgpIC0gcHJldmlvdXN0b3VjaGEueSgpKSArIChiLnkoKSAtIHByZXZpb3VzdG91Y2hiLnkoKSkpIC8gMjtcbiAgICAgICAgICAgIGlmIChwaW5jaFpvb21EZXRlcm1pbmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlncmFwaC5ncmFwaHMoKS5hdCgwKS5kb0RyYWcobXVsdGlncmFwaCwgYmFzZXgsIGJhc2V5LCBjeCwgY3ksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBpbmNoWm9vbURldGVybWluZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpbmNoWm9vbUluaXRpYWxEZWx0YXMuYmFzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpbmNoWm9vbUluaXRpYWxEZWx0YXMuYmFzZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLmJhc2UueCA9IGJhc2V4O1xuICAgICAgICAgICAgICAgICAgICBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLmJhc2UueSA9IGJhc2V5O1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgaWYgKHBpbmNoWm9vbUluaXRpYWxEZWx0YXMuem9vbURlbHRhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpbmNoWm9vbUluaXRpYWxEZWx0YXMuem9vbURlbHRhcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZHhcIiAgICAgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkeVwiICAgICA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRvdGFseFwiIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidG90YWx5XCIgOiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnBhbkRlbHRhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpbmNoWm9vbUluaXRpYWxEZWx0YXMucGFuRGVsdGFzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJkeFwiIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZHlcIiA6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnpvb21EZWx0YXMuZHggKz0gZHg7XG4gICAgICAgICAgICAgICAgcGluY2hab29tSW5pdGlhbERlbHRhcy56b29tRGVsdGFzLmR5ICs9IGR5O1xuICAgICAgICAgICAgICAgIHBpbmNoWm9vbUluaXRpYWxEZWx0YXMucGFuRGVsdGFzLmR4ICs9IGN4O1xuICAgICAgICAgICAgICAgIHBpbmNoWm9vbUluaXRpYWxEZWx0YXMucGFuRGVsdGFzLmR5ICs9IGN5O1xuXG4gICAgICAgICAgICAgICAgcGluY2hab29tSW5pdGlhbERlbHRhcy56b29tRGVsdGFzLnRvdGFseCArPSBNYXRoLmFicyhkeCk7XG4gICAgICAgICAgICAgICAgcGluY2hab29tSW5pdGlhbERlbHRhcy56b29tRGVsdGFzLnRvdGFseSArPSBNYXRoLmFicyhkeSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGluY2hab29tRGV0ZXJtaW5lZFRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwaW5jaFpvb21EZXRlcm1pbmVkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2V4ID0gcGluY2hab29tSW5pdGlhbERlbHRhcy5iYXNlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZXkgPSBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLmJhc2UueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeCA9IHBpbmNoWm9vbUluaXRpYWxEZWx0YXMuem9vbURlbHRhcy5keCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSA9IHBpbmNoWm9vbUluaXRpYWxEZWx0YXMuem9vbURlbHRhcy5keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCA9IHBpbmNoWm9vbUluaXRpYWxEZWx0YXMucGFuRGVsdGFzLmR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gcGluY2hab29tSW5pdGlhbERlbHRhcy5wYW5EZWx0YXMuZHk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoMCkuZG9EcmFnUmVzZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlncmFwaC5ncmFwaHMoKS5hdCgwKS5kb0ZpcnN0UGluY2hab29tKG11bHRpZ3JhcGgsIGJhc2V4LCBiYXNleSwgZHgsIGR5LCBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnpvb21EZWx0YXMudG90YWx4LCBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnpvb21EZWx0YXMudG90YWx5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoMCkuZG9EcmFnKG11bHRpZ3JhcGgsIGJhc2V4LCBiYXNleSwgY3gsIGN5LCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBpbmNoWm9vbUluaXRpYWxEZWx0YXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpbmNoWm9vbURldGVybWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHBpbmNoWm9vbURldGVybWluZWRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpbmNoWm9vbURldGVybWluZWRUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9LCA2MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2aW91c3RvdWNoYSA9IGE7XG4gICAgICAgICAgICBwcmV2aW91c3RvdWNoYiA9IGI7XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2FsY3VsYXRlQWJzb2x1dGVEaXN0YW5jZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpO1xuICAgICAgICB9O1xuXG4gICAgICAgICR0YXJnZXQub24oXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZVRvdWNoU3RhcnQpO1xuICAgICAgICAkdGFyZ2V0Lm9uKFwidG91Y2htb3ZlXCIsIGhhbmRsZVRvdWNoTW92ZSk7XG4gICAgICAgICR0YXJnZXQub24oXCJ0b3VjaGVuZFwiLCBoYW5kbGVUb3VjaEVuZCk7XG4gICAgICAgICR0YXJnZXQub24oXCJ0b3VjaGxlYXZlXCIsIGhhbmRsZVRvdWNoTGVhdmUpO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gTXVsdGlncmFwaDtcbn07XG4iLCJ2YXIgX0lOQ0xVREVEID0gZmFsc2U7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQsIHdpbmRvdykge1xuICAgIGlmIChfSU5DTFVERUQpIHsgcmV0dXJuOyB9XG4gICAgX0lOQ0xVREVEID0gdHJ1ZTtcblxuICAgIHJlcXVpcmUoJy4vbXVsdGlncmFwaC5qcycpKCQsIHdpbmRvdyk7XG5cbiAgICByZXF1aXJlKCcuL2F4aXMuanMnKSgpO1xuICAgIHJlcXVpcmUoJy4vYXhpc190aXRsZS5qcycpKCk7XG4gICAgcmVxdWlyZSgnLi9iYWNrZ3JvdW5kLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL2dyYXBoLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL2dyYXBoX3RpdGxlLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL2ljb24uanMnKSgpO1xuICAgIHJlcXVpcmUoJy4vaW1nLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL2xhYmVsZXIuanMnKSgpO1xuICAgIHJlcXVpcmUoJy4vbGVnZW5kLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL3Bsb3RhcmVhLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL3JlbmRlcmVycy9iYW5kX3JlbmRlcmVyLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL3JlbmRlcmVycy9iYXJfcmVuZGVyZXIuanMnKSgpO1xuICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL2ZpbGxfcmVuZGVyZXIuanMnKSgpO1xuICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3BvaW50bGluZV9yZW5kZXJlci5qcycpKCk7XG4gICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvcmFuZ2ViYXJfcmVuZGVyZXIuanMnKSgpO1xuICAgIHJlcXVpcmUoJy4vdGV4dC5qcycpKCk7XG4gICAgcmVxdWlyZSgnLi93aW5kb3cuanMnKSgpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEF4aXMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2F4aXMuanMnKTtcblxuICAgIGlmICh0eXBlb2YoQXhpcy5yZW5kZXJHcmlkKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gQXhpczsgfVxuXG4gICAgQXhpcy5yZXNwb25kc1RvKFwicmVuZGVyR3JpZFwiLCBmdW5jdGlvbiAoZ3JhcGgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUoKSkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5wcmVwYXJlUmVuZGVyKGNvbnRleHQpO1xuXG4gICAgICAgIC8vIGRyYXcgdGhlIGdyaWQgbGluZXNcbiAgICAgICAgaWYgKHRoaXMuaGFzRGF0YU1pbigpICYmIHRoaXMuaGFzRGF0YU1heCgpKSB7IC8vIHNraXAgaWYgd2UgZG9uJ3QgeWV0IGhhdmUgZGF0YSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQoKS52aXNpYmxlKCkpIHsgLy8gc2tpcCBpZiBncmlkIGxpbmVzIGFyZW4ndCB0dXJuZWQgb25cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYWJlbGVycygpLnNpemUoKSA+IDAgJiYgdGhpcy5jdXJyZW50TGFiZWxEZW5zaXR5KCkgPD0gMS41KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TGFiZWxlciA9IHRoaXMuY3VycmVudExhYmVsZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnBPZmZzZXQgICAgID0gdGhpcy5wZXJwT2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwbG90Qm94ICAgICAgICA9IGdyYXBoLnBsb3RCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExhYmVsZXIucHJlcGFyZSh0aGlzLmRhdGFNaW4oKSwgdGhpcy5kYXRhTWF4KCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudExhYmVsZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGN1cnJlbnRMYWJlbGVyLm5leHQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gdGhpcy5kYXRhVmFsdWVUb0F4aXNWYWx1ZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGEsIHBlcnBPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGEsIHBsb3RCb3guaGVpZ2h0KCkgLSBwZXJwT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocGVycE9mZnNldCwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocGxvdEJveC53aWR0aCgpIC0gcGVycE9mZnNldCwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuZ3JpZCgpLmNvbG9yKCkuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIEF4aXMucmVzcG9uZHNUbyhcInJlbmRlclwiLCBmdW5jdGlvbiAoZ3JhcGgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUoKSkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIHBhcmFsbGVsT2Zmc2V0ID0gdGhpcy5wYXJhbGxlbE9mZnNldCgpLFxuICAgICAgICAgICAgcGVycE9mZnNldCAgICAgPSB0aGlzLnBlcnBPZmZzZXQoKSxcbiAgICAgICAgICAgIHBpeGVsTGVuZ3RoICAgID0gdGhpcy5waXhlbExlbmd0aCgpLFxuICAgICAgICAgICAgY3VycmVudExhYmVsZXIgPSB0aGlzLmN1cnJlbnRMYWJlbGVyKCksXG4gICAgICAgICAgICBheGlzSXNIb3Jpem9udGFsID0gKHRoaXMub3JpZW50YXRpb24oKSA9PT0gQXhpcy5IT1JJWk9OVEFMKTtcbiAgICAgICAgLy9OT1RFOiBheGVzIGFyZSBkcmF3biByZWxhdGl2ZSB0byB0aGUgZ3JhcGgncyBwbG90IGFyZWEgKHBsb3RCb3gpOyB0aGUgY29vcmRpbmF0ZXNcbiAgICAgICAgLy8gICAgICBiZWxvdyBhcmUgcmVsYXRpdmUgdG8gdGhlIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoYXQgYm94LlxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlbmRlciB0aGUgYXhpcyBsaW5lIGl0c2VsZiwgdW5sZXNzIGl0cyBsaW5ld2lkdGgoKSBwcm9wZXJ0eSBpcyAwLlxuICAgICAgICAvLyBUT0RPOiBtb2RpZnkgdGhpcyBzbyB0aGF0IGl0IGNvcnJlY3RseSBkcmF3cyBhIGxpbmUgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgICAgLy8gbGluZXdpZHRoKCkuICBBdCB0aGUgbW9tZW50LCBpdCBvbmx5IG1ha2VzIGEgZGlzdGluY3Rpb24gYmV0d2VlblxuICAgICAgICAvLyBsaW5lcyBvZiB3aWR0aCAwLCB3aGljaCBhcmVuJ3QgZHJhd24gYXQgYWxsLCBhbmQgbGluZXMgd2l0aCB3aWR0aCA+IDAsXG4gICAgICAgIC8vIHdoaWNoIGFyZSBkcmF3biB3aXRoIHdpZHRoIDEuXG4gICAgICAgIGlmICh0aGlzLmxpbmV3aWR0aCgpID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChheGlzSXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocGFyYWxsZWxPZmZzZXQsIHBlcnBPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBhcmFsbGVsT2Zmc2V0ICsgcGl4ZWxMZW5ndGgsIHBlcnBPZmZzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwZXJwT2Zmc2V0LCBwYXJhbGxlbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocGVycE9mZnNldCwgcGFyYWxsZWxPZmZzZXQgKyBwaXhlbExlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yKCkuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBSZW5kZXIgdGhlIHRpY2sgbWFya3MgYW5kIGxhYmVsc1xuICAgICAgICAvL1xuICAgICAgICBpZiAodGhpcy5oYXNEYXRhTWluKCkgJiYgdGhpcy5oYXNEYXRhTWF4KCkpIHsgLy8gYnV0IHNraXAgaWYgd2UgZG9uJ3QgeWV0IGhhdmUgZGF0YSB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGFiZWxlciAmJiBjdXJyZW50TGFiZWxlci52aXNpYmxlKCkpIHsgLy8gYWxzbyBza2lwIGlmIHdlIGhhdmUgbm8gY3VycmVudCBsYWJlbGVyLCBvclxuICAgICAgICAgICAgICAgIHZhciB0aWNrd2lkdGggPSB0aGlzLnRpY2t3aWR0aCgpLCAgICAgICAgICAgICAvLyAgIGlmIHdlIGRvIGJ1dCBpdHMgYHZpc2libGVgIHByb3BlcnR5IGlzIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHRpY2ttaW4gICA9IHRoaXMudGlja21pbigpLFxuICAgICAgICAgICAgICAgICAgICB0aWNrbWF4ICAgPSB0aGlzLnRpY2ttYXgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGlja2NvbG9yID0gdGhpcy50aWNrY29sb3IoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMwMDAwMDAnO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbGVyLnByZXBhcmUodGhpcy5kYXRhTWluKCksIHRoaXMuZGF0YU1heCgpKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudExhYmVsZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gY3VycmVudExhYmVsZXIubmV4dCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMuZGF0YVZhbHVlVG9BeGlzVmFsdWUodik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWNrd2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGlja2NvbG9yICE9PSB1bmRlZmluZWQgJiYgdGlja2NvbG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRpY2tjb2xvci5nZXRIZXhTdHJpbmcoJyMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzSXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oYSwgcGVycE9mZnNldCt0aWNrbWF4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhhLCBwZXJwT2Zmc2V0K3RpY2ttaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwZXJwT2Zmc2V0K3RpY2ttaW4sIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBlcnBPZmZzZXQrdGlja21heCwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGlja2NvbG9yICE9PSB1bmRlZmluZWQgJiYgdGlja2NvbG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExhYmVsZXIucmVuZGVyTGFiZWwoY29udGV4dCwgdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBSZW5kZXIgdGhlIHRpdGxlXG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0aGlzLnRpdGxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGl0bGUoKS5yZW5kZXIoY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEF4aXM7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQXhpc1RpdGxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzX3RpdGxlLmpzJyksXG4gICAgICAgIEF4aXMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2F4aXMuanMnKSxcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKEF4aXNUaXRsZS5yZW5kZXIpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBBeGlzVGl0bGU7IH1cblxuICAgIEF4aXNUaXRsZS5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBheGlzICAgICAgICA9IHRoaXMuYXhpcygpLFxuICAgICAgICAgICAgdGl0bGUgICAgICAgPSB0aGlzLmNvbnRlbnQoKSxcbiAgICAgICAgICAgIGFuY2hvciAgICAgID0gdGhpcy5hbmNob3IoKSxcbiAgICAgICAgICAgIHBlcnBPZmZzZXQgID0gYXhpcy5wZXJwT2Zmc2V0KCksXG4gICAgICAgICAgICBoICAgICAgICAgICA9IHRpdGxlLm9yaWdIZWlnaHQoKSxcbiAgICAgICAgICAgIHcgICAgICAgICAgID0gdGl0bGUub3JpZ1dpZHRoKCksXG4gICAgICAgICAgICBwaXhlbEFuY2hvciA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAwLjUgKiB3ICogKGFuY2hvci54KCkgKyAxKSxcbiAgICAgICAgICAgICAgICAwLjUgKiBoICogKGFuY2hvci55KCkgKyAxKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHN0b3JlZEJhc2UgID0gKHRoaXMuYmFzZSgpICsgMSkgKiAoYXhpcy5waXhlbExlbmd0aCgpIC8gMikgKyBheGlzLm1pbm9mZnNldCgpICsgYXhpcy5wYXJhbGxlbE9mZnNldCgpLFxuICAgICAgICAgICAgcGl4ZWxCYXNlO1xuXG4gICAgICAgIGlmIChheGlzLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgcGl4ZWxCYXNlID0gbmV3IFBvaW50KHN0b3JlZEJhc2UsIHBlcnBPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGl4ZWxCYXNlID0gbmV3IFBvaW50KHBlcnBPZmZzZXQsIHN0b3JlZEJhc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDEpXCI7XG4gICAgICAgIHRpdGxlLmZvbnQodGhpcy5mb250KCkpO1xuICAgICAgICB0aXRsZS5kcmF3VGV4dChjb250ZXh0LCBwaXhlbEFuY2hvciwgcGl4ZWxCYXNlLCB0aGlzLnBvc2l0aW9uKCksIHRoaXMuYW5nbGUoKSk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEF4aXNUaXRsZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCYWNrZ3JvdW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9iYWNrZ3JvdW5kLmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKEJhY2tncm91bmQucmVuZGVyKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gQmFja2dyb3VuZDsgfVxuXG4gICAgQmFja2dyb3VuZC5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uIChncmFwaCwgY29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgbWIgPSBncmFwaC53aW5kb3coKS5tYXJnaW4oKS5sZWZ0KCkgKyBncmFwaC53aW5kb3coKS5ib3JkZXIoKSxcbiAgICAgICAgICAgIGltZyA9IHRoaXMuaW1nKCk7XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5jb2xvcigpLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QobWIsIG1iLCB3aWR0aCAtIDIqbWIsIGhlaWdodCAtIDIqbWIpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpbWcgJiYgaW1nLnNyYygpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGltZy5yZW5kZXIoZ3JhcGgsIGNvbnRleHQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQmFja2dyb3VuZDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBHcmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZ3JhcGguanMnKTtcblxuICAgIGlmICh0eXBlb2YoR3JhcGgucmVuZGVyKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gR3JhcGg7IH1cblxuICAgIEdyYXBoLnJlc3BvbmRzVG8oXCJyZW5kZXJcIiwgZnVuY3Rpb24gKGNvbnRleHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgdGhpcy53aW5kb3coKS5yZW5kZXIoY29udGV4dCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kKCkucmVuZGVyKHRoaXMsIGNvbnRleHQsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsMCwwLDEsdGhpcy54MCgpLHRoaXMueTAoKSk7XG5cbiAgICAgICAgdGhpcy5wbG90YXJlYSgpLnJlbmRlcih0aGlzLCBjb250ZXh0KTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5heGVzKCkuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYXhlcygpLmF0KGkpLnJlbmRlckdyaWQodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgdGhpcy5wbG90Qm94KCkud2lkdGgoKSwgdGhpcy5wbG90Qm94KCkuaGVpZ2h0KCkpO1xuICAgICAgICBjb250ZXh0LmNsaXAoKTtcblxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBsb3RzKCkuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucGxvdHMoKS5hdChpKS5yZW5kZXIodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5heGVzKCkuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYXhlcygpLmF0KGkpLnJlbmRlcih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGVnZW5kKCkucmVuZGVyKGNvbnRleHQpO1xuXG4gICAgICAgIGlmICh0aGlzLnRpdGxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGl0bGUoKS5yZW5kZXIoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBHcmFwaDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBUaXRsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdGl0bGUuanMnKSxcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKFRpdGxlLnJlbmRlcik9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIFRpdGxlOyB9XG5cbiAgICBUaXRsZS5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBncmFwaCAgICAgICAgICAgPSB0aGlzLmdyYXBoKCksXG4gICAgICAgICAgICBib3JkZXIgICAgICAgICAgPSB0aGlzLmJvcmRlcigpLFxuICAgICAgICAgICAgcGFkZGluZyAgICAgICAgID0gdGhpcy5wYWRkaW5nKCksXG4gICAgICAgICAgICBzdG9yZWRBbmNob3IgICAgPSB0aGlzLmFuY2hvcigpLFxuICAgICAgICAgICAgc3RvcmVkQmFzZSAgICAgID0gdGhpcy5iYXNlKCksXG4gICAgICAgICAgICBwb3NpdGlvbiAgICAgICAgPSB0aGlzLnBvc2l0aW9uKCksXG4gICAgICAgICAgICB0aXRsZSAgICAgICAgICAgPSB0aGlzLnRleHQoKSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IHRoaXMuY29sb3IoKS50b1JHQkEodGhpcy5vcGFjaXR5KCkpLFxuICAgICAgICAgICAgcGFkZGluZ0JveCAgICAgID0gZ3JhcGgucGFkZGluZ0JveCgpLFxuICAgICAgICAgICAgcGxvdEJveCAgICAgICAgID0gZ3JhcGgucGxvdEJveCgpLFxuICAgICAgICAgICAgcGxvdGFyZWFNYXJnaW4gID0gZ3JhcGgucGxvdGFyZWEoKS5tYXJnaW4oKSxcbiAgICAgICAgICAgIGggPSB0aXRsZS5vcmlnSGVpZ2h0KCksXG4gICAgICAgICAgICB3ID0gdGl0bGUub3JpZ1dpZHRoKCksXG4gICAgICAgICAgICBwaXhlbEFuY2hvciA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAoMC41ICogdyArIHBhZGRpbmcgKyBib3JkZXIpICogKHN0b3JlZEFuY2hvci54KCkgKyAxKSxcbiAgICAgICAgICAgICAgICAoMC41ICogaCArIHBhZGRpbmcgKyBib3JkZXIpICogKHN0b3JlZEFuY2hvci55KCkgKyAxKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHBpeGVsQmFzZTtcblxuICAgICAgICBpZiAodGhpcy5mcmFtZSgpID09PSBcInBhZGRpbmdcIikge1xuICAgICAgICAgICAgcGl4ZWxCYXNlID0gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIChzdG9yZWRCYXNlLngoKSArIDEpICogKHBhZGRpbmdCb3gud2lkdGgoKSAvIDIpICAtIHBsb3RhcmVhTWFyZ2luLmxlZnQoKSxcbiAgICAgICAgICAgICAgICAoc3RvcmVkQmFzZS55KCkgKyAxKSAqIChwYWRkaW5nQm94LmhlaWdodCgpIC8gMikgLSBwbG90YXJlYU1hcmdpbi5ib3R0b20oKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpeGVsQmFzZSA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAoc3RvcmVkQmFzZS54KCkgKyAxKSAqIChwbG90Qm94LndpZHRoKCkgLyAyKSxcbiAgICAgICAgICAgICAgICAoc3RvcmVkQmFzZS55KCkgKyAxKSAqIChwbG90Qm94LmhlaWdodCgpIC8gMilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgdGl0bGUuc2V0VHJhbnNmb3JtKGNvbnRleHQsIHBpeGVsQW5jaG9yLCBwaXhlbEJhc2UsIHBvc2l0aW9uLCAwKTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oMSwgMCwgMCwgLTEsIDAsIDApO1xuXG4gICAgICAgIC8vIGJvcmRlclxuICAgICAgICBpZiAoYm9yZGVyID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyY29sb3IoKS50b1JHQkEoKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KFxuICAgICAgICAgICAgICAgIGJvcmRlciAvIDIsXG4gICAgICAgICAgICAgICAgYm9yZGVyIC8gMixcbiAgICAgICAgICAgICAgICB3ICsgKDIgKiBwYWRkaW5nKSArIGJvcmRlcixcbiAgICAgICAgICAgICAgICBoICsgKDIgKiBwYWRkaW5nKSArIGJvcmRlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2tncm91bmRcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoXG4gICAgICAgICAgICBib3JkZXIsXG4gICAgICAgICAgICBib3JkZXIsXG4gICAgICAgICAgICB3ICsgKDIgKiBwYWRkaW5nKSxcbiAgICAgICAgICAgIGggKyAoMiAqIHBhZGRpbmcpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vIHRleHRcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIHZhciB0ZXh0UG9zaXRpb24gPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICBwb3NpdGlvbi54KCkgKyBib3JkZXIgKyBwYWRkaW5nLFxuICAgICAgICAgICAgcG9zaXRpb24ueSgpICsgYm9yZGVyICsgcGFkZGluZ1xuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LmZvbnQgPSB0aGlzLmZvbnRTaXplKCkgKyBcIiBzYW5zLXNlcmlmXCI7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDEpXCI7XG4gICAgICAgIHRpdGxlLmRyYXdUZXh0KGNvbnRleHQsIHBpeGVsQW5jaG9yLCBwaXhlbEJhc2UsIHRleHRQb3NpdGlvbiwgMCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFRpdGxlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEljb24gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ljb24uanMnKSxcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKEljb24ucmVuZGVyQm9yZGVyKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gSWNvbjsgfVxuXG4gICAgSWNvbi5yZXNwb25kc1RvKFwicmVuZGVyQm9yZGVyXCIsIGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5KSB7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDEpXCI7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCh4LCB5LCB0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gSWNvbjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBJbWcgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ltZy5qcycpLFxuICAgICAgICBVdGlsID0gcmVxdWlyZSgnLi4vLi4vbWF0aC91dGlsLmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKEltZy5yZW5kZXIpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBJbWc7IH1cblxuICAgIEltZy5oYXNBKFwiaW1hZ2VcIikud2hpY2guZGVmYXVsdHNUbyhmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBJbWFnZSgpO30pO1xuICAgIEltZy5oYXNBKFwiZmV0Y2hlZFwiKS53aGljaC5kZWZhdWx0c1RvKGZhbHNlKTtcblxuICAgIEltZy5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uIChncmFwaCwgY29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5mZXRjaGVkKCkpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnAgICAgICA9IFV0aWwuaW50ZXJwLFxuICAgICAgICAgICAgICAgIGltYWdlICAgICAgID0gdGhpcy5pbWFnZSgpLFxuICAgICAgICAgICAgICAgIGdyYXBoV2luZG93ID0gZ3JhcGgud2luZG93KCksXG4gICAgICAgICAgICAgICAgcGxvdGFyZWEgICAgPSBncmFwaC5wbG90YXJlYSgpLFxuICAgICAgICAgICAgICAgIGJhc2UgPSB0aGlzLmJhc2UoKSxcbiAgICAgICAgICAgICAgICBheCA9IGludGVycCh0aGlzLmFuY2hvcigpLngoKSwgLTEsIDEsIDAsIGltYWdlLndpZHRoKSxcbiAgICAgICAgICAgICAgICBheSA9IGludGVycCh0aGlzLmFuY2hvcigpLnkoKSwgMSwgLTEsIDAsIGltYWdlLmhlaWdodCksXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSBncmFwaFdpbmRvdy5tYXJnaW4oKS5sZWZ0KCkgKyBncmFwaFdpbmRvdy5ib3JkZXIoKSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wICA9IGdyYXBoV2luZG93Lm1hcmdpbigpLnRvcCgpICsgZ3JhcGhXaW5kb3cuYm9yZGVyKCksXG4gICAgICAgICAgICAgICAgcGxvdExlZnQgPSBwYWRkaW5nTGVmdCArIGdyYXBoV2luZG93LnBhZGRpbmcoKS5sZWZ0KCkgKyBwbG90YXJlYS5tYXJnaW4oKS5sZWZ0KCkgKyBwbG90YXJlYS5ib3JkZXIoKSxcbiAgICAgICAgICAgICAgICBwbG90VG9wICA9IHBhZGRpbmdUb3AgKyBncmFwaFdpbmRvdy5wYWRkaW5nKCkudG9wKCkgKyBwbG90YXJlYS5tYXJnaW4oKS50b3AoKSArIHBsb3RhcmVhLmJvcmRlcigpLFxuICAgICAgICAgICAgICAgIGJ4LCBieSxcbiAgICAgICAgICAgICAgICB4LCB5O1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWUoKSA9PT0gSW1nLlBMT1QpIHtcbiAgICAgICAgICAgICAgICBieCA9IHBsb3RMZWZ0ICsgaW50ZXJwKGJhc2UueCgpLCAtMSwgMSwgMCwgZ3JhcGgucGxvdEJveCgpLndpZHRoKCkpO1xuICAgICAgICAgICAgICAgIGJ5ID0gcGxvdFRvcCArIGludGVycChiYXNlLnkoKSwgMSwgLTEsIDAsIGdyYXBoLnBsb3RCb3goKS5oZWlnaHQoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ4ID0gcGFkZGluZ0xlZnQgKyBpbnRlcnAoYmFzZS54KCksIC0xLCAxLCAwLCBncmFwaC5wYWRkaW5nQm94KCkud2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgYnkgPSBwYWRkaW5nVG9wICsgaW50ZXJwKGJhc2UueSgpLCAxLCAtMSwgMCwgZ3JhcGgucGFkZGluZ0JveCgpLmhlaWdodCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggPSBieCArIHRoaXMucG9zaXRpb24oKS54KCkgLSBheDtcbiAgICAgICAgICAgIHkgPSBieSArIHRoaXMucG9zaXRpb24oKS55KCkgLSBheTtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oMSwgMCwgMCwgLTEsIDAsIGhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UoKS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5mZXRjaGVkKHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGdyYXBoLnJlbmRlcihjb250ZXh0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmltYWdlKCkuc3JjID0gdGhpcy5zcmMoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEltZztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBMYWJlbGVyID0gcmVxdWlyZSgnLi4vLi4vY29yZS9sYWJlbGVyLmpzJyksXG4gICAgICAgIFRleHQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RleHQuanMnKSxcbiAgICAgICAgQXhpcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpcy5qcycpLFxuICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKTtcblxuICAgIGlmICh0eXBlb2YoTGFiZWxlci5yZW5kZXJMYWJlbCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIExhYmVsZXI7IH1cblxuICAgIExhYmVsZXIucmVzcG9uZHNUbyhcIm1lYXN1cmVTdHJpbmdXaWR0aFwiLCBmdW5jdGlvbiAoY29udGV4dCwgc3RyaW5nKSB7XG4gICAgICAgIHZhciB0ID0gbmV3IFRleHQoc3RyaW5nKTtcbiAgICAgICAgdC5mb250KHRoaXMuZm9udCgpKTtcbiAgICAgICAgcmV0dXJuIHQuaW5pdGlhbGl6ZUdlb21ldHJ5KHtcbiAgICAgICAgICAgIFwiY29udGV4dFwiIDogY29udGV4dCxcbiAgICAgICAgICAgIFwiYW5nbGVcIiAgIDogdGhpcy5hbmdsZSgpXG4gICAgICAgIH0pLnJvdGF0ZWRXaWR0aCgpO1xuICAgIH0pO1xuXG4gICAgTGFiZWxlci5yZXNwb25kc1RvKFwibWVhc3VyZVN0cmluZ0hlaWdodFwiLCBmdW5jdGlvbiAoY29udGV4dCwgc3RyaW5nKSB7XG4gICAgICAgIHZhciB0ID0gbmV3IFRleHQoc3RyaW5nKTtcbiAgICAgICAgdC5mb250KHRoaXMuZm9udCgpKTtcbiAgICAgICAgcmV0dXJuIHQuaW5pdGlhbGl6ZUdlb21ldHJ5KHtcbiAgICAgICAgICAgIFwiY29udGV4dFwiIDogY29udGV4dCxcbiAgICAgICAgICAgIFwiYW5nbGVcIiAgIDogdGhpcy5hbmdsZSgpXG4gICAgICAgIH0pLnJvdGF0ZWRIZWlnaHQoKTtcbiAgICB9KTtcblxuICAgIExhYmVsZXIucmVzcG9uZHNUbyhcInJlbmRlckxhYmVsXCIsIGZ1bmN0aW9uIChjb250ZXh0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgYXhpcyAgICAgICAgICAgID0gdGhpcy5heGlzKCksXG4gICAgICAgICAgICBzdG9yZWRBbmNob3IgICAgPSB0aGlzLmFuY2hvcigpLFxuICAgICAgICAgICAgYW5nbGUgICAgICAgICAgID0gdGhpcy5hbmdsZSgpLFxuICAgICAgICAgICAgcGVycE9mZnNldCAgICAgID0gYXhpcy5wZXJwT2Zmc2V0KCksXG4gICAgICAgICAgICBhICAgICAgICAgICAgICAgPSBheGlzLmRhdGFWYWx1ZVRvQXhpc1ZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IG5ldyBUZXh0KHRoaXMuZm9ybWF0dGVyKCkuZm9ybWF0KHZhbHVlKSksXG4gICAgICAgICAgICBwaXhlbEFuY2hvcixcbiAgICAgICAgICAgIGJhc2U7XG5cbiAgICAgICAgZm9ybWF0dGVkU3RyaW5nLmZvbnQodGhpcy5mb250KCkpO1xuICAgICAgICBmb3JtYXR0ZWRTdHJpbmcuaW5pdGlhbGl6ZUdlb21ldHJ5KHtcbiAgICAgICAgICAgIFwiY29udGV4dFwiIDogY29udGV4dCxcbiAgICAgICAgICAgIFwiYW5nbGVcIiAgIDogYW5nbGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGl4ZWxBbmNob3IgPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAwLjUgKiBmb3JtYXR0ZWRTdHJpbmcub3JpZ1dpZHRoKCkgKiAoc3RvcmVkQW5jaG9yLngoKSArIDEpLFxuICAgICAgICAgICAgMC41ICogZm9ybWF0dGVkU3RyaW5nLm9yaWdIZWlnaHQoKSAqIChzdG9yZWRBbmNob3IueSgpICsgMSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoYXhpcy5vcmllbnRhdGlvbigpID09PSBBeGlzLkhPUklaT05UQUwpIHtcbiAgICAgICAgICAgIGJhc2UgPSBuZXcgUG9pbnQoYSwgcGVycE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlID0gbmV3IFBvaW50KHBlcnBPZmZzZXQsIGEpO1xuICAgICAgICB9XG5cblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yKCkuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgZm9ybWF0dGVkU3RyaW5nLmRyYXdUZXh0KGNvbnRleHQsIHBpeGVsQW5jaG9yLCBiYXNlLCB0aGlzLnBvc2l0aW9uKCksIGFuZ2xlKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gTGFiZWxlcjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBMZWdlbmQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2xlZ2VuZC5qcycpLFxuICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKTtcblxuICAgIGlmICh0eXBlb2YoTGVnZW5kLnJlbmRlckxlZ2VuZCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIExlZ2VuZDsgfVxuXG4gICAgTGVnZW5kLnJlc3BvbmRzVG8oXCJiZWdpblwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgdGhpcy54KCksIHRoaXMueSgpKTtcbiAgICB9KTtcblxuICAgIExlZ2VuZC5yZXNwb25kc1RvKFwiZW5kXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgTGVnZW5kLnJlc3BvbmRzVG8oXCJyZW5kZXJMZWdlbmRcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGJvcmRlciA9IHRoaXMuYm9yZGVyKCk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBpZiAoYm9yZGVyID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyY29sb3IoKS50b1JHQkEoKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChib3JkZXIvMiwgYm9yZGVyLzIsIHRoaXMud2lkdGgoKSAtIGJvcmRlci8yLCB0aGlzLmhlaWdodCgpIC0gYm9yZGVyLzIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yKCkudG9SR0JBKHRoaXMub3BhY2l0eSgpKTtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdChib3JkZXIsIGJvcmRlciwgdGhpcy53aWR0aCgpIC0gKDIgKiBib3JkZXIpLCB0aGlzLmhlaWdodCgpIC0gKDIgKiBib3JkZXIpKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBMZWdlbmQucmVzcG9uZHNUbyhcInJlbmRlckxhYmVsXCIsIGZ1bmN0aW9uIChsYWJlbCwgY29udGV4dCwgeCwgeSkge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMSlcIjtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oMSwgMCwgMCwgLTEsIDAsIHkgKyB0aGlzLm1heExhYmVsSGVpZ2h0KCkvMiAtIGxhYmVsLm9yaWdIZWlnaHQoKS8yKTtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChsYWJlbC5zdHJpbmcoKSwgeCwgMCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIExlZ2VuZDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQsIHdpbmRvdykge1xuICAgIHZhciBNdWx0aWdyYXBoID0gcmVxdWlyZSgnLi4vLi4vY29yZS9tdWx0aWdyYXBoLmpzJykoJCksXG4gICAgICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpLFxuICAgICAgICB2RiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpO1xuXG4gICAgaWYgKHR5cGVvZihNdWx0aWdyYXBoLnJlbmRlcik9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIE11bHRpZ3JhcGg7IH1cblxuICAgIE11bHRpZ3JhcGguaGFzQShcImNhbnZhc1wiKTsgIC8vIGNhbnZhcyBvYmplY3QgaXRzZWxmICh0aGUgJzxjYW52YXM+JyB0YWcgaXRzZWxmKVxuICAgIE11bHRpZ3JhcGguaGFzQShcImNvbnRleHRcIik7IC8vIGNhbnZhcyBjb250ZXh0IG9iamVjdFxuICAgIE11bHRpZ3JhcGguaGFzQShcIndpZHRoXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICBNdWx0aWdyYXBoLmhhc0EoXCJoZWlnaHRcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuXG4gICAgTXVsdGlncmFwaC5yZXNwb25kc1RvKFwicmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQucmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTXVsdGlncmFwaC5yZXNwb25kc1RvKFwicG9wb3V0XCIsIGZ1bmN0aW9uIChwb3BkaXYpIHtcbiAgICAgICAgLy8gUG9wb3V0IHRha2VzIGEgc2luZ2xlIGFyZyB3aGljaCBpcyBhIGpRdWVyeSBzZWxlY3RvciwgYW5kIHRlbXBvcmFyaWx5IG1vdmVzIHRoZVxuICAgICAgICAvLyBtdWx0aWdyYXBoIHRvIHRoYXQgZWxlbWVudC4gIEl0IHR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHRvIHBvcCB0aGVcbiAgICAgICAgLy8gZ3JhcGggYmFjayBcImluXCIgdG8gaXRzIG9yaWdpbmFsIHBsYWNlLiAgTm90ZSB0aGF0IHRoZSBvcmlnaW5hbCBjYW52YXMgaXMgYWN0dWFsbHlcbiAgICAgICAgLy8gbm90IHJlbW92ZWQgLS0gdGhlIHBvcG91dCBmdW5jdGlvbiBqdXN0IGFkZHMgYSBuZXcgY2FudmFzIHRvIHRoZSBwb3BvdXQgZGlmZiBhbmRcbiAgICAgICAgLy8gc3dpdGhjZXMgdGhlIG11bHRpZ3JhcGggdG8gcmVuZGVyIGluIHRoYXQgY2FudmFzLiAgVGhlIHJldHVybmVkIHBvcGluIGZ1bmN0aW9uXG4gICAgICAgIC8vIHJlbW92ZXMgdGhlIG5ldyBjYW52YXMgZnJvbSB0aGUgcG9wb3V0IGRpdiwgYW5kIHN3aXRjaGVzIHRoZSBtdWx0aWdyYXBoIGJhY2tcbiAgICAgICAgLy8gdG8gaXRzIG9yaWdpbmFsIGNhbnZhcy5cbiAgICAgICAgdmFyIG9yaWdEaXYgPSB0aGlzLmRpdigpO1xuICAgICAgICAkKHBvcGRpdikuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5kaXYoJCgnPGRpdiBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XCI+PC9kaXY+JykuYXBwZW5kVG8oJChwb3BkaXYpKSk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnRzKCk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGF0LmRpdigpKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoYXQuZGl2KG9yaWdEaXYpO1xuICAgICAgICAgICAgdGhhdC53aWR0aCgkKHRoYXQuZGl2KCkpLndpZHRoKCkpO1xuICAgICAgICAgICAgdGhhdC5oZWlnaHQoJCh0aGF0LmRpdigpKS5oZWlnaHQoKSk7XG4gICAgICAgICAgICB0aGF0LmluaXRpYWxpemVTdXJmYWNlKCk7XG4gICAgICAgICAgICB0aGF0LnJlbmRlcigpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgTXVsdGlncmFwaC5yZXNwb25kc1RvKFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW5ldmVyIHRoZSBtdWx0aWdyYXBoJ3MgY29udGFpbmluZyBkaXYgaGFzIGNoYW5nZWQgc2l6ZTtcbiAgICAgICAgLy8gdGhpcyBjYXVzZXMgdGhlIG11bHRpZ3JhcGggdG8gYWRqdXN0IHRvIG1hdGNoIHRoZSBuZXcgc2l6ZSwgYW5kIHRvIHJlLXJlbmRlclxuICAgICAgICAvLyBvbmNlIGF0IHRoYXQgc2l6ZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBjb250YWluaW5nIGFwcGxpY2F0aW9uIGhhcyB0byBjYWxsIHRoaXMgdG8gdGVsbCBtdWx0aWdyYXBoXG4gICAgICAgIC8vIHRoYXQgdGhlIGRpdiBoYXMgY2hhbmdlZCBzaXplIC0tIG11bHRpZ3JhcGggZG9lcyBub3QgYXR0ZW1wdCB0byBtb25pdG9yXG4gICAgICAgIC8vIGFuZCByZXNwb25kIHRvIHNpemUgY2hhbmdlcyBpdHNlbGYuXG4gICAgICAgIHZhciAkZGl2ID0gJCh0aGlzLmRpdigpKTtcbiAgICAgICAgdGhpcy53aWR0aCgkZGl2LndpZHRoKCkpO1xuICAgICAgICB0aGlzLmhlaWdodCgkZGl2LmhlaWdodCgpKTtcbiAgICAgICAgdGhpcy5yZXNpemVTdXJmYWNlKHRoaXMud2lkdGgoKSp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgdGhpcy5oZWlnaHQoKSp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgICRkaXYuZmluZChcImNhbnZhc1wiKS5jc3Moe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgoKSArIFwicHhcIixcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQoKSArIFwicHhcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9KTtcblxuICAgIE11bHRpZ3JhcGgucmVzcG9uZHNUbyhcImluaXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGRpdiA9ICQodGhpcy5kaXYoKSk7XG4gICAgICAgIHRoaXMud2lkdGgoJGRpdi53aWR0aCgpKTtcbiAgICAgICAgdGhpcy5oZWlnaHQoJGRpdi5oZWlnaHQoKSk7XG4gICAgICAgIGlmICh0aGlzLndpZHRoKCkgPiAwICYmIHRoaXMuaGVpZ2h0KCkgPiAwKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGNhbnZhc1xuICAgICAgICAgICAgJChcIjxjYW52YXMgd2lkdGg9XFxcIlwiK3RoaXMud2lkdGgoKSp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbytcIlxcXCIgaGVpZ2h0PVxcXCJcIit0aGlzLmhlaWdodCgpKndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvK1wiXFxcIiBzdHlsZT1cXFwid2lkdGg6XCIrdGhpcy53aWR0aCgpK1wicHg7IGhlaWdodDpcIit0aGlzLmhlaWdodCgpK1wicHg7XFxcIi8+XCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKCRkaXYpO1xuXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVTdXJmYWNlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYnVzeVNwaW5uZXIoJCgnPGRpdiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7bWFyZ2luLXRvcDotMTZweDttYXJnaW4tbGVmdDotMTZweFwiPjwvZGl2PicpIC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kVG8oJGRpdikgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXN5X3NwaW5uZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9KTtcblxuICAgIE11bHRpZ3JhcGgucmVzcG9uZHNUbyhcInJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0KCksXG4gICAgICAgICAgICB3aWR0aCAgID0gdGhpcy53aWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0ICA9IHRoaXMuaGVpZ2h0KCksXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjb250ZXh0LnNjYWxlKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplR2VvbWV0cnkod2lkdGgsIGhlaWdodCwge1wiY29udGV4dFwiIDogY29udGV4dH0pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5ncmFwaHMoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5ncmFwaHMoKS5hdChpKS5yZW5kZXIoY29udGV4dCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE11bHRpZ3JhcGgucmVzcG9uZHNUbyhcInJlZ2lzdGVyRXZlbnRzXCIsIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcygpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTW91c2VFdmVudHMoY2FudmFzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLm5vc2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyVG91Y2hFdmVudHMoY2FudmFzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMucmVnaXN0ZXJSZXNpemVFdmVudHMoY2FudmFzKTtcbiAgICB9KTtcblxuICAgIE11bHRpZ3JhcGgucmVzcG9uZHNUbyhcInJlc2l6ZVN1cmZhY2VcIiwgZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY29udGV4dCgpLmNhbnZhcztcbiAgICAgICAgY2FudmFzLndpZHRoICA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0pO1xuXG4gICAgTXVsdGlncmFwaC5yZXNwb25kc1RvKFwiaW5pdGlhbGl6ZVN1cmZhY2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbnZhcygkKHRoaXMuZGl2KCkpLmNoaWxkcmVuKFwiY2FudmFzXCIpWzBdKTtcbiAgICAgICAgdGhpcy5jb250ZXh0KHRoaXMuY2FudmFzKCkuZ2V0Q29udGV4dChcIjJkXCIpKTtcbiAgICB9KTtcblxuICAgIC8vICAgIHZhciBhcHBseU1peGlucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBvcHRpb25zLm1lc3NhZ2VIYW5kbGVyLmVycm9yO1xuICAgIC8vICAgICAgICB3aW5kb3cubXVsdGlncmFwaC5wYXJzZXIubWl4aW4uYXBwbHkod2luZG93Lm11bHRpZ3JhcGgsIFwicGFyc2VYTUxcIik7XG4gICAgLy8gICAgICAgIG5zLm1peGluLmFwcGx5KHdpbmRvdy5tdWx0aWdyYXBoLmNvcmUpO1xuICAgIC8vICAgICAgICB3aW5kb3cubXVsdGlncmFwaC5ldmVudHMuZHJhZ2dhYmxlLm1peGluLmFwcGx5KHdpbmRvdy5tdWx0aWdyYXBoLCBlcnJvckhhbmRsZXIpO1xuICAgIC8vICAgICAgICB3aW5kb3cubXVsdGlncmFwaC5ldmVudHMubW91c2UubWl4aW4uYXBwbHkod2luZG93Lm11bHRpZ3JhcGgsIGVycm9ySGFuZGxlcik7XG4gICAgLy8gICAgICAgIHdpbmRvdy5tdWx0aWdyYXBoLmV2ZW50cy50b3VjaC5taXhpbi5hcHBseSh3aW5kb3cubXVsdGlncmFwaCwgZXJyb3JIYW5kbGVyKTtcbiAgICAvLyAgICAgICAgd2luZG93Lm11bHRpZ3JhcGgubm9ybWFsaXplci5taXhpbi5hcHBseSh3aW5kb3cubXVsdGlncmFwaC5jb3JlKTtcbiAgICAvLyAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRydWUgaWZmIHRoZSBzdHJpbmcgYHNgIGxvb2tzIGxpa2UgYSBqc29uIG9iamVjdC5cbiAgICAvLyBUaGlzIHNpbXBseSBjaGVja3MgdG8gc2VlIGlmIHRoZSBmaXJzdCBub24td2hpdGVzcGFjZSBjaGFyIGlzIGEgJ3snIG9yICdbJy5cbiAgICBmdW5jdGlvbiBsb29rc19saWtlX2pzb24ocykge1xuICAgICAgICByZXR1cm4gL15cXHMqW3tcXFtdLy50ZXN0KHMpO1xuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZUluaXRpYWxHcmFwaCA9IGZ1bmN0aW9uIChtdWdsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBKUXVlcnlYTUxQYXJzZXIgPSByZXF1aXJlKCcuLi8uLi9wYXJzZXIveG1sL2pxdWVyeV94bWxfcGFyc2VyLmpzJykoJCk7XG4gICAgICAgIHJlcXVpcmUoJy4uLy4uL3BhcnNlci9qc29uL2pzb25fcGFyc2VyLmpzJykoJCk7XG4gICAgICAgIHZhciBtdWx0aWdyYXBoO1xuICAgICAgICBpZiAodkYudHlwZU9mKG11Z2wpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGxvb2tzX2xpa2VfanNvbihtdWdsKSkge1xuICAgICAgICAgICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTM1NjMyL3BhcnNlLWpzb24taW4tamF2YXNjcmlwdFxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBKU09OICYmIEpTT04ucGFyc2UobXVnbCkgfHwgJC5wYXJzZUpTT04obXVnbCk7XG4gICAgICAgICAgICAgICAgbXVsdGlncmFwaCA9IE11bHRpZ3JhcGgucGFyc2VKU09OKCBvYmosIG9wdGlvbnMubXVnbCwgb3B0aW9ucy5tZXNzYWdlSGFuZGxlciApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgeG1sT2JqID0gSlF1ZXJ5WE1MUGFyc2VyLnN0cmluZ1RvSlF1ZXJ5WE1MT2JqKG11Z2wpO1xuICAgICAgICAgICAgICAgIG11bHRpZ3JhcGggPSBNdWx0aWdyYXBoLnBhcnNlWE1MKCB4bWxPYmosIG9wdGlvbnMubXVnbCwgb3B0aW9ucy5tZXNzYWdlSGFuZGxlciApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdGlncmFwaCA9IE11bHRpZ3JhcGgucGFyc2VKU09OKCBtdWdsLCBvcHRpb25zLm11Z2wsIG9wdGlvbnMubWVzc2FnZUhhbmRsZXIgKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbXVsdGlncmFwaC5ub3JtYWxpemUoKTtcbiAgICAgICAgbXVsdGlncmFwaC5kaXYob3B0aW9ucy5kaXYpO1xuICAgICAgICAkKG9wdGlvbnMuZGl2KS5jc3MoXCJjdXJzb3JcIiAsIFwicG9pbnRlclwiKTtcbiAgICAgICAgbXVsdGlncmFwaC5pbml0KCk7XG4gICAgICAgIG11bHRpZ3JhcGgucmVnaXN0ZXJFdmVudHMob3B0aW9ucyk7XG4gICAgICAgIG11bHRpZ3JhcGgucmVnaXN0ZXJDb21tb25EYXRhQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBtdWx0aWdyYXBoLnJlZHJhdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG11bHRpZ3JhcGg7XG4gICAgfTtcblxuICAgIE11bHRpZ3JhcGguY3JlYXRlQ2FudmFzR3JhcGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgbXVnbFByb21pc2UsXG4gICAgICAgICAgICBkZWZlcnJlZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9hcHBseU1peGlucyhvcHRpb25zKTtcbiAgICAgICAgICAgIHJlcXVpcmUoJy4uLy4uL2V2ZW50cy9hbGwuanMnKSgkLCB3aW5kb3csIG9wdGlvbnMubWVzc2FnZUhhbmRsZXIuZXJyb3IpO1xuICAgICAgICAgICAgbXVnbFByb21pc2UgPSAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIFwidXJsXCIgICAgICA6IG9wdGlvbnMubXVnbCxcbiAgICAgICAgICAgICAgICBcImRhdGFUeXBlXCIgOiBcInRleHRcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4vL2NvbnNvbGUubG9nKCdhdCBjIDEnKTtcbnRocm93IGU7XG4vLyAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZUhhbmRsZXIuZXJyb3IoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBtdWdsUHJvbWlzZS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRpdiBzaXplIElTIGF2YWlsYWJsZSBoZXJlOyBzZWUgYmVsb3cuICBXaGF0J3MgZ29pbmcgb24/Pz8hISFcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlncmFwaCA9IGdlbmVyYXRlSW5pdGlhbEdyYXBoKGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobXVsdGlncmFwaCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4vL2NvbnNvbGUubG9nKCdhdCBjIDInKTtcbnRocm93IGU7XG4vLyAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2VIYW5kbGVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgIH07XG5cbiAgICBNdWx0aWdyYXBoLmNyZWF0ZUNhbnZhc0dyYXBoRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9hcHBseU1peGlucyhvcHRpb25zKTtcbiAgICAgICAgICAgIHJlcXVpcmUoJy4uLy4uL2V2ZW50cy9hbGwuanMnKSgkLCB3aW5kb3csIG9wdGlvbnMubWVzc2FnZUhhbmRsZXIuZXJyb3IpO1xuICAgICAgICAgICAgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBmaWd1cmUgdGhpcyBvdXQhICBkaXYgc2l6ZSBpcyBub3QgYXZhaWxhYmxlIGhlcmU/ICBBcHBhcmVudGx5LCBhdCB0aGlzIHBvaW50IGluXG4gICAgICAgICAgICAvLyBjb2RlIGV4ZWN1dGlvbiwgdGhlIGJyb3dzZXIgaGFzbid0IGxhaWQgdGhpbmdzIG91dCBlbm91Z2ggZm9yIHRoZSBkaXYgdG8gaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBhc3NpZ25lZCBhIHNpemUsIGF0IGxlYXN0IHNvbWV0aW1lcz8/PyAgQnV0IGl0IElTIGF2YWlsYWJsZSBhdCB0aGUgY29ycmVzcG9uZGluZyBwbGFjZSBpblxuICAgICAgICAgICAgLy8gY3JlYXRlQ2FudmFzR3JhcGggYWJvdmU/ICBUaGlzIGlzIHdvcmtlZCBhcm91bmQgYnkgdGhlIGNvZGUgaW5cbiAgICAgICAgICAgIC8vIHNyYy9jb3JlL211bHRpZ3JhcGguanM6Y3JlYXRlR3JhcGgoKSB0aGF0IGZvcmNlcyB0aGUgZGl2IHRvIGhhdmUgdGhlIHNpemUgc3BlY2lmaWVkIGluXG4gICAgICAgICAgICAvLyB0aGUgb3B0aW9ucyAtLS0gc28gd2UgY2FuIHdvcmsgYXJvdW5kIHRoZSBwcm9ibGVtIGJ5IHBhc3NpbmcgYW4gZXhwbGljaXQgc2l6ZSBpbiB0aGVcbiAgICAgICAgICAgIC8vIG9wdGlvbnMuICBCdXQgd2UgbmVlZCB0byByZWFsbHkgZmlndXJlIG91dCB3aGF0J3MgZ29pbmcgb24gYW5kIHJlc29sdmUgaXQuXG4gICAgICAgICAgICB2YXIgbXVsdGlncmFwaCA9IGdlbmVyYXRlSW5pdGlhbEdyYXBoKG9wdGlvbnMubXVnbFN0cmluZywgb3B0aW9ucyk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG11bHRpZ3JhcGgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4vL2NvbnNvbGUubG9nKCdhdCBjIDMnKTtcbnRocm93IGU7XG4vLyAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZUhhbmRsZXIuZXJyb3IoZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTXVsdGlncmFwaDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBQbG90YXJlYSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGxvdGFyZWEuanMnKTtcblxuICAgIGlmICh0eXBlb2YoUGxvdGFyZWEucmVuZGVyKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gUGxvdGFyZWE7IH1cblxuICAgIFBsb3RhcmVhLnJlc3BvbmRzVG8oXCJyZW5kZXJcIiwgZnVuY3Rpb24gKGdyYXBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBwbG90Qm94ID0gZ3JhcGgucGxvdEJveCgpLFxuICAgICAgICAgICAgYm9yZGVyID0gdGhpcy5ib3JkZXIoKTtcblxuICAgICAgICBpZiAodGhpcy5jb2xvcigpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5jb2xvcigpLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHBsb3RCb3gud2lkdGgoKSwgcGxvdEJveC5oZWlnaHQoKSk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib3JkZXIgPiAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyY29sb3IoKS5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KC1ib3JkZXIvMiwgLWJvcmRlci8yLCBwbG90Qm94LndpZHRoKCkgKyBib3JkZXIsIHBsb3RCb3guaGVpZ2h0KCkgKyBib3JkZXIpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBQbG90YXJlYTtcbn07XG4iLCJ2YXIgX0lOQ0xVREVEID0gZmFsc2U7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCYW5kUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9jb3JlL3JlbmRlcmVycy9iYW5kX3JlbmRlcmVyLmpzJyk7XG5cbiAgICBpZiAoX0lOQ0xVREVEKSB7IHJldHVybiBCYW5kUmVuZGVyZXI7IH1cbiAgICBfSU5DTFVERUQgPSB0cnVlO1xuXG4gICAgLy8gY2FjaGVkIHN0YXRlIG9iamVjdCwgZm9yIHF1aWNrIGFjY2VzcyBkdXJpbmcgcmVuZGVyaW5nLCBwb3B1bGF0ZWQgaW4gYmVnaW4oKSBtZXRob2Q6XG4gICAgQmFuZFJlbmRlcmVyLmhhc0EoXCJzdGF0ZVwiKTtcblxuICAgIEJhbmRSZW5kZXJlci5yZXNwb25kc1RvKFwiYmVnaW5cIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgXCJjb250ZXh0XCIgICAgICAgICAgICA6IGNvbnRleHQsXG4gICAgICAgICAgICBcInJ1blwiICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBcImxpbmVjb2xvclwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmVjb2xvclwiKSxcbiAgICAgICAgICAgIFwibGluZTFjb2xvclwiICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwibGluZTFjb2xvclwiKSxcbiAgICAgICAgICAgIFwibGluZTJjb2xvclwiICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwibGluZTJjb2xvclwiKSxcbiAgICAgICAgICAgIFwibGluZXdpZHRoXCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwibGluZXdpZHRoXCIpLFxuICAgICAgICAgICAgXCJsaW5lMXdpZHRoXCIgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJsaW5lMXdpZHRoXCIpLFxuICAgICAgICAgICAgXCJsaW5lMndpZHRoXCIgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJsaW5lMndpZHRoXCIpLFxuICAgICAgICAgICAgXCJmaWxsY29sb3JcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJmaWxsY29sb3JcIiksXG4gICAgICAgICAgICBcImZpbGxvcGFjaXR5XCIgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImZpbGxvcGFjaXR5XCIpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdGUoc3RhdGUpO1xuICAgIH0pO1xuXG4gICAgLy8gVGhpcyByZW5kZXJlcidzIGRhdGFQb2ludCgpIG1ldGhvZCB3b3JrcyBieSBhY2N1bXVsYXRpbmdcbiAgICAvLyBhbmQgZHJhd2luZyBvbmUgXCJydW5cIiBvZiBkYXRhIHBvaW50cyBhdCBhIHRpbWUuICBBIFwicnVuXCIgb2ZcbiAgICAvLyBwb2ludHMgY29uc2lzdHMgb2YgYSBjb25zZWN1dGl2ZSBzZXF1ZW5jZSBvZiBub24tbWlzc2luZ1xuICAgIC8vIGRhdGEgcG9pbnRzIHdoaWNoIGhhdmUgdGhlIHNhbWUgZmlsbCBjb2xvci4gIChUaGUgZmlsbFxuICAgIC8vIGNvbG9yIGNhbiBjaGFuZ2UgaWYgdGhlIGRhdGEgbGluZSBjcm9zc2VzIHRoZSBmaWxsIGJhc2VcbiAgICAvLyBsaW5lLCBpZiB0aGUgZG93bmZpbGxjb2xvciBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAvLyBmaWxsY29sb3IuKVxuICAgIEJhbmRSZW5kZXJlci5yZXNwb25kc1RvKFwiZGF0YVBvaW50XCIsIGZ1bmN0aW9uIChkYXRhcCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNNaXNzaW5nKGRhdGFwKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIG1pc3NpbmcgcG9pbnQsIHJlbmRlciBhbmQgcmVzZXQgdGhlIGN1cnJlbnQgcnVuLCBpZiBhbnlcbiAgICAgICAgICAgIGlmIChzdGF0ZS5ydW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUnVuKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUucnVuID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHRyYW5zZm9ybSBwb2ludCB0byBwaXhlbCBjb29yZHNcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy50cmFuc2Zvcm1Qb2ludChkYXRhcCk7XG4gICAgICAgICAgICAvLyBhbmQgYWRkIGl0IHRvIHRoZSBjdXJyZW50IHJ1blxuICAgICAgICAgICAgc3RhdGUucnVuLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIEJhbmRSZW5kZXJlci5yZXNwb25kc1RvKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZSgpO1xuICAgICAgICAvLyByZW5kZXIgdGhlIGN1cnJlbnQgcnVuLCBpZiBhbnlcbiAgICAgICAgaWYgKHN0YXRlLnJ1bi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bigpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAqIFByaXZhdGUgdXRpbGl0eSBmdW5jdGlvbiB0byBzdHJva2UgbGluZSBzZWdtZW50cyBjb25uZWN0aW5nIHRoZSBwb2ludHMgb2YgYSBydW5cbiAgICAgKi9cbiAgICB2YXIgc3Ryb2tlUnVuTGluZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHJ1biwgd2hpY2hMaW5lLCBjb2xvciwgZGVmYXVsdENvbG9yLCB3aWR0aCwgZGVmYXVsdFdpZHRoKSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIHdpZHRoID0gKHdpZHRoID49IDApID8gd2lkdGggOiBkZWZhdWx0V2lkdGg7XG4gICAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbG9yID0gKGNvbG9yICE9PSBudWxsKSA/IGNvbG9yIDogZGVmYXVsdENvbG9yO1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocnVuWzBdWzBdLCBydW5bMF1bd2hpY2hMaW5lXSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcnVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnVuW2ldWzBdLCBydW5baV1bd2hpY2hMaW5lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUmVuZGVyIHRoZSBjdXJyZW50IHJ1biBvZiBkYXRhIHBvaW50cy4gIFRoaXMgY29uc2lzdHMgb2YgZHJhd2luZyB0aGUgZmlsbCByZWdpb25cbiAgICAvLyBpbiB0aGUgYmFuZCBiZXR3ZWVuIHRoZSB0d28gZGF0YSBsaW5lcywgYW5kIGNvbm5lY3RpbmcgdGhlIHBvaW50cyBvZiBlYWNoIGRhdGEgbGluZVxuICAgIC8vIHdpdGggbGluZXMgb2YgdGhlIGFwcHJvcHJpYXRlIGNvbG9yLlxuICAgIEJhbmRSZW5kZXJlci5yZXNwb25kc1RvKFwicmVuZGVyUnVuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlICAgPSB0aGlzLnN0YXRlKCksXG4gICAgICAgICAgICBjb250ZXh0ID0gc3RhdGUuY29udGV4dCxcbiAgICAgICAgICAgIHJ1biAgICAgPSBzdGF0ZS5ydW4sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGZpbGwgdGhlIHJ1blxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHN0YXRlLmZpbGxvcGFjaXR5O1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0YXRlLmZpbGxjb2xvci5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAvLyB0cmFjZSB0byB0aGUgcmlnaHQgYWxvbmcgbGluZSAxXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHJ1blswXVswXSwgcnVuWzBdWzFdKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJ1bi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnVuW2ldWzBdLCBydW5baV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYWNlIGJhY2sgdG8gdGhlIGxlZnQgYWxvbmcgbGluZSAyXG4gICAgICAgIGNvbnRleHQubGluZVRvKHJ1bltydW4ubGVuZ3RoLTFdWzBdLCBydW5bcnVuLmxlbmd0aC0xXVsyXSk7XG4gICAgICAgIGZvciAoaSA9IHJ1bi5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ1bltpXVswXSwgcnVuW2ldWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgLy8gc3Ryb2tlIGxpbmUxXG4gICAgICAgIHN0cm9rZVJ1bkxpbmUoY29udGV4dCwgcnVuLCAxLCBzdGF0ZS5saW5lMWNvbG9yLCBzdGF0ZS5saW5lY29sb3IsIHN0YXRlLmxpbmUxd2lkdGgsIHN0YXRlLmxpbmV3aWR0aCk7XG5cbiAgICAgICAgLy8gc3Ryb2tlIGxpbmUyXG4gICAgICAgIHN0cm9rZVJ1bkxpbmUoY29udGV4dCwgcnVuLCAyLCBzdGF0ZS5saW5lMmNvbG9yLCBzdGF0ZS5saW5lY29sb3IsIHN0YXRlLmxpbmUyd2lkdGgsIHN0YXRlLmxpbmV3aWR0aCk7XG4gICAgfSk7XG5cbiAgICBCYW5kUmVuZGVyZXIucmVzcG9uZHNUbyhcInJlbmRlckxlZ2VuZEljb25cIiwgZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIGljb24pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZSgpLFxuICAgICAgICAgICAgaWNvbldpZHRoICA9IGljb24ud2lkdGgoKSxcbiAgICAgICAgICAgIGljb25IZWlnaHQgPSBpY29uLmhlaWdodCgpO1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybSgxLCAwLCAwLCAxLCB4LCB5KTtcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgLy8gRHJhdyBpY29uIGJhY2tncm91bmQgKHdpdGggb3BhY2l0eSlcbiAgICAgICAgaWYgKGljb25XaWR0aCA8IDEwIHx8IGljb25IZWlnaHQgPCAxMCkge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzdGF0ZS5maWxsY29sb3IudG9SR0JBKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI0ZGRkZGRlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgaWNvbldpZHRoLCBpY29uSGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgLy8gRHJhdyBpY29uIGdyYXBoaWNzXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAoc3RhdGUubGluZTJjb2xvciAhPT0gbnVsbCkgPyBzdGF0ZS5saW5lMmNvbG9yIDogc3RhdGUubGluZWNvbG9yO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCAgID0gKHN0YXRlLmxpbmUyd2lkdGggPj0gMCkgPyBzdGF0ZS5saW5lMndpZHRoIDogc3RhdGUubGluZXdpZHRoO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSAgID0gc3RhdGUuZmlsbGNvbG9yLnRvUkdCQShzdGF0ZS5maWxsb3BhY2l0eSk7XG5cbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAgICAgICAgIDIqaWNvbkhlaWdodC84KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oMCwgICAgICAgICA2Kmljb25IZWlnaHQvOCk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGljb25XaWR0aCwgNyppY29uSGVpZ2h0LzgpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhpY29uV2lkdGgsIDMqaWNvbkhlaWdodC84KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oMCwgICAgICAgICAyKmljb25IZWlnaHQvOCk7XG4gICAgICAgIFxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBCYW5kUmVuZGVyZXI7XG59O1xuIiwidmFyIF9JTkNMVURFRCA9IGZhbHNlO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQmFyUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9jb3JlL3JlbmRlcmVycy9iYXJfcmVuZGVyZXIuanMnKTtcblxuICAgIGlmIChfSU5DTFVERUQpIHsgcmV0dXJuIEJhclJlbmRlcmVyOyB9XG4gICAgX0lOQ0xVREVEID0gdHJ1ZTtcblxuICAgIC8vIGNhY2hlZCBzZXR0aW5ncyBvYmplY3QsIGZvciBxdWljayBhY2Nlc3MgZHVyaW5nIHJlbmRlcmluZywgcG9wdWxhdGVkIGluIGJlZ2luKCkgbWV0aG9kOlxuICAgIEJhclJlbmRlcmVyLmhhc0EoXCJzZXR0aW5nc1wiKTtcblxuICAgIEJhclJlbmRlcmVyLnJlc3BvbmRzVG8oXCJiZWdpblwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBcImNvbnRleHRcIiAgICAgICAgICAgIDogY29udGV4dCxcbiAgICAgICAgICAgIFwiYmFycGl4ZWx3aWR0aFwiICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiYmFyd2lkdGhcIikuZ2V0UmVhbFZhbHVlKCkgKiB0aGlzLnBsb3QoKS5ob3Jpem9udGFsYXhpcygpLmF4aXNUb0RhdGFSYXRpbygpLFxuICAgICAgICAgICAgXCJiYXJvZmZzZXRcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJiYXJvZmZzZXRcIiksXG4gICAgICAgICAgICBcImJhcnBpeGVsYmFzZVwiICAgICAgIDogKHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJiYXJiYXNlXCIpICE9PSBudWxsKT90aGlzLnBsb3QoKS52ZXJ0aWNhbGF4aXMoKS5kYXRhVmFsdWVUb0F4aXNWYWx1ZSh0aGlzLmdldE9wdGlvblZhbHVlKFwiYmFyYmFzZVwiKSk6MCxcbiAgICAgICAgICAgIFwiZmlsbGNvbG9yXCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiZmlsbGNvbG9yXCIpLFxuICAgICAgICAgICAgXCJsaW5lY29sb3JcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJsaW5lY29sb3JcIiksXG4gICAgICAgICAgICBcImhpZGVsaW5lc1wiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImhpZGVsaW5lc1wiKSxcbiAgICAgICAgICAgIFwiYmFyR3JvdXBzXCIgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIFwiY3VycmVudEJhckdyb3VwXCIgICAgOiBudWxsLFxuICAgICAgICAgICAgXCJwcmV2Q29ybmVyXCIgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICBcInBpeGVsRWRnZVRvbGVyYW5jZVwiIDogMVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIH0pO1xuXG4gICAgLy8gVGhpcyBiYXIgcmVuZGVyZXIgdXNlcyBhIHNvbWV3aGF0IHNvcGhpc3RpY2F0ZWQgdGVjaG5pcXVlIHdoZW4gZHJhd2luZ1xuICAgIC8vIHRoZSBvdXRsaW5lcyBhcm91bmQgdGhlIGJhcnMsIGluIG9yZGVyIHRvIG1ha2Ugc3VyZSB0aGF0IGl0IG9ubHkgZHJhd3NcbiAgICAvLyBvbmUgdmVydGljYWwgbGluZSBiZXR3ZWVuIHR3byBiYXJzIHRoYXQgc2hhcmUgYW4gZWRnZS4gIElmIGEgY29tcGxldGVcbiAgICAvLyBvdXRsaW5lIHdlcmUgZHJhd24gYXJvdW5kIGVhY2ggYmFyIHNlcGFyYXRlbHksIHRoZSBjb21tb24gZWRnZSBiZXR3ZWVuXG4gICAgLy8gYWRqYWNlbnQgYmFycyB3b3VsZCBnZXQgZHJhd24gdHdpY2UsIG9uY2UgZm9yIGVhY2ggYmFyLCBwb3NzaWJseSBpblxuICAgIC8vIHNsaWdodGx5IGRpZmZlcmVudCBsb2NhdGlvbnMgb24gdGhlIHNjcmVlbiBkdWUgdG8gcm91bmRvZmYgZXJyb3IsXG4gICAgLy8gdGhlcmVieSBtYWtpbmcgc29tZSBvZiB0aGUgb3V0bGluZSBsaW5lcyBhcHBlYXIgdGhpY2tlciB0aGFuIG90aGVycy5cbiAgICAvLyBcbiAgICAvLyBJbiBvcmRlciB0byBhdm9pZCB0aGlzIHJvdW5kb2ZmIGFydGlmYWN0LCB0aGlzIHJlbmRlciBvbmx5IGRyYXdzIHRoZVxuICAgIC8vIGJhcnMgKHRoZSBmaWxsZWQgcmVnaW9uIG9mIHRoZSBiYXIsIHRoYXQgaXMpIGluIGl0cyBkYXRhUG9pbnQoKSBtZXRob2QsXG4gICAgLy8gYW5kIGtlZXBzIGEgcmVjb3JkIG9mIHRoZSBiYXIgbG9jYXRpb25zIGFuZCBoZWlnaHRzIHNvIHRoYXQgaXQgY2FuIGRyYXcgYWxsXG4gICAgLy8gb2YgdGhlIGJhciBvdXRsaW5lcyBhdCBvbmNlLCBpbiBpdHMgZW5kKCkgbWV0aG9kLiAgVGhlIGJhciBsb2NhdGlvbnMgYW5kXG4gICAgLy8gaGVpZ2h0cyBhcmUgc3RvcmVkIGluIGFuIGFycmF5IGNhbGxlZCBfYmFyR3JvdXBzLCB3aGljaCBpcyBhbiBhcnJheSBvZlxuICAgIC8vIFwiYmFyIGdyb3VwXCIgb2JqZWN0cy4gIEVhY2ggXCJiYXIgZ3JvdXBcIiBjb3JyZXNwb25kcyB0byBhIHNlcXVlbmNlIG9mIGFkamFjZW50XG4gICAgLy8gYmFycyAtLS0gdHdvIGJhcnMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgYWRqYWNlbnQgaWYgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGxlZnRcbiAgICAvLyBiYXIgaXMgd2l0aGluIF9waXhlbEVkZ2VUb2xlcmFuY2UgcGl4ZWxzIG9mIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHJpZ2h0IGJhci5cbiAgICAvLyBBIFwiYmFyIGdyb3VwXCIgaXMgcmVwcmVzZW50ZWQgYnkgYW4gYXJyYXkgb2YgcG9pbnRzIHJlcHJlc2VudGluZyB0aGUgcGl4ZWxcbiAgICAvLyBjb29yZGluYXRlcyBvZiB0aGUgdXBwZXIgbGVmdCBjb3JuZXJzIG9mIGFsbCB0aGUgYmFycyBpbiB0aGUgZ3JvdXAsIGZvbGxvd2VkIGJ5XG4gICAgLy8gdGhlIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB1cHBlciByaWdodCBjb3JuZXIgb2YgdGhlIHJpZ2h0LW1vc3QgYmFyIGluIHRoZSBncm91cC5cbiAgICAvLyAoVGhlIGxhc3QsIHJpZ2h0LW1vc3QsIGJhciBpcyB0aGUgb25seSBvbmUgd2hvc2UgdXBwZXIgcmlnaHQgY29ybmVyIGlzIGluY2x1ZGVkXG4gICAgLy8gaW4gdGhlIGxpc3QpLiAgU28sIGZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGJhciBncm91cFxuICAgIC8vIFxuICAgIC8vICAgICAgICAqLS0qXG4gICAgLy8gICAgICAgIHwgIHwtLSpcbiAgICAvLyAgICAgKi0tKiAgfCAgfFxuICAgIC8vICAgICB8ICB8ICB8ICB8XG4gICAgLy8gICAgIHwgIHwgIHwgIHxcbiAgICAvLyAgIC0tLS0tLS0tLS0tLS0tLVxuICAgIC8vICAgICAxICAyICAzICA0XG4gICAgLy8gXG4gICAgLy8gd291bGQgYmUgcmVwcmVzZW50ZWQgYnkgdGhlIGFycmF5XG4gICAgLy9cbiAgICAvLyAgICBbIFsxLDJdLCBbMiwzXSwgWzMsM10sIFs0LDNdIF1cbiAgICAvL1xuICAgIFxuICAgIEJhclJlbmRlcmVyLnJlc3BvbmRzVG8oXCJkYXRhUG9pbnRcIiwgZnVuY3Rpb24gKGRhdGFwKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTWlzc2luZyhkYXRhcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MoKSxcbiAgICAgICAgICAgIGNvbnRleHQgID0gc2V0dGluZ3MuY29udGV4dCxcbiAgICAgICAgICAgIHAgID0gdGhpcy50cmFuc2Zvcm1Qb2ludChkYXRhcCksXG4gICAgICAgICAgICB4MCA9IHBbMF0gKyBzZXR0aW5ncy5iYXJvZmZzZXQsXG4gICAgICAgICAgICB4MSA9IHBbMF0gKyBzZXR0aW5ncy5iYXJvZmZzZXQgKyBzZXR0aW5ncy5iYXJwaXhlbHdpZHRoO1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJmaWxsY29sb3JcIiwgZGF0YXBbMV0pLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoeDAsIHNldHRpbmdzLmJhcnBpeGVsYmFzZSwgc2V0dGluZ3MuYmFycGl4ZWx3aWR0aCwgcFsxXSAtIHNldHRpbmdzLmJhcnBpeGVsYmFzZSk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5iYXJwaXhlbHdpZHRoID4gc2V0dGluZ3MuaGlkZWxpbmVzKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MucHJldkNvcm5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbnRCYXJHcm91cCA9IFsgW3gwLHBbMV1dIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh4MCAtIHNldHRpbmdzLnByZXZDb3JuZXJbMF0pIDw9IHNldHRpbmdzLnBpeGVsRWRnZVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5jdXJyZW50QmFyR3JvdXAucHVzaCggW3gwLHBbMV1dICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY3VycmVudEJhckdyb3VwLnB1c2goIHNldHRpbmdzLnByZXZDb3JuZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYmFyR3JvdXBzLnB1c2goIHNldHRpbmdzLmN1cnJlbnRCYXJHcm91cCApO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5jdXJyZW50QmFyR3JvdXAgPSBbIFt4MCxwWzFdXSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzLnByZXZDb3JuZXIgPSBbeDEscFsxXV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBCYXJSZW5kZXJlci5yZXNwb25kc1RvKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzICAgICA9IHRoaXMuc2V0dGluZ3MoKSxcbiAgICAgICAgICAgIGNvbnRleHQgICAgICA9IHNldHRpbmdzLmNvbnRleHQsXG4gICAgICAgICAgICBiYXJwaXhlbGJhc2UgPSBzZXR0aW5ncy5iYXJwaXhlbGJhc2UsXG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heCxcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIGJhckdyb3VwLFxuICAgICAgICAgICAgaSwgaiwgbjtcblxuICAgICAgICBpZiAoc2V0dGluZ3MucHJldkNvcm5lciAhPT0gbnVsbCAmJiBzZXR0aW5ncy5jdXJyZW50QmFyR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbnRCYXJHcm91cC5wdXNoKCBzZXR0aW5ncy5wcmV2Q29ybmVyICk7XG4gICAgICAgICAgICBzZXR0aW5ncy5iYXJHcm91cHMucHVzaCggc2V0dGluZ3MuY3VycmVudEJhckdyb3VwICk7XG4gICAgICAgIH0gICAgICAgIFxuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc2V0dGluZ3MubGluZWNvbG9yLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXR0aW5ncy5iYXJHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJhckdyb3VwID0gc2V0dGluZ3MuYmFyR3JvdXBzW2ldO1xuICAgICAgICAgICAgbiA9IGJhckdyb3VwLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuIDwgMikgeyByZXR1cm47IH0gLy8gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZvciB0aGUgZmlyc3QgcG9pbnQsIGRyYXcgMyBsaW5lczpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgICB5IHwtLS0tLS1cbiAgICAgICAgICAgIC8vICAgICAgICAgfFxuICAgICAgICAgICAgLy8gICAgICAgICB8XG4gICAgICAgICAgICAvLyAgICBiYXNlIHwtLS0tLS1cbiAgICAgICAgICAgIC8vICAgICAgICAgXiAgICAgXlxuICAgICAgICAgICAgLy8gICAgICAgICB4ICAgICB4KG5leHQpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAgIGhvcml6b250YWwgbGluZSBAIHkgZnJvbSB4KG5leHQpIHRvIHhcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGJhckdyb3VwWzFdWzBdLCBiYXJHcm91cFswXVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhiYXJHcm91cFswXVswXSwgYmFyR3JvdXBbMF1bMV0pO1xuICAgICAgICAgICAgLy8gICB2ZXJ0aWNhbCBsaW5lIEAgeCBmcm9tIHkgdG8gYmFzZVxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYmFyR3JvdXBbMF1bMF0sIGJhcnBpeGVsYmFzZSk7XG4gICAgICAgICAgICAvLyAgIGhvcml6b250YWwgbGluZSBAIGJhc2UgZnJvbSB4IHRvIHgobmV4dClcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGJhckdyb3VwWzFdWzBdLCBiYXJwaXhlbGJhc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgbiAtIDE7ICsraikge1xuICAgICAgICAgICAgICAgIC8vIEZvciBpbnRlcm1lZGlhdGUgcG9pbnRzLCBkcmF3IDMgbGluZXM6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgICB5IHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHwtLS0tLS0geShuZXh0KVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgfFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgfFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgfC0tLS0tLSBiYXNlXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBeICAgICBeXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB4ICAgICB4KG5leHQpXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgIHZlcnRpY2FsIGxpbmUgQCB4IGZyb20gbWluIHRvIG1heCBvZiAoeSwgeShuZXh0KSwgYmFzZSlcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhiYXJHcm91cFtqXVswXSwgbWluKGJhckdyb3VwW2otMV1bMV0sIGJhckdyb3VwW2pdWzFdLCBiYXJwaXhlbGJhc2UpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhiYXJHcm91cFtqXVswXSwgbWF4KGJhckdyb3VwW2otMV1bMV0sIGJhckdyb3VwW2pdWzFdLCBiYXJwaXhlbGJhc2UpKTtcbiAgICAgICAgICAgICAgICAvLyAgIGhvcml6b250YWwgbGluZSBAIHkobmV4dCkgZnJvbSB4IHRvIHgobmV4dClcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhiYXJHcm91cFtqXVswXSwgICBiYXJHcm91cFtqXVsxXSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYmFyR3JvdXBbaisxXVswXSwgYmFyR3JvdXBbal1bMV0pO1xuICAgICAgICAgICAgICAgIC8vICAgaG9yaXpvbnRhbCBsaW5lIEAgYmFzZSBmcm9tIHggdG8geChuZXh0KVxuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGJhckdyb3VwW2pdWzBdLCAgIGJhcnBpeGVsYmFzZSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYmFyR3JvdXBbaisxXVswXSwgYmFycGl4ZWxiYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBsYXN0IHBvaW50LCBkcmF3IG9uZSBsaW5lOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICAgIHkgfFxuICAgICAgICAgICAgLy8gICAgICAgICB8XG4gICAgICAgICAgICAvLyAgICAgICAgIHxcbiAgICAgICAgICAgIC8vICAgIGJhc2UgfFxuICAgICAgICAgICAgLy8gICAgICAgICBeICAgICBeXG4gICAgICAgICAgICAvLyAgICAgICAgIHggICAgIHgobmV4dClcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIHZlcnRpY2FsIGxpbmUgQCB4IGZyb20gYmFzZSB0byB5XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhiYXJHcm91cFtuLTFdWzBdLCBiYXJHcm91cFtuLTFdWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGJhckdyb3VwW24tMV1bMF0sIGJhcnBpeGVsYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBCYXJSZW5kZXJlci5yZXNwb25kc1RvKFwicmVuZGVyTGVnZW5kSWNvblwiLCBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgaWNvbikge1xuICAgICAgICB2YXIgc2V0dGluZ3MgICAgICAgICAgPSB0aGlzLnNldHRpbmdzKCksXG4gICAgICAgICAgICByZW5kZXJlckZpbGxDb2xvciA9IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJmaWxsY29sb3JcIiwgMCkudG9SR0JBKHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJmaWxsb3BhY2l0eVwiLCAwKSk7XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIDEsIHgsIHkpO1xuXG4gICAgICAgIC8vIERyYXcgaWNvbiBiYWNrZ3JvdW5kICh3aXRoIG9wYWNpdHkpXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpXCI7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgaWNvbi53aWR0aCgpLCBpY29uLmhlaWdodCgpKTtcblxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcmVuZGVyZXJGaWxsQ29sb3I7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmJhcnBpeGVsd2lkdGggPCBzZXR0aW5ncy5oaWRlbGluZXMpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSByZW5kZXJlckZpbGxDb2xvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmdldE9wdGlvblZhbHVlKFwibGluZWNvbG9yXCIsIDApLnRvUkdCQSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRqdXN0IHRoZSB3aWR0aCBvZiB0aGUgaWNvbnMgYmFycyBiYXNlZCB1cG9uIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBpY29uIFJhbmdlczogezIwLCAxMCwgMH1cbiAgICAgICAgdmFyIGljb25XaWR0aCA9IGljb24ud2lkdGgoKSxcbiAgICAgICAgICAgIGljb25IZWlnaHQgPSBpY29uLmhlaWdodCgpLFxuICAgICAgICAgICAgYmFyd2lkdGg7XG4gICAgICAgIGlmIChpY29uV2lkdGggPiAyMCB8fCBpY29uSGVpZ2h0ID4gMjApIHtcbiAgICAgICAgICAgIGJhcndpZHRoID0gaWNvbldpZHRoIC8gNjtcbiAgICAgICAgfSBlbHNlIGlmIChpY29uV2lkdGggPiAxMCB8fCBpY29uSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICAgIGJhcndpZHRoID0gaWNvbldpZHRoIC8gNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhcndpZHRoID0gaWNvbldpZHRoIC8gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBpY29uIGlzIGxhcmdlIGVub3VnaCBkcmF3IGV4dHJhIGJhcnNcbiAgICAgICAgaWYgKGljb25XaWR0aCA+IDIwICYmIGljb25IZWlnaHQgPiAyMCkge1xuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCggICAoaWNvbldpZHRoIC8gNCkgLSAoYmFyd2lkdGggLyAyKSwgICAgICAgICAgICAgMCwgYmFyd2lkdGgsIGljb25IZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCggKGljb25XaWR0aCAvIDQpIC0gKGJhcndpZHRoIC8gMiksICAgICAgICAgICAgIDAsIGJhcndpZHRoLCBpY29uSGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoICAgaWNvbldpZHRoIC0gKGljb25XaWR0aCAvIDQpIC0gKGJhcndpZHRoIC8gMiksIDAsIGJhcndpZHRoLCBpY29uSGVpZ2h0IC8gMyk7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoIGljb25XaWR0aCAtIChpY29uV2lkdGggLyA0KSAtIChiYXJ3aWR0aCAvIDIpLCAwLCBiYXJ3aWR0aCwgaWNvbkhlaWdodCAvIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsUmVjdCggICAgICAgKGljb25XaWR0aCAvIDIpIC0gKGJhcndpZHRoIC8gMiksICAgICAgICAgICAgIDAsIGJhcndpZHRoLCBpY29uSGVpZ2h0IC0gKGljb25IZWlnaHQgLyA0KSk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCggICAgIChpY29uV2lkdGggLyAyKSAtIChiYXJ3aWR0aCAvIDIpLCAgICAgICAgICAgICAwLCBiYXJ3aWR0aCwgaWNvbkhlaWdodCAtIChpY29uSGVpZ2h0IC8gNCkpO1xuXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBCYXJSZW5kZXJlcjtcbn07XG5cbiIsInZhciBfSU5DTFVERUQgPSBmYWxzZTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEZpbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvcmUvcmVuZGVyZXJzL2ZpbGxfcmVuZGVyZXIuanMnKSxcbiAgICAgICAgbWF0aFV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoL3V0aWwuanMnKTtcblxuICAgIGlmIChfSU5DTFVERUQpIHsgcmV0dXJuIEZpbGxSZW5kZXJlcjsgfVxuICAgIF9JTkNMVURFRCA9IHRydWU7XG5cbiAgICAvLyBjYWNoZWQgc3RhdGUgb2JqZWN0LCBmb3IgcXVpY2sgYWNjZXNzIGR1cmluZyByZW5kZXJpbmcsIHBvcHVsYXRlZCBpbiBiZWdpbigpIG1ldGhvZDpcbiAgICBGaWxsUmVuZGVyZXIuaGFzQShcInN0YXRlXCIpO1xuXG4gICAgRmlsbFJlbmRlcmVyLnJlc3BvbmRzVG8oXCJiZWdpblwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBcImNvbnRleHRcIiAgICAgICAgICAgIDogY29udGV4dCxcbiAgICAgICAgICAgIFwicnVuXCIgICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIFwicHJldmlvdXNwb2ludFwiICAgICAgOiBudWxsLFxuICAgICAgICAgICAgXCJsaW5lY29sb3JcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJsaW5lY29sb3JcIiksXG4gICAgICAgICAgICBcImxpbmV3aWR0aFwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmV3aWR0aFwiKSxcbiAgICAgICAgICAgIFwiZmlsbGNvbG9yXCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiZmlsbGNvbG9yXCIpLFxuICAgICAgICAgICAgXCJkb3duZmlsbGNvbG9yXCIgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJkb3duZmlsbGNvbG9yXCIpLFxuICAgICAgICAgICAgXCJmaWxsb3BhY2l0eVwiICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJmaWxsb3BhY2l0eVwiKSxcbiAgICAgICAgICAgIFwiZmlsbGJhc2VcIiAgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiZmlsbGJhc2VcIiksXG4gICAgICAgICAgICBcImN1cnJlbnRmaWxsY29sb3JcIiAgIDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3RhdGUuZG93bmZpbGxjb2xvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUuZG93bmZpbGxjb2xvciA9IHN0YXRlLmZpbGxjb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmlsbGJhc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLmZpbGxwaXhlbGJhc2UgPSB0aGlzLnBsb3QoKS52ZXJ0aWNhbGF4aXMoKS5kYXRhVmFsdWVUb0F4aXNWYWx1ZShzdGF0ZS5maWxsYmFzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5maWxscGl4ZWxiYXNlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUoc3RhdGUpO1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0YXRlLmZpbGxjb2xvci5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuICAgIH0pO1xuXG4gICAgLy8gVGhpcyByZW5kZXJlcidzIGRhdGFQb2ludCgpIG1ldGhvZCB3b3JrcyBieSBhY2N1bXVsYXRpbmdcbiAgICAvLyBhbmQgZHJhd2luZyBvbmUgXCJydW5cIiBvZiBkYXRhIHBvaW50cyBhdCBhIHRpbWUuICBBIFwicnVuXCIgb2ZcbiAgICAvLyBwb2ludHMgY29uc2lzdHMgb2YgYSBjb25zZWN1dGl2ZSBzZXF1ZW5jZSBvZiBub24tbWlzc2luZ1xuICAgIC8vIGRhdGEgcG9pbnRzIHdoaWNoIGhhdmUgdGhlIHNhbWUgZmlsbCBjb2xvci4gIChUaGUgZmlsbFxuICAgIC8vIGNvbG9yIGNhbiBjaGFuZ2UgaWYgdGhlIGRhdGEgbGluZSBjcm9zc2VzIHRoZSBmaWxsIGJhc2VcbiAgICAvLyBsaW5lLCBpZiB0aGUgZG93bmZpbGxjb2xvciBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAvLyBmaWxsY29sb3IuKVxuICAgIEZpbGxSZW5kZXJlci5yZXNwb25kc1RvKFwiZGF0YVBvaW50XCIsIGZ1bmN0aW9uIChkYXRhcCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlKCksXG4gICAgICAgICAgICBmaWxscGl4ZWxiYXNlID0gc3RhdGUuZmlsbHBpeGVsYmFzZSxcbiAgICAgICAgICAgIGZpbGxjb2xvcixcbiAgICAgICAgICAgIGxpbmVjb2xvcixcbiAgICAgICAgICAgIHA7XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIG1pc3NpbmcgcG9pbnQsIGFuZCBpZiBpdCdzIG5vdCB0aGUgZmlyc3QgcG9pbnQsIGVuZCB0aGUgY3VycmVudCBydW4gYW5kIHJlbmRlciBpdFxuICAgICAgICBpZiAodGhpcy5pc01pc3NpbmcoZGF0YXApKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUucHJldmlvdXNwb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnJ1bi5wdXNoKCBbc3RhdGUucHJldmlvdXNwb2ludFswXSwgZmlsbHBpeGVsYmFzZV0gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJ1bigpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJ1biA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YXRlLnByZXZpb3VzcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIHBvaW50IHRvIHBpeGVsIGNvb3Jkc1xuICAgICAgICBwID0gdGhpcy50cmFuc2Zvcm1Qb2ludChkYXRhcCk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBmaWxsY29sb3IgYW5kIGxpbmVjb2xvciBmb3IgdGhpcyBkYXRhIHBvaW50LCBiYXNlZCBvbiB3aGV0aGVyIGl0J3MgYWJvdmVcbiAgICAgICAgLy8gb3IgYmVsb3cgdGhlIGJhc2UgbGluZVxuICAgICAgICBpZiAocFsxXSA+PSBmaWxscGl4ZWxiYXNlKSB7XG4gICAgICAgICAgICBmaWxsY29sb3IgPSBzdGF0ZS5maWxsY29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxsY29sb3IgPSBzdGF0ZS5kb3duZmlsbGNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgcnVuLCBzdGFydCB3aXRoIHRoaXMgZGF0YSBwb2ludCdzIGJhc2UgbGluZSBwcm9qZWN0aW9uXG4gICAgICAgIGlmIChzdGF0ZS5ydW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5ydW4ucHVzaCggW3BbMF0sIGZpbGxwaXhlbGJhc2VdICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBub3Qgc3RhcnRpbmcgYSBuZXcgcnVuLCBidXQgdGhlIGZpbGwgY29sb3JcbiAgICAgICAgICAgIC8vIGhhcyBjaGFuZ2VkLCBpbnRlcnBvbGF0ZSB0byBmaW5kIHRoZSBleGFjdCBiYXNlXG4gICAgICAgICAgICAvLyBsaW5lIGNyb3NzaW5nIHBvaW50LCBlbmQgdGhlIGN1cnJlbnQgcnVuIHdpdGggdGhhdFxuICAgICAgICAgICAgLy8gcG9pbnQsIHJlbmRlciBpdCwgYW5kIHN0YXJ0IGEgbmV3IHJ1biB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gY3Jvc3NpbmcgcG9pbnQuXG4gICAgICAgICAgICBpZiAoIWZpbGxjb2xvci5lcShzdGF0ZS5jdXJyZW50ZmlsbGNvbG9yKSkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gbWF0aFV0aWwuc2FmZV9pbnRlcnAoZmlsbHBpeGVsYmFzZSwgc3RhdGUucHJldmlvdXNwb2ludFsxXSwgcFsxXSwgc3RhdGUucHJldmlvdXNwb2ludFswXSwgcFswXSk7XG4gICAgICAgICAgICAgICAgLy8gYmFzZSBsaW5lIGNyb3NzaW5nIHBvaW50IGlzIFt4LCBzdGF0ZS5maWxscGl4ZWxiYXNlXVxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHBvaW50cyBhcmUgcHVzaGVkIHR3aWNlIHNvIHRoZSBvdXRsaW5lIG9mIHRoZSBmaWxsIHdpbGwgYmUgZHJhd24gcHJvcGVybHksXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBvdXRsaW5lIHdvdWxkIG5vdCBiZSBkcmF3biBhcm91bmQgdGhlIHNlZ21lbnRzIHRoYXQgY3Jvc3MgdGhlIGJhc2VsaW5lLlxuICAgICAgICAgICAgICAgIHN0YXRlLnJ1bi5wdXNoKCBbeCwgZmlsbHBpeGVsYmFzZV0gKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ydW4ucHVzaCggW3gsIGZpbGxwaXhlbGJhc2VdICk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW4oKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ydW4gPSBbXTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ydW4ucHVzaCggW3gsIGZpbGxwaXhlbGJhc2VdICk7XG4gICAgICAgICAgICAgICAgc3RhdGUucnVuLnB1c2goIFt4LCBmaWxscGl4ZWxiYXNlXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoaXMgcG9pbnQgdG8gdGhlIGN1cnJlbnQgcnVuLCBhbmQgcmVtZW1iZXIgaXQgYW5kIHRoZSBjdXJyZW50IGNvbG9ycyBmb3IgbmV4dCB0aW1lXG4gICAgICAgIHN0YXRlLnJ1bi5wdXNoKHApO1xuICAgICAgICBzdGF0ZS5wcmV2aW91c3BvaW50ID0gcDtcbiAgICAgICAgc3RhdGUuY3VycmVudGZpbGxjb2xvciA9IGZpbGxjb2xvcjtcbiAgICB9KTtcblxuICAgIEZpbGxSZW5kZXJlci5yZXNwb25kc1RvKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZSgpLFxuICAgICAgICAgICAgY29udGV4dCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICAgIGlmIChzdGF0ZS5ydW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhdGUucnVuLnB1c2goIFtzdGF0ZS5ydW5bc3RhdGUucnVuLmxlbmd0aC0xXVswXSwgc3RhdGUuZmlsbHBpeGVsYmFzZV0gKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICAvLyBSZW5kZXIgdGhlIGN1cnJlbnQgcnVuIG9mIGRhdGEgcG9pbnRzLiAgVGhpcyBjb25zaXN0cyBvZiBkcmF3aW5nIHRoZSBmaWxsIHJlZ2lvblxuICAgIC8vIHVuZGVyIHRoZSBwb2ludHMsIGFuZCB0aGUgbGluZXMgY29ubmVjdGluZyB0aGUgcG9pbnRzLiAgVGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50c1xuICAgIC8vIGluIHRoZSBydW4gYXJyYXkgYXJlIGFsd2F5cyBvbiB0aGUgYmFzZSBsaW5lOyB0aGUgcG9pbnRzIGluIGJldHdlZW4gdGhlc2UgdHdvXG4gICAgLy8gYXJlIHRoZSBhY3R1YWwgZGF0YSBwb2ludHMuXG4gICAgRmlsbFJlbmRlcmVyLnJlc3BvbmRzVG8oXCJyZW5kZXJSdW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlKCksXG4gICAgICAgICAgICBjb250ZXh0ID0gc3RhdGUuY29udGV4dCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gZmlsbCB0aGUgcnVuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gc3RhdGUuZmlsbG9wYWNpdHk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3RhdGUuY3VycmVudGZpbGxjb2xvci5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhzdGF0ZS5ydW5bMF1bMF0sIHN0YXRlLnJ1blswXVsxXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBzdGF0ZS5ydW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHN0YXRlLnJ1bltpXVswXSwgc3RhdGUucnVuW2ldWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgLy8gc3Ryb2tlIHRoZSBydW5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdGF0ZS5saW5lY29sb3IuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdGF0ZS5saW5ld2lkdGg7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHN0YXRlLnJ1blsxXVswXSwgc3RhdGUucnVuWzFdWzFdKTtcbiAgICAgICAgZm9yIChpID0gMjsgaSA8IHN0YXRlLnJ1bi5sZW5ndGgtMTsgKytpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhzdGF0ZS5ydW5baV1bMF0sIHN0YXRlLnJ1bltpXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBGaWxsUmVuZGVyZXIucmVzcG9uZHNUbyhcInJlbmRlckxlZ2VuZEljb25cIiwgZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIGljb24pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZSgpLFxuICAgICAgICAgICAgaWNvbldpZHRoID0gaWNvbi53aWR0aCgpLFxuICAgICAgICAgICAgaWNvbkhlaWdodCA9IGljb24uaGVpZ2h0KCk7XG4gICAgICAgIFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgeCwgeSk7XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIC8vIERyYXcgaWNvbiBiYWNrZ3JvdW5kICh3aXRoIG9wYWNpdHkpXG4gICAgICAgIGlmIChpY29uV2lkdGggPCAxMCB8fCBpY29uSGVpZ2h0IDwgMTApIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3RhdGUuZmlsbGNvbG9yLnRvUkdCQSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMSlcIjtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGljb25XaWR0aCwgaWNvbkhlaWdodCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdGF0ZS5saW5lY29sb3IudG9SR0JBKCk7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoICAgPSBzdGF0ZS5saW5ld2lkdGg7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlICAgPSBzdGF0ZS5maWxsY29sb3IudG9SR0JBKHN0YXRlLmZpbGxvcGFjaXR5KTtcblxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgbWlkZGxlIHJhbmdlIGljb24gb3IgdGhlIGxhcmdlIHJhbmdlIGljb24gaWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgYWxsb3cgaXRcbiAgICAgICAgaWYgKGljb25XaWR0aCA+IDEwIHx8IGljb25IZWlnaHQgPiAxMCkge1xuICAgICAgICAgICAgLy8gRHJhdyBhIG1vcmUgY29tcGxleCBpY29uIGlmIHRoZSBpY29ucyB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBsYXJnZSBlbm91Z2hcbiAgICAgICAgICAgIGlmIChpY29uV2lkdGggPiAyMCB8fCBpY29uSGVpZ2h0ID4gMjApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhpY29uV2lkdGggLyA2LCBpY29uSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oaWNvbldpZHRoIC8gMywgaWNvbkhlaWdodCAvIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oaWNvbldpZHRoIC8gMiwgaWNvbkhlaWdodCAtIGljb25IZWlnaHQgLyA0KTtcblxuICAgICAgICAgICAgaWYgKGljb25XaWR0aCA+IDIwIHx8IGljb25IZWlnaHQgPiAyMCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGljb25XaWR0aCAtIGljb25XaWR0aCAvIDMsIGljb25IZWlnaHQgLyA0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhpY29uV2lkdGggLSBpY29uV2lkdGggLyA2LCBpY29uSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5saW5lVG8oaWNvbldpZHRoLCAwKTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG5cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gRmlsbFJlbmRlcmVyO1xufTtcbiIsInZhciBfSU5DTFVERUQgPSBmYWxzZTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFBvaW50bGluZVJlbmRlcmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vY29yZS9yZW5kZXJlcnMvcG9pbnRsaW5lX3JlbmRlcmVyLmpzJyksXG4gICAgICAgIFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vY29yZS9yZW5kZXJlci5qcycpO1xuXG4gICAgaWYgKF9JTkNMVURFRCkgeyByZXR1cm4gUG9pbnRsaW5lUmVuZGVyZXI7IH1cbiAgICBfSU5DTFVERUQgPSB0cnVlO1xuXG4gICAgLy8gY2FjaGVkIHNldHRpbmdzIG9iamVjdCwgZm9yIHF1aWNrIGFjY2VzcyBkdXJpbmcgcmVuZGVyaW5nLCBwb3B1bGF0ZWQgaW4gYmVnaW4oKSBtZXRob2Q6XG4gICAgUG9pbnRsaW5lUmVuZGVyZXIuaGFzQShcInNldHRpbmdzXCIpO1xuXG4gICAgUG9pbnRsaW5lUmVuZGVyZXIucmVzcG9uZHNUbyhcImJlZ2luXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIFwiY29udGV4dFwiICAgICAgICAgICAgOiBjb250ZXh0LFxuICAgICAgICAgICAgXCJwb2ludHNcIiAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgXCJmaXJzdFwiICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBcInBvaW50c2hhcGVcIiAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcInBvaW50c2hhcGVcIiksXG4gICAgICAgICAgICBcInBvaW50Y29sb3JcIiAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcInBvaW50Y29sb3JcIiksXG4gICAgICAgICAgICBcInBvaW50b3BhY2l0eVwiICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcInBvaW50b3BhY2l0eVwiKSxcbiAgICAgICAgICAgIFwicG9pbnRzaXplXCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwicG9pbnRzaXplXCIpLFxuICAgICAgICAgICAgXCJwb2ludG91dGxpbmV3aWR0aFwiICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJwb2ludG91dGxpbmV3aWR0aFwiKSxcbiAgICAgICAgICAgIFwicG9pbnRvdXRsaW5lY29sb3JcIiAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwicG9pbnRvdXRsaW5lY29sb3JcIiksXG4gICAgICAgICAgICBcImxpbmVzdHJva2VcIiAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmVzdHJva2VcIiksXG4gICAgICAgICAgICBcImxpbmVjb2xvclwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmVjb2xvclwiKSxcbiAgICAgICAgICAgIFwibGluZXdpZHRoXCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwibGluZXdpZHRoXCIpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdHVybnMgb2ZmIHBvaW50cyBmb3IgbGluZSByZW5kZXJlcnNcbiAgICAgICAgaWYgKHRoaXMudHlwZSgpID09PSBSZW5kZXJlci5MSU5FKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludHNpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHR1cm5zIG9mZiBsaW5lcyBmb3IgcG9pbnQgcmVuZGVyZXJzXG4gICAgICAgIGlmICh0aGlzLnR5cGUoKSA9PT0gUmVuZGVyZXIuUE9JTlQpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmxpbmV3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR0aW5ncyhzZXR0aW5ncyk7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmxpbmV3aWR0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5saW5lc3Ryb2tlID09PSBQb2ludGxpbmVSZW5kZXJlci5EQVNIRUQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs1LDVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc2V0dGluZ3MubGluZXdpZHRoO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHNldHRpbmdzLmxpbmVjb2xvci5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyKCkucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFBvaW50bGluZVJlbmRlcmVyLnJlc3BvbmRzVG8oXCJkYXRhUG9pbnRcIiwgZnVuY3Rpb24gKGRhdGFwKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MoKSxcbiAgICAgICAgICAgIGNvbnRleHQgID0gc2V0dGluZ3MuY29udGV4dCxcbiAgICAgICAgICAgIHA7XG4gICAgICAgIGlmICh0aGlzLmlzTWlzc2luZyhkYXRhcCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwID0gdGhpcy50cmFuc2Zvcm1Qb2ludChkYXRhcCk7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcigpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIoKS5maWx0ZXIoZGF0YXAsIHApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5saW5ld2lkdGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZmlyc3QpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5maXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MucG9pbnRzaXplID4gMCkge1xuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFBvaW50bGluZVJlbmRlcmVyLnJlc3BvbmRzVG8oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzKCksXG4gICAgICAgICAgICBjb250ZXh0ICA9IHNldHRpbmdzLmNvbnRleHQ7XG4gICAgICAgIGlmIChzZXR0aW5ncy5saW5ld2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLnBvaW50c2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1BvaW50cygpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIFBvaW50bGluZVJlbmRlcmVyLnJlc3BvbmRzVG8oXCJkcmF3UG9pbnRzXCIsIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyAgID0gdGhpcy5zZXR0aW5ncygpLFxuICAgICAgICAgICAgY29udGV4dCAgICA9IHNldHRpbmdzLmNvbnRleHQsXG4gICAgICAgICAgICBwb2ludHMgICAgID0gc2V0dGluZ3MucG9pbnRzLFxuICAgICAgICAgICAgcG9pbnRzaGFwZSA9IHNldHRpbmdzLnBvaW50c2hhcGUsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoKHBvaW50c2hhcGUgPT09IFBvaW50bGluZVJlbmRlcmVyLlBMVVMpIHx8IChwb2ludHNoYXBlID09PSBQb2ludGxpbmVSZW5kZXJlci5YKSkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHNldHRpbmdzLnBvaW50Y29sb3IuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc2V0dGluZ3MucG9pbnRvdXRsaW5ld2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzLnBvaW50Y29sb3IudG9SR0JBKHNldHRpbmdzLnBvaW50b3BhY2l0eSk7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc2V0dGluZ3MucG9pbnRvdXRsaW5lY29sb3IuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc2V0dGluZ3MucG9pbnRvdXRsaW5ld2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGk9MDsgaTxwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1BvaW50KGNvbnRleHQsIHNldHRpbmdzLCBwb2ludHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoKHBvaW50c2hhcGUgPT09IFBvaW50bGluZVJlbmRlcmVyLlBMVVMpIHx8IChwb2ludHNoYXBlID09PSBQb2ludGxpbmVSZW5kZXJlci5YKSkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgUG9pbnRsaW5lUmVuZGVyZXIucmVzcG9uZHNUbyhcImRyYXdQb2ludFwiLCBmdW5jdGlvbiAoY29udGV4dCwgc2V0dGluZ3MsIHApIHtcbiAgICAgICAgdmFyIHBvaW50c2l6ZSA9IHNldHRpbmdzLnBvaW50c2l6ZSxcbiAgICAgICAgICAgIHAwID0gcFswXSxcbiAgICAgICAgICAgIHAxID0gcFsxXSxcbiAgICAgICAgICAgIGEsYixkO1xuXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MucG9pbnRzaGFwZSkge1xuICAgICAgICBjYXNlIFBvaW50bGluZVJlbmRlcmVyLlBMVVM6XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwMCwgICAgICAgICAgICAgcDEgLSBwb2ludHNpemUpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAsICAgICAgICAgICAgIHAxICsgcG9pbnRzaXplKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHAwIC0gcG9pbnRzaXplLCBwMSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCArIHBvaW50c2l6ZSwgcDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFBvaW50bGluZVJlbmRlcmVyLlg6XG4gICAgICAgICAgICBkID0gMC43MDcxMCAqIHBvaW50c2l6ZTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHAwLWQsIHAxLWQpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDArZCwgcDErZCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwMC1kLCBwMStkKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwK2QsIHAxLWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFBvaW50bGluZVJlbmRlcmVyLlNRVUFSRTpcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHAwIC0gcG9pbnRzaXplLCBwMSAtIHBvaW50c2l6ZSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCArIHBvaW50c2l6ZSwgcDEgLSBwb2ludHNpemUpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgKyBwb2ludHNpemUsIHAxICsgcG9pbnRzaXplKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwIC0gcG9pbnRzaXplLCBwMSArIHBvaW50c2l6ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgUG9pbnRsaW5lUmVuZGVyZXIuVFJJQU5HTEU6XG4gICAgICAgICAgICBkID0gMS41ICogcG9pbnRzaXplO1xuICAgICAgICAgICAgYSA9IDAuODY2MDI1ICogZDtcbiAgICAgICAgICAgIGIgPSAwLjUgKiBkO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocDAsICAgICBwMSArIGQpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgKyBhLCBwMSAtIGIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgLSBhLCBwMSAtIGIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFBvaW50bGluZVJlbmRlcmVyLkRJQU1PTkQ6XG4gICAgICAgICAgICBkID0gMS41ICogcG9pbnRzaXplO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocDAgLSBwb2ludHNpemUsIHAxKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwLCAgICAgICAgICAgICBwMSArIGQpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgKyBwb2ludHNpemUsIHAxKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwLCAgICAgICAgICAgICBwMSAtIGQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFBvaW50bGluZVJlbmRlcmVyLlNUQVI6XG4gICAgICAgICAgICBkID0gMS41ICogcG9pbnRzaXplO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocDAgLSBkKjAuMDAwMCwgcDEgKyBkKjEuMDAwMCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCArIGQqMC4zNTM2LCBwMSArIGQqMC4zNTM2KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwICsgZCowLjk1MTEsIHAxICsgZCowLjMwOTApO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgKyBkKjAuNDQ1NSwgcDEgLSBkKjAuMjI3MCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCArIGQqMC41ODc4LCBwMSAtIGQqMC44MDkwKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwIC0gZCowLjA3ODIsIHAxIC0gZCowLjQ5MzgpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgLSBkKjAuNTg3OCwgcDEgLSBkKjAuODA5MCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCAtIGQqMC40OTM4LCBwMSAtIGQqMC4wNzgyKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwIC0gZCowLjk1MTEsIHAxICsgZCowLjMwOTApO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgLSBkKjAuMjI3MCwgcDEgKyBkKjAuNDQ1NSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgUG9pbnRsaW5lUmVuZGVyZXIuQ0lSQ0xFOlxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocDAgKyBwb2ludHNpemUsIHAxKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKHAwLCBwMSwgcG9pbnRzaXplLCAwLCAyKk1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgUG9pbnRsaW5lUmVuZGVyZXIucmVzcG9uZHNUbyhcInJlbmRlckxlZ2VuZEljb25cIiwgZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIGljb24pIHtcbiAgICAgICAgdmFyIHNldHRpbmdzICAgPSB0aGlzLnNldHRpbmdzKCksXG4gICAgICAgICAgICBwb2ludHNoYXBlID0gc2V0dGluZ3MucG9pbnRzaGFwZSxcbiAgICAgICAgICAgIGljb25XaWR0aCAgPSBpY29uLndpZHRoKCksXG4gICAgICAgICAgICBpY29uSGVpZ2h0ID0gaWNvbi5oZWlnaHQoKTtcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgLy8gRHJhdyBpY29uIGJhY2tncm91bmQgKHdpdGggb3BhY2l0eSlcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMSlcIjtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCBpY29uV2lkdGgsIGljb25IZWlnaHQpO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5saW5ld2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc2V0dGluZ3MubGluZWNvbG9yLnRvUkdCQSgpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggICA9IHNldHRpbmdzLmxpbmV3aWR0aDtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5ICsgaWNvbkhlaWdodC8yKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHggKyBpY29uV2lkdGgsIHkgKyBpY29uSGVpZ2h0LzIpO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MucG9pbnRzaXplID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmICgocG9pbnRzaGFwZSA9PT0gUG9pbnRsaW5lUmVuZGVyZXIuUExVUykgfHwgKHBvaW50c2hhcGUgPT09IFBvaW50bGluZVJlbmRlcmVyLlgpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHNldHRpbmdzLnBvaW50Y29sb3IudG9SR0JBKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggICA9IHNldHRpbmdzLnBvaW50b3V0bGluZXdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSAgID0gc2V0dGluZ3MucG9pbnRjb2xvci50b1JHQkEoc2V0dGluZ3MucG9pbnRvcGFjaXR5KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc2V0dGluZ3MucG9pbnRvdXRsaW5lY29sb3IudG9SR0JBKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggICA9IHNldHRpbmdzLnBvaW50b3V0bGluZXdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRyYXdQb2ludChjb250ZXh0LCBzZXR0aW5ncywgWyh4ICsgaWNvbldpZHRoLzIpLCAoeSArIGljb25IZWlnaHQvMildKTtcblxuICAgICAgICAgICAgaWYgKCEoKHBvaW50c2hhcGUgPT09IFBvaW50bGluZVJlbmRlcmVyLlBMVVMpIHx8IChwb2ludHNoYXBlID09PSBQb2ludGxpbmVSZW5kZXJlci5YKSkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUG9pbnRsaW5lUmVuZGVyZXI7XG59O1xuIiwidmFyIF9JTkNMVURFRCA9IGZhbHNlO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgUmFuZ2VCYXJSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvcmUvcmVuZGVyZXJzL3JhbmdlYmFyX3JlbmRlcmVyLmpzJyk7XG5cbiAgICBpZiAoX0lOQ0xVREVEKSB7IHJldHVybiBSYW5nZUJhclJlbmRlcmVyOyB9XG4gICAgX0lOQ0xVREVEID0gdHJ1ZTtcblxuICAgIC8vIGNhY2hlZCBzdGF0ZSBvYmplY3QsIGZvciBxdWljayBhY2Nlc3MgZHVyaW5nIHJlbmRlcmluZywgcG9wdWxhdGVkIGluIGJlZ2luKCkgbWV0aG9kOlxuICAgIFJhbmdlQmFyUmVuZGVyZXIuaGFzQShcInN0YXRlXCIpO1xuXG4gICAgUmFuZ2VCYXJSZW5kZXJlci5yZXNwb25kc1RvKFwiYmVnaW5cIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgXCJjb250ZXh0XCIgICAgICAgICAgICA6IGNvbnRleHQsXG4gICAgICAgICAgICBcInJ1blwiICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBcImJhcnBpeGVsd2lkdGhcIiAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImJhcndpZHRoXCIpLmdldFJlYWxWYWx1ZSgpICogdGhpcy5wbG90KCkuaG9yaXpvbnRhbGF4aXMoKS5heGlzVG9EYXRhUmF0aW8oKSxcbiAgICAgICAgICAgIFwiYmFycGl4ZWxvZmZzZXRcIiAgICAgOiAwLFxuICAgICAgICAgICAgXCJiYXJvZmZzZXRcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJiYXJvZmZzZXRcIiksXG4gICAgICAgICAgICBcImZpbGxjb2xvclwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImZpbGxjb2xvclwiKSxcbiAgICAgICAgICAgIFwiZmlsbG9wYWNpdHlcIiAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiZmlsbG9wYWNpdHlcIiksXG4gICAgICAgICAgICBcImxpbmVjb2xvclwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmVjb2xvclwiKSxcbiAgICAgICAgICAgIFwibGluZXdpZHRoXCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwibGluZXdpZHRoXCIpLFxuICAgICAgICAgICAgXCJoaWRlbGluZXNcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJoaWRlbGluZXNcIilcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUuYmFycGl4ZWxvZmZzZXQgPSBzdGF0ZS5iYXJwaXhlbHdpZHRoICogc3RhdGUuYmFyb2Zmc2V0O1xuICAgICAgICB0aGlzLnN0YXRlKHN0YXRlKTtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfSk7XG5cbiAgICBSYW5nZUJhclJlbmRlcmVyLnJlc3BvbmRzVG8oXCJkYXRhUG9pbnRcIiwgZnVuY3Rpb24gKGRhdGFwKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTWlzc2luZyhkYXRhcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUoKSxcbiAgICAgICAgICAgIGNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LFxuICAgICAgICAgICAgcCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoZGF0YXApLFxuICAgICAgICAgICAgeDAgPSBwWzBdIC0gc3RhdGUuYmFycGl4ZWxvZmZzZXQsXG4gICAgICAgICAgICB4MSA9IHgwICsgc3RhdGUuYmFycGl4ZWx3aWR0aDtcblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MCwgcFsxXSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgwLCBwWzJdKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEsIHBbMl0pO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MSwgcFsxXSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgwLCBwWzFdKTtcbiAgICB9KTtcblxuICAgIFJhbmdlQmFyUmVuZGVyZXIucmVzcG9uZHNUbyhcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUoKSxcbiAgICAgICAgICAgIGNvbnRleHQgPSBzdGF0ZS5jb250ZXh0O1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBzdGF0ZS5maWxsb3BhY2l0eTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzdGF0ZS5maWxsY29sb3IuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIGlmIChzdGF0ZS5saW5ld2lkdGggPiAwICYmIHN0YXRlLmJhcnBpeGVsd2lkdGggPiBzdGF0ZS5oaWRlbGluZXMpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdGF0ZS5saW5lY29sb3IuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3RhdGUubGluZXdpZHRoO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIFJhbmdlQmFyUmVuZGVyZXIucmVzcG9uZHNUbyhcInJlbmRlckxlZ2VuZEljb25cIiwgZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIGljb24pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZSgpLFxuICAgICAgICAgICAgaWNvbldpZHRoICA9IGljb24ud2lkdGgoKSxcbiAgICAgICAgICAgIGljb25IZWlnaHQgPSBpY29uLmhlaWdodCgpLFxuICAgICAgICAgICAgYmFyd2lkdGg7XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIDEsIHgsIHkpO1xuXG4gICAgICAgIC8vIERyYXcgaWNvbiBiYWNrZ3JvdW5kICh3aXRoIG9wYWNpdHkpXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCIjRkZGRkZGXCI7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjRkZGRkZGXCI7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgaWNvbldpZHRoLCBpY29uSGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgLy8gRHJhdyBpY29uIGdyYXBoaWNzXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3RhdGUuZmlsbGNvbG9yLnRvUkdCQShzdGF0ZS5maWxsb3BhY2l0eSk7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3RhdGUubGluZXdpZHRoO1xuICAgICAgICBpZiAoc3RhdGUuYmFycGl4ZWx3aWR0aCA8IDEwKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3RhdGUuZmlsbGNvbG9yLnRvUkdCQShzdGF0ZS5maWxsb3BhY2l0eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3RhdGUubGluZWNvbG9yLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3QgdGhlIHdpZHRoIG9mIHRoZSBpY29ucyBiYXJzIGJhc2VkIHVwb24gdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGljb24gUmFuZ2VzOiB7MjAsIDEwLCAwfVxuICAgICAgICBpZiAoaWNvbldpZHRoID4gMjAgfHwgaWNvbkhlaWdodCA+IDIwKSB7XG4gICAgICAgICAgICBiYXJ3aWR0aCA9IGljb25XaWR0aCAvIDY7XG4gICAgICAgIH0gZWxzZSBpZihpY29uV2lkdGggPiAxMCB8fCBpY29uSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICAgIGJhcndpZHRoID0gaWNvbldpZHRoIC8gNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhcndpZHRoID0gaWNvbldpZHRoIC8gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBpY29uIGlzIGxhcmdlIGVub3VnaCBkcmF3IGV4dHJhIGJhcnNcbiAgICAgICAgaWYgKGljb25XaWR0aCA+IDIwICYmIGljb25IZWlnaHQgPiAyMCkge1xuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCggIGljb25XaWR0aC80IC0gYmFyd2lkdGgvMiwgICAgICAgICAgICAgaWNvbkhlaWdodC84LCBiYXJ3aWR0aCwgaWNvbkhlaWdodC8yKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChpY29uV2lkdGgvNCAtIGJhcndpZHRoLzIsICAgICAgICAgICAgIGljb25IZWlnaHQvOCwgYmFyd2lkdGgsIGljb25IZWlnaHQvMik7XG5cbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoICBpY29uV2lkdGggLSBpY29uV2lkdGgvNCAtIGJhcndpZHRoLzIsIGljb25IZWlnaHQvNCwgYmFyd2lkdGgsIGljb25IZWlnaHQvMyk7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoaWNvbldpZHRoIC0gaWNvbldpZHRoLzQgLSBiYXJ3aWR0aC8yLCBpY29uSGVpZ2h0LzQsIGJhcndpZHRoLCBpY29uSGVpZ2h0LzMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsUmVjdCggIGljb25XaWR0aC8yIC0gYmFyd2lkdGgvMiwgMCwgYmFyd2lkdGgsIGljb25IZWlnaHQtaWNvbkhlaWdodC80KTtcbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGljb25XaWR0aC8yIC0gYmFyd2lkdGgvMiwgMCwgYmFyd2lkdGgsIGljb25IZWlnaHQtaWNvbkhlaWdodC80KTtcblxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBSYW5nZUJhclJlbmRlcmVyO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFRleHQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RleHQuanMnKTtcblxuICAgIGlmICh0eXBlb2YoVGV4dC5kcmF3VGV4dCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIFRleHQ7IH1cblxuICAgIFRleHQucmVzcG9uZHNUbyhcImluaXRpYWxpemVHZW9tZXRyeVwiLCBmdW5jdGlvbiAoZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIHZhciBvcmlnV2lkdGgsXG4gICAgICAgICAgICBvcmlnSGVpZ2h0LFxuICAgICAgICAgICAgcm90YXRlZFdpZHRoLFxuICAgICAgICAgICAgcm90YXRlZEhlaWdodDtcblxuICAgICAgICBncmFwaGljc0NvbnRleHQuY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGlmICh0aGlzLmZvbnQoKSAhPT0gXCJcIikge1xuICAgICAgICAgICAgLy8gdGhlIG5ldyB3YXk6IHVzZSB0aGUgXCJmb250XCIgcHJvcGVydHlcbiAgICAgICAgICAgIGdyYXBoaWNzQ29udGV4dC5jb250ZXh0LmZvbnQgPSB0aGlzLmZvbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChncmFwaGljc0NvbnRleHQuZm9udFNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdGhlIG9sZCB3YXksIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IChcImZvbnRTaXplXCIgcHJvcGVydHkgb2YgZ3JhcGhpY3MgY29udGV4dCBvYmplY3QpOlxuICAgICAgICAgICAgZ3JhcGhpY3NDb250ZXh0LmNvbnRleHQuZm9udCA9IGdyYXBoaWNzQ29udGV4dC5mb250U2l6ZSArIFwiIHNhbnMtc2VyaWZcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9yaWdXaWR0aCAgPSB0aGlzLm1lYXN1cmVTdHJpbmdXaWR0aChncmFwaGljc0NvbnRleHQuY29udGV4dCk7XG4gICAgICAgIG9yaWdIZWlnaHQgPSB0aGlzLm1lYXN1cmVTdHJpbmdIZWlnaHQoZ3JhcGhpY3NDb250ZXh0LmNvbnRleHQpO1xuXG4gICAgICAgIGdyYXBoaWNzQ29udGV4dC5jb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICBpZiAoZ3JhcGhpY3NDb250ZXh0LmFuZ2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IGdyYXBoaWNzQ29udGV4dC5hbmdsZS8xODAgKiBNYXRoLlBJO1xuICAgICAgICAgICAgcm90YXRlZFdpZHRoID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKSAqIG9yaWdXaWR0aCArIE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSkgKiBvcmlnSGVpZ2h0O1xuICAgICAgICAgICAgcm90YXRlZEhlaWdodCA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSkgKiBvcmlnV2lkdGggKyBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpICogb3JpZ0hlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdGF0ZWRXaWR0aCA9IG9yaWdXaWR0aDtcbiAgICAgICAgICAgIHJvdGF0ZWRIZWlnaHQgPSBvcmlnSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcmlnV2lkdGgob3JpZ1dpZHRoKTtcbiAgICAgICAgdGhpcy5vcmlnSGVpZ2h0KG9yaWdIZWlnaHQpO1xuICAgICAgICB0aGlzLnJvdGF0ZWRXaWR0aChyb3RhdGVkV2lkdGgpO1xuICAgICAgICB0aGlzLnJvdGF0ZWRIZWlnaHQocm90YXRlZEhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHVucm90YXRlZCB3aWR0aCBmb3IgdGhlIHN0b3JlZCBzdHJpbmcgaW4gdGhlIGNhbnZhcyBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbWVhc3VyZVN0cmluZ1dpZHRoXG4gICAgICogQGZvciBUZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtGbG9hdH0gVW5yb3RhdGVkIHdpZHRoIG9mIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBUZXh0LnJlc3BvbmRzVG8oXCJtZWFzdXJlU3RyaW5nV2lkdGhcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyaW5nKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWVhc3VyZVN0cmluZ1dpZHRoIHJlcXVpcmVzIHRoZSBzdHJpbmcgYXR0ciB0byBiZSBzZXQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1ldHJpY3MgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRoaXMuc3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gbWV0cmljcy53aWR0aDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdW5yb3RhdGVkIGhlaWdodCBmb3IgdGhlIHN0b3JlZCBzdHJpbmcgaW4gdGhlIGNhbnZhcyBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbWVhc3VyZVN0cmluZ0hlaWdodFxuICAgICAqIEBmb3IgVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7RmxvYXR9IFVucm90YXRlZCBoZWlnaHQgb2Ygc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFRleHQucmVzcG9uZHNUbyhcIm1lYXN1cmVTdHJpbmdIZWlnaHRcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyaW5nKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWVhc3VyZVN0cmluZ0hlaWdodCByZXF1aXJlcyB0aGUgc3RyaW5nIGF0dHIgdG8gYmUgc2V0LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vTk9URToga2x1ZGdlOiBjYW52YXMgY2Fubm90IGV4YWN0bHkgbWVhc3VyZSB0ZXh0IGhlaWdodCwgc28gd2UganVzdCByZXR1cm4gYSB2YWx1ZVxuICAgICAgICAvLyAgICAgIGVzdGltYXRlZCBieSB1c2luZyB0aGUgd2lkdGggb2YgYW4gXCJNXCIgYXMgYSBzdWJzdGl0dXRlLiAgTWF5YmUgaW1wcm92ZSB0aGlzXG4gICAgICAgIC8vICAgICAgbGF0ZXIgYnkgdXNpbmcgYSBiZXR0ZXIgd29ya2Fyb3VuZC5cbiAgICAgICAgdmFyIG1ldHJpY3MgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KFwiTVwiKSxcbiAgICAgICAgICAgIG5ld2xpbmVDb3VudCA9IHRoaXMuc3RyaW5nKCkubWF0Y2goL1xcbi9nKTtcbiAgICAgICAgcmV0dXJuIChuZXdsaW5lQ291bnQgIT09IG51bGwgPyAobmV3bGluZUNvdW50Lmxlbmd0aCArIDEpIDogMSkgKiBtZXRyaWNzLndpZHRoO1xuICAgIH0pO1xuXG4gICAgVGV4dC5yZXNwb25kc1RvKFwic2V0VHJhbnNmb3JtXCIsIGZ1bmN0aW9uIChjb250ZXh0LCBhbmNob3IsIGJhc2UsIHBvc2l0aW9uLCBhbmdsZSkge1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybSgxLCAwLCAwLCAtMSwgMCwgMiAqIGJhc2UueSgpKTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgYmFzZS54KCksIGJhc2UueSgpKTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgcG9zaXRpb24ueCgpLCAtcG9zaXRpb24ueSgpKTtcbiAgICAgICAgY29udGV4dC5yb3RhdGUoLWFuZ2xlICogTWF0aC5QSS8xODAuMCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIDEsIC1hbmNob3IueCgpLCBhbmNob3IueSgpKTtcbiAgICB9KTtcblxuICAgIFRleHQucmVzcG9uZHNUbyhcImRyYXdUZXh0XCIsIGZ1bmN0aW9uIChjb250ZXh0LCBhbmNob3IsIGJhc2UsIHBvc2l0aW9uLCBhbmdsZSkge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY29udGV4dCwgYW5jaG9yLCBiYXNlLCBwb3NpdGlvbiwgYW5nbGUpO1xuICAgICAgICBpZiAodGhpcy5mb250KCkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZm9udCA9IHRoaXMuZm9udCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGhpcy5zdHJpbmcoKSwgMCwgMCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFRleHQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgV2luZG93ID0gcmVxdWlyZSgnLi4vLi4vY29yZS93aW5kb3cuanMnKTtcblxuICAgIGlmICh0eXBlb2YoV2luZG93LnJlbmRlcik9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIFdpbmRvdzsgfVxuXG4gICAgV2luZG93LnJlc3BvbmRzVG8oXCJyZW5kZXJcIiwgZnVuY3Rpb24gKGNvbnRleHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLm1hcmdpbigpLmxlZnQoKTtcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmJvcmRlcmNvbG9yKCkuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdChtLCBtLCB3aWR0aCAtIDIqbSwgaGVpZ2h0IC0gMiptKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gV2luZG93O1xufTtcbiIsInJlcXVpcmUoJy4uL2xpYi9hamF4dGhyb3R0bGUvc3JjL2FqYXh0aHJvdHRsZS5qcycpO1xucmVxdWlyZSgnLi4vbGliL2xpZ2h0Ym94L2xpZ2h0Ym94LmpzJyk7XG5yZXF1aXJlKCcuLi9saWIvanF1ZXJ5L2pxdWVyeS5tb3VzZXdoZWVsLmpzJyk7XG5yZXF1aXJlKCcuLi9saWIvYnVzeS1zcGlubmVyL2J1c3lfc3Bpbm5lci5qcycpO1xucmVxdWlyZSgnLi4vbGliL2Vycm9yLWRpc3BsYXkvYnVpbGQvZXJyb3JEaXNwbGF5LmpzJyk7XG5yZXF1aXJlKCcuLi9saWIvcmVxdWVzdGFuaW1hdGlvbmZyYW1lL3JlcXVlc3RhbmltYXRpb25mcmFtZS5qcycpO1xuXG5yZXF1aXJlKCcuL3BhcnNlci94bWwvanF1ZXJ5X3htbF9wYXJzZXIuanMnKSgkKTtcbnJlcXVpcmUoJy4vcGFyc2VyL2pzb24vanNvbl9wYXJzZXIuanMnKSgkKTtcbnJlcXVpcmUoJy4vZ3JhcGhpY3MvY2FudmFzL2FsbC5qcycpKCQsIHdpbmRvdyk7XG5cbi8vIFRoaXMgZm9yY2VzIC4vZXZlbnRzL211bHRpZ3JhcGguanMgdG8gbG9hZCwgd2hpY2ggaXMgd2hlcmUgdGhlICdtYWluJyBwcm9ncmFtXG4vLyByZWFsbHkgbGl2ZXMgLS0tIGkuZS4gaW5zdGFsbGF0aW9uIG9mIHRoZSBNdWx0aWdyYXBoIGpRdWVyeSBwbHVnaW4sIGFuZCB0aGVcbi8vICQoZG9jdW1lbnQpLnJlYWR5KC4uLikgc3R1ZmYgdGhhdCBzcHJpbmdzIGludG8gYWN0aW9uIG9uY2UgdGhlIHBhZ2UgaGFzIGxvYWRlZC5cbi8vIE5vdGUgdGhhdCB0aGUgM3JkIGFyZyB0byByZXF1aXJlKCcuL2V2ZW50cy9tdWx0aWdyYXBoLmpzJykgaXMgdW51c2VkLlxucmVxdWlyZSgnLi9ldmVudHMvbXVsdGlncmFwaC5qcycpKCQsIHdpbmRvdywgdW5kZWZpbmVkKTtcblxuLy8gRm9yIEpTIGFwcGxpY2F0aW9ucyB0aGF0IHdhbnQgdG8gdXNlIHRoZSBidW5kbGVkIG11bHRpZ3JhcGggZmlsZSwgaW5zdGVhZCBvZlxuLy8gcmVmZXJlbmNpbmcgTXVsdGlncmFwaCB0aHJvdWdoIG5wbS1zdHlsZSByZXF1aXJlIHN0YXRlbWVudHMsIGFuZCBmb3IgYmFja3dhcmRcbi8vIGNvbXBhdGliaWxpdHkgd2l0aCBwcmUtbnBtIHZlcnNpb25zIG9mIE11bHRpZ3JhcGgsIGNyZWF0ZSB0aGUgZ2xvYmFlbFxuLy8gd2luZG93Lm11bHRpZ3JhcGggb2JqZWN0IHdoaWNoIGV4cG9zZXMgYSBidW5jaCBvZiBvYmplY3RzL2Z1bmN0aW9ucyBmcm9tIHRoZVxuLy8gTXVsdGlncmFwaCBjb2RlLlxudmFyIE11bHRpZ3JhcGggPSByZXF1aXJlKCcuL2NvcmUvbXVsdGlncmFwaC5qcycpKCQpO1xudmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpO1xudmFyIHBhcnNpbmdGdW5jdGlvbnMgPSByZXF1aXJlKCcuL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpO1xudmFyIHZhbGlkYXRpb25GdW5jdGlvbnMgPSByZXF1aXJlKCcuL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpO1xuXG53aW5kb3cubXVsdGlncmFwaCA9IHtcbiAgICAnY29yZScgOiB7XG4gICAgICAgICdNdWx0aWdyYXBoJzogICAgICAgICAgICAgICAgXHRNdWx0aWdyYXBoLFxuICAgICAgICAnQ1NWRGF0YSc6ICAgICAgICAgICAgICAgIFx0XHRyZXF1aXJlKCcuL2NvcmUvY3N2X2RhdGEuanMnKSgkKSxcbiAgICAgICAgJ1dlYlNlcnZpY2VEYXRhJzogICAgICAgICAgICAgXHRyZXF1aXJlKCcuL2NvcmUvd2ViX3NlcnZpY2VfZGF0YS5qcycpKCQpLFxuXG4gICAgICAgICdBcnJheURhdGEnOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2FycmF5X2RhdGEuanMnKSxcbiAgICAgICAgJ0F4aXMnOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvYXhpcy5qcycpLFxuICAgICAgICAnQXhpc0JpbmRpbmcnOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9heGlzX2JpbmRpbmcuanMnKSxcbiAgICAgICAgJ0F4aXNUaXRsZSc6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvYXhpc190aXRsZS5qcycpLFxuICAgICAgICAnQmFja2dyb3VuZCc6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9iYWNrZ3JvdW5kLmpzJyksXG4gICAgICAgICdDb25zdGFudFBsb3QnOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2NvbnN0YW50X3Bsb3QuanMnKSxcbiAgICAgICAgJ0RhdGEnOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvZGF0YS5qcycpLFxuICAgICAgICAnRGF0YUZvcm1hdHRlcic6ICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9kYXRhX2Zvcm1hdHRlci5qcycpLFxuICAgICAgICAnRGF0YU1lYXN1cmUnOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9kYXRhX21lYXN1cmUuanMnKSxcbiAgICAgICAgJ0RhdGFQbG90JzogICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvZGF0YV9wbG90LmpzJyksXG4gICAgICAgICdEYXRhVmFsdWUnOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgJ0RhdGFWYXJpYWJsZSc6ICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvZGF0YV92YXJpYWJsZS5qcycpLFxuICAgICAgICAnRGF0YXRpcHMnOiAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9kYXRhdGlwcy5qcycpLFxuICAgICAgICAnRGF0YXRpcHNWYXJpYWJsZSc6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9kYXRhdGlwc192YXJpYWJsZS5qcycpLFxuICAgICAgICAnRGF0ZXRpbWVGb3JtYXR0ZXInOiAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9kYXRldGltZV9mb3JtYXR0ZXIuanMnKSxcbiAgICAgICAgJ0RhdGV0aW1lTWVhc3VyZSc6ICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvZGF0ZXRpbWVfbWVhc3VyZS5qcycpLFxuICAgICAgICAnRGF0ZXRpbWVWYWx1ZSc6ICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9kYXRldGltZV92YWx1ZS5qcycpLFxuICAgICAgICAnRXZlbnRFbWl0dGVyJzogICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9ldmVudF9lbWl0dGVyLmpzJyksXG4gICAgICAgICdGaWx0ZXJPcHRpb24nOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2ZpbHRlcl9vcHRpb24uanMnKSxcbiAgICAgICAgJ0ZpbHRlcic6ICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvZmlsdGVyLmpzJyksXG4gICAgICAgICdHcmFwaCc6ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2dyYXBoLmpzJyksXG4gICAgICAgICdHcmlkJzogICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2dyaWQuanMnKSxcbiAgICAgICAgJ0ljb24nOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvaWNvbi5qcycpLFxuICAgICAgICAnSW1nJzogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9pbWcuanMnKSxcbiAgICAgICAgJ0xhYmVsZXInOiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvbGFiZWxlci5qcycpLFxuICAgICAgICAnTGVnZW5kJzogICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9sZWdlbmQuanMnKSxcbiAgICAgICAgJ01peGluJzogICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvbWl4aW4uanMnKSxcbiAgICAgICAgJ051bWJlckZvcm1hdHRlcic6ICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvbnVtYmVyX2Zvcm1hdHRlci5qcycpLFxuICAgICAgICAnTnVtYmVyTWVhc3VyZSc6ICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9udW1iZXJfbWVhc3VyZS5qcycpLFxuICAgICAgICAnTnVtYmVyVmFsdWUnOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9udW1iZXJfdmFsdWUuanMnKSxcbiAgICAgICAgJ1Bhbic6ICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvcGFuLmpzJyksXG4gICAgICAgICdQZXJpb2RpY0FycmF5RGF0YSc6ICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL3BlcmlvZGljX2FycmF5X2RhdGEuanMnKSxcbiAgICAgICAgJ1Bsb3QnOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvcGxvdC5qcycpLFxuICAgICAgICAnUGxvdExlZ2VuZCc6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9wbG90X2xlZ2VuZC5qcycpLFxuICAgICAgICAnUGxvdGFyZWEnOiAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9wbG90YXJlYS5qcycpLFxuICAgICAgICAnUmVuZGVyZXInOiAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9yZW5kZXJlci5qcycpLFxuICAgICAgICAnQmFuZFJlbmRlcmVyJzogICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9yZW5kZXJlcnMvYmFuZF9yZW5kZXJlci5qcycpLFxuICAgICAgICAnQmFyUmVuZGVyZXInOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9yZW5kZXJlcnMvYmFyX3JlbmRlcmVyLmpzJyksXG4gICAgICAgICdGaWxsUmVuZGVyZXInOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL3JlbmRlcmVycy9maWxsX3JlbmRlcmVyLmpzJyksXG4gICAgICAgICdQb2ludGxpbmVSZW5kZXJlcic6ICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL3JlbmRlcmVycy9wb2ludGxpbmVfcmVuZGVyZXIuanMnKSxcbiAgICAgICAgJ1JhbmdlQmFyUmVuZGVyZXInOiAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvcmVuZGVyZXJzL3JhbmdlYmFyX3JlbmRlcmVyLmpzJyksXG4gICAgICAgICdUZXh0JzogICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL3RleHQuanMnKSxcbiAgICAgICAgJ1RpdGxlJzogICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvdGl0bGUuanMnKSxcbiAgICAgICAgJ1dhcm5pbmcnOiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvd2FybmluZy5qcycpLFxuICAgICAgICAnV2ViU2VydmljZURhdGFDYWNoZU5vZGUnOiAgICAgIHJlcXVpcmUoJy4vY29yZS93ZWJfc2VydmljZV9kYXRhX2NhY2hlX25vZGUuanMnKSxcbiAgICAgICAgJ1dlYlNlcnZpY2VEYXRhSXRlcmF0b3InOiAgICAgICByZXF1aXJlKCcuL2NvcmUvd2ViX3NlcnZpY2VfZGF0YV9pdGVyYXRvci5qcycpLFxuICAgICAgICAnV2luZG93JzogICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS93aW5kb3cuanMnKSxcbiAgICAgICAgJ1pvb20nOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvem9vbS5qcycpLFxuXG4gICAgICAgICdicm93c2VySGFzQ2FudmFzU3VwcG9ydCcgOiBNdWx0aWdyYXBoLmJyb3dzZXJIYXNDYW52YXNTdXBwb3J0LFxuICAgICAgICAnYnJvd3Nlckhhc1NWR1N1cHBvcnQnICAgIDogTXVsdGlncmFwaC5icm93c2VySGFzU1ZHU3VwcG9ydFxuICAgIH0sXG5cbiAgICAnY3JlYXRlJzogTXVsdGlncmFwaC5jcmVhdGUsXG5cbiAgICAnbWF0aCc6IHtcbiAgICAgICAgJ0JveCc6IFx0XHRcdFx0cmVxdWlyZSgnLi9tYXRoL2JveC5qcycpLFxuICAgICAgICAnRGlzcGxhY2VtZW50JzogXHRyZXF1aXJlKCcuL21hdGgvZGlzcGxhY2VtZW50LmpzJyksXG4gICAgICAgICdFbnVtJzogXHRcdFx0cmVxdWlyZSgnLi9tYXRoL2VudW0uanMnKSxcbiAgICAgICAgJ0luc2V0cyc6IFx0XHRcdHJlcXVpcmUoJy4vbWF0aC9pbnNldHMuanMnKSxcbiAgICAgICAgJ1BvaW50JzogXHRcdFx0cmVxdWlyZSgnLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgICdSR0JDb2xvcic6IFx0XHRyZXF1aXJlKCcuL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgICd1dGlsJzogXHRcdFx0cmVxdWlyZSgnLi9tYXRoL3V0aWwuanMnKVxuICAgIH0sXG4gICAgJ3BhcnNlcicgOiB7XG4gICAgICAgICdqcXVlcnknIDoge1xuICAgICAgICAgICAgJ3N0cmluZ1RvSlF1ZXJ5WE1MT2JqJyA6IChyZXF1aXJlKCcuL3BhcnNlci94bWwvanF1ZXJ5X3htbF9wYXJzZXIuanMnKSgkKSkuc3RyaW5nVG9KUXVlcnlYTUxPYmpcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAndXRpbGl0eUZ1bmN0aW9ucycgOiB7XG4gICAgICAgICdnZXRLZXlzJyBcdFx0XHRcdFx0OiB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMsXG4gICAgICAgICdpbnNlcnREZWZhdWx0cycgXHRcdFx0OiB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzLFxuICAgICAgICAnZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QnIFx0OiB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNELFxuICAgICAgICBcbiAgICAgICAgJ3BhcnNlQXR0cmlidXRlJyBcdFx0XHQ6IHBhcnNpbmdGdW5jdGlvbnMucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgICdwYXJzZUludGVnZXInIFx0XHRcdFx0OiBwYXJzaW5nRnVuY3Rpb25zLnBhcnNlSW50ZWdlcixcbiAgICAgICAgJ3BhcnNlQm9vbGVhbicgXHRcdFx0XHQ6IHBhcnNpbmdGdW5jdGlvbnMucGFyc2VCb29sZWFuLFxuICAgICAgICAnZ2V0WE1MQXR0cicgXHRcdFx0XHQ6IHBhcnNpbmdGdW5jdGlvbnMuZ2V0WE1MQXR0cixcbiAgICAgICAgXG4gICAgICAgICd2YWxpZGF0ZU51bWJlclJhbmdlJyBcdFx0OiB2YWxpZGF0aW9uRnVuY3Rpb25zLnZhbGlkYXRlTnVtYmVyUmFuZ2UsXG4gICAgICAgICd0eXBlT2YnIFx0XHRcdFx0XHQ6IHZhbGlkYXRpb25GdW5jdGlvbnMudHlwZU9mXG4gICAgfSxcblxuICAgICdqZXJtYWluZSc6IHJlcXVpcmUoJy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKSxcblxuICAgICdqUXVlcnknIDogJFxufTtcbndpbmRvdy5zcHJpbnRmID0gcmVxdWlyZSgnc3ByaW50ZicpO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgQm94ID0gbmV3IGplcm1haW5lLk1vZGVsKFwiQm94XCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhc0EoXCJ3aWR0aFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5oYXNBKFwiaGVpZ2h0XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwid2lkdGhcIiwgXCJoZWlnaHRcIik7XG59KTtcbiAgICBcbm1vZHVsZS5leHBvcnRzID0gQm94O1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpLFxuICAgIHZhbGlkYXRpb25GdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKTtcblxudmFyIERpc3BsYWNlbWVudCA9IHt9O1xuLyoqXG4gKiBBIERpc3BsYWNlbWVudCByZXByZXNlbnRzIGEgZ2VvbWV0cmljIHBvc2l0aW9uIGFsb25nIGEgbGluZVxuICogc2VnbWVudCwgZXhwcmVzc2VkIGluIHRlcm1zIG9mIHR3byBxdWFudGl0aWVzOiBhIHJlbGF0aXZlXG4gKiBwb3NpdGlvbiBjYWxsZWQgYGFgLCBhbmQgYW4gYWJzb2x1dGUgb2Zmc2V0IGNhbGxlZCBgYmAuICBUaGVcbiAqIGxlbmd0aCBvZiB0aGUgbGluZSBzZWdtZW50IGlzIG5vdCBrbm93biBpbiBhZHZhbmNlIC0tLSB0aGUgaWRlYVxuICogaXMgdGhhdCB0aGUgRGlzcGxhY2VtZW50IG9iamVjdCBlbmNhcHN1bGF0ZXMgYSBydWxlIGZvclxuICogZGV0ZXJtaW5pbmcgYSBsb2NhdGlvbiBhbG9uZyBBTlkgbGluZSBzZWdtZW50LiAgVGhlIERpc3BsYWNlbWVudFxuICogaGFzIG1ldGhvZHMgd2hpY2ggdGFrZSB0aGUgbGluZSBzZWdtZW50IGxlbmd0aCBhcyBhbiBhcmd1bWVudFxuICogYW5kIHJldHVybiB0aGUgY29tcHV0ZWQgZmluYWwgcG9zaXRpb24uXG4gKlxuICogVGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgcG9zaXRpb24tY2FsY3VhdGluZyBtZXRob2RzLFxuICogY29ycmVzcG9uZGluZyB0byB0d28gZGlmZmVyZW50IGludGVycHJldGF0aW9ucyBvZiB0aGUgcmVsYXRpdmVcbiAqIHZhbHVlIGBhYDpcbiAqXG4gKiAqKnJlbGF0aXZlIGxlbmd0aCoqOlxuICogICAgIGBhYCBpcyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEsIHJlcHJlc2VudGluZyBhIGZyYWN0aW9uIG9mXG4gKiAgICAgICB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQ7IHRoZSByZWxhdGl2ZVxuICogICAgICAgcG9zaXRpb24gZGV0ZXJtaW5lZCBieSBgYWAgaXMgdGhlIGZyYWN0aW9uIGBhYCBvZiB0aGVcbiAqICAgICAgIHRvdGFsIGxlbmd0aCBvZiB0aGUgc2VnbWVudC5cbiAqICAgICBJbiB0aGlzIGNhc2UsIHRoZSBwb3NpdGlvbi1jYWxjdWxhdGluZyBtZXRob2RcbiAqICAgICAgIGBjYWxjdWxhdGVMZW5ndGgoTClgIHJldHVybnMgdGhlIG51bWJlciBgYSAqIEwgKyBiYCwgd2hpY2hcbiAqICAgICAgIGNvcnJlc3BvbmRzIHRvIG1vdmluZyBgYWAgb2YgdGhlIHdheSBhbG9uZyB0aGUgbGVuZ3RoIEwsXG4gKiAgICAgICB0aGVuIGFkZGluZyBgYmA6XG4gKlxuICogICAgICAgICAgICAgWy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWC0tLS0tLS0tLS0tLV1cbiAqICAgICAgICAgICAgIHw8LS0tLSBhICogTCAtLS0+fDwtLS0tIGIgLS0tLS0tPnxcbiAqICAgICAgICAgICAgIHw8LS0tLS0tLS0tLS0tLS0tLS0tICBMICAtLS0tLS0tLS0tLS0tLS0tLS0tLT58XG4gKlxuICogKipyZWxhdGl2ZSBjb29yZGluYXRlKio6XG4gKiAgICAgYGFgIGlzIGEgbnVtYmVyIGJldHdlZW4gLTEgYW5kIDEsIHJlcHJlc2VudGluZyBhIGNvb3JkaW5hdGVcbiAqICAgICAgIHZhbHVlIGluIGEgWy0xLDFdIGNvb3JkaW5hdGUgc3lzdGVtIGFsb25nIHRoZSBsaW5lXG4gKiAgICAgICBzZWdtZW50LlxuICogICAgIEluIHRoaXMgY2FzZSwgdGhlIHBvc2l0aW9uLWNhbGN1bGF0aW5nIG1ldGhvZFxuICogICAgICAgYGNhbGN1bGF0ZUNvb3JkaW5hdGUoTClgIHJldHVybnMgdGhlIG51bWJlciBgKGErMSkgKiBMLzIgK1xuICogICAgICAgYmAuICB3aGljaCBjb3JyZXNwb25kcyB0byBtb3ZpbmcgdG8gdGhlIHBvc2l0aW9uXG4gKiAgICAgICBkZXRlcm1pbmVkIGJ5IHRoZSBgYWAgY29vcmRpbmF0ZSwgdGhlbiBhZGRpbmcgYGJgOlxuICpcbiAqICAgICAgICAgICAgIFstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1YLS0tLS0tLS1dXG4gKiAgICAgICAgICAgICB8PC0tLSAoYSsxKSAqIEwvMiAtLS0+fDwtLS0tIGIgLS0tLS0+fFxuICogICAgICAgICAgICAgfDwtLS0tLS0tLS0tLS0tLS0tLS0gIEwgIC0tLS0tLS0tLS0tLS0tLS0tLS0tPnxcbiAqXG4gKiBAY2xhc3MgRGlzcGxhY2VtZW50XG4gKiBAZm9yIERpc3BsYWNlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gYVxuICogQHBhcmFtIHtJbnRlZ2VyfSBiIChPUFRJT05BTClcbiAqL1xuRGlzcGxhY2VtZW50ID0gbmV3IGplcm1haW5lLk1vZGVsKFwiRGlzcGxhY2VtZW50XCIsIGZ1bmN0aW9uICgpIHtcbiAgICBcbiAgICB0aGlzLmhhc0EoXCJhXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25GdW5jdGlvbnMudmFsaWRhdGVOdW1iZXJSYW5nZShhLCAtMS4wLCAxLjApO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImJcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKS5hbmQuZGVmYXVsdHNUbygwKTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwiYVwiLCBcIiViXCIpO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiY2FsY3VsYXRlTGVuZ3RoXCIsIGZ1bmN0aW9uICh0b3RhbExlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hKCkgKiB0b3RhbExlbmd0aCArIHRoaXMuYigpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiY2FsY3VsYXRlQ29vcmRpbmF0ZVwiLCBmdW5jdGlvbiAodG90YWxMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmEoKSArIDEpICogdG90YWxMZW5ndGgvMi4wICsgdGhpcy5iKCk7XG4gICAgfSk7XG5cbn0pO1xuXG5EaXNwbGFjZW1lbnQucmVnRXhwID0gL14oW1xcK1xcLV0/WzAtOVxcLl0rKShbK1xcLV0pKFswLTlcXC4rXFwtXSspJC87XG5cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIGludG8gYSBEaXNwbGFjZW1lbnQuICBUaGUgc3RyaW5nIHNob3VsZCBiZSBvZiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAqXG4gKiAgICAgXCJBK0JcIiAgPT0+ICBhPUEgIGI9QlxuICogICAgIFwiQS1CXCIgID09PiAgYT1BICBiPS1CXG4gKiAgICAgXCJBXCIgICAgPT0+ICBhPUEgIGI9MFxuICogICAgIFwiK0FcIiAgID09PiAgYT1BICBiPTBcbiAqICAgICBcIi1BXCIgICA9PT4gIGE9LUEgYj0wXG4gKiBcbiAqIElmIHRoZSBpbnB1dCBhcmd1bWVudCBpcyBub3QgYSBzdHJpbmcsIGl0IGlzIGNvZXJjZWQgaW50byBvbmUuXG4gKi9cbkRpc3BsYWNlbWVudC5wYXJzZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mKHN0cmluZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3RyaW5nID0gU3RyaW5nKHN0cmluZyk7XG4gICAgfVxuICAgIHZhciBhciA9IERpc3BsYWNlbWVudC5yZWdFeHAuZXhlYyhzdHJpbmcpLFxuICAgICAgICBkLFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBzaWduO1xuICAgIGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkID0gbmV3IERpc3BsYWNlbWVudCgxKTtcbiAgICB9IGVsc2UgaWYgKGFyICE9PSBudWxsKSB7XG4gICAgICAgIGEgPSBwYXJzZUZsb2F0KGFyWzFdKTtcbiAgICAgICAgYiA9IHBhcnNlRmxvYXQoYXJbM10pO1xuICAgICAgICBzd2l0Y2ggKGFyWzJdKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICBzaWduID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzaWduID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICBpZiAoaXNOYU4oYSkgfHwgc2lnbiA9PSAwIHx8IGlzTmFOKGIpKSB7XG4gICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigncGFyc2UgZXJyb3InKTtcbiAgICAgICAgIH1cbiAgICAgICAgICovXG4gICAgICAgIGQgPSBuZXcgRGlzcGxhY2VtZW50KGEsIHNpZ24gKiBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhID0gcGFyc2VGbG9hdChzdHJpbmcpO1xuICAgICAgICAvKm5cbiAgICAgICAgIGlmIChpc05hTihhKSkge1xuICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoJ3BhcnNlIGVycm9yJyk7XG4gICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICBkID0gbmV3IERpc3BsYWNlbWVudChhKTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BsYWNlbWVudDtcbiIsIi8vIFVzZSBFbnVtIHRvIGNyZWF0ZSBvYmplY3RzIHRoYXQgYWN0IGxpa2UgZW51bWVyYXRpb25zIGluIG90aGVyIGxhbmd1YWdlcyAoc3VjaCBhcyBKYXZhKS5cbi8vIFxuLy8gVXNhZ2UgaXMgbGlrZSB0aGlzOlxuLy8gXG4vLyAgIHZhciBTdWl0ID0gRW51bShcIlN1aXRcIik7XG4vLyAgIHZhciBjbHVicyA9IG5ldyBTdWl0KFwiY2x1YnNcIik7XG4vLyAgIHZhciBkaWFtb25kcyA9IG5ldyBTdWl0KFwiZGlhbW9uZHNcIik7XG4vLyAgIHZhciBzcGFkZXMgPSBuZXcgU3VpdChcInNwYWRlc1wiKTtcbi8vICAgdmFyIGhlYXJ0cyA9IG5ldyBTdWl0KFwiaGVhcnRzXCIpO1xuLy8gXG4vLyAgIHZhciBjID0gU3VpdC5wYXJzZShcImNsdWJzXCIpOyAgIyBjIGlzIGd1YXJhbnRlZWQgdG8gZXF1YWwgdGhlIGNsdWJzIHZhcmlhYmxlIGZyb20gYWJvdmVcbi8vIFxudmFyIEVudW0gPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgdmFyIGluc3RhbmNlcyA9IHt9O1xuXG4gICAgdmFyIEVudW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChpbnN0YW5jZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0IHRvIHJlZGVmaW5lIFwiK25hbWUrXCIgRW51bSB3aXRoIGtleSAnXCIra2V5K1wiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVudW1UeXBlID0gbmFtZTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIGluc3RhbmNlc1trZXldID0gdGhpcztcbiAgICB9O1xuXG4gICAgRW51bS5wYXJzZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlc1trZXldO1xuICAgIH07XG5cbiAgICBFbnVtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgIH07XG5cbiAgICBFbnVtLmlzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiAob2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsICYmIG9iai5lbnVtVHlwZSA9PT0gbmFtZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBFbnVtO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbnVtO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgSW5zZXRzID0gbmV3IGplcm1haW5lLk1vZGVsKFwiSW5zZXRzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhc0EoXCJ0b3BcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQShcImxlZnRcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQShcImJvdHRvbVwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5oYXNBKFwicmlnaHRcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInNldFwiLCBmdW5jdGlvbiAodG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0KSB7XG4gICAgICAgIHRoaXMudG9wKHRvcCk7XG4gICAgICAgIHRoaXMubGVmdChsZWZ0KTtcbiAgICAgICAgdGhpcy5ib3R0b20oYm90dG9tKTtcbiAgICAgICAgdGhpcy5yaWdodChyaWdodCk7XG4gICAgfSk7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInRvcFwiLCBcImxlZnRcIiwgXCJib3R0b21cIiwgXCJyaWdodFwiKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluc2V0cztcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIFBvaW50ID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUG9pbnRcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcInhcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQShcInlcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJ4XCIsIFwieVwiKTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJlcVwiLCBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLngoKT09PXAueCgpKSAmJiAodGhpcy55KCk9PT1wLnkoKSkpO1xuICAgIH0pO1xufSk7XG5cbnZhciByZWdFeHAgPSAvXlxccyooWzAtOVxcLVxcK1xcLmVFXSspKCx8XFxzK3xcXHMqLFxccyt8XFxzKyxcXHMqKShbMC05XFwtXFwrXFwuZUVdKylcXHMqJC87XG5cblBvaW50LnBhcnNlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciBhciA9IHJlZ0V4cC5leGVjKHN0cmluZyksXG4gICAgICAgIHA7XG4gICAgLy8gYXJbMV0gaXMgeCB2YWx1ZVxuICAgIC8vIGFyWzJdIGlzIHNlcGFyYXRvciBiZXR3ZWVuIHggYW5kIHlcbiAgICAvLyBhclszXSBpcyB5IHZhbHVlXG4gICAgXG4gICAgaWYgKCFhciB8fCAoYXIubGVuZ3RoICE9PSA0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgcGFyc2Ugc3RyaW5nICdcIitzdHJpbmcrXCInIGFzIGEgUG9pbnRcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9pbnQocGFyc2VGbG9hdChhclsxXSksIHBhcnNlRmxvYXQoYXJbM10pKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIHZhbGlkYXRpb25GdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKTtcblxudmFyIFJHQkNvbG9yID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUkdCQ29sb3JcIiwgZnVuY3Rpb24gKCkge1xuICAgIFxuICAgIHRoaXMuaGFzQShcInJcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkZ1bmN0aW9ucy52YWxpZGF0ZU51bWJlclJhbmdlKHIsIDAsIDEuMCk7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiZ1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uRnVuY3Rpb25zLnZhbGlkYXRlTnVtYmVyUmFuZ2UoZywgMCwgMS4wKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJiXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25GdW5jdGlvbnMudmFsaWRhdGVOdW1iZXJSYW5nZShiLCAwLCAxLjApO1xuICAgIH0pO1xuICAgIFxuICAgIHZhciBudW1iZXJUb0hleCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgbnVtYmVyID0gcGFyc2VJbnQobnVtYmVyICogMjU1LCAxMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAobnVtYmVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbnVtYmVyID0gXCIwXCIgKyBudW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucmVzcG9uZHNUbyhcImdldEhleFN0cmluZ1wiLCBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgIGlmICghcHJlZml4KSB7XG4gICAgICAgICAgICBwcmVmaXggPSBcIjB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZWZpeCArIG51bWJlclRvSGV4KHRoaXMucigpKSArIG51bWJlclRvSGV4KHRoaXMuZygpKSArIG51bWJlclRvSGV4KHRoaXMuYigpKTtcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJ0b1JHQkFcIiwgZnVuY3Rpb24gKGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbHBoYSA9IDEuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKGFscGhhKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUkdCQ29sb3IudG9SR0JBOiBUaGUgYXJndW1lbnQsIGlmIHByZXNlbnQsIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwicmdiYShcIiArICgyNTUqdGhpcy5yKCkpICsgXCIsIFwiICsgKDI1NSp0aGlzLmcoKSkgKyBcIiwgXCIgKyAoMjU1KnRoaXMuYigpKSArIFwiLCBcIiArIGFscGhhICsgXCIpXCI7XG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZXFcIiwgZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMucigpPT09Y29sb3IucigpKSAmJiAodGhpcy5nKCk9PT1jb2xvci5nKCkpICYmICh0aGlzLmIoKT09PWNvbG9yLmIoKSkpO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJyXCIsIFwiZ1wiLCBcImJcIik7XG4gICAgXG59KTtcblxuXG4vKlxuICogVG8gcmVtb3ZlIHN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgY29sb3IgbmFtZXMsIHJlbW92ZSB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uLFxuICogYW5kIGZpbmQgYWxsIHJlZmVyZW5jZXMgdG8gaXQgZWxzZXdoZXJlIGluIHRoZSBzb3VyY2UgY29kZSwgYW5kIHJlbW92ZSB0aGVtLFxuICogYWxvbmcgd2l0aCBhY2NvbXBhbnlpbmcgY29kZSB0aGF0IGdlbmVyYXRlcyB3YXJuaW5nIG1lc3NhZ2UuICBBbHNvIHJlbW92ZVxuICogc3VwcG9ydCBmb3IgdGhlc2UgOSBjb2xvciBuYW1lcyBmcm9tIFJHQkNvbG9yLnBhcnNlIGJlbG93LlxuICovXG5SR0JDb2xvci5jb2xvck5hbWVJc0RlcHJlY2F0ZWQgPSBmdW5jdGlvbiAoY29sb3JOYW1lKSB7XG4gICAgc3dpdGNoIChjb2xvck5hbWUpIHtcbiAgICBjYXNlIFwiZ3JleVwiOiByZXR1cm4gXCIweGVlZWVlZVwiO1xuICAgIGNhc2UgXCJza3libHVlXCI6IHJldHVybiBcIjB4ODdjZWViXCI7XG4gICAgY2FzZSBcImtoYWtpXCI6IHJldHVybiBcIjB4ZjBlNjhjXCI7XG4gICAgY2FzZSBcIm9yYW5nZVwiOiByZXR1cm4gXCIweGZmYTUwMFwiO1xuICAgIGNhc2UgXCJzYWxtb25cIjogcmV0dXJuIFwiMHhmYTgwNzJcIjtcbiAgICBjYXNlIFwib2xpdmVcIjogcmV0dXJuIFwiMHg5YWNkMzJcIjtcbiAgICBjYXNlIFwic2llbm5hXCI6IHJldHVybiBcIjB4YTA1MjJkXCI7XG4gICAgY2FzZSBcInBpbmtcIjogcmV0dXJuIFwiMHhmZmI1YzVcIjtcbiAgICBjYXNlIFwidmlvbGV0XCI6IHJldHVybiBcIjB4ZWU4MmVlXCI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblJHQkNvbG9yLnBhcnNlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHJlZCxcbiAgICAgICAgZ3JlZW4sXG4gICAgICAgIGJsdWUsXG4gICAgICAgIGdyZXksXG4gICAgICAgIHBhcnNlZElucHV0LFxuICAgICAgICBjb2xvck9iajtcbiAgICBcbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXJzZWRJbnB1dCA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIFxuICAgICAgICBzd2l0Y2ggKHBhcnNlZElucHV0KSB7XG4gICAgICAgIGNhc2UgXCJibGFja1wiOlxuICAgICAgICAgICAgcmVkID0gMDtcbiAgICAgICAgICAgIGdyZWVuID0gMDtcbiAgICAgICAgICAgIGJsdWUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWRcIjpcbiAgICAgICAgICAgIHJlZCA9IDE7XG4gICAgICAgICAgICBncmVlbiA9IDA7XG4gICAgICAgICAgICBibHVlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ3JlZW5cIjpcbiAgICAgICAgICAgIHJlZCA9IDA7XG4gICAgICAgICAgICBncmVlbiA9IDE7XG4gICAgICAgICAgICBibHVlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmx1ZVwiOlxuICAgICAgICAgICAgcmVkID0gMDtcbiAgICAgICAgICAgIGdyZWVuID0gMDtcbiAgICAgICAgICAgIGJsdWUgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ5ZWxsb3dcIjpcbiAgICAgICAgICAgIHJlZCA9IDE7XG4gICAgICAgICAgICBncmVlbiA9IDE7XG4gICAgICAgICAgICBibHVlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWFnZW50YVwiOlxuICAgICAgICAgICAgcmVkID0gMTtcbiAgICAgICAgICAgIGdyZWVuID0gMDtcbiAgICAgICAgICAgIGJsdWUgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjeWFuXCI6XG4gICAgICAgICAgICByZWQgPSAwO1xuICAgICAgICAgICAgZ3JlZW4gPSAxO1xuICAgICAgICAgICAgYmx1ZSA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndoaXRlXCI6XG4gICAgICAgICAgICByZWQgPSAxO1xuICAgICAgICAgICAgZ3JlZW4gPSAxO1xuICAgICAgICAgICAgYmx1ZSA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImdyZXlcIjpcbiAgICAgICAgICAgIGdyZXkgPSBwYXJzZUludChcImVlXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIHJlZCA9IGdyZXk7XG4gICAgICAgICAgICBncmVlbiA9IGdyZXk7XG4gICAgICAgICAgICBibHVlID0gZ3JleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2t5Ymx1ZVwiOlxuICAgICAgICAgICAgcmVkID0gcGFyc2VJbnQoXCI4N1wiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBncmVlbiA9IHBhcnNlSW50KFwiY2VcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgYmx1ZSA9IHBhcnNlSW50KFwiZWJcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJraGFraVwiOlxuICAgICAgICAgICAgcmVkID0gcGFyc2VJbnQoXCJmMFwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBncmVlbiA9IHBhcnNlSW50KFwiZTZcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgYmx1ZSA9IHBhcnNlSW50KFwiOGNcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvcmFuZ2VcIjpcbiAgICAgICAgICAgIHJlZCA9IHBhcnNlSW50KFwiZmZcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgZ3JlZW4gPSBwYXJzZUludChcImE1XCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGJsdWUgPSBwYXJzZUludChcIjAwXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2FsbW9uXCI6XG4gICAgICAgICAgICByZWQgPSBwYXJzZUludChcImZhXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQoXCI4MFwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBibHVlID0gcGFyc2VJbnQoXCI3MlwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9saXZlXCI6XG4gICAgICAgICAgICByZWQgPSBwYXJzZUludChcIjlhXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQoXCJjZFwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBibHVlID0gcGFyc2VJbnQoXCIzMlwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNpZW5uYVwiOlxuICAgICAgICAgICAgcmVkID0gcGFyc2VJbnQoXCJhMFwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBncmVlbiA9IHBhcnNlSW50KFwiNTJcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgYmx1ZSA9IHBhcnNlSW50KFwiMmRcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwaW5rXCI6XG4gICAgICAgICAgICByZWQgPSBwYXJzZUludChcImZmXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQoXCJiNVwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBibHVlID0gcGFyc2VJbnQoXCJjNVwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInZpb2xldFwiOlxuICAgICAgICAgICAgcmVkID0gcGFyc2VJbnQoXCJlZVwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBncmVlbiA9IHBhcnNlSW50KFwiODJcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgYmx1ZSA9IHBhcnNlSW50KFwiZWVcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IHBhcnNlZElucHV0LnJlcGxhY2UoLygwKHh8WCl8IykvLCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dC5zZWFyY2gobmV3IFJlZ0V4cCgvKFteMC05YS1mXSkvKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ1wiICsgaW5wdXQgKyBcIicgaXMgbm90IGEgdmFsaWQgY29sb3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dC5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgICAgICByZWQgPSBwYXJzZUludChwYXJzZWRJbnB1dC5zdWJzdHJpbmcoMCwyKSwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQocGFyc2VkSW5wdXQuc3Vic3RyaW5nKDIsNCksIDE2KSAvIDI1NTtcbiAgICAgICAgICAgICAgICBibHVlID0gcGFyc2VJbnQocGFyc2VkSW5wdXQuc3Vic3RyaW5nKDQsNiksIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VkSW5wdXQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmVkID0gcGFyc2VJbnQocGFyc2VkSW5wdXQuY2hhckF0KDApLCAxNikgLyAxNTtcbiAgICAgICAgICAgICAgICBncmVlbiA9IHBhcnNlSW50KHBhcnNlZElucHV0LmNoYXJBdCgxKSwgMTYpIC8gMTU7XG4gICAgICAgICAgICAgICAgYmx1ZSA9IHBhcnNlSW50KHBhcnNlZElucHV0LmNoYXJBdCgyKSwgMTYpIC8gMTU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidcIiArIGlucHV0ICsgXCInIGlzIG5vdCBhIHZhbGlkIGNvbG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29sb3JPYmogPSBuZXcgUkdCQ29sb3IocmVkLCBncmVlbiwgYmx1ZSk7XG4gICAgICAgIHJldHVybiBjb2xvck9iajtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiJ1wiICsgaW5wdXQgKyBcIicgaXMgbm90IGEgdmFsaWQgY29sb3JcIik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJHQkNvbG9yO1xuIiwiVXRpbCA9IHt9O1xuXG5VdGlsLmludGVycCA9IGZ1bmN0aW9uICh4LCB4MCwgeDEsIHkwLCB5MSkge1xuICAgIC8vIHJldHVybiB0aGUgJ3knIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IG9uIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAvLyBjb25uZWN0aW5nIHRoZSB0d28gcG9pbnRzICh4MCx5MCkgYW5kICh4MSx5MSkgd2hvc2UgJ3gnXG4gICAgLy8gY29vcmRpbmF0ZSBpcyB4XG4gICAgcmV0dXJuIHkwICsgKCh5MSAtIHkwKSAqICh4IC0geDApKSAvICh4MSAtIHgwKTtcbn07XG5cblV0aWwuc2FmZV9pbnRlcnAgPSBmdW5jdGlvbiAoeCwgeDAsIHgxLCB5MCwgeTEpIHtcbiAgICAvLyBzYW1lIGFzIFwiaW50ZXJwXCIsIGJ1dCBpZiB0aGUgbGluZSBpcyB2ZXJ0aWNhbCAoeDAgPT09IHgxKSwgcmV0dXJuXG4gICAgLy8gdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byB5IHZhbHVlcywgcmF0aGVyIHRoYW4gTmFOXG4gICAgaWYgKHgwID09PSB4MSkgeyByZXR1cm4gKHkwICsgeTEpIC8gMjsgfVxuICAgIHJldHVybiBVdGlsLmludGVycCh4LCB4MCwgeDEsIHkwLCB5MSk7XG59O1xuXG5VdGlsLmwyZGlzdCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBkeCA9IHgxIC0geDI7XG4gICAgdmFyIGR5ID0geTEgLSB5MjtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsO1xuIiwiXG4vLyAgXCJob3Jpem9udGFsYXhpc1wiIDoge1xuLy8gICAgXCJpZFwiIDogU1RSSU5HLCBcInR5cGVcIiA6IERBVEFUWVBFKG51bWJlciksIFwibGVuZ3RoXCIgOiBSRUxMRU4oMS4wKSwgXCJiYXNlXCIgOiBQT0lOVCgtMSwxKSwgXCJhbmNob3JcIiA6IERPVUJMRSgtMSksIFwicG9zaXRpb25cIiA6IFBPSU5UKDAsMCksXG4vLyAgICBcIm1pblwiIDogREFUQVZBTFVFT1JBVVRPKGF1dG8pLCBcIm1heFwiIDogREFUQVZBTFVFT1JBVVRPKGF1dG8pLCBcIm1pbnBvc2l0aW9uXCIgOiBSRUxQT1MoLTEuMCksIFwibWF4cG9zaXRpb25cIiA6IFJFTFBPUygxLjApLCBcImNvbG9yXCIgOiBDT0xPUihibGFjayksIFwibGluZXdpZHRoXCIgOiBJTlRFR0VSKDEpLFxuLy8gICAgXCJ0aWNrbWluXCIgOiBJTlRFR0VSKC0zKSwgXCJ0aWNrbWF4XCIgOiBJTlRFR0VSKDMpLCBcInRpY2tjb2xvclwiIDogQ09MT1IoYmxhY2spLFxuLy8gICAgXCJsYWJlbHNcIiA6IHtcbi8vICAgICAgIFwiZm9ybWF0XCIgOiBTVFJJTkcsIFwic3RhcnRcIiA6IERBVEFWQUxVRSgwKSwgXCJhbmdsZVwiIDogRE9VQkxFKDApLCBcInBvc2l0aW9uXCIgOiBQT0lOVCxcbi8vICAgICAgIFwiYW5jaG9yXCIgOiBQT0lOVCwgXCJjb2xvclwiIDogQ09MT1IoYmxhY2spLCBcInNwYWNpbmdcIiA6IFNUUklORywgXCJkZW5zaXR5ZmFjdG9yXCIgOiBET1VCTEUoMS4wKSxcbi8vICAgICAgIFwibGFiZWxcIiA6IFtcbi8vICAgICAgICAgICB7IFwiZm9ybWF0XCIgOiBTVFJJTkcsIFwic3RhcnRcIiA6IFNUUklORywgXCJhbmdsZVwiIDogRE9VQkxFLCBcInBvc2l0aW9uXCIgOiBQT0lOVCwgXCJhbmNob3JcIiA6IFBPSU5ULCBcInNwYWNpbmdcIiA6IFNUUklORywgXCJkZW5zaXR5ZmFjdG9yXCIgOiBET1VCTEUgfSxcbi8vICAgICAgICAgICB7IFwiZm9ybWF0XCIgOiBTVFJJTkcsIFwic3RhcnRcIiA6IFNUUklORywgXCJhbmdsZVwiIDogRE9VQkxFLCBcInBvc2l0aW9uXCIgOiBQT0lOVCwgXCJhbmNob3JcIiA6IFBPSU5ULCBcInNwYWNpbmdcIiA6IFNUUklORywgXCJkZW5zaXR5ZmFjdG9yXCIgOiBET1VCTEUgfSxcbi8vICAgICAgICAgICAuLi5cbi8vICAgICAgICBdXG4vLyAgICB9XG4vLyAgICBcInRpdGxlXCIgOiB7IFwiYmFzZVwiIDogRE9VQkxFKDApLCBcImFuY2hvclwiIDogUE9JTlQsIFwicG9zaXRpb25cIiA6IFBPSU5ULCBcImFuZ2xlXCIgOiBET1VCTEUoMCksIFwidGV4dFwiIDogXCJUSVRMRVRFWFRcIiwgXCJmb250XCI6IFNUUklORyB9LFxuLy8gICAgXCJncmlkXCIgOiB7IFwiY29sb3JcIiA6IENPTE9SKDB4ZWVlZWVlKSwgXCJ2aXNpYmxlXCIgOiBCT09MRUFOKGZhbHNlKSB9LFxuLy8gICAgXCJwYW5cIiA6IHsgXCJhbGxvd2VkXCIgOiBCT09MRUFOKHllcyksIFwibWluXCIgOiBEQVRBVkFMVUUsIFwibWF4XCIgOiBEQVRBVkFMVUUgfSxcbi8vICAgIFwiem9vbVwiIDogeyBcImFsbG93ZWRcIiA6IEJPT0xFQU4oeWVzKSwgXCJtaW5cIiA6IERBVEFNRUFTVVJFLCBcIm1heFwiIDogREFUQU1FQVNVUkUsIFwiYW5jaG9yXCIgOiBEQVRBVkFMVUUgfSxcbi8vICAgIFwiYmluZGluZ1wiIDogeyBcImlkXCIgOiBTVFJJTkchLCBcIm1pblwiIDogREFUQVZBTFVFISwgXCJtYXhcIiA6IERBVEFWQUxVRSEgfVxuLy8gICAgXCJ2aXNpYmxlXCIgOiBCT09MRUFOKHRydWUpXG4vLyAgfVxuXG5cbi8vIHRoZXNlIGFyZSBuZWVkZWQgc28gdGhhdCB0aGVpciAucGFyc2VKU09OIG1ldGhvZHMgd2lsbCBiZSBkZWZpbmVkIHdoZW4gY2FsbGVkIGJlbG93OlxucmVxdWlyZSgnLi9sYWJlbGVyLmpzJyk7XG5yZXF1aXJlKCcuL2F4aXNfdGl0bGUuanMnKTtcbnJlcXVpcmUoJy4vZ3JpZC5qcycpO1xucmVxdWlyZSgnLi9wYW4uanMnKTtcbnJlcXVpcmUoJy4vem9vbS5qcycpO1xuXG52YXIgQXhpcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpcy5qcycpLFxuICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgdkYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKSxcbiAgICB1RiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpO1xuXG52YXIgcGFyc2VMYWJlbHMgPSBmdW5jdGlvbiAoanNvbiwgYXhpcykge1xuICAgIHZhciBzcGFjaW5ncyxcbiAgICAgICAgbGFiZWxlcnMgID0gYXhpcy5sYWJlbGVycygpLFxuICAgICAgICBMYWJlbGVyID0gcmVxdWlyZSgnLi4vLi4vY29yZS9sYWJlbGVyLmpzJyksXG4gICAgICAgIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgICAgICBpO1xuXG4gICAgc3BhY2luZ3MgPSBbXTtcbiAgICBpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChqc29uLnNwYWNpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3BhY2luZ3MgPSB2Ri50eXBlT2YoanNvbi5zcGFjaW5nKSA9PT0gJ2FycmF5JyA/IGpzb24uc3BhY2luZyA6IFsganNvbi5zcGFjaW5nIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwYWNpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgc3BhY2luZyBhdHRyIG9uIHRoZSA8bGFiZWxzPiB0YWcsIGNyZWF0ZSBhIG5ldyBsYWJlbGVyIGZvclxuICAgICAgICAvLyBlYWNoIHNwYWNpbmcgcHJlc2VudCBpbiBpdCwgdXNpbmcgdGhlIG90aGVyIHZhbHVlcyBmcm9tIHRoZSA8bGFiZWxzPiB0YWdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsYWJlbGVycy5hZGQoTGFiZWxlci5wYXJzZUpTT04oanNvbiwgYXhpcywgdW5kZWZpbmVkLCBzcGFjaW5nc1tpXSkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGFiZWwubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgPGxhYmVsPiB0YWdzLCBwYXJzZSB0aGUgPGxhYmVscz4gdGFnIHRvIGdldCBkZWZhdWx0IHZhbHVlc1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSBMYWJlbGVyLnBhcnNlSlNPTihqc29uLCBheGlzLCB1bmRlZmluZWQsIG51bGwpO1xuICAgICAgICAvLyBBbmQgbG9vcCBvdmVyIGVhY2ggPGxhYmVsPiB0YWcsIGNyZWF0aW5nIGxhYmVsZXJzIGZvciBlYWNoLCBzcGxpdHRpbmcgbXVsdGlwbGVcbiAgICAgICAgLy8gc3BhY2luZ3Mgb24gdGhlIHNhbWUgPGxhYmVsPiB0YWcgaW50byBtdWx0aXBsZSBsYWJlbGVyczpcbiAgICAgICAganNvbi5sYWJlbC5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBzcGFjaW5nID0gW107XG4gICAgICAgICAgICBpZiAoZS5zcGFjaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzcGFjaW5nID0gdkYudHlwZU9mKGUuc3BhY2luZykgPT09ICdhcnJheScgPyBlLnNwYWNpbmcgOiBbIGUuc3BhY2luZyBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BhY2luZy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICBsYWJlbGVycy5hZGQoIExhYmVsZXIucGFyc2VKU09OKGUsIGF4aXMsIGRlZmF1bHRzLCBzKSApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgbGFiZWxlcnMgdXNpbmcgdGhlIGRlZmF1bHQgc3BhY2luZywgd2l0aCB0aGUgb3RoZXIgdmFsdWVzXG4gICAgICAgIC8vIGZyb20gdGhlIDxsYWJlbHM+IHRhZ1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlcyA9ICh1Ri5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpKS5ob3Jpem9udGFsYXhpcy5sYWJlbHM7XG4gICAgICAgIHZhciBkZWZhdWx0U3BhY2luZ3MgPSBheGlzLnR5cGUoKSA9PT0gRGF0YVZhbHVlLk5VTUJFUiA/XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlcy5kZWZhdWx0TnVtYmVyU3BhY2luZyA6XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlcy5kZWZhdWx0RGF0ZXRpbWVTcGFjaW5nO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVmYXVsdFNwYWNpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsYWJlbGVycy5hZGQoTGFiZWxlci5wYXJzZUpTT04oanNvbiwgYXhpcywgdW5kZWZpbmVkLCBkZWZhdWx0U3BhY2luZ3NbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuQXhpcy5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbiwgb3JpZW50YXRpb24sIG1lc3NhZ2VIYW5kbGVyLCBtdWx0aWdyYXBoKSB7XG5cbiAgICB2YXIgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpLFxuICAgICAgICBSR0JDb2xvciA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgIERpc3BsYWNlbWVudCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvZGlzcGxhY2VtZW50LmpzJyksXG4gICAgICAgIEF4aXNUaXRsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpc190aXRsZS5qcycpLFxuICAgICAgICBHcmlkID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ncmlkLmpzJyksXG4gICAgICAgIFBhbiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGFuLmpzJyksXG4gICAgICAgIFpvb20gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3pvb20uanMnKSxcbiAgICAgICAgQXhpc0JpbmRpbmcgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2F4aXNfYmluZGluZy5qcycpLFxuXG4gICAgICAgIGF4aXMgICAgICAgICAgICAgID0gbmV3IEF4aXMob3JpZW50YXRpb24pLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBwYXJzZURpc3BsYWNlbWVudCA9IERpc3BsYWNlbWVudC5wYXJzZSxcbiAgICAgICAgcGFyc2VKU09OUG9pbnQgICAgPSBmdW5jdGlvbihwKSB7IHJldHVybiBuZXcgUG9pbnQocFswXSwgcFsxXSk7IH0sXG4gICAgICAgIHBhcnNlUkdCQ29sb3IgICAgID0gUkdCQ29sb3IucGFyc2UsXG4gICAgICAgIGF0dHIsIGNoaWxkLFxuICAgICAgICB2YWx1ZTtcblxuICAgIGlmIChqc29uKSB7XG5cbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5pZCwgICAgIGF4aXMuaWQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnR5cGUsICAgYXhpcy50eXBlLCAgIERhdGFWYWx1ZS5wYXJzZVR5cGUpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmxlbmd0aCwgYXhpcy5sZW5ndGgsIHBhcnNlRGlzcGxhY2VtZW50KTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHByb3ZpZGVzIHN1cHBvcnQgZm9yIHRoZSBkZXByZWNhdGVkIFwicG9zaXRpb25iYXNlXCIgYXhpcyBhdHRyaWJ1dGU7XG4gICAgICAgIC8vIE1VR0wgZmlsZXMgc2hvdWxkIHVzZSB0aGUgXCJiYXNlXCIgYXR0cmlidXRlIGluc3RlYWQuICBXaGVuIHdlJ3JlIHJlYWR5IHRvIHJlbW92ZVxuICAgICAgICAvLyBzdXBwb3J0IGZvciB0aGUgZGVwcmVjYXRlZCBhdHRyaWJ1dGUsIGRlbGV0ZSB0aGlzIGJsb2NrIG9mIGNvZGU6XG4gICAgICAgIC8vXG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25iYXNlID0ganNvbi5wb3NpdGlvbmJhc2U7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25iYXNlKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIud2FybmluZygnVXNlIG9mIGRlcHJlY2F0ZWQgYXhpcyBhdHRyaWJ1dGUgXCJwb3NpdGlvbmJhc2VcIjsgdXNlIFwiYmFzZVwiIGF0dHJpYnV0ZSBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgaWYgKChwb3NpdGlvbmJhc2UgPT09IFwibGVmdFwiKSB8fCAocG9zaXRpb25iYXNlID09PSBcImJvdHRvbVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBheGlzLmJhc2UobmV3IFBvaW50KC0xLCAtMSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb25iYXNlID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5iYXNlKG5ldyBQb2ludCgxLCAtMSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb25iYXNlID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMuYmFzZShuZXcgUG9pbnQoLTEsIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0oKSk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEVuZCBvZiBjb2RlIHRvIGRlbGV0ZSB3aGVuIHJlbW92aW5nIHN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgXCJwb3NpdGlvbmJhc2VcIlxuICAgICAgICAvLyBhdHRyaWJ1dGUuXG4gICAgICAgIC8vXG5cbiAgICAgICAgYXR0ciA9IGpzb24ucG9zaXRpb247XG4gICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoYXR0cikgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBheGlzLnBvc2l0aW9uKHBhcnNlSlNPTlBvaW50KGF0dHIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcG9zaXRpb24gaXMgbm90IGFuIGFycmF5LCBhbmQgaWYgaXQgY2FuIGJlIGludGVycHJldGVkXG4gICAgICAgICAgICAgICAgLy8gYXMgYSBudW1iZXIsIGNvbnN0cnVjdCB0aGUgcG9zaXRpb24gcG9pbnQgYnkgaW50ZXJwcmV0aW5nIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBudW1iZXIgYXMgYW4gb2Zmc2V0IGZyb20gdGhlIDAgbG9jYXRpb24gYWxvbmcgdGhlIHBlcnBlbmRpY3VsYXJcbiAgICAgICAgICAgICAgICAvLyBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgICAgaWYgKHZGLmlzTnVtYmVyTm90TmFOKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gQXhpcy5IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLnBvc2l0aW9uKG5ldyBQb2ludCgwLCBhdHRyKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLnBvc2l0aW9uKG5ldyBQb2ludChhdHRyLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHBvc2l0aW9uICdcIithdHRyK1wiJyBpcyBvZiB0aGUgd3JvbmcgdHlwZTsgaXQgc2hvdWxkIGJlIGEgbnVtYmVyIG9yIGEgcG9pbnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90ZTogd2UgY29lcmNlIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgdG8gc3RyaW5ncyBoZXJlLCBiZWNhdXNlIHRoZSBcIm1pblwiIGFuZCBcIm1heFwiIGF0dHJzXG4gICAgICAgIC8vIG9mIHRoZSBBeGlzIG9iamVjdCByZXF1aXJlIHN0cmluZ3MuICBTZWUgdGhlIGNvbW1lbnRzIGFib3V0IHRoZXNlIHByb3BlcnRpZXMgaW4gc3JjL2NvcmUvYXhpcy5qc1xuICAgICAgICAvLyBmb3IgYSBkaXNjdXNzaW9uIG9mIHdoeSB0aGlzIGlzIHRoZSBjYXNlLlxuICAgICAgICBpZiAoXCJtaW5cIiBpbiBqc29uKSB7XG4gICAgICAgICAgICBheGlzLm1pbih1Ri5jb2VyY2VUb1N0cmluZyhqc29uLm1pbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzLm1pbigpICE9PSBcImF1dG9cIikge1xuICAgICAgICAgICAgYXhpcy5kYXRhTWluKERhdGFWYWx1ZS5wYXJzZShheGlzLnR5cGUoKSwgYXhpcy5taW4oKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm1heFwiIGluIGpzb24pIHtcbiAgICAgICAgICAgIGF4aXMubWF4KHVGLmNvZXJjZVRvU3RyaW5nKGpzb24ubWF4KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXMubWF4KCkgIT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICBheGlzLmRhdGFNYXgoRGF0YVZhbHVlLnBhcnNlKGF4aXMudHlwZSgpLCBheGlzLm1heCgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnByZWdhcCwgICAgICAgICBheGlzLnByZWdhcCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ucG9zdGdhcCwgICAgICAgIGF4aXMucG9zdGdhcCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYW5jaG9yLCAgICAgICAgIGF4aXMuYW5jaG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5iYXNlLCAgICAgICAgICAgYXhpcy5iYXNlLCAgICAgICAgICAgcGFyc2VKU09OUG9pbnQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm1pbnBvc2l0aW9uLCAgICBheGlzLm1pbnBvc2l0aW9uLCAgICBwYXJzZURpc3BsYWNlbWVudCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubWF4cG9zaXRpb24sICAgIGF4aXMubWF4cG9zaXRpb24sICAgIHBhcnNlRGlzcGxhY2VtZW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5taW5vZmZzZXQsICAgICAgYXhpcy5taW5vZmZzZXQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm1heG9mZnNldCwgICAgICBheGlzLm1heG9mZnNldCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uY29sb3IsICAgICAgICAgIGF4aXMuY29sb3IsICAgICAgICAgIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnRpY2tjb2xvciwgICAgICBheGlzLnRpY2tjb2xvciwgICAgICBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi50aWNrd2lkdGgsICAgICAgYXhpcy50aWNrd2lkdGgpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnRpY2ttaW4sICAgICAgICBheGlzLnRpY2ttaW4pO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnRpY2ttYXgsICAgICAgICBheGlzLnRpY2ttYXgpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmhpZ2hsaWdodHN0eWxlLCBheGlzLmhpZ2hsaWdodHN0eWxlKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5saW5ld2lkdGgsICAgICAgYXhpcy5saW5ld2lkdGgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKFwidGl0bGVcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGpzb24udGl0bGUpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi50aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICBheGlzLnRpdGxlKG5ldyBBeGlzVGl0bGUoYXhpcykpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50aXRsZShBeGlzVGl0bGUucGFyc2VKU09OKHt9LCBheGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXhpcy50aXRsZShBeGlzVGl0bGUucGFyc2VKU09OKGpzb24udGl0bGUsIGF4aXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF4aXMudGl0bGUobmV3IEF4aXNUaXRsZShheGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoanNvbi5ncmlkKSB7XG4gICAgICAgICAgICBheGlzLmdyaWQoR3JpZC5wYXJzZUpTT04oanNvbi5ncmlkKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoanNvbi52aXNpYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF4aXMudmlzaWJsZShqc29uLnZpc2libGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwicGFuXCIgaW4ganNvbikge1xuICAgICAgICAgICAgYXhpcy5wYW4oUGFuLnBhcnNlSlNPTihqc29uLnBhbiwgYXhpcy50eXBlKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcInpvb21cIiBpbiBqc29uKSB7XG4gICAgICAgICAgICBheGlzLnpvb20oWm9vbS5wYXJzZUpTT04oanNvbi56b29tLCBheGlzLnR5cGUoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGpzb24ubGFiZWxzKSB7XG4gICAgICAgICAgICBwYXJzZUxhYmVscyhqc29uLmxhYmVscywgYXhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoanNvbi5iaW5kaW5nKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZ01pbkRhdGFWYWx1ZSA9IERhdGFWYWx1ZS5wYXJzZShheGlzLnR5cGUoKSwganNvbi5iaW5kaW5nLm1pbiksXG4gICAgICAgICAgICAgICAgYmluZGluZ01heERhdGFWYWx1ZSA9IERhdGFWYWx1ZS5wYXJzZShheGlzLnR5cGUoKSwganNvbi5iaW5kaW5nLm1heCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGpzb24uYmluZGluZy5pZCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGF4aXMgYmluZGluZyBpZDogJ1wiICsganNvbi5iaW5kaW5nLmlkICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEgRGF0YVZhbHVlLmlzSW5zdGFuY2UoYmluZGluZ01pbkRhdGFWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGF4aXMgYmluZGluZyBtaW46ICdcIiArIGpzb24uYmluZGluZy5taW4gKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISBEYXRhVmFsdWUuaXNJbnN0YW5jZShiaW5kaW5nTWF4RGF0YVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXhpcyBiaW5kaW5nIG1heDogJ1wiICsganNvbi5iaW5kaW5nLm1heCArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEF4aXNCaW5kaW5nLmZpbmRCeUlkT3JDcmVhdGVOZXcoanNvbi5iaW5kaW5nLmlkKS5hZGRBeGlzKGF4aXMsIGJpbmRpbmdNaW5EYXRhVmFsdWUsIGJpbmRpbmdNYXhEYXRhVmFsdWUsIG11bHRpZ3JhcGgpO1xuICAgICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIGF4aXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aXM7XG4iLCJ2YXIgQXhpc1RpdGxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzX3RpdGxlLmpzJyk7XG5cbi8vIFwidGl0bGVcIiB7IFwiYmFzZVwiOiAyMy4yLCBcImFuY2hvclwiOiBbMTIsIDRdLCBcInBvc2l0aW9uXCI6IFszLCA3XSwgXCJhbmdsZVwiOiA0NSwgXCJ0ZXh0XCIgOiBcInRlbXBlcmF0dXJlXCIsIFwiZm9udFwiIDogXCJSb2JvdG9cIiB9XG4vLyBlbXB0eSB0aXRsZTpcbi8vICAgXCJ0aXRsZVwiIHt9XG4vLyAgIFwidGl0bGVcIiB7XCJ0ZXh0XCIgOiBcIlwiIH1cbkF4aXNUaXRsZS5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbiwgYXhpcykge1xuICAgIHZhciB0aXRsZSA9IG5ldyBBeGlzVGl0bGUoYXhpcyksXG4gICAgICAgIFRleHQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RleHQuanMnKSxcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJykucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIG5vbkVtcHR5VGl0bGUgPSBmYWxzZSxcbiAgICAgICAgcGFyc2VKU09OUG9pbnQgPSBmdW5jdGlvbihwKSB7IHJldHVybiBuZXcgUG9pbnQocFswXSwgcFsxXSk7IH0sXG4gICAgICAgIHRleHQ7XG5cbiAgICBpZiAoanNvbikge1xuICAgICAgICB0ZXh0ID0ganNvbi50ZXh0O1xuICAgICAgICBpZiAodGV4dCAhPT0gXCJcIiAmJiB0ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpdGxlLmNvbnRlbnQobmV3IFRleHQodGV4dCkpO1xuICAgICAgICAgICAgbm9uRW1wdHlUaXRsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5hbmNob3IsICAgdGl0bGUuYW5jaG9yLCAgIHBhcnNlSlNPTlBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5iYXNlLCAgICAgdGl0bGUuYmFzZSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ucG9zaXRpb24sIHRpdGxlLnBvc2l0aW9uLCBwYXJzZUpTT05Qb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYW5nbGUsICAgIHRpdGxlLmFuZ2xlKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5mb250LCAgICB0aXRsZS5mb250KTtcbiAgICB9XG5cbiAgICBpZiAobm9uRW1wdHlUaXRsZSA9PT0gdHJ1ZSkgeyBcbiAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlzVGl0bGU7XG4iLCJ2YXIgQmFja2dyb3VuZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYmFja2dyb3VuZC5qcycpO1xuXG4vLyBcImJhY2tncm91bmRcIiA6IHtcbi8vICAgXCJjb2xvclwiOiBcIiNmZmZmMDBcIixcbi8vICAgXCJpbWdcIiA6IHsgXCJzcmNcIjogXCJmb28ucG5nXCIsIFwiYW5jaG9yXCI6IFstMSwgNV0sIFwiYmFzZVwiOiBbMywgMTJdLCBcInBvc2l0aW9uXCI6IFstMiwgM10sIFwiZnJhbWVcIjogXCJwYWRkaW5nXCIgfVxuLy8gfVxuQmFja2dyb3VuZC5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbiwgbXVsdGlncmFwaCkge1xuICAgIHZhciBiYWNrZ3JvdW5kICAgICAgID0gbmV3IEJhY2tncm91bmQoKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgSW1nICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvaW1nLmpzJyksXG4gICAgICAgIGNoaWxkO1xuXG4gICAgaWYgKGpzb24pIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5jb2xvciwgYmFja2dyb3VuZC5jb2xvciwgUkdCQ29sb3IucGFyc2UpO1xuICAgICAgICBpZiAoanNvbi5pbWcpIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQuaW1nKEltZy5wYXJzZUpTT04oanNvbi5pbWcsIG11bHRpZ3JhcGgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFja2dyb3VuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2dyb3VuZDtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgRGF0YSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YS5qcycpO1xuXG4gICAgLy8gaWYgcGFyc2VYTUwgbWV0aG9kIGFscmVhZHkgaGFzIGJlZW4gZGVmaW5lZCwgd2hpY2ggd291bGQgYmUgdGhlIGNhc2UgaWYgdGhpc1xuICAgIC8vIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGNhbGxlZCwganVzdCByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICBpZiAodHlwZW9mKERhdGEucGFyc2VKU09OKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gRGF0YTsgfTtcblxuICAgIC8vIFwiZGF0YVwiIDoge1xuICAgIC8vICAgXCJhZGFwdGVyXCIgICAgICA6IFNUUklORyxcbiAgICAvLyAgIFwibWlzc2luZ3ZhbHVlXCIgOiBcIkRBVEFWQUxVRVwiLFxuICAgIC8vICAgXCJtaXNzaW5nb3BcIiAgICA6IFwiQ09NUEFSQVRPUlwiPixcbiAgICAvLyAgIFwidmFyaWFibGVzXCIgOiBbXG4gICAgLy8gICAgICAgICB7IFwiaWRcIiA6IFNUUklORyEsIFwiY29sdW1uXCIgOiBJTlRFR0VSLCBcInR5cGVcIiA6IERBVEFUWVBFKG51bWJlciksIFwibWlzc2luZ3ZhbHVlXCIgOiBTVFJJTkcsIFwibWlzc2luZ29wXCIgOiBDT01QQVJBVE9SIH1cbiAgICAvLyAgICAgICAgIHsgXCJpZFwiIDogU1RSSU5HISwgXCJjb2x1bW5cIiA6IElOVEVHRVIsIFwidHlwZVwiIDogREFUQVRZUEUobnVtYmVyKSwgXCJtaXNzaW5ndmFsdWVcIiA6IFNUUklORywgXCJtaXNzaW5nb3BcIiA6IENPTVBBUkFUT1IgfVxuICAgIC8vICAgICAgICAgLi4uXG4gICAgLy8gICBdLFxuICAgIC8vICAgXCJyZXBlYXRcIiA6IHsgXCJwZXJpb2RcIiA6IFNUUklORyB9LFxuICAgIC8vICAgXCJyZXBlYXRcIiA6IFNUUklORyxcbiAgICAvLyAgIFwidmFsdWVzXCIgOiBbXG4gICAgLy8gICAgICBbIDMuMiwgMS40LCAuLi5dLFxuICAgIC8vICAgICAgWyA1LjEsIDcuOCwgLi4uXSxcbiAgICAvLyAgICAgIC4uLlxuICAgIC8vICAgXSxcbiAgICAvLyAgIFwiY3N2XCIgOiBTVFJJTkcsXG4gICAgLy8gICBcImNzdlwiIDogeyBcImxvY2F0aW9uXCIgOiBTVFJJTkcgfSxcbiAgICAvLyAgIFwic2VydmljZVwiIDogU1RSSU5HLFxuICAgIC8vICAgXCJzZXJ2aWNlXCIgOiB7XG4gICAgLy8gICAgICAgXCJsb2NhdGlvblwiIDogU1RSSU5HIVxuICAgIC8vICAgICAgIFwiZm9ybWF0XCIgICA6IFNUUklOR1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBEYXRhLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBtdWx0aWdyYXBoLCBtZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB2YXIgQXJyYXlEYXRhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9hcnJheV9kYXRhLmpzJyksXG4gICAgICAgICAgICBEYXRhVmFyaWFibGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFyaWFibGUuanMnKSxcbiAgICAgICAgICAgIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX21lYXN1cmUuanMnKSxcbiAgICAgICAgICAgIFBlcmlvZGljQXJyYXlEYXRhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wZXJpb2RpY19hcnJheV9kYXRhLmpzJyksXG4gICAgICAgICAgICBDU1ZEYXRhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jc3ZfZGF0YS5qcycpKCQpLFxuICAgICAgICAgICAgV2ViU2VydmljZURhdGEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3dlYl9zZXJ2aWNlX2RhdGEuanMnKSgkKSxcbiAgICAgICAgICAgIE11bHRpZ3JhcGggPSByZXF1aXJlKCcuLi8uLi9jb3JlL211bHRpZ3JhcGguanMnKSgkKSxcbiAgICAgICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgICAgICB2RiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpLFxuICAgICAgICAgICAgdUYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgICAgIGRlZmF1bHRNaXNzaW5ndmFsdWVTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0TWlzc2luZ29wU3RyaW5nLFxuICAgICAgICAgICAgZGF0YVZhcmlhYmxlcyA9IFtdLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGFkYXAsIGFkYXB0ZXIgPSBBcnJheURhdGE7XG5cbiAgICAgICAgcmVxdWlyZSgnLi9kYXRhX3ZhcmlhYmxlLmpzJyk7IC8vIHNvIHRoYXQgRGF0YVZhcmlhYmxlLnBhcnNlSlNPTiBtZXRob2QgaXMgZGVmaW5lZCB3aGVuIG5lZWRlZCBiZWxvd1xuXG4gICAgICAgIGlmIChqc29uKSB7XG5cbiAgICAgICAgICAgIGFkYXAgPSBqc29uLmFkYXB0ZXI7XG4gICAgICAgICAgICBpZiAoYWRhcCAhPT0gdW5kZWZpbmVkICYmIGFkYXAgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBhZGFwdGVyID0gTXVsdGlncmFwaC5nZXREYXRhQWRhcHRlcihhZGFwKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRhcHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZGF0YSBhZGFwYXRlcjogXCIgKyBhZGFwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJlIHN1cmUgdG8gbGVhdmUgZGVmYXVsdE1pc3Npbmd2YWx1ZVN0cmluZyB1bmRlZmluZWQgaWZcbiAgICAgICAgICAgIC8vIGpzb24ubWlzc2luZ3ZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIHRoZSBTdHJpbmcgY2FzdFxuICAgICAgICAgICAgLy8gaGVyZSB3aWxsIHJlc3VsdCBpbiB0aGUgc3RyaW5nIFwidW5kZWZpbmVkXCIsIHdoaWNoIHdyZWFrcyBoYXZvYyFcbiAgICAgICAgICAgIGlmIChqc29uLm1pc3Npbmd2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRNaXNzaW5ndmFsdWVTdHJpbmcgPSB1Ri5jb2VyY2VUb1N0cmluZyhqc29uLm1pc3Npbmd2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0TWlzc2luZ29wU3RyaW5nICAgID0ganNvbi5taXNzaW5nb3A7XG5cbiAgICAgICAgICAgIGlmIChqc29uLnZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIGpzb24udmFyaWFibGVzLmZvckVhY2goZnVuY3Rpb24odmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVZhcmlhYmxlcy5wdXNoKERhdGFWYXJpYWJsZS5wYXJzZUpTT04odmFyaWFibGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSA8cmVwZWF0PiBzZWN0aW9uLCBhbmQgaWYgc28sIGdyYWIgdGhlIHBlcmlvZCBmcm9tIGl0XG4gICAgICAgICAgICB2YXIgaGF2ZVJlcGVhdCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBlcmlvZDtcbiAgICAgICAgICAgIGlmIChcInJlcGVhdFwiIGluIGpzb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVyaW9kUHJvcCA9ICh2Ri50eXBlT2YoanNvbi5yZXBlYXQpID09PSAnb2JqZWN0JykgPyBqc29uLnJlcGVhdC5wZXJpb2QgOiBqc29uLnJlcGVhdDtcbiAgICAgICAgICAgICAgICBpZiAocGVyaW9kUHJvcCA9PT0gdW5kZWZpbmVkIHx8IHBlcmlvZFByb3AgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIud2FybmluZyhcInJlcGVhdCByZXF1aXJlcyBhIHBlcmlvZDsgZGF0YSB0cmVhdGVkIGFzIG5vbi1yZXBlYXRpbmdcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kID0gRGF0YU1lYXN1cmUucGFyc2UoZGF0YVZhcmlhYmxlc1swXS50eXBlKCksIHBlcmlvZFByb3ApO1xuICAgICAgICAgICAgICAgICAgICBoYXZlUmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSA8dmFsdWVzPiBzZWN0aW9uLCBwYXJzZSBpdCBhbmQgcmV0dXJuIGFuIEFycmF5RGF0YSBpbnN0YW5jZTpcbiAgICAgICAgICAgIGlmIChqc29uLnZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhpcyBkb2VzIG5vdCB1c2UgdGhlIGRhdGEgYWRhcHRlciAtLSBub3Qgc3VwcG9ydGVkIGZvciBpbmxpbmUganNvbiBkYXRhXG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlcyA9IGpzb24udmFsdWVzO1xuICAgICAgICAgICAgICAgIGlmIChoYXZlUmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgUGVyaW9kaWNBcnJheURhdGEoZGF0YVZhcmlhYmxlcywgc3RyaW5nVmFsdWVzLCBwZXJpb2QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgQXJyYXlEYXRhKGRhdGFWYXJpYWJsZXMsIHN0cmluZ1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgPGNzdj4gc2VjdGlvbiwgcGFyc2UgaXQgYW5kIHJldHVybiBhIENTVkRhdGEgaW5zdGFuY2U6XG4gICAgICAgICAgICBpZiAoanNvbi5jc3YpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSAodkYudHlwZU9mKGpzb24uY3N2KSA9PT0gJ29iamVjdCcpID8ganNvbi5jc3YubG9jYXRpb24gOiBqc29uLmNzdjtcbiAgICAgICAgICAgICAgICBkYXRhID0gbmV3IENTVkRhdGEoZGF0YVZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlncmFwaCA/IG11bHRpZ3JhcGgucmViYXNlVXJsKGZpbGVuYW1lKSA6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlncmFwaCA/IG11bHRpZ3JhcGguZ2V0QWpheFRocm90dGxlKGZpbGVuYW1lKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSA8c2VydmljZT4gc2VjdGlvbiwgcGFyc2UgaXQgYW5kIHJldHVybiBhIFdlYlNlcnZpY2VEYXRhIGluc3RhbmNlOlxuICAgICAgICAgICAgaWYgKGpzb24uc2VydmljZSkge1xuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9ICh2Ri50eXBlT2YoanNvbi5zZXJ2aWNlKSA9PT0gJ29iamVjdCcpID8ganNvbi5zZXJ2aWNlLmxvY2F0aW9uIDoganNvbi5zZXJ2aWNlO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgV2ViU2VydmljZURhdGEoZGF0YVZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZ3JhcGggPyBtdWx0aWdyYXBoLnJlYmFzZVVybChsb2NhdGlvbikgOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlncmFwaCA/IG11bHRpZ3JhcGguZ2V0QWpheFRocm90dGxlKGxvY2F0aW9uKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLnNlcnZpY2UpID09PSAnb2JqZWN0JyAmJiAoXCJmb3JtYXRcIiBpbiBqc29uLnNlcnZpY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9ybWF0KGpzb24uc2VydmljZS5mb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIGpzb24gY29udGFpbnMgYW4gXCJpZFwiIHByb3BlcnR5LCBwYXNzIGl0IG9uIHRvIG91ciBkYXRhIG9iamVjdDpcbiAgICAgICAgICAgIGlmIChcImlkXCIgaW4ganNvbikge1xuICAgICAgICAgICAgICAgIGRhdGEuaWQoanNvbi5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRNaXNzaW5ndmFsdWVTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZGVmYXVsdE1pc3Npbmd2YWx1ZShkZWZhdWx0TWlzc2luZ3ZhbHVlU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZhdWx0TWlzc2luZ29wU3RyaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmRlZmF1bHRNaXNzaW5nb3AoZGVmYXVsdE1pc3NpbmdvcFN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmFkYXB0ZXIoYWRhcHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGF0YTtcbn07XG5cblxuIiwidmFyIERhdGFWYXJpYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YXJpYWJsZS5qcycpO1xuXG4vLyAgXCJ2YXJpYWJsZVwiIDoge1xuLy8gICAgICBcImlkXCIgICAgICAgICAgIDogU1RSSU5HISxcbi8vICAgICAgXCJjb2x1bW5cIiAgICAgICA6IElOVEVHRVIsXG4vLyAgICAgIFwidHlwZVwiICAgICAgICAgOiBEQVRBVFlQRShudW1iZXIpLFxuLy8gICAgICBcIm1pc3Npbmd2YWx1ZVwiIDogU1RSSU5HLFxuLy8gICAgICBcIm1pc3NpbmdvcFwiICAgIDogQ09NUEFSQVRPUixcbi8vICB9XG5EYXRhVmFyaWFibGUucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24sIGRhdGEpIHtcbiAgICB2YXIgdmFyaWFibGUsXG4gICAgICAgIHBGICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIERhdGFWYWx1ZSAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIGF0dHI7XG5cbiAgICBpZiAoanNvbiAmJiBqc29uLmlkKSB7XG4gICAgICAgIHZhcmlhYmxlID0gbmV3IERhdGFWYXJpYWJsZShqc29uLmlkKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5jb2x1bW4sICAgICAgIHZhcmlhYmxlLmNvbHVtbik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24udHlwZSwgICAgICAgICB2YXJpYWJsZS50eXBlLCAgICAgICAgIERhdGFWYWx1ZS5wYXJzZVR5cGUpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm1pc3Npbmd2YWx1ZSwgdmFyaWFibGUubWlzc2luZ3ZhbHVlLCBmdW5jdGlvbih2KSB7IHJldHVybiBEYXRhVmFsdWUucGFyc2UodmFyaWFibGUudHlwZSgpLCB2KTsgfSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubWlzc2luZ29wLCAgICB2YXJpYWJsZS5taXNzaW5nb3AsICAgIERhdGFWYWx1ZS5wYXJzZUNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gdmFyaWFibGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWYXJpYWJsZTtcbiIsInZhciBEYXRhdGlwcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YXRpcHMuanMnKTtcblxuLy8gXCJkYXRhdGlwc1wiIDoge1xuLy8gICBcImZvcm1hdFwiICAgICAgICAgICA6IFwiU1RSSU5HIVwiLFxuLy8gICBcImJnY29sb3JcIiAgICAgICAgICA6IFwiQ09MT1JcIixcbi8vICAgXCJiZ2FscGhhXCIgICAgICAgICAgOiBcIkRPVUJMRVwiLFxuLy8gICBcImJvcmRlclwiICAgICAgICAgICA6IFwiSU5URUdFUlwiLFxuLy8gICBcImJvcmRlcmNvbG9yXCIgICAgICA6IFwiQ09MT1JcIixcbi8vICAgXCJwYWRcIiAgICAgICAgICAgICAgOiBcIklOVEVHRVJcIixcbi8vICAgXCJ2YXJpYWJsZS1mb3JtYXRzXCIgOiBbIFwiU1RSSU5HIVwiLCAuLi4gXVxuLy8gfVxuRGF0YXRpcHMucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICB2YXIgZGF0YXRpcHMgICAgICAgICA9IG5ldyBEYXRhdGlwcygpLFxuICAgICAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgRGF0YXRpcHNWYXJpYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YXRpcHNfdmFyaWFibGUuanMnKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICB1RiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHBhcnNlUkdCQ29sb3IgICAgPSBSR0JDb2xvci5wYXJzZSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBwYXJzZUludGVnZXIgICAgID0gcEYucGFyc2VJbnRlZ2VyLFxuICAgICAgICBjaGlsZDtcbiAgICBpZiAoanNvbikge1xuICAgICAgICBpZiAoanNvbltcInZhcmlhYmxlLWZvcm1hdHNcIl0pIHtcbiAgICAgICAgICAgIGpzb25bXCJ2YXJpYWJsZS1mb3JtYXRzXCJdLmZvckVhY2goZnVuY3Rpb24oZm10KSB7XG4gICAgICAgICAgICAgICAgdmFyIGR0diA9IG5ldyBEYXRhdGlwc1ZhcmlhYmxlKCk7XG4gICAgICAgICAgICAgICAgZHR2LmZvcm1hdFN0cmluZyhmbXQpO1xuICAgICAgICAgICAgICAgIGRhdGF0aXBzLnZhcmlhYmxlcygpLmFkZChkdHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uZm9ybWF0LCAgICAgIGRhdGF0aXBzLmZvcm1hdFN0cmluZyk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYmdjb2xvciwgICAgIGRhdGF0aXBzLmJnY29sb3IsICAgICBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5iZ2FscGhhLCAgICAgZGF0YXRpcHMuYmdhbHBoYSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYm9yZGVyLCAgICAgIGRhdGF0aXBzLmJvcmRlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYm9yZGVyY29sb3IsIGRhdGF0aXBzLmJvcmRlcmNvbG9yLCBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5wYWQsICAgICAgICAgZGF0YXRpcHMucGFkKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGF0aXBzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhdGlwcztcbiIsInZhciBGaWx0ZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ZpbHRlci5qcycpO1xuXG4vLyBcImZpbHRlclwiIDoge1xuLy8gICBcInR5cGVcIjogXCJTVFJJTkdcIlxuLy8gICBcIm9wdGlvbnNcIiA6IFtcbi8vICAgICB7IFwibmFtZVwiIDogXCJTVFJJTkchXCIsIFwidmFsdWVcIiA6IFwiU1RSSU5HIVwiIH0sXG4vLyAgICAgeyBcIm5hbWVcIiA6IFwiU1RSSU5HIVwiLCBcInZhbHVlXCIgOiBcIlNUUklORyFcIiB9XG4vLyAgICAgLi4uXG4vLyAgIH1cbi8vIH1cbkZpbHRlci5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciBmaWx0ZXIgPSBuZXcgRmlsdGVyKCksXG4gICAgICAgIEZpbHRlck9wdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZmlsdGVyX29wdGlvbi5qcycpLFxuICAgICAgICBwRiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICB1RiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgICAgICBvO1xuXG4gICAgcmVxdWlyZSgnLi9maWx0ZXJfb3B0aW9uLmpzJyk7IC8vIHNvIHRoYXQgRmlsdGVyT3B0aW9uLnBhcnNlSlNPTiB3aWxsIGV4aXN0IGJlbG93XG5cbiAgICBpZiAoanNvbikge1xuICAgICAgICBpZiAoanNvbi5vcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKG9wdCBpbiBqc29uLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5vcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbyA9IG5ldyBGaWx0ZXJPcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgby5uYW1lKG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIG8udmFsdWUodUYuY29lcmNlVG9TdHJpbmcoanNvbi5vcHRpb25zW29wdF0pKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLm9wdGlvbnMoKS5hZGQoIG8gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwRi5wYXJzZUF0dHJpYnV0ZShqc29uLnR5cGUsIGZpbHRlci50eXBlKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbHRlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyO1xuIiwidmFyIEZpbHRlck9wdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZmlsdGVyX29wdGlvbi5qcycpO1xuXG4vLyBcIm9wdGlvblwiIDogeyBcIm5hbWVcIiA6IFwiU1RSSU5HIVwiLCAgXCJ2YWx1ZVwiIDogXCJTVFJJTkchXCIgfVxuRmlsdGVyT3B0aW9uLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgdmFyIHBGICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICB1RiAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgb3B0aW9uID0gbmV3IEZpbHRlck9wdGlvbigpO1xuICAgIGlmIChqc29uKSB7XG4gICAgICAgIG9wdGlvbi5uYW1lKGpzb24ubmFtZSk7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4ganNvbiAmJiBqc29uLnZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAvLyBjb2VyY2UgdG8gc3RyaW5nIHNpbmNlIFwidmFsdWVcIiBhdHRyIG9mIGZpbHRlcl9vcHRpb24gaXMgb2YgdHlwZSBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbi52YWx1ZSh1Ri5jb2VyY2VUb1N0cmluZyhqc29uLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyT3B0aW9uO1xuIiwiLy8gVGhpcyBmaWxlIHVzZXMgalF1ZXJ5LiAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZVxuLy8gZnVuY3Rpb24gcmV0dXJuZWQgYnkgcmVxdWlyaW5nIHRoaXMgZmlsZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIHZhciBHcmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZ3JhcGguanMnKSxcbiAgICAgICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKTtcblxuICAgIC8vIGlmIHBhcnNlSlNPTiBtZXRob2QgYWxyZWFkeSBoYXMgYmVlbiBkZWZpbmVkLCB3aGljaCB3b3VsZCBiZSB0aGUgY2FzZSBpZiB0aGlzXG4gICAgLy8gZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkLCBqdXN0IHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0eXBlb2YoR3JhcGgucGFyc2VKU09OKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gR3JhcGg7IH07XG5cbiAgICBHcmFwaC5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbiwgbXVsdGlncmFwaCwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGdyYXBoID0gbmV3IEdyYXBoKCksXG4gICAgICAgICAgICBBeGlzICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpcy5qcycpLFxuICAgICAgICAgICAgV2luZG93ID0gcmVxdWlyZSgnLi4vLi4vY29yZS93aW5kb3cuanMnKSxcbiAgICAgICAgICAgIExlZ2VuZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbGVnZW5kLmpzJyksXG4gICAgICAgICAgICBCYWNrZ3JvdW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9iYWNrZ3JvdW5kLmpzJyksXG4gICAgICAgICAgICBQbG90YXJlYSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGxvdGFyZWEuanMnKSxcbiAgICAgICAgICAgIENvbnNlY3V0aXZlRGlzdGFuY2VGaWx0ZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbnNlY3V0aXZlX2Rpc3RhbmNlX2ZpbHRlci5qcycpLFxuICAgICAgICAgICAgVGl0bGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RpdGxlLmpzJyksXG4gICAgICAgICAgICBEYXRhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhLmpzJyksXG4gICAgICAgICAgICBQbG90ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wbG90LmpzJyksXG4gICAgICAgICAgICB1RiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgICAgICAgICAgdkYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKSxcbiAgICAgICAgICAgIGRlZmF1bHRzID0gdUYuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICAgICAgICAgIGNoaWxkO1xuXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlc2Ugb2JqZWN0cycgLnBhcnNlSlNPTiBtZXRob2RzIHdpbGwgZXhpc3Qgd2hlbiBuZWVkZWQgYmVsb3c6XG4gICAgICAgIHJlcXVpcmUoJy4vd2luZG93LmpzJyk7XG4gICAgICAgIHJlcXVpcmUoJy4vbGVnZW5kLmpzJyk7XG4gICAgICAgIHJlcXVpcmUoJy4vYmFja2dyb3VuZC5qcycpO1xuICAgICAgICByZXF1aXJlKCcuL3Bsb3RhcmVhLmpzJyk7XG4gICAgICAgIHJlcXVpcmUoJy4vdGl0bGUuanMnKTtcbiAgICAgICAgcmVxdWlyZSgnLi9heGlzLmpzJyk7XG4gICAgICAgIHJlcXVpcmUoJy4vZGF0YS5qcycpKCQpO1xuICAgICAgICByZXF1aXJlKCcuL3Bsb3QuanMnKTtcblxuICAgICAgICBncmFwaC5tdWx0aWdyYXBoKG11bHRpZ3JhcGgpO1xuICAgICAgICBpZiAoanNvbikge1xuXG4gICAgICAgICAgICBpZiAoanNvbi53aW5kb3cpIHtcbiAgICAgICAgICAgICAgICBncmFwaC53aW5kb3coIFdpbmRvdy5wYXJzZUpTT04oanNvbi53aW5kb3cpICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcImxlZ2VuZFwiIGluIGpzb24pIHtcbiAgICAgICAgICAgICAgICBncmFwaC5sZWdlbmQoIExlZ2VuZC5wYXJzZUpTT04oanNvbi5sZWdlbmQpICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyYXBoLmxlZ2VuZCggTGVnZW5kLnBhcnNlSlNPTigpICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqc29uLmJhY2tncm91bmQpIHtcbiAgICAgICAgICAgICAgICBncmFwaC5iYWNrZ3JvdW5kKCBCYWNrZ3JvdW5kLnBhcnNlSlNPTihqc29uLmJhY2tncm91bmQsIGdyYXBoLm11bHRpZ3JhcGgoKSkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpzb24ucGxvdGFyZWEpIHtcbiAgICAgICAgICAgICAgICBncmFwaC5wbG90YXJlYSggUGxvdGFyZWEucGFyc2VKU09OKGpzb24ucGxvdGFyZWEpICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqc29uLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGgudGl0bGUoIFRpdGxlLnBhcnNlSlNPTihqc29uLnRpdGxlLCBncmFwaCkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFwiZmlsdGVyXCIgaW4ganNvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24uZmlsdGVyKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mKGpzb24uZmlsdGVyLnR5cGUpICE9PSAndW5kZWZpbmVkJykgJiYgKGpzb24uZmlsdGVyLnR5cGUgIT09ICdjb25zZWN1dGl2ZWRpc3RhbmNlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZmlsdGVyIHR5cGU6ICcgKyBqc29uLmZpbHRlci50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLmZpbHRlcihuZXcgQ29uc2VjdXRpdmVEaXN0YW5jZUZpbHRlcihqc29uLmZpbHRlcikpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLmZpbHRlcikgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWx0ZXIgcHJvcGVydHk6ICcgKyBqc29uLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb24uZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguZmlsdGVyKG5ldyBDb25zZWN1dGl2ZURpc3RhbmNlRmlsdGVyKHt9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhheGVzID0ganNvbi5ob3Jpem9udGFsYXhpcyA/IGpzb24uaG9yaXpvbnRhbGF4aXMgOiBqc29uLmhvcml6b250YWxheGVzO1xuICAgICAgICAgICAgaWYgKGpzb24uaG9yaXpvbnRhbGF4aXMgJiYganNvbi5ob3Jpem9udGFsYXhlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdyYXBoIG1heSBub3QgaGF2ZSBib3RoICdob3Jpem9udGFsYXhpcycgYW5kICdob3Jpem9udGFsYXhlcydcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGF4ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGhheGVzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICBoYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLmF4ZXMoKS5hZGQoIEF4aXMucGFyc2VKU09OKGF4aXMsIEF4aXMuSE9SSVpPTlRBTCwgbWVzc2FnZUhhbmRsZXIsIGdyYXBoLm11bHRpZ3JhcGgoKSkgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguYXhlcygpLmFkZCggQXhpcy5wYXJzZUpTT04oaGF4ZXMsIEF4aXMuSE9SSVpPTlRBTCwgbWVzc2FnZUhhbmRsZXIsIGdyYXBoLm11bHRpZ3JhcGgoKSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YXhlcyA9IGpzb24udmVydGljYWxheGlzID8ganNvbi52ZXJ0aWNhbGF4aXMgOiBqc29uLnZlcnRpY2FsYXhlcztcbiAgICAgICAgICAgIGlmIChqc29uLnZlcnRpY2FsYXhpcyAmJiBqc29uLnZlcnRpY2FsYXhlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdyYXBoIG1heSBub3QgaGF2ZSBib3RoICd2ZXJ0aWNhbGF4aXMnIGFuZCAndmVydGljYWxheGVzJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YXhlcykge1xuICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YodmF4ZXMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZheGVzLmZvckVhY2goZnVuY3Rpb24oYXhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguYXhlcygpLmFkZCggQXhpcy5wYXJzZUpTT04oYXhpcywgQXhpcy5WRVJUSUNBTCwgbWVzc2FnZUhhbmRsZXIsIGdyYXBoLm11bHRpZ3JhcGgoKSkgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguYXhlcygpLmFkZCggQXhpcy5wYXJzZUpTT04odmF4ZXMsIEF4aXMuVkVSVElDQUwsIG1lc3NhZ2VIYW5kbGVyLCBncmFwaC5tdWx0aWdyYXBoKCkpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZEFqYXhUaHJvdHRsZSh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gICAgPSB0LnBhdHRlcm4gICAgPyB0LnBhdHRlcm4gICAgOiBkZWZhdWx0cy50aHJvdHRsZS5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0cyAgID0gdC5yZXF1ZXN0cyAgID8gdC5yZXF1ZXN0cyAgIDogZGVmYXVsdHMudGhyb3R0bGUucmVxdWVzdHMsXG4gICAgICAgICAgICAgICAgICAgIHBlcmlvZCAgICAgPSB0LnBlcmlvZCAgICAgPyB0LnBlcmlvZCAgICAgOiBkZWZhdWx0cy50aHJvdHRsZS5wZXJpb2QsXG4gICAgICAgICAgICAgICAgICAgIGNvbmN1cnJlbnQgPSB0LmNvbmN1cnJlbnQgPyB0LmNvbmN1cnJlbnQgOiBkZWZhdWx0cy50aHJvdHRsZS5jb25jdXJyZW50O1xuICAgICAgICAgICAgICAgIG11bHRpZ3JhcGguYWRkQWpheFRocm90dGxlKHBhdHRlcm4sIHJlcXVlc3RzLCBwZXJpb2QsIGNvbmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRocm90dGxlcyA9IGpzb24udGhyb3R0bGUgPyBqc29uLnRocm90dGxlIDoganNvbi50aHJvdHRsZXM7XG4gICAgICAgICAgICBpZiAoanNvbi50aHJvdHRsZSAmJiBqc29uLnRocm90dGxlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdyYXBoIG1heSBub3QgaGF2ZSBib3RoICd0aHJvdHRsZScgYW5kICd0aHJvdHRsZXMnXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRocm90dGxlcykge1xuICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YodGhyb3R0bGVzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZXMuZm9yRWFjaChhZGRBamF4VGhyb3R0bGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEFqYXhUaHJvdHRsZSh0aHJvdHRsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpzb24uZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi5kYXRhKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICBqc29uLmRhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5kYXRhKCkuYWRkKCBEYXRhLnBhcnNlSlNPTihkYXRhLCBncmFwaC5tdWx0aWdyYXBoKCksIG1lc3NhZ2VIYW5kbGVyKSApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFwaC5kYXRhKCkuYWRkKCBEYXRhLnBhcnNlSlNPTihqc29uLmRhdGEsIGdyYXBoLm11bHRpZ3JhcGgoKSwgbWVzc2FnZUhhbmRsZXIpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGxvdHMgPSBqc29uLnBsb3QgPyBqc29uLnBsb3QgOiBqc29uLnBsb3RzO1xuICAgICAgICAgICAgaWYgKGpzb24ucGxvdCAmJiBqc29uLnBsb3RzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ3JhcGggbWF5IG5vdCBoYXZlIGJvdGggJ3Bsb3QnIGFuZCAncGxvdHMnXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsb3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihwbG90cykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxvdHMuZm9yRWFjaChmdW5jdGlvbihwbG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5wbG90cygpLmFkZCggUGxvdC5wYXJzZUpTT04ocGxvdCwgZ3JhcGgsIG1lc3NhZ2VIYW5kbGVyKSApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFwaC5wbG90cygpLmFkZCggUGxvdC5wYXJzZUpTT04ocGxvdHMsIGdyYXBoLCBtZXNzYWdlSGFuZGxlcikgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyYXBoLnBvc3RQYXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFwaDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEdyYXBoO1xufTtcbiIsInZhciBHcmlkID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ncmlkLmpzJyk7XG5cbi8vIFwiZ3JpZFwiOiB7IFwiY29sb3JcIjogXCIjZmYwMGZmXCIsIHZpc2libGU6IHRydWUgfVxuR3JpZC5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciBncmlkICAgICAgICAgICAgID0gbmV3IEdyaWQoKSxcbiAgICAgICAgUkdCQ29sb3IgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKS5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgYXR0cjtcbiAgICBpZiAoanNvbikge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmNvbG9yLCBncmlkLmNvbG9yLCBSR0JDb2xvci5wYXJzZSk7XG4gICAgICAgIC8vTk9URTogdmlzaWJsZSBhdHRyaWJ1dGUgc2hvdWxkIGRlZmF1bHQgdG8gdHJ1ZSB3aGVuIHBhcnNpbmcsIHNvIHRoYXRcbiAgICAgICAgLy8gICAgICB0aGUgcHJlc2VuY2Ugb2YgYSBcImdyaWRcIiBwcm9wZXJ0eSBhdCBhbGwgd2lsbCB0dXJuIG9uIGEgZ3JpZC4gIEluXG4gICAgICAgIC8vICAgICAgdGhlIEdyaWQgb2JqZWN0IGl0c2VsZiwgdGhvdWdoLCB0aGUgZGVmYXVsdCBmb3IgdGhlIHZpc2libGVcbiAgICAgICAgLy8gICAgICBhdHRyaWJ1dGUgaXMgZmFsc2UsIHNvIHRoYXQgd2hlbiB3ZSBjcmVhdGUgYSBkZWZhdWx0IGdyaWQgb2JqZWN0XG4gICAgICAgIC8vICAgICAgaW4gY29kZSAoYXMgb3Bwb3NlZCB0byBwYXJzaW5nKSwgaXQgZGVmYXVsdHMgdG8gbm90IHZpc2libGUuXG4gICAgICAgIGF0dHIgPSBqc29uLnZpc2libGU7XG4gICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGdyaWQudmlzaWJsZShhdHRyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQudmlzaWJsZSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JpZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZDtcbiIsInZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9pY29uLmpzJyk7XG5cbi8vIFwiaWNvblwiIDogeyBcImJvcmRlclwiOiAyLCBcIndpZHRoXCI6IDMwLCBcImhlaWdodFwiOiAyMCB9XG5JY29uLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgdmFyIGljb24gPSBuZXcgSWNvbigpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLnBhcnNlQXR0cmlidXRlO1xuICAgIGlmIChqc29uKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uaGVpZ2h0LCBpY29uLmhlaWdodCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ud2lkdGgsICBpY29uLndpZHRoKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5ib3JkZXIsIGljb24uYm9yZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGljb247XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEljb247XG4iLCJ2YXIgSW1nID0gcmVxdWlyZSgnLi4vLi4vY29yZS9pbWcuanMnKTtcblxuLy8gXCJpbWdcIiA6IHsgXCJzcmNcIjogXCJmb28ucG5nXCIsIFwiYW5jaG9yXCI6IFstMSwgNV0sIFwiYmFzZVwiOiBbMywgMTJdLCBcInBvc2l0aW9uXCI6IFstMiwgM10sIFwiZnJhbWVcIjogXCJwYWRkaW5nXCIgfVxuSW1nLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBtdWx0aWdyYXBoKSB7XG4gICAgdmFyIGltZyxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKS5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgUG9pbnQgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIHBhcnNlSlNPTlBvaW50ID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gbmV3IFBvaW50KHBbMF0sIHBbMV0pOyB9O1xuICAgIGlmIChqc29uICYmIGpzb24uc3JjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHNyYyA9IGpzb24uc3JjO1xuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbWcgcmVxdWlyZXMgYSBcInNyY1wiIHByb3BlcnR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11bHRpZ3JhcGgpIHtcbiAgICAgICAgICAgIHNyYyA9IG11bHRpZ3JhcGgucmViYXNlVXJsKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgaW1nID0gbmV3IEltZyhzcmMpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmFuY2hvciwgICBpbWcuYW5jaG9yLCAgIHBhcnNlSlNPTlBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5iYXNlLCAgICAgaW1nLmJhc2UsICAgICBwYXJzZUpTT05Qb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ucG9zaXRpb24sIGltZy5wb3NpdGlvbiwgcGFyc2VKU09OUG9pbnQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmZyYW1lLCAgICBpbWcuZnJhbWUsICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbWc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltZztcbiIsIi8vIHVzYWdlOlxuLy8gXG4vLyAgIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgcmVxdWlyaW5nIHRoaXMgZmlsZS5cbi8vXG4vLyAgICAgIHJlcXVpcmUoJy4uLi9zcmMvcGFyc2VyL2pzb24vanNvbl9wYXJzZXIuanMnKSgkKTtcbi8vICAgICAgdmFyIE11bHRpZ3JhcGggPSByZXF1aXJlKCcuLi4vc3JjL2NvcmUvbXVsdGlncmFwaC5qcycpKCQpO1xuLy8gICAgICB2YXIgbSA9IE11bHRpZ3JhcGgucGFyc2VKU09OKCB7Li4ufSB9O1xuLy8gXG4vLyAgIHdoZXJlIHsuLi59IGlzIHRoZSBKU09OIG9iamVjdCB0byBiZSBwYXJzZWQuXG4vL1xudmFyIGluY2x1ZGVkID0gZmFsc2U7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICBpZiAoaW5jbHVkZWQpIHsgcmV0dXJuOyB9XG4gICAgaW5jbHVkZWQgPSB0cnVlO1xuXG4gICAgcmVxdWlyZSgnLi9kYXRhLmpzJykoJCk7XG4gICAgcmVxdWlyZSgnLi9ncmFwaC5qcycpKCQpO1xuICAgIHJlcXVpcmUoJy4vbXVsdGlncmFwaC5qcycpKCQpO1xuXG4gICAgcmVxdWlyZSgnLi9heGlzLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9heGlzX3RpdGxlLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9iYWNrZ3JvdW5kLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9kYXRhdGlwcy5qcycpO1xuICAgIHJlcXVpcmUoJy4vZGF0YV92YXJpYWJsZS5qcycpO1xuICAgIHJlcXVpcmUoJy4vZmlsdGVyLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9maWx0ZXJfb3B0aW9uLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9ncmlkLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9pY29uLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9pbWcuanMnKTtcbiAgICByZXF1aXJlKCcuL2pzb25fcGFyc2VyLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9sYWJlbGVyLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9sZWdlbmQuanMnKTtcbiAgICByZXF1aXJlKCcuL3Bhbi5qcycpO1xuICAgIHJlcXVpcmUoJy4vcGxvdGFyZWEuanMnKTtcbiAgICByZXF1aXJlKCcuL3Bsb3QuanMnKTtcbiAgICByZXF1aXJlKCcuL3Bsb3RfbGVnZW5kLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9yZW5kZXJlci5qcycpO1xuICAgIHJlcXVpcmUoJy4vdGl0bGUuanMnKTtcbiAgICByZXF1aXJlKCcuL3dpbmRvdy5qcycpO1xuICAgIHJlcXVpcmUoJy4vem9vbS5qcycpO1xufTtcbiIsInZhciBMYWJlbGVyID0gcmVxdWlyZSgnLi4vLi4vY29yZS9sYWJlbGVyLmpzJyk7XG5cbi8vIFwibGFiZWxzXCIgOiB7XG4vLyAgIFwiZm9ybWF0OiBTVFJJTkcsXG4vLyAgIFwic3RhcnRcIiA6IERBVEFWQUxVRSgwKSxcbi8vICAgXCJhbmdsZVwiIDogRE9VQkxFKDApLFxuLy8gICBcInBvc2l0aW9uXCIgOiBQT0lOVCxcbi8vICAgXCJhbmNob3JcIiA6IFBPSU5ULFxuLy8gICBcImNvbG9yXCIgOiBDT0xPUihibGFjayksXG4vLyAgIFwic3BhY2luZ1wiIDogU1RSSU5HLFxuLy8gICBcImZvbnRcIjogU1RSSU5HLFxuLy8gICBcImRlbnNpdHlmYWN0b3JcIiA6IERPVUJMRSgxLjApLFxuLy8gICBcImxhYmVsXCIgOiBbXG4vLyAgICAgeyBcImZvcm1hdFwiOiBcIiVZXCIsIFwic3RhcnRcIjogU1RSSU5HLCBcImFuZ2xlXCI6IDQ1LCBcInBvc2l0aW9uXCI6IFsyLDNdLFxuLy8gICAgICAgXCJhbmNob3JcIjogWzEsMV0sIFwic3BhY2luZ1wiOiBcIjFZXCIsIFwiZGVuc2l0eWZhY3RvclwiOiAwLjIgfSxcbi8vICAgICB7IFwiZm9ybWF0XCI6IFwiJU1cIiwgXCJzdGFydFwiOiBTVFJJTkcsIFwiYW5nbGVcIjogNDUsIFwicG9zaXRpb25cIjogWzIsM10sXG4vLyAgICAgICBcImFuY2hvclwiOiBbMSwxXSwgXCJzcGFjaW5nXCI6IFtcIjFNXCIsIFwiMURcIl0sIFwiZGVuc2l0eWZhY3RvclwiOiA5LjAgfVxuLy8gICBdXG4vLyB9XG4vL1xuLy8gRmVhdHVyZSBhZGRlZCAyMDE1LTEyLTE2OlxuLy8gICBUaGUgXCJmb3JtYXRcIiBhdHRyaWJ1dGUgKGZvciBhbiBheGlzIG9mIHR5cGUgbnVtYmVyIG9ubHkpIGNhbiBiZSBhblxuLy8gICBhcnJheSBvZiBzdHJpbmdzIHRvIGJlIGRpc3BsYXllZCBmb3IgdGhlIHZhbHVlcyAwLi5MLTEgd2hlcmUgTCBpcyB0aGVcbi8vICAgbnVtYmVyIG9mIHN0cmluZ3MgaW4gdGhlIGFycmF5LiAgRm9yIGV4YW1wbGU6XG4vLyAgICAgICAgXCJmb3JtYXRcIjogW1wiSmFuXCIsXCJGZWJcIixcIk1hclwiLFwiQXByXCIsXCJNYXlcIixcIkp1blwiLFwiSnVsXCIsXCJBdWdcIixcIlNlcFwiLFwiT2N0XCIsXCJOb3ZcIl1cbi8vICAgd291bGQgY2F1c2UgXCJKYW5cIiB0byBiZSByZW5kZXJlZCBhcyB0aGUgbGFiZWwgZm9yIHZhbHVlIDAsIFwiRmViXCIgZm9yIHZhbHVlIDEsXG4vLyAgIGFuZCBzbyBvbi4gIFRoZXJlIGlzIGN1cnJlbnRseSBubyB3YXkgdG8gY3VzdG9taXplIHRoZSBhc3NvY2lhdGlvbiBiZXR3ZWVuIG51bWVyaWNhbFxuLy8gICB2YWx1ZXMgYW5kIHN0cmluZ3MgLS0gaXQncyBoYXJkY29kZWQgdG8gYmUgdGhlIGludGVnZXJzIHN0YXJ0aW5nIHdpdGggMC5cblxuTGFiZWxlci5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbiwgYXhpcywgZGVmYXVsdHMsIHNwYWNpbmcpIHtcbiAgICAvLyBUaGlzIHBhcnNlciB0YWtlcyBhbiBvcHRpb25hbCBmaW5hbCBhcmd1bWVudCwgc3BhY2luZywgd2hpY2ggaXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nXG4gICAgLy8gdGhlIHNwYWNpbmcgdG8gYmUgcGFyc2VkIGZvciB0aGUgbGFiZWxlci4gIElmIHRoYXQgYXJndW1lbnQgaXMgbm90IHByZXNlbnQsIHRoZSBzcGFjaW5nXG4gICAgLy8gdmFsdWUgaXMgdGFrZW4gZnJvbSB0aGUganNvbiBvYmplY3QuICBJZiBhIHNwYWNpbmcgYXJndW1lbnQgaXMgcHJlc2VudCwgaXQgaXMgcGFyc2VkXG4gICAgLy8gYW5kIHVzZWQgdG8gc2V0IHRoZSBzcGFjaW5nIGF0dHJpYnV0ZSBvZiB0aGUgTGFiZWxlciBvYmplY3QsIGFuZCBpbiB0aGlzIGNhc2UsIGFueVxuICAgIC8vIHNwYWNpbmcgdmFsdWUgcHJlc2VudCBpbiB0aGUganNvbiBpcyBpZ25vcmVkLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlIHNwYWNpbmcgYXJndW1lbnQgaGFzIHRoZSB2YWx1ZSBudWxsLCB0aGUgcmVzdWx0aW5nIGxhYmVsZXIgd2lsbCBoYXZlIG5vIHNwYWNpbmdcbiAgICAvLyBhdHRyaWJ1dGUgc2V0IGF0IGFsbC5cbiAgICB2YXIgbGFiZWxlcixcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgRGF0YU1lYXN1cmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfbWVhc3VyZS5qcycpLFxuICAgICAgICBEYXRhVmFsdWUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgRGF0YUZvcm1hdHRlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV9mb3JtYXR0ZXIuanMnKSxcbiAgICAgICAgQ2F0ZWdvcnlGb3JtYXR0ZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NhdGVnb3J5X2Zvcm1hdHRlci5qcycpLFxuICAgICAgICBwRiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICB2RiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpLFxuICAgICAgICBwYXJzZUpTT05Qb2ludCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIG5ldyBQb2ludChwWzBdLCBwWzFdKTsgfTtcblxuICAgIC8vIGBwYXJzZUF0dHJpYnV0ZWAgcmV0dXJucyB0cnVlIG9yIGZhbHNlIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9yIG5vdCBpdCBzZXQgdGhlIGF0dHJpYnV0ZS5cbiAgICAvLyBJZiBpdCBkaWQgbm90IGFuZCBpZiB0aGUgYGRlZmF1bHRzYCBvYmplY3QgZXhpc3RzIHRoZW4gdGhlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gdGhlXG4gICAgLy8gYXBwcm9wcmlhdGUgZGVmYXVsdCB2YWx1ZS5cbiAgICB2YXIgcGFyc2VMYWJlbGVyQXR0cmlidXRlID0gZnVuY3Rpb24gKHZhbHVlLCBhdHRyaWJ1dGUsIHByZXByb2Nlc3NvciwgZGVmYXVsdE5hbWUpIHtcbiAgICAgICAgaWYgKCFwRi5wYXJzZUF0dHJpYnV0ZSh2YWx1ZSwgYXR0cmlidXRlLCBwcmVwcm9jZXNzb3IpICYmIGRlZmF1bHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZShkZWZhdWx0c1tkZWZhdWx0TmFtZV0oKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZURhdGFGb3JtYXR0ZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0YUZvcm1hdHRlci5jcmVhdGUodHlwZSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIHBhcnNlRGF0YVZhbHVlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGFWYWx1ZS5wYXJzZSh0eXBlLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGlmIChqc29uKSB7XG4gICAgICAgIGxhYmVsZXIgPSBuZXcgTGFiZWxlcihheGlzKTtcbiAgICAgICAgaWYgKHNwYWNpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzcGFjaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzcGFjaW5nID0ganNvbi5zcGFjaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9OT1RFOiBzcGFjaW5nIG1pZ2h0IHN0aWxsID09PSB1bmRlZmluZWQgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKHNwYWNpbmcsIGxhYmVsZXIuc3BhY2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih2KSB7IHJldHVybiBEYXRhTWVhc3VyZS5wYXJzZShheGlzLnR5cGUoKSwgdik7IH0sIC8vcEYucGFyc2VEYXRhTWVhc3VyZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhY2luZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi5mb3JtYXQpID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShqc29uLmZvcm1hdCwgICAgbGFiZWxlci5mb3JtYXR0ZXIsICAgICBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENhdGVnb3J5Rm9ybWF0dGVyKGpzb24uZm9ybWF0KTtcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUoanNvbi5mb3JtYXQsICAgICAgICBsYWJlbGVyLmZvcm1hdHRlciwgICAgIHBhcnNlRGF0YUZvcm1hdHRlcihheGlzLnR5cGUoKSksICAgICAgICAgIFwiZm9ybWF0dGVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKGpzb24uc3RhcnQsICAgICAgICAgbGFiZWxlci5zdGFydCwgICAgICAgICBwYXJzZURhdGFWYWx1ZShheGlzLnR5cGUoKSksICAgICAgICAgICAgICAgICAgXCJzdGFydFwiKTtcbiAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKGpzb24uYW5nbGUsICAgICAgICAgbGFiZWxlci5hbmdsZSwgICAgICAgICB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbmdsZVwiKTtcbiAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKGpzb24ucG9zaXRpb24sICAgICAgbGFiZWxlci5wb3NpdGlvbiwgICAgICBwYXJzZUpTT05Qb2ludCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiKTtcbiAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKGpzb24uYW5jaG9yLCAgICAgICAgbGFiZWxlci5hbmNob3IsICAgICAgICBwYXJzZUpTT05Qb2ludCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbmNob3JcIik7XG4gICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShqc29uLmRlbnNpdHlmYWN0b3IsIGxhYmVsZXIuZGVuc2l0eWZhY3RvciwgdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVuc2l0eWZhY3RvclwiKTtcbiAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKGpzb24uY29sb3IsICAgICAgICAgbGFiZWxlci5jb2xvciwgICAgICAgICBSR0JDb2xvci5wYXJzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiKTtcbiAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKGpzb24uZm9udCwgICAgICAgICAgbGFiZWxlci5mb250LCAgICAgICAgICB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250XCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUoanNvbi52aXNpYmxlLCAgICAgICBsYWJlbGVyLnZpc2libGUsICAgICAgIHBGLnBhcnNlQm9vbGVhbiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInZpc2libGVcIik7XG5cbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsZXI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhYmVsZXI7XG4iLCJ2YXIgTGVnZW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9sZWdlbmQuanMnKTtcblxuLy8gXCJsZWdlbmRcIiA6IHtcbi8vICAgICBcInZpc2libGVcIiAgICAgIDogXCJCT09MRUFOXCIsXG4vLyAgICAgXCJiYXNlXCIgICAgICAgICA6IFwiUE9JTlQoMSwxKVwiLFxuLy8gICAgIFwiYW5jaG9yXCIgICAgICAgOiBcIlBPSU5UKDEsMSlcIixcbi8vICAgICBcInBvc2l0aW9uXCIgICAgIDogXCJQT0lOVCgwLDApXCIsXG4vLyAgICAgXCJmcmFtZVwiICAgICAgICA6IFwiRlJBTUUocGFkZGluZylcIixcbi8vICAgICBcImNvbG9yXCIgICAgICAgIDogXCJDT0xPUih3aGl0ZSlcIixcbi8vICAgICBcIm9wYWNpdHlcIiAgICAgIDogXCJET1VCTEUoMS4wKVwiLFxuLy8gICAgIFwiYm9yZGVyXCIgICAgICAgOiBcIklOVEVHRVIoMSlcIixcbi8vICAgICBcImJvcmRlcmNvbG9yXCIgIDogXCJDT0xPUihibGFjaylcIixcbi8vICAgICBcInJvd3NcIiAgICAgICAgIDogXCJJTlRFR0VSXCIsXG4vLyAgICAgXCJjb2x1bW5zXCIgICAgICA6IFwiSU5URUdFUlwiLFxuLy8gICAgIFwiY29ybmVycmFkaXVzXCIgOiBcIklOVEVHRVIoMClcIixcbi8vICAgICBcInBhZGRpbmdcIiAgICAgIDogXCJJTlRFR0VSKDApXCIsXG4vLyAgICAgXCJpY29uXCIgOiB7XG4vLyAgICAgICBcIndpZHRoXCIgIDogXCJJTlRFR0VSKDQwKVwiLFxuLy8gICAgICAgXCJoZWlnaHRcIiA6IFwiSU5URUdFUigzMClcIixcbi8vICAgICAgIFwiYm9yZGVyXCIgOiBcIklOVEVHRVIoMSlcIlxuLy8gICAgIH1cbi8vIH1cbkxlZ2VuZC5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciBsZWdlbmQgICAgICAgICAgID0gbmV3IExlZ2VuZCgpLFxuICAgICAgICBwRiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIFBvaW50ICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIFJHQkNvbG9yICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICBQb2ludCAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpLFxuICAgICAgICBJY29uICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9pY29uLmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgcGFyc2VKU09OUG9pbnQgICA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIG5ldyBQb2ludChwWzBdLCBwWzFdKTsgfTtcblxuICAgIHJlcXVpcmUoJy4vaWNvbi5qcycpOyAvLyBmb3IgSWNvbi5wYXJzZUpTT04gYmVsb3dcblxuICAgIGlmICh0eXBlb2YoanNvbikgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24sIGxlZ2VuZC52aXNpYmxlKTtcbiAgICB9IGVsc2UgaWYgKGpzb24pIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi52aXNpYmxlLCAgICAgIGxlZ2VuZC52aXNpYmxlLCAgICAgIHBGLnBhcnNlQm9vbGVhbik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYmFzZSwgICAgICAgICBsZWdlbmQuYmFzZSwgICAgICAgICBwYXJzZUpTT05Qb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYW5jaG9yLCAgICAgICBsZWdlbmQuYW5jaG9yLCAgICAgICBwYXJzZUpTT05Qb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ucG9zaXRpb24sICAgICBsZWdlbmQucG9zaXRpb24sICAgICBwYXJzZUpTT05Qb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uZnJhbWUsICAgICAgICBsZWdlbmQuZnJhbWUpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmNvbG9yLCAgICAgICAgbGVnZW5kLmNvbG9yLCAgICAgICAgUkdCQ29sb3IucGFyc2UpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJvcmRlcmNvbG9yLCAgbGVnZW5kLmJvcmRlcmNvbG9yLCAgUkdCQ29sb3IucGFyc2UpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm9wYWNpdHksICAgICAgbGVnZW5kLm9wYWNpdHkpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJvcmRlciwgICAgICAgbGVnZW5kLmJvcmRlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ucm93cywgICAgICAgICBsZWdlbmQucm93cyk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uY29sdW1ucywgICAgICBsZWdlbmQuY29sdW1ucyk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uY29ybmVycmFkaXVzLCBsZWdlbmQuY29ybmVycmFkaXVzKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5wYWRkaW5nLCAgICAgIGxlZ2VuZC5wYWRkaW5nKTtcblxuICAgICAgICBpZiAoanNvbi5pY29uKSB7XG4gICAgICAgICAgICBsZWdlbmQuaWNvbihJY29uLnBhcnNlSlNPTihqc29uLmljb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWdlbmQ7XG4iLCIvLyBUaGlzIGZpbGUgdXNlcyBqUXVlcnkuICBBIHZhbGlkIGpRdWVyeSBvYmplY3QgbXVzdCBiZSBwYXNzZWQgdG8gdGhlXG4vLyBmdW5jdGlvbiByZXR1cm5lZCBieSByZXF1aXJpbmcgdGhpcyBmaWxlLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkKSB7XG4gICAgdmFyIE11bHRpZ3JhcGggPSByZXF1aXJlKCcuLi8uLi9jb3JlL211bHRpZ3JhcGguanMnKSgkKTtcblxuICAgIC8vIGlmIHBhcnNlSlNPTiBtZXRob2QgYWxyZWFkeSBoYXMgYmVlbiBkZWZpbmVkLCB3aGljaCB3b3VsZCBiZSB0aGUgY2FzZSBpZiB0aGlzXG4gICAgLy8gZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkLCBqdXN0IHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0eXBlb2YoTXVsdGlncmFwaC5wYXJzZUpTT04pPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBNdWx0aWdyYXBoOyB9O1xuXG4gICAgTXVsdGlncmFwaC5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbiwgbXVnbCwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgdmFyIG11bHRpZ3JhcGggPSBuZXcgTXVsdGlncmFwaCgpLFxuICAgICAgICAgICAgZ3JhcGhzICAgICA9IG11bHRpZ3JhcGguZ3JhcGhzKCksXG4gICAgICAgICAgICBHcmFwaCAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ncmFwaC5qcycpLFxuICAgICAgICAgICAgdkYgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpO1xuXG4gICAgICAgIHJlcXVpcmUoJy4vZ3JhcGguanMnKSgkKTsgLy8gZm9yIEdyYXBoLnBhcnNlSlNPTiBiZWxvd1xuXG4gICAgICAgIG11bHRpZ3JhcGgubXVnbChtdWdsKTsgLy8gc2V0IHRoZSBtdWdsIHVybFxuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGpzb24uZm9yRWFjaChmdW5jdGlvbihncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICBncmFwaHMuYWRkKCBHcmFwaC5wYXJzZUpTT04oZ3JhcGgsIG11bHRpZ3JhcGgsIG1lc3NhZ2VIYW5kbGVyKSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmFwaHMuYWRkKCBHcmFwaC5wYXJzZUpTT04oanNvbiwgbXVsdGlncmFwaCwgbWVzc2FnZUhhbmRsZXIpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG11bHRpZ3JhcGg7XG4gICAgfTtcblxuICAgIHJldHVybiBNdWx0aWdyYXBoO1xufTtcbiIsInZhciBQYW4gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3Bhbi5qcycpO1xuXG5QYW4ucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24sIHR5cGUpIHtcbiAgICB2YXIgcGFuICAgICAgICAgICAgPSBuZXcgUGFuKCksXG4gICAgICAgIHBGICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHZGICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC92YWxpZGF0aW9uRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlQm9vbGVhbiAgID0gcEYucGFyc2VCb29sZWFuLFxuICAgICAgICBEYXRhVmFsdWUgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgICAgICBwYXJzZURhdGFWYWx1ZSA9IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIERhdGFWYWx1ZS5wYXJzZSh0eXBlLCB2KTsgfTtcbiAgICBpZiAodkYudHlwZU9mKGpzb24pID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbiwgICAgICAgICBwYW4uYWxsb3dlZCwgcGFyc2VCb29sZWFuKTtcbiAgICB9IGVsc2UgaWYgKGpzb24pIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5hbGxvd2VkLCBwYW4uYWxsb3dlZCwgcGFyc2VCb29sZWFuKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5taW4sICAgICBwYW4ubWluLCAgICAgcGFyc2VEYXRhVmFsdWUpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm1heCwgICAgIHBhbi5tYXgsICAgICBwYXJzZURhdGFWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBwYW47XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhbjtcbiIsInZhciBQbG90ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wbG90LmpzJyk7XG5cbi8vIFwicGxvdFwiIDoge1xuLy8gICBcImxlZ2VuZFwiIDogeyBcInZpc2libGVcIjogXCJCT09MRUFOXCIsIFwibGFiZWxcIjogXCJTVFJJTkdcIiB9LCBcbi8vICAgXCJsZWdlbmRcIiA6IEJPT0xFQU4sXG4vLyAgICAgICAgICAgICAgICAgLy9OTzogIFwiaG9yaXpvbnRhbGF4aXNcIiA6IHtcbi8vICAgICAgICAgICAgICAgICAvL05POiAgICBcInJlZlwiIDogU1RSSU5HISxcbi8vICAgICAgICAgICAgICAgICAvL05POiAgICBcInZhcmlhYmxlc1wiIFsgU1RSSU5HLCAuLi4gXVxuLy8gICAgICAgICAgICAgICAgIC8vTk86ICB9LFxuLy8gICAgICAgICAgICAgICAgIC8vTk86ICBcInZlcnRpY2FsYXhpc1wiIDoge1xuLy8gICAgICAgICAgICAgICAgIC8vTk86ICAgIFwicmVmXCIgOiBTVFJJTkchLFxuLy8gICAgICAgICAgICAgICAgIC8vTk86ICAgIFwidmFyaWFibGVzXCIgWyBTVFJJTkcsIC4uLiBdLFxuLy8gICAgICAgICAgICAgICAgIC8vTk86ICAgIFwiY29uc3RhbnRcIiA6IERBVEFWQUxVRVxuLy8gICAgICAgICAgICAgICAgIC8vTk86ICB9LFxuLy8gXG4vLyAgIFwiaG9yaXpvbnRhbGF4aXNcIiA6IEFYSVMtSUQoc3RyaW5nKVxuLy8gICBcImhvcml6b250YWxheGlzXCIgOiBbIFZBUklBQkxFLUlEKHN0cmluZyksIC4uLiBdXG4vLyAgIFwiaG9yaXpvbnRhbGF4aXNcIiA6IHsgQVhJUy1JRChzdHJpbmcpOiBbIFZBUklBQkxFLUlEKHN0cmluZyksIC4uLiBdIH1cbi8vIFxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogWyBWQVJJQUJMRS1JRChzdHJpbmcpLCAuLi4gXVxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogeyBBWElTLUlEKHN0cmluZyk6IERBVEEtVkFMVUUobnVtYmVyIG9yIHN0cmluZykgfSAgICAgPC0tIENvbnN0YW50UGxvdFxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogeyBBWElTLUlEKHN0cmluZyk6IFZBUklBQkxFLUlEKHN0cmluZykgfVxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogeyBBWElTLUlEKHN0cmluZyk6IFsgVkFSSUFCTEUtSUQoc3RyaW5nKSwgLi4uIF0gfVxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogREFUQS1WQUxVRShudW1iZXIgb3Igc3RyaW5nKSAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tIENvbnN0YW50UGxvdFxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogQVhJUy1JRChzdHJpbmcpXG4vLyAgIFwidmlzaWJsZVwiIDogQk9PTEVBTih0cnVlKVxuLy8gICBcInJlbmRlcmVyXCIgOiB7XG4vLyAgICAgXCJ0eXBlXCIgOiBSRU5ERVJFUlRZUEUobGluZSksXG4vLyAgICAgXCJvcHRpb25zXCIgOiB7XG4vLyAgICAgICAgIFwib3B0aW9uMVwiOiB2YWx1ZTEsXG4vLyAgICAgICAgIFwib3B0aW9uMlwiOiB2YWx1ZTIsXG4vLyAgICAgICAgIFwib3B0aW9uM1wiOiBbIHsgXCJ2YWx1ZVwiOiB2YWx1ZTMsIFwibWluXCI6IERBVEFWQUxVRSwgXCJtYXhcIiA6IERBVEFWQUxVRSB9LCAuLiBdXG4vLyAgICAgICAgIC4uLlxuLy8gICAgIH0sXG4vLyAgIH0sXG4vLyAgIFwiZGF0YXRpcHNcIiA6IHtcbi8vICAgICBcImZvcm1hdFwiICAgICAgICAgICA6IFNUUklORyEsXG4vLyAgICAgXCJiZ2NvbG9yXCIgICAgICAgICAgOiBDT0xPUixcbi8vICAgICBcImJnYWxwaGFcIiAgICAgICAgICA6IERPVUJMRSxcbi8vICAgICBcImJvcmRlclwiICAgICAgICAgICA6IElOVEVHRVIsXG4vLyAgICAgXCJib3JkZXJjb2xvclwiICAgICAgOiBDT0xPUixcbi8vICAgICBcInBhZFwiICAgICAgICAgICAgICA6IElOVEVHRVIsXG4vLyAgICAgXCJ2YXJpYWJsZS1mb3JtYXRzXCIgOiBbIFNUUklORyEsIC4uLiBdXG4vLyAgIH1cbi8vIH1cbi8vXG4vLyBBbHRlcm5hdGVseSwgaW5zdGVhZCBvZiB0aGUgXCJyZW5kZXJlclwiIHNlY3Rpb24sIHRoZSBcInBsb3RcIiBzZWN0aW9uIG1heSBpbnN0ZWFkIGNvbnRhaW5cbi8vIHRoZSBmb2xsb3dpbmcgKGF0IHRoZSB0b3AgbGV2ZWwgb2YgdGhlIFwicGxvdFwiIG9iamVjdCk6XG4vLyBcbi8vICAgXCJzdHlsZVwiIDogUkVOREVSRVJUWVBFKGxpbmUpLFxuLy8gICBcIm9wdGlvbnNcIiA6IHtcbi8vICAgICAgIFwib3B0aW9uMVwiOiB2YWx1ZTEsXG4vLyAgICAgICBcIm9wdGlvbjJcIjogdmFsdWUyLFxuLy8gICAgICAgXCJvcHRpb24zXCI6IFsgeyBcInZhbHVlXCI6IHZhbHVlMywgXCJtaW5cIjogREFUQVZBTFVFLCBcIm1heFwiIDogREFUQVZBTFVFIH0sIC4uIF1cbi8vICAgICAgIC4uLlxuLy8gICB9LFxuLy8gXG5QbG90LnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBncmFwaCwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICB2YXIgRGF0YVBsb3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV9wbG90LmpzJyksXG4gICAgICAgIFBsb3RMZWdlbmQgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3Bsb3RfbGVnZW5kLmpzJyksXG4gICAgICAgIENvbnN0YW50UGxvdCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbnN0YW50X3Bsb3QuanMnKSxcbiAgICAgICAgRGF0YVZhbHVlICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgICAgICBEYXRlVGltZVZhbHVlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRldGltZV92YWx1ZS5qcycpLFxuICAgICAgICBSZW5kZXJlciAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9yZW5kZXJlci5qcycpLFxuICAgICAgICBGaWx0ZXIgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9maWx0ZXIuanMnKSxcbiAgICAgICAgQ29uc2VjdXRpdmVEaXN0YW5jZUZpbHRlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29uc2VjdXRpdmVfZGlzdGFuY2VfZmlsdGVyLmpzJyksXG4gICAgICAgIERhdGF0aXBzICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGF0aXBzLmpzJyksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgdkYgICAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpLFxuICAgICAgICBwbG90LFxuICAgICAgICBoYXhpcyxcbiAgICAgICAgdmF4aXMsXG4gICAgICAgIHZhcmlhYmxlLFxuICAgICAgICBhdHRyO1xuXG4gICAgLy8gc28gdGhhdCBQbG90TGVnZW5kLFJlbmRlcmVyLEZpbHRlcixEYXRhdGlwcyB3aWxsIGhhdmUgLnBhcnNlSlNPTiB3aGVuIGNhbGxlZCBiZWxvdzpcbiAgICByZXF1aXJlKCcuL3Bsb3RfbGVnZW5kLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9yZW5kZXJlci5qcycpO1xuICAgIHJlcXVpcmUoJy4vZmlsdGVyLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9kYXRhdGlwcy5qcycpO1xuXG4gICAgLy8gcmV0dXJuIHRoZSAoZmlyc3QpIGtleSBvZiBhbiBvYmplY3Q7IGludGVuZGVkIGZvciBjb252ZW5pZW50IGZldGNoaW5nIG9mIHRoZVxuICAgIC8vIGtleSBuYW1lIG9mIGFuIG9iamVjdCAodmVydGljYWxheGlzIG9yIGhvcml6b250YWxheGlzKSB0aGF0IGNvbnRhaW5zIG9ubHkgb25lIGtleVxuICAgIGZ1bmN0aW9uIGtleShvYmopIHtcbiAgICAgICAgcmV0dXJuIChPYmplY3Qua2V5cyhvYmopKVswXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdGhlIG51bWJlciBvZiBrZXlzIGluIGFuIG9iamVjdFxuICAgIGZ1bmN0aW9uIGtleUNvdW50KG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWZmIHRoZSB2YWx1ZSB2IGxvb2tzIGxpa2UgYSBkYXRhX3ZhbHVlIC0tIGkuZS4gaXQncyBlaXRoZXIgYSBudW1iZXIsXG4gICAgLy8gb3IgYSBzdHJpbmcgdGhhdCBsb29rcyBsaWtlIGl0IGNvdWxkIGJlIHBhcnNlZCBpbnRvIGVpdGhlciBhIG51bWJlciBvciBhIGRhdGV0aW1lIHZhbHVlLlxuICAgIGZ1bmN0aW9uIGxvb2tzX2xpa2VfZGF0YV92YWx1ZSh2KSB7XG4gICAgICAgIGlmICh2Ri50eXBlT2YodikgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2Ri50eXBlT2YodikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyAhaXNOYU4gaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byB0ZXN0IHdoZXRoZXIgYSBzdHJpbmcgcmVwcmVzZW50cyBhIHZhbGlkIG51bWJlclxuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNzU3MzkvaXMtdGhlcmUtYS1idWlsdC1pbi13YXktaW4tamF2YXNjcmlwdC10by1jaGVjay1pZi1hLXN0cmluZy1pcy1hLXZhbGlkLW51bWJlclxuICAgICAgICAgICAgaWYgKCFpc05hTih2KSkgeyAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdHJpbmcgaXNuJ3QgYSB2YWxpZCBudW1iZXIsIHRyeSB0byBwYXJzZSBpdCBhcyBhIERhdGV0aW1lVmFsdWVcbiAgICAgICAgICAgICAgICB0cnkgeyBEYXRldGltZVZhbHVlLnBhcnNlKHYpOyB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoanNvbikge1xuICAgICAgICB2YXIgdmFycyA9IHtcbiAgICAgICAgICAgIFwiaG9yaXpvbnRhbFwiIDogW10sXG4gICAgICAgICAgICBcInZlcnRpY2FsXCIgICA6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBheGlzaWQgPSB7XG4gICAgICAgICAgICBcImhvcml6b250YWxcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFwidmVydGljYWxcIiAgIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG5cbi8vICAgXCJ2ZXJ0aWNhbGF4aXNcIiA6IFsgVkFSSUFCTEUtSUQoc3RyaW5nKSwgLi4uIF1cbi8vICAgXCJ2ZXJ0aWNhbGF4aXNcIiA6IHsgQVhJUy1JRChzdHJpbmcpOiBEQVRBLVZBTFVFKG51bWJlciBvciBzdHJpbmcpIH0gICAgIDwtLSBDb25zdGFudFBsb3Rcbi8vICAgXCJ2ZXJ0aWNhbGF4aXNcIiA6IHsgQVhJUy1JRChzdHJpbmcpOiBWQVJJQUJMRS1JRChzdHJpbmcpIH1cbi8vICAgXCJ2ZXJ0aWNhbGF4aXNcIiA6IHsgQVhJUy1JRChzdHJpbmcpOiBbIFZBUklBQkxFLUlEKHN0cmluZyksIC4uLiBdIH1cbi8vICAgXCJ2ZXJ0aWNhbGF4aXNcIiA6IERBVEEtVkFMVUUobnVtYmVyIG9yIHN0cmluZykgICAgICAgICAgICAgICAgICAgICAgICAgIDwtLSBDb25zdGFudFBsb3Rcbi8vICAgXCJ2ZXJ0aWNhbGF4aXNcIiA6IEFYSVMtSUQoc3RyaW5nKVxuXG4gICAgICAgIC8vIGRlYWwgd2l0aCB2ZXJ0aWNhbCBheGlzIGZpcnN0LCBiZWNhdXNlIGl0IGRldGVybWluZXMgd2hldGhlciB3ZSBoYXZlXG4gICAgICAgIC8vIGEgQ29uc3RhbnRQbG90IG9yIGEgRGF0YVBsb3RcbiAgICAgICAgdmFyIGNvbnN0YW50X3ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoanNvbi52ZXJ0aWNhbGF4aXMpIHtcbiAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi52ZXJ0aWNhbGF4aXMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbiBhcnJheSwgaXQncyBhIGxpc3Qgb2YgdmFyaWFibGUgaWRzIGZvciB0aGUgcGxvdCxcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIGF4aXNpZCBpcyB1bnNwZWNpZmllZFxuICAgICAgICAgICAgICAgIHZhcnMudmVydGljYWwgPSBqc29uLnZlcnRpY2FsYXhpcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodkYudHlwZU9mKGpzb24udmVydGljYWxheGlzKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGVvcnkgd2UnZCBsaWtlIHRvIHZhbGlkYXRlIGhlcmUgdGhhdCB0aGUgdmVydGljYWwgYXhpcyB0eXBlIGlzIE5VTUJFUiwgYnV0XG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgZG8gdGhhdCBiZWNhdXNlIHdlIGRvbid0IGFjdHVhbGx5IGhhdmUgdGhlIGF4aXMgeWV0IC0tIGl0cyBpZCBpcyBpbXBsaWVkXG4gICAgICAgICAgICAgICAgLy8gc28gaXQgd2lsbCBiZSBkZXRlcm1pbmVkIGxhdGVyLiAgU28gd2Ugc2V0IGEgbnVtZXJpYyBjb25zdGFudCB2YWx1ZSBhbmQgaG9wZVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgYmVzdC5cbiAgICAgICAgICAgICAgICBjb25zdGFudF92YWx1ZSA9IERhdGFWYWx1ZS5wYXJzZShEYXRhVmFsdWUuTlVNQkVSLCBqc29uLnZlcnRpY2FsYXhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZGLnR5cGVPZihqc29uLnZlcnRpY2FsYXhpcykgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIHN0cmluZyB0aGF0IGlzIGVpdGhlciBhbiBheGlzIGlkLCBvciBhIERhdGV0aW1lVmFsdWUgY29uc3RhbnQgKHdlXG4gICAgICAgICAgICAgICAgLy8ga25vdyBpdCdzIG5vdCBhIG51bWJlciBjb25zdGFudCwgYmVjYXVzZSB0aGF0IHdvdWxkIGhhdmUgYmVlbiBjYXVnaHQgYnlcbiAgICAgICAgICAgICAgICAvLyB0aGUgJ251bWJlcicgY2FzZSBhYm92ZSkuXG4gICAgICAgICAgICAgICAgaWYgKGxvb2tzX2xpa2VfZGF0YV92YWx1ZShqc29uLnZlcnRpY2FsYXhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWdhaW4sIGluIHRoZW9yeSwgd2UnZCBsaWtlIHRvIHZhbGlkYXRlIHRoYXQgdGhlIGF4aXMgdHlwZSBpcyBEYXRlVGltZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdlIGNhbid0IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGUgYXhpcyB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0YW50X3ZhbHVlID0gRGF0YVZhbHVlLnBhcnNlKERhdGFWYWx1ZS5EQVRFVElNRSwganNvbi52ZXJ0aWNhbGF4aXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNpZC52ZXJ0aWNhbCA9IGpzb24udmVydGljYWxheGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXhpcyA9IGdyYXBoLmF4aXNCeUlkKGF4aXNpZC52ZXJ0aWNhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YodmF4aXMpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGxvdCByZWZlcnMgdG8gdW5rbm93biB2ZXJ0aWNhbCBheGlzIGlkOiBcIiArIGF4aXNpZC52ZXJ0aWNhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZGLnR5cGVPZihqc29uLnZlcnRpY2FsYXhpcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbiBvYmplY3QsIHRoZSBrZXkgaXMgdGhlIGF4aXMgaWQsIGFuZCB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyBpcyBlaXRoZXI6XG4gICAgICAgICAgICAgICAgLy8gICAgY2FzZSAxOiBhbiBhcnJheSBvZiB2YXJpYWJsZSBpZHMsIG9yXG4gICAgICAgICAgICAgICAgLy8gICAgY2FzZSAyOiBhIHNpbmdsZSB2YWx1ZSB0aGF0IGlzIGVpdGhlciBhbiBheGlzIGlkLCBvclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgYSBjb25zdGFudCB2YWx1ZSBmb3IgYSBjb25zdGFudCBwbG90XG4gICAgICAgICAgICAgICAgaWYgKGtleUNvdW50KGpzb24udmVydGljYWxheGlzKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwbG90LnZlcnRpY2FsYXhpcyBvYmplY3QgbXVzdCBjb250YWluIGV4YWN0bHkgb25lIGtleS92YWx1ZSBwYWlyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBheGlzaWQudmVydGljYWwgPSBrZXkoanNvbi52ZXJ0aWNhbGF4aXMpO1xuICAgICAgICAgICAgICAgIHZheGlzID0gZ3JhcGguYXhpc0J5SWQoYXhpc2lkLnZlcnRpY2FsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHZheGlzKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGxvdCByZWZlcnMgdG8gdW5rbm93biB2ZXJ0aWNhbCBheGlzIGlkOiBcIiArIGF4aXNpZC52ZXJ0aWNhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLnZlcnRpY2FsYXhpc1theGlzaWQudmVydGljYWxdKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAxOiBhcnJheSBvZiB2YXJpYWJsZSBpZHMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnZlcnRpY2FsID0ganNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMjogc2luZ2xlIHZhbHVlLCBlaXRoZXIgYXhpcyBpZCwgb3IgY29uc3RhbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGlmIGl0J3MgYSBudW1iZXIsIGl0IG11c3QgYmUgYSBjb25zdGFudCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLnZlcnRpY2FsYXhpc1theGlzaWQudmVydGljYWxdKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmF4aXMudHlwZSgpICE9PSBEYXRhVmFsdWUuTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN0YW50IHZhbHVlIG9mICdcIiArIGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgXCInIG5vdCBhcHByb3ByaWF0ZSBmb3IgYXhpcyBvZiB0eXBlICdcIiArIHZheGlzLnR5cGUoKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRfdmFsdWUgPSBEYXRhVmFsdWUucGFyc2UoRGF0YVZhbHVlLk5VTUJFUiwganNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90IGEgbnVtYmVyLCBzbyBpdCBtdXN0IGJlIGEgc3RyaW5nIHRoYXQgaXMgZWl0aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjb25zdGFudCBEYXRldGltZVZhbHVlLCBvciBhbiBheGlzIGlkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhbHVlIGZvciBrZXkgJ1wiICsgYXhpc2lkLnZlcnRpY2FsICsgXCInIGZvciB2ZXJ0aWNhbGF4aXMgaXMgb2Ygd3JvbmcgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2tzX2xpa2VfZGF0YV92YWx1ZShqc29uLnZlcnRpY2FsYXhpc1theGlzaWQudmVydGljYWxdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudF92YWx1ZSA9IERhdGFWYWx1ZS5wYXJzZSh2YXhpcy50eXBlKCksIGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMudmVydGljYWwgPSBbIGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uc3RhbnRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGxvdCA9IG5ldyBDb25zdGFudFBsb3QoY29uc3RhbnRfdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGxvdCA9IG5ldyBEYXRhUGxvdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxvdC52ZXJ0aWNhbGF4aXModmF4aXMpO1xuXG4gICAgICAgIC8vICAgXCJob3Jpem9udGFsYXhpc1wiIDogQVhJUy1JRChzdHJpbmcpXG4gICAgICAgIC8vICAgXCJob3Jpem9udGFsYXhpc1wiIDogWyBWQVJJQUJMRS1JRChzdHJpbmcpLCAuLi4gXVxuICAgICAgICAvLyAgIFwiaG9yaXpvbnRhbGF4aXNcIiA6IHsgQVhJUy1JRChzdHJpbmcpOiBbIFZBUklBQkxFLUlEKHN0cmluZyksIC4uLiBdIH1cbiAgICAgICAgaWYgKGpzb24uaG9yaXpvbnRhbGF4aXMpIHtcbiAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi5ob3Jpem9udGFsYXhpcykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGFuIGFycmF5LCBpdCdzIGEgbGlzdCBvZiB2YXJpYWJsZSBpZHMgZm9yIHRoZSBwbG90LFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgYXhpc2lkIGlzIHVuc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgdmFycy5ob3Jpem9udGFsID0ganNvbi5ob3Jpem9udGFsYXhpcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodkYudHlwZU9mKGpzb24uaG9yaXpvbnRhbGF4aXMpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGF4aXNpZC5ob3Jpem9udGFsID0ganNvbi5ob3Jpem9udGFsYXhpcztcbiAgICAgICAgICAgICAgICBoYXhpcyA9IGdyYXBoLmF4aXNCeUlkKGF4aXNpZC5ob3Jpem9udGFsKTtcbiAgICAgICAgICAgICAgICBpZiAoaGF4aXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwbG90Lmhvcml6b250YWxheGlzKGhheGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbG90IEhvcml6b250YWwgQXhpcyBFcnJvcjogVGhlIGdyYXBoIGRvZXMgbm90IGNvbnRhaW4gYW4gYXhpcyB3aXRoIGFuIGlkIG9mICdcIiArIGF4aXNpZC5ob3Jpem9udGFsICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodkYudHlwZU9mKGpzb24uaG9yaXpvbnRhbGF4aXMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgYW4gb2JqZWN0LCB0aGUga2V5IGlzIHRoZSBheGlzIGlkLCBhbmQgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gaXMgZWl0aGVyOlxuICAgICAgICAgICAgICAgIC8vICAgIGNhc2UgMTogYW4gYXJyYXkgb2YgdmFyaWFibGUgaWRzLCBvclxuICAgICAgICAgICAgICAgIC8vICAgIGNhc2UgMjogYW4gYXhpcyBpZFxuICAgICAgICAgICAgICAgIGlmIChrZXlDb3VudChqc29uLmhvcml6b250YWxheGlzKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwbG90Lmhvcml6b250YWxheGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gZXhhY3RseSBvbmUga2V5L3ZhbHVlIHBhaXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF4aXNpZC5ob3Jpem9udGFsID0ga2V5KGpzb24uaG9yaXpvbnRhbGF4aXMpO1xuICAgICAgICAgICAgICAgIGhheGlzID0gZ3JhcGguYXhpc0J5SWQoYXhpc2lkLmhvcml6b250YWwpO1xuICAgICAgICAgICAgICAgIGlmIChoYXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QuaG9yaXpvbnRhbGF4aXMoaGF4aXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgSG9yaXpvbnRhbCBBeGlzIEVycm9yOiBUaGUgZ3JhcGggZG9lcyBub3QgY29udGFpbiBhbiBheGlzIHdpdGggYW4gaWQgb2YgJ1wiICsgYXhpc2lkLmhvcml6b250YWwgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi5ob3Jpem9udGFsYXhpc1theGlzaWQuaG9yaXpvbnRhbF0pICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi5ob3Jpem9udGFsYXhpc1theGlzaWQuaG9yaXpvbnRhbF0pID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDE6IGFycmF5IG9mIHZhcmlhYmxlIGlkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuaG9yaXpvbnRhbCA9IGpzb24uaG9yaXpvbnRhbGF4aXNbYXhpc2lkLmhvcml6b250YWxdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAyOiBhbiBheGlzIGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbXVzdCBiZSBhIHN0cmluZyB0aGF0IGlzIGFuIGF4aXMgaWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLmhvcml6b250YWxheGlzW2F4aXNpZC5ob3Jpem9udGFsXSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhbHVlIGZvciBrZXkgJ1wiICsgYXhpc2lkLmhvcml6b250YWwgKyBcIicgZm9yIGhvcml6b250YWxheGlzIGlzIG9mIHdyb25nIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFycy5ob3Jpem9udGFsID0gWyBqc29uLmhvcml6b250YWxheGlzW2F4aXNpZC5ob3Jpem9udGFsXSBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIERhdGFQbG90LCBwYXJzZSB2YXJpYWJsZXNcbiAgICAgICAgaWYgKHBsb3QgaW5zdGFuY2VvZiBEYXRhUGxvdCkge1xuXG4gICAgICAgICAgICAvLyBwcm92aWRlIGRlZmF1bHQgaG9yaXpvbnRhbGF4aXMgdmFyaWFibGUgaWYgbm9uZSBwcmVzZW50XG4gICAgICAgICAgICBpZiAodmFycy5ob3Jpem9udGFsLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcGxvdC52YXJpYWJsZSgpLmFkZChudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9UT0RPOiBkZWZlciBwb3B1bGF0aW9uIG9mIHZhcmlhYmxlcyB1bnRpbCBub3JtYWxpemVyIGhhcyBleGVjdXRlZFxuICAgICAgICAgICAgLy8gcG9wdWxhdGUgYXhpcyB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmIChncmFwaCkge1xuICAgICAgICAgICAgICAgIHZhciBhbGx2YXJzID0gW10uY29uY2F0KHZhcnMuaG9yaXpvbnRhbCwgdmFycy52ZXJ0aWNhbCk7XG4gICAgICAgICAgICAgICAgYWxsdmFycy5mb3JFYWNoKGZ1bmN0aW9uKHZpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IGdyYXBoLnZhcmlhYmxlQnlJZCh2aWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5kYXRhKCB2YXJpYWJsZS5kYXRhKCkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QudmFyaWFibGUoKS5hZGQodmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxvdCBWYXJpYWJsZSBFcnJvcjogTm8gRGF0YSB0YWcgY29udGFpbnMgYSB2YXJpYWJsZSB3aXRoIGFuIGlkIG9mICdcIiArIHZpZCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuXG5cblxuLy94eHggICAgICAgIC8vIHBvcHVsYXRlIHZlcnRpY2FsYXhpc1xuLy94eHggICAgICAgIGlmIChqc29uLnZlcnRpY2FsYXhpcykge1xuLy94eHggICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24udmVydGljYWxheGlzKSA9PT0gJ3N0cmluZycpIHtcbi8veHh4ICAgICAgICAgICAgICAgIGF4aXNpZC52ZXJ0aWNhbCA9IGpzb24udmVydGljYWxheGlzO1xuLy94eHggICAgICAgICAgICB9IGVsc2Uge1xuLy94eHggICAgICAgICAgICAgICAgaWYgKGtleUNvdW50KGpzb24udmVydGljYWxheGlzKSAhPT0gMSkge1xuLy94eHggICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBsb3QudmVydGljYWxheGlzIG11c3QgY29udGFpbiBleGFjdGx5IG9uZSBrZXkvdmFsdWUgcGFpclwiKTtcbi8veHh4ICAgICAgICAgICAgICAgIH1cbi8veHh4ICAgICAgICAgICAgICAgIGF4aXNpZC52ZXJ0aWNhbCA9IGtleShqc29uLnZlcnRpY2FsYXhpcyk7XG4vL3h4eCAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF0pICE9PSBcInVuZGVmaW5lZFwiKSB7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLnZlcnRpY2FsYXhpc1theGlzaWQudmVydGljYWxdKSA9PT0gJ2FycmF5Jykge1xuLy94eHggICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnZlcnRpY2FsID0ganNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXTtcbi8veHh4ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuLy94eHggICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnZlcnRpY2FsID0gWyBqc29uLnZlcnRpY2FsYXhpc1theGlzaWQudmVydGljYWxdIF07XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgfVxuLy94eHggICAgICAgICAgICAgICAgfVxuLy94eHggICAgICAgICAgICB9XG4vL3h4eCAgICAgICAgICAgIHZheGlzID0gZ3JhcGguYXhpc0J5SWQoYXhpc2lkLnZlcnRpY2FsKTtcbi8veHh4ICAgICAgICAgICAgaWYgKHZheGlzID09PSB1bmRlZmluZWQpIHtcbi8veHh4ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgVmVydGljYWwgQXhpcyBFcnJvcjogVGhlIGdyYXBoIGRvZXMgbm90IGNvbnRhaW4gYW4gYXhpcyB3aXRoIGFuIGlkIG9mICdcIiArIGF4aXNpZC52ZXJ0aWNhbCArIFwiJ1wiKTtcbi8veHh4ICAgICAgICAgICAgfVxuLy94eHggICAgICAgIH1cbi8veHh4XG4vL3h4eFxuLy94eHgvLyAgICAgICAgLy8gcG9wdWxhdGUgdmVydGljYWxheGlzXG4vL3h4eC8vICAgICAgICBpZiAoanNvbi52ZXJ0aWNhbGF4aXMgJiYganNvbi52ZXJ0aWNhbGF4aXMucmVmKSB7XG4vL3h4eC8vICAgICAgICAgICAgdmF4aXMgPSBncmFwaC5heGlzQnlJZChqc29uLnZlcnRpY2FsYXhpcy5yZWYpO1xuLy94eHgvLyAgICAgICAgICAgIGlmICh2YXhpcyA9PT0gdW5kZWZpbmVkKSB7XG4vL3h4eC8vICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgVmVydGljYWwgQXhpcyBFcnJvcjogVGhlIGdyYXBoIGRvZXMgbm90IGNvbnRhaW4gYW4gYXhpcyB3aXRoIGFuIGlkIG9mICdcIiArIGpzb24udmVydGljYWxheGlzLnJlZiArIFwiJ1wiKTtcbi8veHh4Ly8gICAgICAgICAgICB9XG4vL3h4eC8vICAgICAgICB9XG4vL3h4eFxuLy94eHggICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdmVydGljYWxheGlzIG9iamVjdCwgYW5kIGlmIHRoZSB2YWx1ZSBpdCBjb250YWlucyBsb29rcyBsaWtlIGFcbi8veHh4ICAgICAgICAvLyBudW1iZXIgb3IgZGF0ZXRpbWUgdmFsdWUsIGFzc3VtZSBpdCdzIGEgQ29uc3RhbnQgUGxvdC4gIE90aGVyd2lzZSBhc3N1bWUgdGhlXG4vL3h4eCAgICAgICAgLy8gdmFsdWUgaXMgZWl0aGVyIGEgdmFyaWFibGUgaWQsIG9yIGEgbGlzdCBvZiB2YXJpYWJsZSBpZHMsIHNvIHdlIGhhdmUgYSBEYXRhIFBsb3QuXG4vL3h4eCAgICAgICAgaWYgKCh2Ri50eXBlT2YoanNvbi52ZXJ0aWNhbGF4aXMpID09PSAnb2JqZWN0JykgJiYgbG9va3NfbGlrZV9kYXRhX3ZhbHVlKGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF0pKSB7XG4vL3h4eCAgICAgICAgICAgIHBsb3QgPSBuZXcgQ29uc3RhbnRQbG90KERhdGFWYWx1ZS5wYXJzZSh2YXhpcy50eXBlKCksIGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF0pKTtcbi8veHh4ICAgICAgICB9IGVsc2Uge1xuLy94eHggICAgICAgICAgICBwbG90ID0gbmV3IERhdGFQbG90KCk7XG4vL3h4eCAgICAgICAgfVxuLy94eHhcbi8veHh4Ly8gICAgICAgIGlmIChqc29uLnZlcnRpY2FsYXhpcyAmJiBqc29uLnZlcnRpY2FsYXhpcy5jb25zdGFudCkge1xuLy94eHgvLyAgICAgICAgICAgIHBsb3QgPSBuZXcgQ29uc3RhbnRQbG90KERhdGFWYWx1ZS5wYXJzZSh2YXhpcy50eXBlKCksIGpzb24udmVydGljYWxheGlzLmNvbnN0YW50KSk7XG4vL3h4eC8vICAgICAgICB9IGVsc2Uge1xuLy94eHgvLyAgICAgICAgICAgIHBsb3QgPSBuZXcgRGF0YVBsb3QoKTtcbi8veHh4Ly8gICAgICAgIH1cbi8veHh4XG4vL3h4eCAgICAgICAgcGxvdC52ZXJ0aWNhbGF4aXModmF4aXMpO1xuLy94eHhcbi8veHh4ICAgICAgICAvLyBwb3B1bGF0ZSBob3Jpem9udGFsYXhpc1xuLy94eHggICAgICAgIGlmIChqc29uLmhvcml6b250YWxheGlzKSB7XG4vL3h4eCAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi5ob3Jpem9udGFsYXhpcykgPT09ICdzdHJpbmcnKSB7XG4vL3h4eCAgICAgICAgICAgICAgICBheGlzaWQuaG9yaXpvbnRhbCA9IGpzb24uaG9yaXpvbnRhbGF4aXM7XG4vL3h4eCAgICAgICAgICAgIH0gZWxzZSB7XG4vL3h4eCAgICAgICAgICAgICAgICBpZiAoa2V5Q291bnQoanNvbi5ob3Jpem9udGFsYXhpcykgIT09IDEpIHtcbi8veHh4ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwbG90Lmhvcml6b250YWxheGlzIG11c3QgY29udGFpbiBleGFjdGx5IG9uZSBrZXkvdmFsdWUgcGFpclwiKTtcbi8veHh4ICAgICAgICAgICAgICAgIH1cbi8veHh4ICAgICAgICAgICAgICAgIGF4aXNpZC5ob3Jpem9udGFsID0ga2V5KGpzb24uaG9yaXpvbnRhbGF4aXMpO1xuLy94eHggICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLmhvcml6b250YWxheGlzW2F4aXNpZC5ob3Jpem9udGFsXSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbi8veHh4ICAgICAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24uaG9yaXpvbnRhbGF4aXNbYXhpc2lkLmhvcml6b250YWxdKSA9PT0gJ2FycmF5Jykge1xuLy94eHggICAgICAgICAgICAgICAgICAgICAgICB2YXJzLmhvcml6b250YWwgPSBqc29uLmhvcml6b250YWxheGlzW2F4aXNpZC5ob3Jpem9udGFsXTtcbi8veHh4ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuLy94eHggICAgICAgICAgICAgICAgICAgICAgICB2YXJzLmhvcml6b250YWwgPSBbIGpzb24uaG9yaXpvbnRhbGF4aXNbYXhpc2lkLmhvcml6b250YWxdIF07XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgfVxuLy94eHggICAgICAgICAgICAgICAgfVxuLy94eHggICAgICAgICAgICAgICAgaGF4aXMgPSBncmFwaC5heGlzQnlJZChheGlzaWQuaG9yaXpvbnRhbCk7XG4vL3h4eCAgICAgICAgICAgICAgICBpZiAoaGF4aXMgIT09IHVuZGVmaW5lZCkge1xuLy94eHggICAgICAgICAgICAgICAgICAgIHBsb3QuaG9yaXpvbnRhbGF4aXMoaGF4aXMpO1xuLy94eHggICAgICAgICAgICAgICAgfSBlbHNlIHtcbi8veHh4ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbG90IEhvcml6b250YWwgQXhpcyBFcnJvcjogVGhlIGdyYXBoIGRvZXMgbm90IGNvbnRhaW4gYW4gYXhpcyB3aXRoIGFuIGlkIG9mICdcIiArIGF4aXNpZC5ob3Jpem9udGFsICsgXCInXCIpO1xuLy94eHggICAgICAgICAgICAgICAgfVxuLy94eHggICAgICAgICAgICB9XG4vL3h4eCAgICAgICAgfVxuLy94eHhcbi8veHh4Ly8gICAgICAgIGlmIChqc29uLmhvcml6b250YWxheGlzICYmIGpzb24uaG9yaXpvbnRhbGF4aXMucmVmKSB7XG4vL3h4eC8vICAgICAgICAgICAgaGF4aXMgPSBncmFwaC5heGlzQnlJZChqc29uLmhvcml6b250YWxheGlzLnJlZik7XG4vL3h4eC8vICAgICAgICAgICAgaWYgKGhheGlzICE9PSB1bmRlZmluZWQpIHtcbi8veHh4Ly8gICAgICAgICAgICAgICAgcGxvdC5ob3Jpem9udGFsYXhpcyhoYXhpcyk7XG4vL3h4eC8vICAgICAgICAgICAgfSBlbHNlIHtcbi8veHh4Ly8gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxvdCBIb3Jpem9udGFsIEF4aXMgRXJyb3I6IFRoZSBncmFwaCBkb2VzIG5vdCBjb250YWluIGFuIGF4aXMgd2l0aCBhbiBpZCBvZiAnXCIgKyBqc29uLmhvcml6b250YWxheGlzLnJlZiArIFwiJ1wiKTtcbi8veHh4Ly8gICAgICAgICAgICB9XG4vL3h4eC8vICAgICAgICB9XG4vL3h4eFxuLy94eHggICAgICAgIC8vIGlmIHRoaXMgaXMgYSBEYXRhUGxvdCwgcGFyc2UgdmFyaWFibGVzXG4vL3h4eCAgICAgICAgaWYgKHBsb3QgaW5zdGFuY2VvZiBEYXRhUGxvdCkge1xuLy94eHhcbi8veHh4ICAgICAgICAgICAgLy8gcHJvdmlkZSBkZWZhdWx0IGhvcml6b250YWxheGlzIHZhcmlhYmxlIGlmIG5vbmUgcHJlc2VudFxuLy94eHggICAgICAgICAgICBpZiAodmFycy5ob3Jpem9udGFsLmxlbmd0aCA9PSAwKSB7XG4vL3h4eCAgICAgICAgICAgICAgICBwbG90LnZhcmlhYmxlKCkuYWRkKG51bGwpO1xuLy94eHggICAgICAgICAgICB9XG4vL3h4eFxuLy94eHggICAgICAgICAgICAvL1RPRE86IGRlZmVyIHBvcHVsYXRpb24gb2YgdmFyaWFibGVzIHVudGlsIG5vcm1hbGl6ZXIgaGFzIGV4ZWN1dGVkXG4vL3h4eCAgICAgICAgICAgIC8vIHBvcHVsYXRlIGF4aXMgdmFyaWFibGVzXG4vL3h4eCAgICAgICAgICAgIGlmIChncmFwaCkge1xuLy94eHggICAgICAgICAgICAgICAgdmFyIGFsbHZhcnMgPSBbXS5jb25jYXQodmFycy5ob3Jpem9udGFsLCB2YXJzLnZlcnRpY2FsKTtcbi8veHh4ICAgICAgICAgICAgICAgIGFsbHZhcnMuZm9yRWFjaChmdW5jdGlvbih2aWQpIHtcbi8veHh4ICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IGdyYXBoLnZhcmlhYmxlQnlJZCh2aWQpO1xuLy94eHggICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QuZGF0YSggdmFyaWFibGUuZGF0YSgpICk7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QudmFyaWFibGUoKS5hZGQodmFyaWFibGUpO1xuLy94eHggICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgVmFyaWFibGUgRXJyb3I6IE5vIERhdGEgdGFnIGNvbnRhaW5zIGEgdmFyaWFibGUgd2l0aCBhbiBpZCBvZiAnXCIgKyB2aWQgKyBcIidcIik7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgfVxuLy94eHggICAgICAgICAgICAgICAgfSk7XG4vL3h4eCAgICAgICAgICAgIH1cbi8veHh4ICAgICAgICB9XG5cblxuXG4vLyAgICAgICAgLy8gaWYgdGhpcyBpcyBhIERhdGFQbG90LCBwYXJzZSB2YXJpYWJsZXNcbi8vICAgICAgICBpZiAocGxvdCBpbnN0YW5jZW9mIERhdGFQbG90KSB7XG4vLyAgICAgICAgICAgIC8vIHByb3ZpZGUgZGVmYXVsdCBob3Jpem9udGFsYXhpcyB2YXJpYWJsZSBpZiBub3QgcHJlc2VudFxuLy8gICAgICAgICAgICBpZiAoIWpzb24uaG9yaXpvbnRhbGF4aXMgfHwgIWpzb24uaG9yaXpvbnRhbGF4aXMudmFyaWFibGVzIHx8IGpzb24uaG9yaXpvbnRhbGF4aXMudmFyaWFibGVzLmxlbmd0aCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgcGxvdC52YXJpYWJsZSgpLmFkZChudWxsKTtcbi8vICAgICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgICAgLy9UT0RPOiBkZWZlciBwb3B1bGF0aW9uIG9mIHZhcmlhYmxlcyB1bnRpbCBub3JtYWxpemVyIGhhcyBleGVjdXRlZFxuLy8gICAgICAgICAgICAvLyBwb3B1bGF0ZSBheGlzIHZhcmlhYmxlc1xuLy8gICAgICAgICAgICB2YXIgdmFycyA9IFtdO1xuLy8gICAgICAgICAgICBpZiAoZ3JhcGgpIHtcbi8vICAgICAgICAgICAgICAgIGlmIChqc29uLmhvcml6b250YWxheGlzICYmIGpzb24uaG9yaXpvbnRhbGF4aXMudmFyaWFibGVzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgdmFycyA9IHZhcnMuY29uY2F0KGpzb24uaG9yaXpvbnRhbGF4aXMudmFyaWFibGVzKTtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGlmIChqc29uLnZlcnRpY2FsYXhpcyAmJiBqc29uLnZlcnRpY2FsYXhpcy52YXJpYWJsZXMpIHtcbi8vICAgICAgICAgICAgICAgICAgICB2YXJzID0gdmFycy5jb25jYXQoanNvbi52ZXJ0aWNhbGF4aXMudmFyaWFibGVzKTtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIHZhcnMuZm9yRWFjaChmdW5jdGlvbih2aWQpIHtcbi8vICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IGdyYXBoLnZhcmlhYmxlQnlJZCh2aWQpO1xuLy8gICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QuZGF0YSggdmFyaWFibGUuZGF0YSgpICk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QudmFyaWFibGUoKS5hZGQodmFyaWFibGUpO1xuLy8gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgVmFyaWFibGUgRXJyb3I6IE5vIERhdGEgdGFnIGNvbnRhaW5zIGEgdmFyaWFibGUgd2l0aCBhbiBpZCBvZiAnXCIgKyB2aWQgKyBcIidcIik7XG4vLyAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgIH1cbi8vICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwibGVnZW5kXCIgaW4ganNvbikge1xuICAgICAgICAgICAgcGxvdC5sZWdlbmQoUGxvdExlZ2VuZC5wYXJzZUpTT04oanNvbi5sZWdlbmQsIHBsb3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBsb3QubGVnZW5kKFBsb3RMZWdlbmQucGFyc2VKU09OKHVuZGVmaW5lZCwgcGxvdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChcInJlbmRlcmVyXCIgaW4ganNvbikgJiYgKChcInN0eWxlXCIgaW4ganNvbikgfHwgKFwib3B0aW9uc1wiIGluIGpzb24pKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGxvdCBtYXkgbm90IGNvbnRhaW4gYm90aCAncmVuZGVyZXInIGFuZCAnc3R5bGUnLCBvciAncmVuZGVyZXInIGFuZCAnb3B0aW9ucydcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoanNvbi52aXNpYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBsb3QudmlzaWJsZShqc29uLnZpc2libGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwicmVuZGVyZXJcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICBwbG90LnJlbmRlcmVyKFJlbmRlcmVyLnBhcnNlSlNPTihqc29uLnJlbmRlcmVyLCBwbG90LCBtZXNzYWdlSGFuZGxlcikpO1xuICAgICAgICB9IGVsc2UgaWYgKFwic3R5bGVcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICAvLyBqc29uLm9wdGlvbnMgbWF5IG9yIG1heSBub3QgYmUgcHJlc2VudCBoZXJlXG4gICAgICAgICAgICBwbG90LnJlbmRlcmVyKFJlbmRlcmVyLnBhcnNlSlNPTihcbiAgICAgICAgICAgICAgICB7IFwidHlwZVwiIDoganNvbi5zdHlsZSwgXCJvcHRpb25zXCIgOiBqc29uLm9wdGlvbnMgfSxcbiAgICAgICAgICAgICAgICBwbG90LCBtZXNzYWdlSGFuZGxlcikpO1xuICAgICAgICB9IGVsc2UgaWYgKFwib3B0aW9uc1wiIGluIGpzb24pIHtcbiAgICAgICAgICAgIC8vIGpzb24ub3B0aW9ucyBpcyBwcmVzZW50LCBidXQganNvbi5zdHlsZSBpcyBub3QgaGVyZVxuICAgICAgICAgICAgLy8ganNvbi5vcHRpb25zIG1heSBvciBtYXkgbm90IGJlIHByZXNlbnQgaGVyZVxuICAgICAgICAgICAgcGxvdC5yZW5kZXJlcihSZW5kZXJlci5wYXJzZUpTT04oXG4gICAgICAgICAgICAgICAgeyBcInR5cGVcIiA6IFwibGluZVwiLCBcIm9wdGlvbnNcIiA6IGpzb24ub3B0aW9ucyB9LFxuICAgICAgICAgICAgICAgIHBsb3QsIG1lc3NhZ2VIYW5kbGVyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJmaWx0ZXJcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24uZmlsdGVyKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZihqc29uLmZpbHRlci50eXBlKSAhPT0gJ3VuZGVmaW5lZCcpICYmIChqc29uLmZpbHRlci50eXBlICE9PSAnY29uc2VjdXRpdmVkaXN0YW5jZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBmaWx0ZXIgdHlwZTogJyArIGpzb24uZmlsdGVyLnR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwbG90LnJlbmRlcmVyKCkuZmlsdGVyKG5ldyBDb25zZWN1dGl2ZURpc3RhbmNlRmlsdGVyKGpzb24uZmlsdGVyKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZGLnR5cGVPZihqc29uLmZpbHRlcikgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhcGggJiYgZ3JhcGguZmlsdGVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QucmVuZGVyZXIoKS5maWx0ZXIoZ3JhcGguZmlsdGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5yZW5kZXJlcigpLmZpbHRlcihuZXcgQ29uc2VjdXRpdmVEaXN0YW5jZUZpbHRlcih7fSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmlsdGVyIHByb3BlcnR5OiAnICsganNvbi5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyYXBoICYmIGdyYXBoLmZpbHRlcigpKSB7XG4gICAgICAgICAgICBwbG90LnJlbmRlcmVyKCkuZmlsdGVyKGdyYXBoLmZpbHRlcigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcImRhdGF0aXBzXCIgaW4ganNvbikge1xuICAgICAgICAgICAgcGxvdC5kYXRhdGlwcyhEYXRhdGlwcy5wYXJzZUpTT04oanNvbi5kYXRhdGlwcykpO1xuICAgICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIHBsb3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsb3Q7XG4iLCJ2YXIgUGxvdExlZ2VuZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGxvdF9sZWdlbmQuanMnKTtcblxuLy8gXCJsZWdlbmRcIiA6IHsgXCJ2aXNpYmxlXCIgOiBCT09MRUFOLCAgXCJsYWJlbFwiIDogXCJTVFJJTkdcIiB9XG4vLyBCT09MRUFOXG5QbG90TGVnZW5kLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBwbG90KSB7XG4gICAgdmFyIGxlZ2VuZCAgICAgICAgICAgPSBuZXcgUGxvdExlZ2VuZCgpLFxuICAgICAgICBwRiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIFRleHQgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RleHQuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBjaGlsZDtcbiAgICBpZiAodHlwZW9mKGpzb24pID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBsZWdlbmQudmlzaWJsZShqc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi52aXNpYmxlLCBsZWdlbmQudmlzaWJsZSwgcEYucGFyc2VCb29sZWFuKTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubGFiZWwsICAgbGVnZW5kLmxhYmVsLCAgIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFRleHQodmFsdWUpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVnZW5kLmxhYmVsKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB1Z2x5IHBhdGNoIHdpdGggc29tZXRoaW5nIHRoYXQgd29ya3MgcHJvcGVybHlcbiAgICAgICAgaWYgKHR5cGVvZihwbG90LnZhcmlhYmxlKT09PVwiZnVuY3Rpb25cIiAmJiBwbG90LnZhcmlhYmxlKCkuc2l6ZSgpID49IDIpIHsgXG4gICAgICAgICAgICBsZWdlbmQubGFiZWwobmV3IFRleHQocGxvdC52YXJpYWJsZSgpLmF0KDEpLmlkKCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2VuZC5sYWJlbChuZXcgVGV4dChcInBsb3RcIikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlZ2VuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGxvdExlZ2VuZDtcbiIsInZhciBQbG90YXJlYSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGxvdGFyZWEuanMnKTtcblxuLy8gIFwicGxvdGFyZWFcIiA6IHtcbi8vICAgICBcIm1hcmdpbmJvdHRvbVwiOiBJTlRFR0VSKDM1KSxcbi8vICAgICBcIm1hcmdpbmxlZnRcIjogSU5URUdFUigzOCksXG4vLyAgICAgXCJtYXJnaW50b3BcIjogSU5URUdFUigxMCksXG4vLyAgICAgXCJtYXJnaW5yaWdodFwiOiBJTlRFR0VSKDM1KSxcbi8vICAgICBcImJvcmRlclwiOiBJTlRFR0VSKDApLFxuLy8gICAgIFwiYm9yZGVyY29sb3JcIjogQ09MT1IoMHhlZWVlZWUpLFxuLy8gICAgIFwiY29sb3JcIjogQ09MT1IsXG4vLyAgfVxuUGxvdGFyZWEucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICB2YXIgcGxvdGFyZWEgPSBuZXcgUGxvdGFyZWEoKSxcbiAgICAgICAgbWFyZ2luID0gcGxvdGFyZWEubWFyZ2luKCksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgUkdCQ29sb3IgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgIHBhcnNlUkdCQ29sb3IgICAgPSBSR0JDb2xvci5wYXJzZSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBwYXJzZUludGVnZXIgICAgID0gcEYucGFyc2VJbnRlZ2VyO1xuICAgIGlmIChqc29uKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubWFyZ2luYm90dG9tLCBtYXJnaW4uYm90dG9tKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5tYXJnaW5sZWZ0LCAgIG1hcmdpbi5sZWZ0KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5tYXJnaW50b3AsICAgIG1hcmdpbi50b3ApO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm1hcmdpbnJpZ2h0LCAgbWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5ib3JkZXIsICAgICAgIHBsb3RhcmVhLmJvcmRlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uY29sb3IsICAgICAgICBwbG90YXJlYS5jb2xvciwgICAgICAgcGFyc2VSR0JDb2xvcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYm9yZGVyY29sb3IsICBwbG90YXJlYS5ib3JkZXJjb2xvciwgcGFyc2VSR0JDb2xvcik7XG4gICAgfVxuICAgIHJldHVybiBwbG90YXJlYTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGxvdGFyZWE7XG4iLCJ2YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3JlbmRlcmVyLmpzJyk7XG5cbi8vIFwicmVuZGVyZXJcIiA6IHtcbi8vICAgICBcInR5cGVcIiA6IFJFTkRFUkVSVFlQRShsaW5lKVxuLy8gICAgIFwib3B0aW9uc1wiIDogW1xuLy8gICAgICAgeyBcIm5hbWVcIiA6IFwiU1RSSU5HIVwiLCBcInZhbHVlXCIgOiBcIlNUUklORyFcIiwgXCJtaW5cIiA6IFwiREFUQVZBTFVFXCIsIFwibWF4XCIgOiBcIkRBVEFWQUxVRVwiIH0sXG4vLyAgICAgICB7IFwibmFtZVwiIDogXCJTVFJJTkchXCIsIFwidmFsdWVcIiA6IFwiU1RSSU5HIVwiLCBcIm1pblwiIDogXCJEQVRBVkFMVUVcIiwgXCJtYXhcIiA6IFwiREFUQVZBTFVFXCIgfSxcbi8vICAgICAgIC4uLlxuLy8gICAgIF1cbi8vICAgfVxuUmVuZGVyZXIucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24sIHBsb3QsIG1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgdmFyIERhdGFWYWx1ZSAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIE51bWJlclZhbHVlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9udW1iZXJfdmFsdWUuanMnKSxcbiAgICAgICAgV2FybmluZyAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3dhcm5pbmcuanMnKSxcbiAgICAgICAgcEYgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgdkYgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcmVuZGVyZXJUeXBlLFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgb3B0O1xuXG4gICAgcmVxdWlyZSgnLi4vLi4vY29yZS9yZW5kZXJlcnMvYWxsX3JlbmRlcmVycy5qcycpO1xuXG4gICAgZnVuY3Rpb24gc2V0T3B0aW9uKG5hbWUsIHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0T3B0aW9uRnJvbVN0cmluZyhuYW1lLCB2YWx1ZSwgbWluLCBtYXgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFdhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci53YXJuaW5nKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGpzb24gJiYganNvbi50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVuZGVyZXJUeXBlID0gUmVuZGVyZXIuVHlwZS5wYXJzZShqc29uLnR5cGUpO1xuICAgICAgICBpZiAoIVJlbmRlcmVyLlR5cGUuaXNJbnN0YW5jZShyZW5kZXJlclR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHJlbmRlcmVyIHR5cGUgJ1wiICsganNvbi50eXBlICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyID0gUmVuZGVyZXIuY3JlYXRlKHJlbmRlcmVyVHlwZSk7XG4gICAgICAgIHJlbmRlcmVyLnBsb3QocGxvdCk7XG5cbiAgICAgICAgaWYgKGpzb24ub3B0aW9ucykge1xuICAgICAgICAgICAgZm9yIChvcHQgaW4ganNvbi5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24ub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi5vcHRpb25zW29wdF0pID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLm9wdGlvbnNbb3B0XS5mb3JFYWNoKGZ1bmN0aW9uKHN1Ym9wdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbihvcHQsIHN1Ym9wdC52YWx1ZSwgc3Vib3B0Lm1pbiwgc3Vib3B0Lm1heCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbihvcHQsIGpzb24ub3B0aW9uc1tvcHRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiByZW5kZXJlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG4iLCJ2YXIgVGl0bGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RpdGxlLmpzJyk7XG5cbi8vICBcInRpdGxlXCIgOiB7XG4vLyAgICAgIFwiYmFzZVwiIDogUE9JTlQoMCwxKSxcbi8vICAgICAgXCJhbmNob3JcIiA6IFBPSU5UKDAsMSksXG4vLyAgICAgIFwicG9zaXRpb25cIiA6IFBPSU5UKDAsMCksXG4vLyAgICAgIFwiZnJhbWVcIiA6IEZSQU1FKHBhZGRpbmcpLFxuLy8gICAgICBcImNvbG9yXCIgOiBDT0xPUih3aGl0ZSksXG4vLyAgICAgIFwib3BhY2l0eVwiIDogRE9VQkxFKDEuMCksXG4vLyAgICAgIFwiYm9yZGVyXCIgOiBJTlRFR0VSKDApLFxuLy8gICAgICBcImJvcmRlcmNvbG9yXCIgOiBDT0xPUihibGFjayksXG4vLyAgICAgIFwicGFkZGluZ1wiIDogSU5URUdFUigwKSxcbi8vICAgICAgXCJjb3JuZXJyYWRpdXNcIiA6IElOVEVHRVIoMTUpLFxuLy8gICAgICBcImZvbnRzaXplXCIgOiBJTlRFR0VSLFxuLy8gICAgICBcInRleHRcIiA6IFNUUklOR1xuLy8gIH1cblRpdGxlLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBncmFwaCkge1xuICAgIHZhciBQb2ludCAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpLFxuICAgICAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgVGV4dCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdGV4dC5qcycpLFxuICAgICAgICBwRiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHBhcnNlSlNPTlBvaW50ICAgPSBmdW5jdGlvbihwKSB7IHJldHVybiBuZXcgUG9pbnQocFswXSwgcFsxXSk7IH0sXG4gICAgICAgIHBhcnNlUkdCQ29sb3IgICAgPSBSR0JDb2xvci5wYXJzZSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICB0aXRsZTtcblxuICAgIGlmIChqc29uKSB7XG4gICAgICAgIHZhciB0ZXh0ID0ganNvbi50ZXh0O1xuICAgICAgICBpZiAodGV4dCAhPT0gXCJcIikge1xuICAgICAgICAgICAgdGl0bGUgPSBuZXcgVGl0bGUobmV3IFRleHQodGV4dCksIGdyYXBoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gICAgICAgICAgICAgICAgXG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uZnJhbWUsICAgICAgICB0aXRsZS5mcmFtZSwgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTsgfSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYm9yZGVyLCAgICAgICB0aXRsZS5ib3JkZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmNvbG9yLCAgICAgICAgdGl0bGUuY29sb3IsICAgICAgICBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5ib3JkZXJjb2xvciwgIHRpdGxlLmJvcmRlcmNvbG9yLCAgcGFyc2VSR0JDb2xvcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ub3BhY2l0eSwgICAgICB0aXRsZS5vcGFjaXR5KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5wYWRkaW5nLCAgICAgIHRpdGxlLnBhZGRpbmcpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmNvcm5lcnJhZGl1cywgdGl0bGUuY29ybmVycmFkaXVzKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5hbmNob3IsICAgICAgIHRpdGxlLmFuY2hvciwgICAgICAgcGFyc2VKU09OUG9pbnQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJhc2UsICAgICAgICAgdGl0bGUuYmFzZSwgICAgICAgICBwYXJzZUpTT05Qb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ucG9zaXRpb24sICAgICB0aXRsZS5wb3NpdGlvbiwgICAgIHBhcnNlSlNPTlBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpdGxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaXRsZTtcbiIsInZhciBXaW5kb3cgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3dpbmRvdy5qcycpO1xuXG4vLyBcIndpbmRvd1wiIHtcbi8vICAgICAgIFwid2lkdGhcIjogSU5URUdFUixcbi8vICAgICAgIFwiaGVpZ2h0XCI6IElOVEVHRVIsXG4vLyAgICAgICBcImJvcmRlclwiOiBJTlRFR0VSKDIpLFxuLy8gICAgICAgXCJib3JkZXJjb2xvclwiOiBDT0xPUihibGFjayksXG4vLyAgICAgICBcIm1hcmdpblwiOiBJTlRFR0VSKDIpLFxuLy8gICAgICAgXCJwYWRkaW5nXCI6IElOVEVHRVIoNSksXG4vLyB9XG5XaW5kb3cucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICB2YXIgdyA9IG5ldyBXaW5kb3coKSxcbiAgICAgICAgUkdCQ29sb3IgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBwYXJzZUludGVnZXIgICAgID0gcEYucGFyc2VJbnRlZ2VyLFxuICAgICAgICBhdHRyO1xuICAgIGlmIChqc29uKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ud2lkdGgsICB3LndpZHRoKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5oZWlnaHQsIHcuaGVpZ2h0KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5ib3JkZXIsIHcuYm9yZGVyKTtcblxuICAgICAgICBhdHRyID0ganNvbi5tYXJnaW47XG4gICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHcubWFyZ2luKCkuc2V0KGF0dHIsYXR0cixhdHRyLGF0dHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0ciA9IGpzb24ucGFkZGluZztcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHcucGFkZGluZygpLnNldChhdHRyLGF0dHIsYXR0cixhdHRyKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJvcmRlcmNvbG9yLCB3LmJvcmRlcmNvbG9yLCBSR0JDb2xvci5wYXJzZSk7XG4gICAgfVxuICAgIHJldHVybiB3O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaW5kb3c7XG4iLCJ2YXIgWm9vbSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvem9vbS5qcycpO1xuXG5ab29tLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCB0eXBlKSB7XG4gICAgdmFyIHpvb20gICAgICAgICAgICAgPSBuZXcgWm9vbSgpLFxuICAgICAgICBEYXRhVmFsdWUgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIERhdGFNZWFzdXJlICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfbWVhc3VyZS5qcycpLFxuICAgICAgICBwRiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHZGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBwYXJzZUJvb2xlYW4gICAgID0gcEYucGFyc2VCb29sZWFuLFxuICAgICAgICBwYXJzZURhdGFNZWFzdXJlID0gZnVuY3Rpb24odikgeyByZXR1cm4gRGF0YU1lYXN1cmUucGFyc2UodHlwZSwgdik7IH0sIC8vcEYucGFyc2VEYXRhTWVhc3VyZVxuICAgICAgICBhdHRyO1xuICAgIGlmICh2Ri50eXBlT2YoanNvbikgPT09ICdib29sZWFuJykge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLCAgICAgICAgIHpvb20uYWxsb3dlZCwgcGFyc2VCb29sZWFuKTtcbiAgICB9IGVsc2UgaWYgKGpzb24pIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5hbGxvd2VkLCB6b29tLmFsbG93ZWQsIHBhcnNlQm9vbGVhbik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubWluLCAgICAgem9vbS5taW4sICAgICBwYXJzZURhdGFNZWFzdXJlKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5tYXgsICAgICB6b29tLm1heCwgICAgIHBhcnNlRGF0YU1lYXN1cmUpO1xuICAgICAgICBhdHRyID0ganNvbi5hbmNob3I7XG4gICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoYXR0cikgPT09IFwic3RyaW5nXCIgJiYgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgIHpvb20uYW5jaG9yKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB6b29tLmFuY2hvciggRGF0YVZhbHVlLnBhcnNlKHR5cGUsIGF0dHIpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHpvb207XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFpvb207XG4iLCIvLyBUaGlzIGZpbGUgdXNlcyBqUXVlcnkuICBBIHZhbGlkIGpRdWVyeSBvYmplY3QgbXVzdCBiZSBwYXNzZWQgdG8gdGhlXG4vLyBmdW5jdGlvbiByZXR1cm5lZCBieSByZXF1aXJpbmcgdGhpcyBmaWxlLlxuXG4vLyAgPGhvcml6b250YWxheGlzIGlkPVwiU1RSSU5HXCIgdHlwZT1cIkRBVEFUWVBFKG51bWJlcilcIiBsZW5ndGg9XCJSRUxMRU4oMS4wKVwiIGJhc2U9XCJQT0lOVCgtMSwxKVwiIGFuY2hvcj1cIkRPVUJMRSgtMSlcIiBwb3NpdGlvbj1cIlBPSU5UKDAsMClcIlxuLy8gICAgICBtaW49XCJEQVRBVkFMVUVPUkFVVE8oYXV0bylcIiBtYXg9XCJEQVRBVkFMVUVPUkFVVE8oYXV0bylcIiBtaW5wb3NpdGlvbj1cIlJFTFBPUygtMS4wKVwiIG1heHBvc2l0aW9uPVwiUkVMUE9TKDEuMClcIiBjb2xvcj1cIkNPTE9SKGJsYWNrKVwiIGxpbmV3aWR0aD1cIklOVEVHRVIoMSlcIlxuLy8gICAgICB0aWNrbWluPVwiSU5URUdFUigtMylcIiB0aWNrbWF4PVwiSU5URUdFUigzKVwiIHRpY2tjb2xvcj1cIkNPTE9SKGJsYWNrKVwiPlxuLy8gICAgPGxhYmVscyBmb3JtYXQ9XCJTVFJJTkdcIiBzdGFydD1cIkRBVEFWQUxVRSgwKVwiIGFuZ2xlPVwiRE9VQkxFKDApXCIgcG9zaXRpb249XCJQT0lOVFwiIGFuY2hvcj1cIlBPSU5UXCIgY29sb3I9XCJDT0xPUihibGFjaylcIiBzcGFjaW5nPVwiU1RSSU5HXCIgZGVuc2l0eWZhY3Rvcj1cIkRPVUJMRSgxLjApXCI+XG4vLyAgICAgICAgPGxhYmVsIGZvcm1hdD1cIlNUUklOR1wiIHN0YXJ0PVwiU1RSSU5HXCIgYW5nbGU9XCJET1VCTEVcIiBwb3NpdGlvbj1cIlBPSU5UXCIgYW5jaG9yPVwiUE9JTlRcIiBzcGFjaW5nPVwiU1RSSU5HXCIgZGVuc2l0eWZhY3Rvcj1cIkRPVUJMRVwiPlxuLy8gICAgICAgIDxsYWJlbCBmb3JtYXQ9XCJTVFJJTkdcIiBzdGFydD1cIlNUUklOR1wiIGFuZ2xlPVwiRE9VQkxFXCIgcG9zaXRpb249XCJQT0lOVFwiIGFuY2hvcj1cIlBPSU5UXCIgc3BhY2luZz1cIlNUUklOR1wiIGRlbnNpdHlmYWN0b3I9XCJET1VCTEVcIj5cbi8vICAgICAgPC9sYWJlbD5cbi8vICAgIDwvbGFiZWxzPlxuLy8gICAgPHRpdGxlIGJhc2U9XCJET1VCTEUoMClcIiBhbmNob3I9XCJQT0lOVFwiIHBvc2l0aW9uPVwiUE9JTlRcIiBhbmdsZT1cIkRPVUJMRSgwKVwiPlRJVExFVEVYVDwvdGl0bGU+XG4vLyAgICA8Z3JpZCBjb2xvcj1cIkNPTE9SKDB4ZWVlZWVlKVwiIHZpc2libGU9XCJCT09MRUFOKGZhbHNlKVwiIC8+XG4vLyAgICA8cGFuIGFsbG93ZWQ9XCJCT09MRUFOKHllcylcIiBtaW49XCJEQVRBVkFMVUVcIiBtYXg9XCJEQVRBVkFMVUVcIiAvPlxuLy8gICAgPHpvb20gYWxsb3dlZD1cIkJPT0xFQU4oeWVzKVwiIG1pbj1cIkRBVEFNRUFTVVJFXCIgbWF4PVwiREFUQU1FQVNVUkVcIiBhbmNob3I9XCJEQVRBVkFMVUVcIiAvPlxuLy8gICAgPGJpbmRpbmcgaWQ9XCJTVFJJTkchXCIgbWluPVwiREFUQVZBTFVFIVwiIG1heD1cIkRBVEFWQUxVRSFcIiAvPlxuLy8gIDwvaG9yaXpvbnRhbGF4aXM+XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIHZhciBBeGlzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzLmpzJyksXG4gICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyk7XG5cbiAgICAvLyBpZiBwYXJzZVhNTCBtZXRob2QgYWxyZWFkeSBoYXMgYmVlbiBkZWZpbmVkLCB3aGljaCB3b3VsZCBiZSB0aGUgY2FzZSBpZiB0aGlzXG4gICAgLy8gZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkLCBqdXN0IHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0eXBlb2YoQXhpcy5wYXJzZVhNTCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIEF4aXM7IH07XG5cbiAgICB2YXIgcGFyc2VMYWJlbHMgPSBmdW5jdGlvbiAoeG1sLCBheGlzKSB7XG4gICAgICAgIHZhciBzcGFjaW5nU3RyaW5ncyA9IFtdLFxuICAgICAgICAgICAgc3BhY2luZ1N0cmluZyxcbiAgICAgICAgICAgIGxhYmVsc1RhZyA9IHhtbC5maW5kKFwibGFiZWxzXCIpLFxuICAgICAgICAgICAgbGFiZWxUYWdzID0geG1sLmZpbmQoXCJsYWJlbFwiKSxcbiAgICAgICAgICAgIGxhYmVsZXJzICA9IGF4aXMubGFiZWxlcnMoKSxcbiAgICAgICAgICAgIExhYmVsZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2xhYmVsZXIuanMnKSxcbiAgICAgICAgICAgIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgICAgICAgICAgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgc3BhY2luZ1N0cmluZyA9ICQudHJpbShwRi5nZXRYTUxBdHRyKGxhYmVsc1RhZyxcInNwYWNpbmdcIikpO1xuICAgICAgICBpZiAoc3BhY2luZ1N0cmluZyAhPT0gXCJcIikge1xuICAgICAgICAgICAgc3BhY2luZ1N0cmluZ3MgPSBzcGFjaW5nU3RyaW5nLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwYWNpbmdTdHJpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHNwYWNpbmcgYXR0ciBvbiB0aGUgPGxhYmVscz4gdGFnLCBjcmVhdGUgYSBuZXcgbGFiZWxlciBmb3JcbiAgICAgICAgICAgIC8vIGVhY2ggc3BhY2luZyBwcmVzZW50IGluIGl0LCB1c2luZyB0aGUgb3RoZXIgdmFsdWVzIGZyb20gdGhlIDxsYWJlbHM+IHRhZ1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNpbmdTdHJpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxlcnMuYWRkKExhYmVsZXIucGFyc2VYTUwobGFiZWxzVGFnLCBheGlzLCB1bmRlZmluZWQsIHNwYWNpbmdTdHJpbmdzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGFiZWxUYWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSA8bGFiZWw+IHRhZ3MsIHBhcnNlIHRoZSA8bGFiZWxzPiB0YWcgdG8gZ2V0IGRlZmF1bHQgdmFsdWVzXG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBMYWJlbGVyLnBhcnNlWE1MKGxhYmVsc1RhZywgYXhpcywgdW5kZWZpbmVkLCBudWxsKTtcbiAgICAgICAgICAgIC8vIEFuZCBsb29wIG92ZXIgZWFjaCA8bGFiZWw+IHRhZywgY3JlYXRpbmcgbGFiZWxlcnMgZm9yIGVhY2gsIHNwbGl0dGluZyBtdWx0aXBsZVxuICAgICAgICAgICAgLy8gc3BhY2luZ3Mgb24gdGhlIHNhbWUgPGxhYmVsPiB0YWcgaW50byBtdWx0aXBsZSBsYWJlbGVyczpcbiAgICAgICAgICAgICQuZWFjaChsYWJlbFRhZ3MsIGZ1bmN0aW9uIChqLCBlKSB7XG4gICAgICAgICAgICAgICAgc3BhY2luZ1N0cmluZyA9ICQudHJpbShwRi5nZXRYTUxBdHRyKCQoZSksIFwic3BhY2luZ1wiKSk7XG4gICAgICAgICAgICAgICAgc3BhY2luZ1N0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2luZ1N0cmluZyAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBzcGFjaW5nU3RyaW5ncyA9IHNwYWNpbmdTdHJpbmcuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNpbmdTdHJpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsZXJzLmFkZCggTGFiZWxlci5wYXJzZVhNTCgkKGUpLCBheGlzLCBkZWZhdWx0cywgc3BhY2luZ1N0cmluZ3NbaV0pICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgY3JlYXRlIGxhYmVsZXJzIHVzaW5nIHRoZSBkZWZhdWx0IHNwYWNpbmcsIHdpdGggdGhlIG90aGVyIHZhbHVlc1xuICAgICAgICAgICAgLy8gZnJvbSB0aGUgPGxhYmVscz4gdGFnXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlcyA9ICh1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCkpLmhvcml6b250YWxheGlzLmxhYmVscztcbiAgICAgICAgICAgIHZhciBkZWZhdWx0U3BhY2luZ3MgPSBheGlzLnR5cGUoKSA9PT0gRGF0YVZhbHVlLk5VTUJFUiA/XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXMuZGVmYXVsdE51bWJlclNwYWNpbmcgOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzLmRlZmF1bHREYXRldGltZVNwYWNpbmc7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVmYXVsdFNwYWNpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxlcnMuYWRkKExhYmVsZXIucGFyc2VYTUwobGFiZWxzVGFnLCBheGlzLCB1bmRlZmluZWQsIGRlZmF1bHRTcGFjaW5nc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFxuICAgIEF4aXMucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sLCBvcmllbnRhdGlvbiwgbWVzc2FnZUhhbmRsZXIsIG11bHRpZ3JhcGgpIHtcblxuICAgICAgICB2YXIgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICAgICAgICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgICAgIERpc3BsYWNlbWVudCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvZGlzcGxhY2VtZW50LmpzJyksXG4gICAgICAgICAgICBBeGlzVGl0bGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2F4aXNfdGl0bGUuanMnKSxcbiAgICAgICAgICAgIEdyaWQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2dyaWQuanMnKSxcbiAgICAgICAgICAgIFBhbiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGFuLmpzJyksXG4gICAgICAgICAgICBab29tID0gcmVxdWlyZSgnLi4vLi4vY29yZS96b29tLmpzJyksXG4gICAgICAgICAgICBBeGlzQmluZGluZyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpc19iaW5kaW5nLmpzJyksXG5cbiAgICAgICAgICAgIGF4aXMgICAgICAgICAgICAgID0gbmV3IEF4aXMob3JpZW50YXRpb24pLFxuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgICAgIHBhcnNlSW50ZWdlciAgICAgID0gcEYucGFyc2VJbnRlZ2VyLFxuICAgICAgICAgICAgcGFyc2VEaXNwbGFjZW1lbnQgPSBEaXNwbGFjZW1lbnQucGFyc2UsXG4gICAgICAgICAgICBwYXJzZVBvaW50ICAgICAgICA9IFBvaW50LnBhcnNlLFxuICAgICAgICAgICAgcGFyc2VSR0JDb2xvciAgICAgPSBSR0JDb2xvci5wYXJzZSxcbiAgICAgICAgICAgIGF0dHIsIGNoaWxkLFxuICAgICAgICAgICAgdmFsdWU7XG5cbiAgICAgICAgaWYgKHhtbCkge1xuXG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJpZFwiKSwgICAgIGF4aXMuaWQpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwidHlwZVwiKSwgICBheGlzLnR5cGUsICAgRGF0YVZhbHVlLnBhcnNlVHlwZSk7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJsZW5ndGhcIiksIGF4aXMubGVuZ3RoLCBwYXJzZURpc3BsYWNlbWVudCk7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHByb3ZpZGVzIHN1cHBvcnQgZm9yIHRoZSBkZXByZWNhdGVkIFwicG9zaXRpb25iYXNlXCIgYXhpcyBhdHRyaWJ1dGU7XG4gICAgICAgICAgICAvLyBNVUdMIGZpbGVzIHNob3VsZCB1c2UgdGhlIFwiYmFzZVwiIGF0dHJpYnV0ZSBpbnN0ZWFkLiAgV2hlbiB3ZSdyZSByZWFkeSB0byByZW1vdmVcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIHRoZSBkZXByZWNhdGVkIGF0dHJpYnV0ZSwgZGVsZXRlIHRoaXMgYmxvY2sgb2YgY29kZTpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbmJhc2UgPSBwRi5nZXRYTUxBdHRyKHhtbCwgXCJwb3NpdGlvbmJhc2VcIik7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci53YXJuaW5nKCdVc2Ugb2YgZGVwcmVjYXRlZCBheGlzIGF0dHJpYnV0ZSBcInBvc2l0aW9uYmFzZVwiOyB1c2UgXCJiYXNlXCIgYXR0cmlidXRlIGluc3RlYWQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwb3NpdGlvbmJhc2UgPT09IFwibGVmdFwiKSB8fCAocG9zaXRpb25iYXNlID09PSBcImJvdHRvbVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5iYXNlKHBhcnNlUG9pbnQoXCItMSAtMVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb25iYXNlID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuYmFzZShwYXJzZVBvaW50KFwiMSAtMVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb25iYXNlID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLmJhc2UocGFyc2VQb2ludChcIi0xIDFcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBFbmQgb2YgY29kZSB0byBkZWxldGUgd2hlbiByZW1vdmluZyBzdXBwb3J0IGZvciBkZXByZWNhdGVkIFwicG9zaXRpb25iYXNlXCJcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGF0dHIgPSBwRi5nZXRYTUxBdHRyKHhtbCwgXCJwb3NpdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBheGlzLnBvc2l0aW9uKHBhcnNlUG9pbnQoYXR0cikpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgcG9zaXRpb24gZGlkIG5vdCBwYXJzZSBhcyBhIFBvaW50LCBhbmQgaWYgaXQgY2FuIGJlIGludGVycHJldGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGEgbnVtYmVyLCBjb25zdHJ1Y3QgdGhlIHBvc2l0aW9uIHBvaW50IGJ5IGludGVycHJldGluZyB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgMCBsb2NhdGlvbiBhbG9uZyB0aGUgcGVycGVuZGljdWxhclxuICAgICAgICAgICAgICAgICAgICAvLyBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoYXR0ciwgMTApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSB7IC8vIHRlc3QgZm9yIGlzTmFOXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gQXhpcy5IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLnBvc2l0aW9uKG5ldyBQb2ludCgwLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5wb3NpdGlvbihuZXcgUG9pbnQodmFsdWUsIDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXhpcy5taW4ocEYuZ2V0WE1MQXR0cih4bWwsIFwibWluXCIpKTtcbiAgICAgICAgICAgIGlmIChheGlzLm1pbigpICE9PSBcImF1dG9cIikge1xuICAgICAgICAgICAgICAgIGF4aXMuZGF0YU1pbihEYXRhVmFsdWUucGFyc2UoYXhpcy50eXBlKCksIGF4aXMubWluKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF4aXMubWF4KHBGLmdldFhNTEF0dHIoeG1sLCBcIm1heFwiKSk7XG4gICAgICAgICAgICBpZiAoYXhpcy5tYXgoKSAhPT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgICAgICBheGlzLmRhdGFNYXgoRGF0YVZhbHVlLnBhcnNlKGF4aXMudHlwZSgpLCBheGlzLm1heCgpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLCBcInByZWdhcFwiKSwgICAgICAgICBheGlzLnByZWdhcCwgICAgICAgICBwYXJzZUZsb2F0KTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLCBcInBvc3RnYXBcIiksICAgICAgICBheGlzLnBvc3RnYXAsICAgICAgICBwYXJzZUZsb2F0KTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLCBcImFuY2hvclwiKSwgICAgICAgICBheGlzLmFuY2hvciwgICAgICAgICBwYXJzZUZsb2F0KTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLCBcImJhc2VcIiksICAgICAgICAgICBheGlzLmJhc2UsICAgICAgICAgICBwYXJzZVBvaW50KTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLCBcIm1pbnBvc2l0aW9uXCIpLCAgICBheGlzLm1pbnBvc2l0aW9uLCAgICBwYXJzZURpc3BsYWNlbWVudCk7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJtYXhwb3NpdGlvblwiKSwgICAgYXhpcy5tYXhwb3NpdGlvbiwgICAgcGFyc2VEaXNwbGFjZW1lbnQpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwibWlub2Zmc2V0XCIpLCAgICAgIGF4aXMubWlub2Zmc2V0LCAgICAgIHBhcnNlRmxvYXQpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwibWF4b2Zmc2V0XCIpLCAgICAgIGF4aXMubWF4b2Zmc2V0LCAgICAgIHBhcnNlRmxvYXQpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwiY29sb3JcIiksICAgICAgICAgIGF4aXMuY29sb3IsICAgICAgICAgIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwidGlja2NvbG9yXCIpLCAgICAgIGF4aXMudGlja2NvbG9yLCAgICAgIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwidGlja3dpZHRoXCIpLCAgICAgIGF4aXMudGlja3dpZHRoLCAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJ0aWNrbWluXCIpLCAgICAgICAgYXhpcy50aWNrbWluLCAgICAgICAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLCBcInRpY2ttYXhcIiksICAgICAgICBheGlzLnRpY2ttYXgsICAgICAgICBwYXJzZUludGVnZXIpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwiaGlnaGxpZ2h0c3R5bGVcIiksIGF4aXMuaGlnaGxpZ2h0c3R5bGUpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwibGluZXdpZHRoXCIpLCAgICAgIGF4aXMubGluZXdpZHRoLCAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJ0aXRsZVwiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSAgICAgICAgICAgICAgICAgICAgeyBheGlzLnRpdGxlKEF4aXNUaXRsZS5wYXJzZVhNTChjaGlsZCwgYXhpcykpOyAgICAgfVxuICAgICAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGF4aXMudGl0bGUobmV3IEF4aXNUaXRsZShheGlzKSk7ICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcImdyaWRcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkgICAgICAgICAgICAgICAgICAgIHsgYXhpcy5ncmlkKEdyaWQucGFyc2VYTUwoY2hpbGQpKTsgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJwYW5cIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkgICAgICAgICAgICAgICAgICAgIHsgYXhpcy5wYW4oUGFuLnBhcnNlWE1MKGNoaWxkLCBheGlzLnR5cGUoKSkpOyAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJ6b29tXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApICAgICAgICAgICAgICAgICAgICB7IGF4aXMuem9vbShab29tLnBhcnNlWE1MKGNoaWxkLCBheGlzLnR5cGUoKSkpOyAgICB9XG4gICAgICAgICAgICBpZiAoeG1sLmZpbmQoXCJsYWJlbHNcIikubGVuZ3RoID4gMCkgICAgICAgeyBwYXJzZUxhYmVscyh4bWwsIGF4aXMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwiYmluZGluZ1wiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdJZEF0dHIgID0gcEYuZ2V0WE1MQXR0cihjaGlsZCxcImlkXCIpLFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nTWluQXR0ciA9IHBGLmdldFhNTEF0dHIoY2hpbGQsXCJtaW5cIiksXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdNYXhBdHRyID0gcEYuZ2V0WE1MQXR0cihjaGlsZCxcIm1heFwiKSxcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ01pbkRhdGFWYWx1ZSA9IERhdGFWYWx1ZS5wYXJzZShheGlzLnR5cGUoKSwgYmluZGluZ01pbkF0dHIpLFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nTWF4RGF0YVZhbHVlID0gRGF0YVZhbHVlLnBhcnNlKGF4aXMudHlwZSgpLCBiaW5kaW5nTWF4QXR0cik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihiaW5kaW5nSWRBdHRyKSAhPT0gXCJzdHJpbmdcIiB8fCBiaW5kaW5nSWRBdHRyLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXhpcyBiaW5kaW5nIGlkOiAnXCIgKyBiaW5kaW5nSWRBdHRyICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoISBEYXRhVmFsdWUuaXNJbnN0YW5jZShiaW5kaW5nTWluRGF0YVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGF4aXMgYmluZGluZyBtaW46ICdcIiArIGJpbmRpbmdNaW5BdHRyICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoISBEYXRhVmFsdWUuaXNJbnN0YW5jZShiaW5kaW5nTWF4RGF0YVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGF4aXMgYmluZGluZyBtYXg6ICdcIiArIGJpbmRpbmdNYXhBdHRyICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBBeGlzQmluZGluZy5maW5kQnlJZE9yQ3JlYXRlTmV3KGJpbmRpbmdJZEF0dHIpLmFkZEF4aXMoYXhpcywgYmluZGluZ01pbkRhdGFWYWx1ZSwgYmluZGluZ01heERhdGFWYWx1ZSwgbXVsdGlncmFwaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF4aXM7XG59O1xuIiwidmFyIEF4aXNUaXRsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpc190aXRsZS5qcycpO1xuXG4vLyA8dGl0bGUgYmFzZT1cIjIzLjJcIiBhbmNob3I9XCIxMiA0XCIgcG9zaXRpb249XCIzIDdcIiBhbmdsZT1cIjQ1XCI+dGVtcGVyYXR1cmU8L3RpdGxlPlxuLy8gZW1wdHkgdGl0bGU6XG4vLyAgIDx0aXRsZS8+XG5BeGlzVGl0bGUucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sLCBheGlzKSB7XG4gICAgdmFyIHRpdGxlID0gbmV3IEF4aXNUaXRsZShheGlzKSxcbiAgICAgICAgVGV4dCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdGV4dC5qcycpLFxuICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICAgICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgbm9uRW1wdHlUaXRsZSA9IGZhbHNlLFxuICAgICAgICBwYXJzZVBvaW50ID0gUG9pbnQucGFyc2UsXG4gICAgICAgIHRleHQsXG4gICAgICAgIHBhcnNlVGl0bGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodmFsdWUsIGF0dHJpYnV0ZSwgcHJlcHJvY2Vzc29yKSB7XG4gICAgICAgICAgICBpZiAocEYucGFyc2VBdHRyaWJ1dGUodmFsdWUsIGF0dHJpYnV0ZSwgcHJlcHJvY2Vzc29yKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vLiAgRG9uJ3QgY291bnQgdGhlIHRpdGxlIGFzIG5vbkVtcHR5IGp1c3QgYmVjYXVzZSBvZiBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgICAgIC8vIElmIGEgPHRpdGxlPiB0YWcgaGFzIG9ubHkgYXR0cmlidXRlcywgYW5kIG5vIGNvbnRlbnQsIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGB1bmRlZmluZWRgIHNvIHRoYXQgdGhlIG5vcm1hbGl6ZXIgd29uJ3RcbiAgICAgICAgICAgICAgICAvLyBjb21lIGFsb25nIGxhdGVyIGFuZCBwb3B1bGF0ZSB0aGUgdGl0bGUgY29udGVudCB3aXRoIHRoZSBheGlzIGlkLlxuICAgICAgICAgICAgICAgIC8vIEVtcHR5IDx0aXRsZT4gY29udGVudCBtZWFucyBkb24ndCBkcmF3IGEgdGl0bGUgYXQgYWxsLCBpbiB3aGljaFxuICAgICAgICAgICAgICAgIC8vIGNhc2UgaXQncyBPSyB0byBqdXN0IGZvcmdldCBhYm91dCBhbnkgYXR0cmlidXRlcyB0aGF0IHdlcmUgc2V0LlxuICAgICAgICAgICAgICAgIC8vbm9uRW1wdHlUaXRsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICBpZiAoeG1sKSB7XG4gICAgICAgIHRleHQgPSB4bWwudGV4dCgpO1xuICAgICAgICBpZiAodGV4dCAhPT0gXCJcIikge1xuICAgICAgICAgICAgdGl0bGUuY29udGVudChuZXcgVGV4dCh0ZXh0KSk7XG4gICAgICAgICAgICBub25FbXB0eVRpdGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVRpdGxlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYW5jaG9yXCIpLCAgIHRpdGxlLmFuY2hvciwgICBwYXJzZVBvaW50KTtcbiAgICAgICAgcGFyc2VUaXRsZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJhc2VcIiksICAgICB0aXRsZS5iYXNlLCAgICAgcGFyc2VGbG9hdCk7XG4gICAgICAgIHBhcnNlVGl0bGVBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJwb3NpdGlvblwiKSwgdGl0bGUucG9zaXRpb24sIHBhcnNlUG9pbnQpO1xuICAgICAgICBwYXJzZVRpdGxlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYW5nbGVcIiksICAgIHRpdGxlLmFuZ2xlLCAgICBwYXJzZUZsb2F0KTtcbiAgICB9XG5cbiAgICBpZiAobm9uRW1wdHlUaXRsZSA9PT0gdHJ1ZSkgeyBcbiAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlzVGl0bGU7XG4iLCJ2YXIgQmFja2dyb3VuZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYmFja2dyb3VuZC5qcycpO1xuXG4vLyA8YmFja2dyb3VuZCBjb2xvcj1cIiNmZmZmMDBcIj5cbi8vICAgPGltZyBzcmM9XCJmb28ucG5nXCIgYW5jaG9yPVwiLTEgNVwiIGJhc2U9XCIzIDEyXCIgcG9zaXRpb249XCItMiAzXCIgZnJhbWU9XCJwYWRkaW5nXCIvPlxuLy8gPC9iYWNrZ3JvdW5kPlxuQmFja2dyb3VuZC5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwsIG11bHRpZ3JhcGgpIHtcbiAgICB2YXIgYmFja2dyb3VuZCAgICAgICA9IG5ldyBCYWNrZ3JvdW5kKCksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgUkdCQ29sb3IgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgIEltZyAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ltZy5qcycpLFxuICAgICAgICBjaGlsZDtcblxuICAgIGlmICh4bWwpIHtcbiAgICAgICAgcEYucGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJjb2xvclwiKSwgYmFja2dyb3VuZC5jb2xvciwgUkdCQ29sb3IucGFyc2UpO1xuICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwiaW1nXCIpO1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYmFja2dyb3VuZC5pbWcoSW1nLnBhcnNlWE1MKGNoaWxkLCBtdWx0aWdyYXBoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tncm91bmQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tncm91bmQ7XG4iLCIvLyBUaGlzIGZpbGUgdXNlcyBqUXVlcnkuICBBIHZhbGlkIGpRdWVyeSBvYmplY3QgbXVzdCBiZSBwYXNzZWQgdG8gdGhlXG4vLyBmdW5jdGlvbiByZXR1cm5lZCBieSByZXF1aXJpbmcgdGhpcyBmaWxlLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkKSB7XG4gICAgdmFyIERhdGEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGEuanMnKTtcblxuICAgIC8vIGlmIHBhcnNlWE1MIG1ldGhvZCBhbHJlYWR5IGhhcyBiZWVuIGRlZmluZWQsIHdoaWNoIHdvdWxkIGJlIHRoZSBjYXNlIGlmIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBjYWxsZWQsIGp1c3QgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKHR5cGVvZihEYXRhLnBhcnNlWE1MKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gRGF0YTsgfTtcblxuICAgIC8vIDxkYXRhPlxuICAgIC8vICAgPHZhcmlhYmxlc1xuICAgIC8vICAgICAgIG1pc3Npbmd2YWx1ZT1cIkRBVEFWQUxVRVwiXG4gICAgLy8gICAgICAgbWlzc2luZ29wPVwiQ09NUEFSQVRPUlwiPlxuICAgIC8vICAgICA8dmFyaWFibGVcbiAgICAvLyAgICAgICAgIGlkPVwiU1RSSU5HIVwiXG4gICAgLy8gICAgICAgICBjb2x1bW49XCJJTlRFR0VSXCJcbiAgICAvLyAgICAgICAgIHR5cGU9XCJEQVRBVFlQRShudW1iZXIpXCJcbiAgICAvLyAgICAgICAgIG1pc3Npbmd2YWx1ZT1cIlNUUklOR1wiXG4gICAgLy8gICAgICAgICBtaXNzaW5nb3A9XCJDT01QQVJBVE9SXCI+XG4gICAgLy8gICAgIDwvdmFyaWFibGU+XG4gICAgLy8gICA8L3ZhcmlhYmxlcz5cbiAgICAvLyAgIDxyZXBlYXQgcGVyaW9kPVwiU1RSSU5HXCIvPlxuICAgIC8vICAgPHZhbHVlcz5cbiAgICAvLyAgIDwvdmFsdWVzPlxuICAgIC8vICAgPGNzdlxuICAgIC8vICAgICAgIGxvY2F0aW9uPVwiU1RSSU5HIVwiPlxuICAgIC8vICAgPC9jc3Y+XG4gICAgLy8gICA8c2VydmljZVxuICAgIC8vICAgICAgIGxvY2F0aW9uPVwiU1RSSU5HIVwiXG4gICAgLy8gICAgICAgZm9ybWF0PVwiU1RSSU5HXCI+XG4gICAgLy8gICA8L3NlcnZpY2U+XG4gICAgLy8gPC9kYXRhPlxuICAgIERhdGEucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sLCBtdWx0aWdyYXBoLCBtZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB2YXIgQXJyYXlEYXRhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9hcnJheV9kYXRhLmpzJyksXG4gICAgICAgICAgICBEYXRhVmFyaWFibGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFyaWFibGUuanMnKSxcbiAgICAgICAgICAgIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX21lYXN1cmUuanMnKSxcbiAgICAgICAgICAgIFBlcmlvZGljQXJyYXlEYXRhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wZXJpb2RpY19hcnJheV9kYXRhLmpzJyksXG4gICAgICAgICAgICBDU1ZEYXRhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jc3ZfZGF0YS5qcycpKCQpLFxuICAgICAgICAgICAgV2ViU2VydmljZURhdGEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3dlYl9zZXJ2aWNlX2RhdGEuanMnKSgkKSxcbiAgICAgICAgICAgIE11bHRpZ3JhcGggPSByZXF1aXJlKCcuLi8uLi9jb3JlL211bHRpZ3JhcGguanMnKSgkKSxcbiAgICAgICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgICAgICB2YXJpYWJsZXNfeG1sLFxuICAgICAgICAgICAgZGVmYXVsdE1pc3Npbmd2YWx1ZVN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHRNaXNzaW5nb3BTdHJpbmcsXG4gICAgICAgICAgICBkYXRhVmFyaWFibGVzID0gW10sXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgYWRhcCwgYWRhcHRlciA9IEFycmF5RGF0YTtcblxuICAgICAgICBpZiAoeG1sKSB7XG5cbiAgICAgICAgICAgIGFkYXAgPSBwRi5nZXRYTUxBdHRyKCQoeG1sKSxcImFkYXB0ZXJcIik7XG4gICAgICAgICAgICBpZiAoYWRhcCAhPT0gdW5kZWZpbmVkICYmIGFkYXAgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBhZGFwdGVyID0gTXVsdGlncmFwaC5nZXREYXRhQWRhcHRlcihhZGFwKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRhcHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZGF0YSBhZGFwYXRlcjogXCIgKyBhZGFwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHBhcnNlIHRoZSA8dmFyaWFibGVzPiBzZWN0aW9uXG4gICAgICAgICAgICB2YXJpYWJsZXNfeG1sID0geG1sLmZpbmQoXCJ2YXJpYWJsZXNcIik7XG4gICAgICAgICAgICBkZWZhdWx0TWlzc2luZ3ZhbHVlU3RyaW5nID0gcEYuZ2V0WE1MQXR0cih2YXJpYWJsZXNfeG1sLFwibWlzc2luZ3ZhbHVlXCIpO1xuICAgICAgICAgICAgZGVmYXVsdE1pc3NpbmdvcFN0cmluZyAgICA9IHBGLmdldFhNTEF0dHIodmFyaWFibGVzX3htbCxcIm1pc3NpbmdvcFwiKTtcblxuICAgICAgICAgICAgdmFyIHZhcmlhYmxlcyA9IHZhcmlhYmxlc194bWwuZmluZChcIj52YXJpYWJsZVwiKTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICQuZWFjaCh2YXJpYWJsZXMsIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFWYXJpYWJsZXMucHVzaCggRGF0YVZhcmlhYmxlLnBhcnNlWE1MKCQoZSkpICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgPHJlcGVhdD4gc2VjdGlvbiwgYW5kIGlmIHNvLCBncmFiIHRoZSBwZXJpb2QgZnJvbSBpdFxuICAgICAgICAgICAgdmFyIGhhdmVSZXBlYXQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBwZXJpb2QsXG4gICAgICAgICAgICAgICAgcmVwZWF0X3htbCA9ICQoeG1sLmZpbmQoXCI+cmVwZWF0XCIpKTtcbiAgICAgICAgICAgIGlmIChyZXBlYXRfeG1sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVyaW9kU3RyaW5nID0gcEYuZ2V0WE1MQXR0cigkKHJlcGVhdF94bWwpLFwicGVyaW9kXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwZXJpb2RTdHJpbmcgPT09IHVuZGVmaW5lZCB8fCBwZXJpb2RTdHJpbmcgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIud2FybmluZyhcIjxyZXBlYXQ+IHRhZyByZXF1aXJlcyBhICdwZXJpb2QnIGF0dHJpYnV0ZTsgZGF0YSB0cmVhdGVkIGFzIG5vbi1yZXBlYXRpbmdcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kID0gRGF0YU1lYXN1cmUucGFyc2UoZGF0YVZhcmlhYmxlc1swXS50eXBlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcmlvZFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGhhdmVSZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIDx2YWx1ZXM+IHNlY3Rpb24sIHBhcnNlIGl0IGFuZCByZXR1cm4gYW4gQXJyYXlEYXRhIGluc3RhbmNlOlxuICAgICAgICAgICAgdmFyIHZhbHVlc194bWwgPSAkKHhtbC5maW5kKFwiPnZhbHVlc1wiKSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzX3htbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzX3htbCA9IHZhbHVlc194bWxbMF07XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlcyA9IGFkYXB0ZXIudGV4dFRvU3RyaW5nQXJyYXkoZGF0YVZhcmlhYmxlcywgJCh2YWx1ZXNfeG1sKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgIGlmIChoYXZlUmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgUGVyaW9kaWNBcnJheURhdGEoZGF0YVZhcmlhYmxlcywgc3RyaW5nVmFsdWVzLCBwZXJpb2QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgQXJyYXlEYXRhKGRhdGFWYXJpYWJsZXMsIHN0cmluZ1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgPGNzdj4gc2VjdGlvbiwgcGFyc2UgaXQgYW5kIHJldHVybiBhIENTVkRhdGEgaW5zdGFuY2U6XG4gICAgICAgICAgICB2YXIgY3N2X3htbCA9ICQoeG1sLmZpbmQoXCI+Y3N2XCIpKTtcbiAgICAgICAgICAgIGlmIChjc3ZfeG1sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjc3ZfeG1sID0gY3N2X3htbFswXTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBwRi5nZXRYTUxBdHRyKCQoY3N2X3htbCksXCJsb2NhdGlvblwiKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gbmV3IENTVkRhdGEoZGF0YVZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlncmFwaCA/IG11bHRpZ3JhcGgucmViYXNlVXJsKGZpbGVuYW1lKSA6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlncmFwaCA/IG11bHRpZ3JhcGguZ2V0QWpheFRocm90dGxlKGZpbGVuYW1lKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSA8c2VydmljZT4gc2VjdGlvbiwgcGFyc2UgaXQgYW5kIHJldHVybiBhIFdlYlNlcnZpY2VEYXRhIGluc3RhbmNlOlxuICAgICAgICAgICAgdmFyIHNlcnZpY2VfeG1sID0gJCh4bWwuZmluZChcIj5zZXJ2aWNlXCIpKTtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlX3htbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VydmljZV94bWwgPSAkKHNlcnZpY2VfeG1sWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBwRi5nZXRYTUxBdHRyKHNlcnZpY2VfeG1sLFwibG9jYXRpb25cIik7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBXZWJTZXJ2aWNlRGF0YShkYXRhVmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlncmFwaCA/IG11bHRpZ3JhcGgucmViYXNlVXJsKGxvY2F0aW9uKSA6IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoID8gbXVsdGlncmFwaC5nZXRBamF4VGhyb3R0bGUobG9jYXRpb24pIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0ID0gcEYuZ2V0WE1MQXR0cihzZXJ2aWNlX3htbCxcImZvcm1hdFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0TWlzc2luZ3ZhbHVlU3RyaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmRlZmF1bHRNaXNzaW5ndmFsdWUoZGVmYXVsdE1pc3Npbmd2YWx1ZVN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmYXVsdE1pc3NpbmdvcFN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5kZWZhdWx0TWlzc2luZ29wKGRlZmF1bHRNaXNzaW5nb3BTdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5hZGFwdGVyKGFkYXB0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHJldHVybiBEYXRhO1xufTtcblxuIiwidmFyIERhdGFWYXJpYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YXJpYWJsZS5qcycpO1xuXG4vLyAgPHZhcmlhYmxlXG4vLyAgICAgIGlkPVwiU1RSSU5HIVwiXG4vLyAgICAgIGNvbHVtbj1cIklOVEVHRVJcIlxuLy8gICAgICB0eXBlPVwiREFUQVRZUEUobnVtYmVyKVwiXG4vLyAgICAgIG1pc3Npbmd2YWx1ZT1cIlNUUklOR1wiXG4vLyAgICAgIG1pc3NpbmdvcD1cIkNPTVBBUkFUT1JcIj5cbi8vICA8L3ZhcmlhYmxlPlxuRGF0YVZhcmlhYmxlLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgZGF0YSkge1xuICAgIHZhciB2YXJpYWJsZSxcbiAgICAgICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBEYXRhVmFsdWUgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIGF0dHI7XG5cbiAgICBpZiAoeG1sICYmIHBGLmdldFhNTEF0dHIoeG1sLFwiaWRcIikpIHtcbiAgICAgICAgdmFyaWFibGUgPSBuZXcgRGF0YVZhcmlhYmxlKHBGLmdldFhNTEF0dHIoeG1sLFwiaWRcIikpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImNvbHVtblwiKSwgICAgICAgdmFyaWFibGUuY29sdW1uLCAgICAgICBwRi5wYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcInR5cGVcIiksICAgICAgICAgdmFyaWFibGUudHlwZSwgICAgICAgICBEYXRhVmFsdWUucGFyc2VUeXBlKTtcbiAgICAgICAgLy9wYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcIm1pc3Npbmd2YWx1ZVwiKSwgdmFyaWFibGUubWlzc2luZ3ZhbHVlLCBwRi5wYXJzZURhdGFWYWx1ZSh2YXJpYWJsZS50eXBlKCkpKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJtaXNzaW5ndmFsdWVcIiksIHZhcmlhYmxlLm1pc3Npbmd2YWx1ZSwgZnVuY3Rpb24odikgeyByZXR1cm4gRGF0YVZhbHVlLnBhcnNlKHZhcmlhYmxlLnR5cGUoKSwgdik7IH0pO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcIm1pc3NpbmdvcFwiKSwgICAgdmFyaWFibGUubWlzc2luZ29wLCAgICBEYXRhVmFsdWUucGFyc2VDb21wYXJhdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhYmxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmFyaWFibGU7XG4iLCJcbi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgRGF0YXRpcHMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGF0aXBzLmpzJyk7XG5cbiAgICAvLyBpZiBwYXJzZVhNTCBtZXRob2QgYWxyZWFkeSBoYXMgYmVlbiBkZWZpbmVkLCB3aGljaCB3b3VsZCBiZSB0aGUgY2FzZSBpZiB0aGlzXG4gICAgLy8gZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkLCBqdXN0IHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0eXBlb2YoRGF0YXRpcHMucGFyc2VYTUwpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBEYXRhdGlwczsgfTtcblxuICAgIC8vIDxkYXRhdGlwc1xuICAgIC8vICAgZm9ybWF0PVwiU1RSSU5HIVwiXG4gICAgLy8gICBiZ2NvbG9yPVwiQ09MT1JcIlxuICAgIC8vICAgYmdhbHBoYT1cIkRPVUJMRVwiXG4gICAgLy8gICBib3JkZXI9XCJJTlRFR0VSXCJcbiAgICAvLyAgIGJvcmRlcmNvbG9yPVwiQ09MT1JcIlxuICAgIC8vICAgcGFkPVwiSU5URUdFUlwiPlxuICAgIC8vICAgPHZhcmlhYmxlXG4gICAgLy8gICAgIGZvcm1hdD1cIlNUUklORyFcIj5cbiAgICAvLyAgIDwvdmFyaWFibGU+XG4gICAgLy8gPC9kYXRhdGlwcz5cbiAgICBEYXRhdGlwcy5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwpIHtcbiAgICAgICAgdmFyIGRhdGF0aXBzICAgICAgICAgPSBuZXcgRGF0YXRpcHMoKSxcbiAgICAgICAgICAgIFJHQkNvbG9yICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICAgICAgRGF0YXRpcHNWYXJpYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YXRpcHNfdmFyaWFibGUuanMnKSxcbiAgICAgICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgICAgICBwYXJzZVJHQkNvbG9yICAgID0gUkdCQ29sb3IucGFyc2UsXG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgICAgICBwYXJzZUludGVnZXIgICAgID0gcEYucGFyc2VJbnRlZ2VyLFxuICAgICAgICAgICAgY2hpbGQ7XG4gICAgICAgIGlmICh4bWwpIHtcbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJ2YXJpYWJsZVwiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKGNoaWxkLCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhdGlwcy52YXJpYWJsZXMoKS5hZGQoIERhdGF0aXBzVmFyaWFibGUucGFyc2VYTUwoJChlKSkgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJmb3JtYXRcIiksICAgICAgZGF0YXRpcHMuZm9ybWF0U3RyaW5nKTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYmdjb2xvclwiKSwgICAgIGRhdGF0aXBzLmJnY29sb3IsICAgICBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYmdhbHBoYVwiKSwgICAgIGRhdGF0aXBzLmJnYWxwaGEsICAgICBwYXJzZUZsb2F0KTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYm9yZGVyXCIpLCAgICAgIGRhdGF0aXBzLmJvcmRlciwgICAgICBwYXJzZUludGVnZXIpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJib3JkZXJjb2xvclwiKSwgZGF0YXRpcHMuYm9yZGVyY29sb3IsIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJwYWRcIiksICAgICAgICAgZGF0YXRpcHMucGFkLCAgICAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGF0aXBzO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGF0YXRpcHM7XG59O1xuIiwidmFyIERhdGF0aXBzVmFyaWFibGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGF0aXBzX3ZhcmlhYmxlLmpzJyk7XG5cbkRhdGF0aXBzVmFyaWFibGUucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sKSB7XG4gICAgdmFyIHZhcmlhYmxlID0gbmV3IERhdGF0aXBzVmFyaWFibGUoKSxcbiAgICAgICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKTtcblxuICAgIGlmICh4bWwpIHtcbiAgICAgICAgcEYucGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJmb3JtYXRcIiksIHZhcmlhYmxlLmZvcm1hdFN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB2YXJpYWJsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YXRpcHNWYXJpYWJsZTtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgRmlsdGVyID0gcmVxdWlyZSgnLi4vLi4vY29yZS9maWx0ZXIuanMnKTtcblxuICAgIC8vIGlmIHBhcnNlWE1MIG1ldGhvZCBhbHJlYWR5IGhhcyBiZWVuIGRlZmluZWQsIHdoaWNoIHdvdWxkIGJlIHRoZSBjYXNlIGlmIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBjYWxsZWQsIGp1c3QgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKHR5cGVvZihGaWx0ZXIucGFyc2VYTUwpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBGaWx0ZXI7IH07XG5cbiAgICAvLyA8ZmlsdGVyIHR5cGU9XCJTVFJJTkdcIj5cbiAgICAvLyAgICA8b3B0aW9uIG5hbWU9XCJTVFJJTkchXCIgdmFsdWU9XCJTVFJJTkchXCIvPlxuICAgIC8vICAgIDxvcHRpb24gbmFtZT1cIlNUUklORyFcIiB2YWx1ZT1cIlNUUklORyFcIi8+XG4gICAgLy8gICAgLi4uXG4gICAgLy8gPC9maWx0ZXI+XG4gICAgRmlsdGVyLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCkge1xuICAgICAgICB2YXIgZmlsdGVyID0gbmV3IEZpbHRlcigpLFxuICAgICAgICAgICAgRmlsdGVyT3B0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9maWx0ZXJfb3B0aW9uLmpzJyksXG4gICAgICAgICAgICBwRiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICAgICAgY2hpbGQ7XG4gICAgICAgIGlmICh4bWwpIHtcbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICQuZWFjaChjaGlsZCwgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLm9wdGlvbnMoKS5hZGQoIEZpbHRlck9wdGlvbi5wYXJzZVhNTCgkKGUpKSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcEYucGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJ0eXBlXCIpLCBmaWx0ZXIudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbHRlcjtcbn07XG5cbiIsInZhciBGaWx0ZXJPcHRpb24gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ZpbHRlcl9vcHRpb24uanMnKTtcblxuLy8gPG9wdGlvbiBuYW1lPVwiU1RSSU5HIVwiIHZhbHVlPVwiU1RSSU5HIVwiLz5cbkZpbHRlck9wdGlvbi5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwpIHtcbiAgICB2YXIgcEYgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIG9wdGlvbiA9IG5ldyBGaWx0ZXJPcHRpb24oKTtcbiAgICBpZiAoeG1sKSB7XG4gICAgICAgIG9wdGlvbi5uYW1lKHBGLmdldFhNTEF0dHIoeG1sLFwibmFtZVwiKSk7XG4gICAgICAgIG9wdGlvbi52YWx1ZShwRi5nZXRYTUxBdHRyKHhtbCxcInZhbHVlXCIpID09PSBcIlwiID8gdW5kZWZpbmVkIDogcEYuZ2V0WE1MQXR0cih4bWwsXCJ2YWx1ZVwiKSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb247XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlck9wdGlvbjtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgR3JhcGggPSByZXF1aXJlKCcuLi8uLi9jb3JlL2dyYXBoLmpzJyksXG4gICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyk7XG5cbiAgICAvLyBpZiBwYXJzZVhNTCBtZXRob2QgYWxyZWFkeSBoYXMgYmVlbiBkZWZpbmVkLCB3aGljaCB3b3VsZCBiZSB0aGUgY2FzZSBpZiB0aGlzXG4gICAgLy8gZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkLCBqdXN0IHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0eXBlb2YoR3JhcGgucGFyc2VYTUwpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBHcmFwaDsgfTtcblxuICAgIC8qXG4gICAgICogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgYW4gWE1MIGRvY3VtZW50IGxvb2tpbmcgZm9yIGF0dHJpYnV0ZXMgdmFsdWVzIGludm9sdmluZyBkZXByZWNhdGVkXG4gICAgICogY29sb3IgbmFtZXMgYW5kIGlzc3VlcyBhIHdhcm5pbmcgYWJvdXQgZWFjaCBvbmUgZm91bmQuICBSZW1vdmUgdGhpcyBmdW5jdGlvbiB3aGVuIHJlbW92aW5nXG4gICAgICogc3VwcG9ydCBmb3IgdGhlc2UgbmFtZXMuICBTZWUgc3JjL21hdGgvcmdiX2NvbG9yLmpzIGZvciBhIGxpc3Qgb2YgdGhlIGRlcHJlY2F0ZWQgY29sb3JzLlxuICAgICAqL1xuICAgIHZhciBjaGVja0RlcHJlY2F0ZWRDb2xvck5hbWVzID0gZnVuY3Rpb24gKHhtbCwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgdmFyIFJHQkNvbG9yICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICAgICAgJHhtbCAgICAgICA9ICQoeG1sKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSAkeG1sWzBdLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjaGlsZHJlbiAgID0gJHhtbC5jaGlsZHJlbigpLFxuICAgICAgICAgICAgY29sb3JOYW1lSXNEZXByZWNhdGVkID0gUkdCQ29sb3IuY29sb3JOYW1lSXNEZXByZWNhdGVkLFxuICAgICAgICAgICAgZGVwO1xuICAgICAgICBpZiAoeG1sLm5vZGVOYW1lID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoL2NvbG9yLy50ZXN0KHBGLmdldFhNTEF0dHIoJHhtbCwnbmFtZScpKSkge1xuICAgICAgICAgICAgICAgIGRlcCA9IGNvbG9yTmFtZUlzRGVwcmVjYXRlZChwRi5nZXRYTUxBdHRyKCR4bWwsJ3ZhbHVlJykpO1xuICAgICAgICAgICAgICAgIGlmIChkZXApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIud2FybmluZygnV2FybmluZzogY29sb3Igc3RyaW5nIFwiJyArIHBGLmdldFhNTEF0dHIoJHhtbCwndmFsdWUnKSArICdcIiBpcyBkZXByZWNhdGVkOyB1c2UgXCInICsgZGVwICsgJ1wiIGluc3RlYWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICQuZWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKC9jb2xvci8udGVzdCh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcCA9IGNvbG9yTmFtZUlzRGVwcmVjYXRlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIud2FybmluZygnV2FybmluZzogY29sb3Igc3RyaW5nIFwiJyArIHRoaXMudmFsdWUgKyAnXCIgaXMgZGVwcmVjYXRlZDsgdXNlIFwiJyArIGRlcCArICdcIiBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgY2hpbGRyZW4uZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tEZXByZWNhdGVkQ29sb3JOYW1lcyh0aGlzLCBtZXNzYWdlSGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIEdyYXBoLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgbXVsdGlncmFwaCwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGdyYXBoID0gbmV3IEdyYXBoKCksXG4gICAgICAgICAgICBBeGlzICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpcy5qcycpLFxuICAgICAgICAgICAgV2luZG93ID0gcmVxdWlyZSgnLi4vLi4vY29yZS93aW5kb3cuanMnKSxcbiAgICAgICAgICAgIExlZ2VuZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbGVnZW5kLmpzJyksXG4gICAgICAgICAgICBCYWNrZ3JvdW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9iYWNrZ3JvdW5kLmpzJyksXG4gICAgICAgICAgICBQbG90YXJlYSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGxvdGFyZWEuanMnKSxcbiAgICAgICAgICAgIFRpdGxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS90aXRsZS5qcycpLFxuICAgICAgICAgICAgRGF0YSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YS5qcycpLFxuICAgICAgICAgICAgUGxvdCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGxvdC5qcycpLFxuICAgICAgICAgICAgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgICAgICAgICAgZGVmYXVsdHMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgICAgICAgICBjaGlsZDtcblxuICAgICAgICBncmFwaC5tdWx0aWdyYXBoKG11bHRpZ3JhcGgpO1xuICAgICAgICBpZiAoeG1sKSB7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEZWxldGUgdGhpcyB0cnkvY2F0Y2ggYmxvY2sgd2hlbiByZW1vdmluZyBzdXBwb3J0IGZvciBkZXByZWNhdGVkIGNvbG9yIG5hbWVzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hlY2tEZXByZWNhdGVkQ29sb3JOYW1lcyh4bWwsIG1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBqdXN0IGlnbm9yZSBhbnkgZXJyb3JzIGhlcmU7IHRoZSB3b3JzdCB0aGF0IHdpbGwgaGFwcGVuIGlzIHRoYXQgdGhlIHVzZXIganVzdFxuICAgICAgICAgICAgICAgIC8vIHdvbid0IHNlZSB0aGUgd2FybmluZ3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBlbmQgb2YgYmxvY2sgdG8gZGVsZXRlIHdoZW4gcmVtb3Zpbmcgc3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBjb2xvciBuYW1lc1xuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgLy8gTk9URTogJ09CSi5maW5kKFwiPlRBR1wiKScgcmV0dXJucyBhIGxpc3Qgb2YgSlF1ZXJ5IG9iamVjdHMgY29ycmVzcG9uZGluZyB0byB0aGUgaW1tZWRpYXRlXG4gICAgICAgICAgICAvLyAoMXN0IGdlbmVyYXRpb24pIGNoaWxkIG5vZGVzIG9mIE9CSiBjb3JyZXNwb25kaW5nIHRvIHhtbCB0YWcgVEFHXG4gICAgICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwiPndpbmRvd1wiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGgud2luZG93KCBXaW5kb3cucGFyc2VYTUwoY2hpbGQpICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCI+bGVnZW5kXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBncmFwaC5sZWdlbmQoIExlZ2VuZC5wYXJzZVhNTChjaGlsZCkgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JhcGgubGVnZW5kKCBMZWdlbmQucGFyc2VYTUwoKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcIj5iYWNrZ3JvdW5kXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBncmFwaC5iYWNrZ3JvdW5kKCBCYWNrZ3JvdW5kLnBhcnNlWE1MKGNoaWxkLCBncmFwaC5tdWx0aWdyYXBoKCkpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwiPnBsb3RhcmVhXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBncmFwaC5wbG90YXJlYSggUGxvdGFyZWEucGFyc2VYTUwoY2hpbGQpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwiPnRpdGxlXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBncmFwaC50aXRsZSggVGl0bGUucGFyc2VYTUwoY2hpbGQsIGdyYXBoKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJC5lYWNoKHhtbC5maW5kKFwiPmhvcml6b250YWxheGlzXCIpLCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgIGdyYXBoLmF4ZXMoKS5hZGQoIEF4aXMucGFyc2VYTUwoJChlKSwgQXhpcy5IT1JJWk9OVEFMLCBtZXNzYWdlSGFuZGxlciwgZ3JhcGgubXVsdGlncmFwaCgpKSApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkLmVhY2goeG1sLmZpbmQoXCI+dmVydGljYWxheGlzXCIpLCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgIGdyYXBoLmF4ZXMoKS5hZGQoIEF4aXMucGFyc2VYTUwoJChlKSwgQXhpcy5WRVJUSUNBTCwgbWVzc2FnZUhhbmRsZXIsIGdyYXBoLm11bHRpZ3JhcGgoKSkgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICBpZiAoeG1sLmZpbmQoXCI+ZGF0YVwiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAvLyBPbiBzZWNvbmQgdGhyb3VnaHQsIGxldCdzIG5vdCB0aHJvdyBhbiBlcnJvciBpZiBubyA8ZGF0YT4gdGFnXG4gICAgICAgICAgICAgLy8gaXMgc3BlY2lmaWVkLCBiZWNhdXNlIGNvbmNlaXZhYmx5IHRoZXJlIGNvdWxkIGJlIGdyYXBocyBpblxuICAgICAgICAgICAgIC8vIHdoaWNoIGFsbCB0aGUgcGxvdHMgYXJlIGNvbnN0YW50IHBsb3RzLCBzbyBubyBkYXRhIGlzIG5lZWRlZC5cbiAgICAgICAgICAgICAvLyBJbiBwYXJ0aWN1bGFyLCBpbiBvdXIgc3BlYy9tdWdsL2NvbnN0YW50LXBsb3QueG1sIHRlc3QhXG4gICAgICAgICAgICAgLy8gSSdtIG5vdCBzdXJlIHdoYXQgc2hvdWxkIGJlIGRvbmUgaGVyZSAtLS0gbWF5YmUgaXNzdWUgYSB3YXJuaW5nLFxuICAgICAgICAgICAgIC8vIG9yIG1heWJlIGRvbid0IGRvIGFueXRoaW5nLlxuICAgICAgICAgICAgIC8vICAgIG1icCBNb24gTm92IDEyIDE2OjA1OjIxIDIwMTJcbiAgICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihcIkdyYXBoIERhdGEgRXJyb3I6IE5vIGRhdGEgdGFncyBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAkLmVhY2goeG1sLmZpbmQoXCI+dGhyb3R0bGVcIiksIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gICAgPSBwRi5nZXRYTUxBdHRyKCQoZSksJ3BhdHRlcm4nKSAgICA/IHBGLmdldFhNTEF0dHIoJChlKSwncGF0dGVybicpICAgIDogZGVmYXVsdHMudGhyb3R0bGUucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHMgICA9IHBGLmdldFhNTEF0dHIoJChlKSwncmVxdWVzdHMnKSAgID8gcEYuZ2V0WE1MQXR0cigkKGUpLCdyZXF1ZXN0cycpICAgOiBkZWZhdWx0cy50aHJvdHRsZS5yZXF1ZXN0cyxcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kICAgICA9IHBGLmdldFhNTEF0dHIoJChlKSwncGVyaW9kJykgICAgID8gcEYuZ2V0WE1MQXR0cigkKGUpLCdwZXJpb2QnKSAgICAgOiBkZWZhdWx0cy50aHJvdHRsZS5wZXJpb2QsXG4gICAgICAgICAgICAgICAgICAgIGNvbmN1cnJlbnQgPSBwRi5nZXRYTUxBdHRyKCQoZSksJ2NvbmN1cnJlbnQnKSA/IHBGLmdldFhNTEF0dHIoJChlKSwnY29uY3VycmVudCcpIDogZGVmYXVsdHMudGhyb3R0bGUuY29uY3VycmVudDtcbiAgICAgICAgICAgICAgICBtdWx0aWdyYXBoLmFkZEFqYXhUaHJvdHRsZShwYXR0ZXJuLCByZXF1ZXN0cywgcGVyaW9kLCBjb25jdXJyZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJC5lYWNoKHhtbC5maW5kKFwiPmRhdGFcIiksIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGguZGF0YSgpLmFkZCggRGF0YS5wYXJzZVhNTCgkKGUpLCBncmFwaC5tdWx0aWdyYXBoKCksIG1lc3NhZ2VIYW5kbGVyKSApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkLmVhY2goeG1sLmZpbmQoXCI+cGxvdFwiKSwgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICAgICAgICBncmFwaC5wbG90cygpLmFkZCggUGxvdC5wYXJzZVhNTCgkKGUpLCBncmFwaCwgbWVzc2FnZUhhbmRsZXIpICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyYXBoLnBvc3RQYXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFwaDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEdyYXBoO1xufTtcbiIsInZhciBHcmlkID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ncmlkLmpzJyk7XG5cbi8vIDxncmlkIGNvbG9yPVwiI2ZmMDBmZlwiIHZpc2libGU9XCJ0cnVlXCIvPlxuR3JpZC5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwpIHtcbiAgICB2YXIgZ3JpZCAgICAgICAgICAgICA9IG5ldyBHcmlkKCksXG4gICAgICAgIFJHQkNvbG9yICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICBwRiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgYXR0cjtcbiAgICBpZiAoeG1sKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiY29sb3JcIiksIGdyaWQuY29sb3IsIFJHQkNvbG9yLnBhcnNlKTtcbiAgICAgICAgLy9OT1RFOiB2aXNpYmxlIGF0dHJpYnV0ZSBzaG91bGQgZGVmYXVsdCB0byB0cnVlIHdoZW4gcGFyc2luZywgc28gdGhhdFxuICAgICAgICAvLyAgICAgIHRoZSBwcmVzZW5jZSBvZiBhIDxncmlkPiB0YWcgYXQgYWxsIHdpbGwgdHVybiBvbiBhIGdyaWQuICBJblxuICAgICAgICAvLyAgICAgIHRoZSBHcmlkIG9iamVjdCBpdHNlbGYsIHRob3VnaCwgdGhlIGRlZmF1bHQgZm9yIHRoZSB2aXNpYmxlXG4gICAgICAgIC8vICAgICAgYXR0cmlidXRlIGlzIGZhbHNlLCBzbyB0aGF0IHdoZW4gd2UgY3JlYXRlIGEgZGVmYXVsdCBncmlkIG9iamVjdFxuICAgICAgICAvLyAgICAgIGluIGNvZGUgKGFzIG9wcG9zZWQgdG8gcGFyc2luZyksIGl0IGRlZmF1bHRzIHRvIG5vdCB2aXNpYmxlLlxuICAgICAgICBhdHRyID0gcEYuZ2V0WE1MQXR0cih4bWwsXCJ2aXNpYmxlXCIpO1xuICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBncmlkLnZpc2libGUocEYucGFyc2VCb29sZWFuKGF0dHIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQudmlzaWJsZSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JpZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZDtcbiIsInZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9pY29uLmpzJyk7XG5cbi8vIDxpY29uIGJvcmRlcj1cIjJcIiB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMjBcIi8+XG5JY29uLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCkge1xuXG4gICAgdmFyIGljb24gPSBuZXcgSWNvbigpLFxuICAgICAgICBwRiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlSW50ZWdlciAgICAgPSBwRi5wYXJzZUludGVnZXI7XG4gICAgaWYgKHhtbCkge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImhlaWdodFwiKSwgaWNvbi5oZWlnaHQsIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwid2lkdGhcIiksICBpY29uLndpZHRoLCAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJib3JkZXJcIiksIGljb24uYm9yZGVyLCBwYXJzZUludGVnZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaWNvbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSWNvbjtcbiIsInZhciBJbWcgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ltZy5qcycpO1xuXG4vLyAgIDxpbWcgc3JjPVwiZm9vLnBuZ1wiIGFuY2hvcj1cIi0xIDVcIiBiYXNlPVwiMyAxMlwiIHBvc2l0aW9uPVwiLTIgM1wiIGZyYW1lPVwicGFkZGluZ1wiLz5cbkltZy5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwsIG11bHRpZ3JhcGgpIHtcbiAgICB2YXIgaW1nLFxuICAgICAgICBwRiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBQb2ludCAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlUG9pbnQgICAgICAgPSBQb2ludC5wYXJzZTtcbiAgICBpZiAoeG1sICYmIHBGLmdldFhNTEF0dHIoeG1sLFwic3JjXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHNyYyA9IHBGLmdldFhNTEF0dHIoeG1sLFwic3JjXCIpO1xuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbWcgZWxtZW50IHJlcXVpcmVzIGEgXCJzcmNcIiBhdHRyaWJ1dGUgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGlncmFwaCkge1xuICAgICAgICAgICAgc3JjID0gbXVsdGlncmFwaC5yZWJhc2VVcmwoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBpbWcgPSBuZXcgSW1nKHNyYyk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYW5jaG9yXCIpLCAgIGltZy5hbmNob3IsICAgcGFyc2VQb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYmFzZVwiKSwgICAgIGltZy5iYXNlLCAgICAgcGFyc2VQb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwicG9zaXRpb25cIiksIGltZy5wb3NpdGlvbiwgcGFyc2VQb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiZnJhbWVcIiksICAgIGltZy5mcmFtZSwgICAgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGltZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1nO1xuIiwiLy8gdXNhZ2U6XG4vLyBcbi8vICAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSByZXF1aXJpbmcgdGhpcyBmaWxlLlxuLy8gICBUaGF0IGZ1bmN0aW9uIHJldHVybnMgYSBQYXJzZVhNTCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBmb2xsb3dzOlxuLy9cbi8vICAgICAgdmFyIFBhcnNlWE1MID0gcmVxdWlyZSgncGFyc2VfeG1sLmpzJykoJCk7XG4vLyAgICAgIFBhcnNlWE1MLnN0cmluZ1RvSlF1ZXJ5WE1MT2JqKC4uLik7XG4vL1xudmFyIEpRdWVyeVhNTFBhcnNlcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIGlmICh0eXBlb2YoSlF1ZXJ5WE1MUGFyc2VyKSE9XCJ1bmRlZmluZWRcIikgeyByZXR1cm4gSlF1ZXJ5WE1MUGFyc2VyOyB9O1xuXG4gICAgSlF1ZXJ5WE1MUGFyc2VyID0ge307XG5cbiAgICByZXF1aXJlKCcuL2F4aXMuanMnKSgkKTtcbiAgICByZXF1aXJlKCcuL2RhdGEuanMnKSgkKTtcbiAgICByZXF1aXJlKCcuL2RhdGF0aXBzLmpzJykoJCk7XG4gICAgcmVxdWlyZSgnLi9maWx0ZXIuanMnKSgkKTtcbiAgICByZXF1aXJlKCcuL2dyYXBoLmpzJykoJCk7XG4gICAgcmVxdWlyZSgnLi9tdWx0aWdyYXBoLmpzJykoJCk7XG4gICAgcmVxdWlyZSgnLi9wbG90LmpzJykoJCk7XG4gICAgcmVxdWlyZSgnLi9yZW5kZXJlci5qcycpKCQpO1xuXG4gICAgcmVxdWlyZSgnLi9heGlzX3RpdGxlLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9iYWNrZ3JvdW5kLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9kYXRhdGlwc192YXJpYWJsZS5qcycpO1xuICAgIHJlcXVpcmUoJy4vZGF0YV92YXJpYWJsZS5qcycpO1xuICAgIHJlcXVpcmUoJy4vZmlsdGVyX29wdGlvbi5qcycpO1xuICAgIHJlcXVpcmUoJy4vZ3JpZC5qcycpO1xuICAgIHJlcXVpcmUoJy4vaWNvbi5qcycpO1xuICAgIHJlcXVpcmUoJy4vaW1nLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9sYWJlbGVyLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9sZWdlbmQuanMnKTtcbiAgICByZXF1aXJlKCcuL3Bhbi5qcycpO1xuICAgIHJlcXVpcmUoJy4vcGxvdGFyZWEuanMnKTtcbiAgICByZXF1aXJlKCcuL3Bsb3RfbGVnZW5kLmpzJyk7XG4gICAgcmVxdWlyZSgnLi90aXRsZS5qcycpO1xuICAgIHJlcXVpcmUoJy4vd2luZG93LmpzJyk7XG4gICAgcmVxdWlyZSgnLi96b29tLmpzJyk7XG5cbiAgICBKUXVlcnlYTUxQYXJzZXIuc3RyaW5nVG9KUXVlcnlYTUxPYmogPSBmdW5jdGlvbiAodGhpbmd5KSB7XG4gICAgICAgIGlmICh0eXBlb2YodGhpbmd5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpbmd5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeG1sID0gJC5wYXJzZVhNTCh0aGluZ3kpO1xuICAgICAgICByZXR1cm4gJCgkKHhtbCkuY2hpbGRyZW4oKVswXSk7XG4gICAgfTtcblxuICAgIHJldHVybiBKUXVlcnlYTUxQYXJzZXI7XG59O1xuIiwidmFyIExhYmVsZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2xhYmVsZXIuanMnKTtcblxuLy8gPGxhYmVsc1xuLy8gICBmb3JtYXQ9XCJTVFJJTkdcIlxuLy8gICBzdGFydD1cIkRBVEFWQUxVRSgwKVwiXG4vLyAgIGFuZ2xlPVwiRE9VQkxFKDApXCJcbi8vICAgcG9zaXRpb249XCJQT0lOVFwiXG4vLyAgIGFuY2hvcj1cIlBPSU5UXCJcbi8vICAgY29sb3I9XCJDT0xPUihibGFjaylcIlxuLy8gICBzcGFjaW5nPVwiU1RSSU5HXCJcbi8vICAgZGVuc2l0eWZhY3Rvcj1cIkRPVUJMRSgxLjApXCI+XG4vLyAgICAgPGxhYmVsIGZvcm1hdD1cIlNUUklOR1wiIHN0YXJ0PVwiU1RSSU5HXCIgYW5nbGU9XCJET1VCTEVcIiBwb3NpdGlvbj1cIlBPSU5UXCIgYW5jaG9yPVwiUE9JTlRcIiBzcGFjaW5nPVwiU1RSSU5HXCIgZGVuc2l0eWZhY3Rvcj1cIkRPVUJMRVwiPlxuLy8gICAgIDxsYWJlbCBmb3JtYXQ9XCJTVFJJTkdcIiBzdGFydD1cIlNUUklOR1wiIGFuZ2xlPVwiRE9VQkxFXCIgcG9zaXRpb249XCJQT0lOVFwiIGFuY2hvcj1cIlBPSU5UXCIgc3BhY2luZz1cIlNUUklOR1wiIGRlbnNpdHlmYWN0b3I9XCJET1VCTEVcIj5cbi8vIDwvbGFiZWw+XG5MYWJlbGVyLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgYXhpcywgZGVmYXVsdHMsIHNwYWNpbmcpIHtcbiAgICAvLyBUaGlzIHBhcnNlciB0YWtlcyBhbiBvcHRpb25hbCBmaW5hbCBhcmd1bWVudCwgc3BhY2luZywgd2hpY2ggaXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nXG4gICAgLy8gdGhlIHNwYWNpbmcgdG8gYmUgcGFyc2VkIGZvciB0aGUgbGFiZWxlci4gIElmIHRoYXQgYXJndW1lbnQgaXMgbm90IHByZXNlbnQsIHRoZSBzcGFjaW5nXG4gICAgLy8gdmFsdWUgaXMgdGFrZW4gZnJvbSB0aGUgeG1sIG9iamVjdC4gIElmIGEgc3BhY2luZyBhcmd1bWVudCBpcyBwcmVzZW50LCBpdCBpcyBwYXJzZWRcbiAgICAvLyBhbmQgdXNlZCB0byBzZXQgdGhlIHNwYWNpbmcgYXR0cmlidXRlIG9mIHRoZSBMYWJlbGVyIG9iamVjdCwgYW5kIGluIHRoaXMgY2FzZSwgYW55XG4gICAgLy8gc3BhY2luZyB2YWx1ZSBwcmVzZW50IGluIHRoZSB4bWwgaXMgaWdub3JlZC5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBzcGFjaW5nIGFyZ3VtZW50IGhhcyB0aGUgdmFsdWUgbnVsbCwgdGhlIHJlc3VsdGluZyBsYWJlbGVyIHdpbGwgaGF2ZSBubyBzcGFjaW5nXG4gICAgLy8gYXR0cmlidXRlIHNldCBhdCBhbGwuXG4gICAgdmFyIGxhYmVsZXIsXG4gICAgICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpLFxuICAgICAgICBSR0JDb2xvciA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX21lYXN1cmUuanMnKSxcbiAgICAgICAgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIERhdGFGb3JtYXR0ZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfZm9ybWF0dGVyLmpzJyksXG4gICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHBhcnNlUG9pbnQgPSBQb2ludC5wYXJzZTtcblxuICAgIC8vIGBwYXJzZUF0dHJpYnV0ZWAgcmV0dXJucyB0cnVlIG9yIGZhbHNlIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9yIG5vdCBpdCBzZXQgdGhlIGF0dHJpYnV0ZS5cbiAgICAvLyBJZiBpdCBkaWQgbm90IGFuZCBpZiB0aGUgYGRlZmF1bHRzYCBvYmplY3QgZXhpc3RzIHRoZW4gdGhlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gdGhlXG4gICAgLy8gYXBwcm9wcmlhdGUgZGVmYXVsdCB2YWx1ZS5cbiAgICB2YXIgcGFyc2VMYWJlbGVyQXR0cmlidXRlID0gZnVuY3Rpb24gKHZhbHVlLCBhdHRyaWJ1dGUsIHByZXByb2Nlc3NvciwgZGVmYXVsdE5hbWUpIHtcbiAgICAgICAgaWYgKCFwRi5wYXJzZUF0dHJpYnV0ZSh2YWx1ZSwgYXR0cmlidXRlLCBwcmVwcm9jZXNzb3IpICYmIGRlZmF1bHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZShkZWZhdWx0c1tkZWZhdWx0TmFtZV0oKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZURhdGFGb3JtYXR0ZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0YUZvcm1hdHRlci5jcmVhdGUodHlwZSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIHBhcnNlRGF0YVZhbHVlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGFWYWx1ZS5wYXJzZSh0eXBlLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGlmICh4bWwpIHtcbiAgICAgICAgbGFiZWxlciA9IG5ldyBMYWJlbGVyKGF4aXMpO1xuICAgICAgICBpZiAoc3BhY2luZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNwYWNpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNwYWNpbmcgPSBwRi5nZXRYTUxBdHRyKHhtbCxcInNwYWNpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL05PVEU6IHNwYWNpbmcgbWlnaHQgc3RpbGwgPT09IHVuZGVmaW5lZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUoc3BhY2luZywgbGFiZWxlci5zcGFjaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIERhdGFNZWFzdXJlLnBhcnNlKGF4aXMudHlwZSgpLCB2KTsgfSwgLy9wRi5wYXJzZURhdGFNZWFzdXJlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFjaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImZvcm1hdFwiKSwgICAgICAgIGxhYmVsZXIuZm9ybWF0dGVyLCAgICAgcGFyc2VEYXRhRm9ybWF0dGVyKGF4aXMudHlwZSgpKSwgICAgICAgICAgICAgIFwiZm9ybWF0dGVyXCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJzdGFydFwiKSwgICAgICAgICBsYWJlbGVyLnN0YXJ0LCAgICAgICAgIHBhcnNlRGF0YVZhbHVlKGF4aXMudHlwZSgpKSwgICAgICAgICAgICAgICAgICBcInN0YXJ0XCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJhbmdsZVwiKSwgICAgICAgICBsYWJlbGVyLmFuZ2xlLCAgICAgICAgIHBhcnNlRmxvYXQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFuZ2xlXCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJwb3NpdGlvblwiKSwgICAgICBsYWJlbGVyLnBvc2l0aW9uLCAgICAgIHBhcnNlUG9pbnQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJhbmNob3JcIiksICAgICAgICBsYWJlbGVyLmFuY2hvciwgICAgICAgIHBhcnNlUG9pbnQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFuY2hvclwiKTtcbiAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiZGVuc2l0eWZhY3RvclwiKSwgbGFiZWxlci5kZW5zaXR5ZmFjdG9yLCBwYXJzZUZsb2F0LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkZW5zaXR5ZmFjdG9yXCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJjb2xvclwiKSwgICAgICAgICBsYWJlbGVyLmNvbG9yLCAgICAgICAgIFJHQkNvbG9yLnBhcnNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJ2aXNpYmxlXCIpLCAgICAgICBsYWJlbGVyLnZpc2libGUsICAgICAgIHBGLnBhcnNlQm9vbGVhbiwgICAgICAgICAgICAgICAgXCJ2aXNpYmxlXCIpO1xuXG4gICAgfVxuICAgIHJldHVybiBsYWJlbGVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYWJlbGVyO1xuIiwidmFyIExlZ2VuZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbGVnZW5kLmpzJyk7XG5cbi8vIDxsZWdlbmRcbi8vICAgICB2aXNpYmxlPVwiQk9PTEVBTlwiXG4vLyAgICAgYmFzZT1cIlBPSU5UKDEsMSlcIlxuLy8gICAgIGFuY2hvcj1cIlBPSU5UKDEsMSlcIlxuLy8gICAgIHBvc2l0aW9uPVwiUE9JTlQoMCwwKVwiXG4vLyAgICAgZnJhbWU9XCJGUkFNRShwYWRkaW5nKVwiXG4vLyAgICAgY29sb3I9XCJDT0xPUih3aGl0ZSlcIlxuLy8gICAgIG9wYWNpdHk9XCJET1VCTEUoMS4wKVwiXG4vLyAgICAgYm9yZGVyPVwiSU5URUdFUigxKVwiXG4vLyAgICAgYm9yZGVyY29sb3I9XCJDT0xPUihibGFjaylcIlxuLy8gICAgIHJvd3M9XCJJTlRFR0VSXCJcbi8vICAgICBjb2x1bW5zPVwiSU5URUdFUlwiXG4vLyAgICAgY29ybmVycmFkaXVzPVwiSU5URUdFUigwKVwiXG4vLyAgICAgcGFkZGluZz1cIklOVEVHRVIoMClcIj5cbi8vICAgPGljb25cbi8vICAgICAgIHdpZHRoPVwiSU5URUdFUig0MClcIlxuLy8gICAgICAgaGVpZ2h0PVwiSU5URUdFUigzMClcIlxuLy8gICAgICAgYm9yZGVyPVwiSU5URUdFUigxKVwiPlxuLy8gICA8L2ljb24+XG4vLyA8L2xlZ2VuZD5cbkxlZ2VuZC5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwpIHtcbiAgICB2YXIgbGVnZW5kICAgICAgICAgICA9IG5ldyBMZWdlbmQoKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBQb2ludCAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpLFxuICAgICAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgSWNvbiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvaWNvbi5qcycpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlSW50ZWdlciAgICAgPSBwRi5wYXJzZUludGVnZXIsXG4gICAgICAgIHBhcnNlUG9pbnQgICAgICAgPSBQb2ludC5wYXJzZSxcbiAgICAgICAgcGFyc2VSR0JDb2xvciAgICA9IFJHQkNvbG9yLnBhcnNlLFxuICAgICAgICBjaGlsZDtcbiAgICBpZiAoeG1sKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwidmlzaWJsZVwiKSwgICAgICBsZWdlbmQudmlzaWJsZSwgICAgICBwRi5wYXJzZUJvb2xlYW4pO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJhc2VcIiksICAgICAgICAgbGVnZW5kLmJhc2UsICAgICAgICAgcGFyc2VQb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYW5jaG9yXCIpLCAgICAgICBsZWdlbmQuYW5jaG9yLCAgICAgICBwYXJzZVBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJwb3NpdGlvblwiKSwgICAgIGxlZ2VuZC5wb3NpdGlvbiwgICAgIHBhcnNlUG9pbnQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImZyYW1lXCIpLCAgICAgICAgbGVnZW5kLmZyYW1lKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJjb2xvclwiKSwgICAgICAgIGxlZ2VuZC5jb2xvciwgICAgICAgIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJvcmRlcmNvbG9yXCIpLCAgbGVnZW5kLmJvcmRlcmNvbG9yLCAgcGFyc2VSR0JDb2xvcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwib3BhY2l0eVwiKSwgICAgICBsZWdlbmQub3BhY2l0eSwgICAgICBwYXJzZUZsb2F0KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJib3JkZXJcIiksICAgICAgIGxlZ2VuZC5ib3JkZXIsICAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwicm93c1wiKSwgICAgICAgICBsZWdlbmQucm93cywgICAgICAgICBwYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImNvbHVtbnNcIiksICAgICAgbGVnZW5kLmNvbHVtbnMsICAgICAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJjb3JuZXJyYWRpdXNcIiksIGxlZ2VuZC5jb3JuZXJyYWRpdXMsIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwicGFkZGluZ1wiKSwgICAgICBsZWdlbmQucGFkZGluZywgICAgICBwYXJzZUludGVnZXIpO1xuXG4gICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJpY29uXCIpO1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGVnZW5kLmljb24oSWNvbi5wYXJzZVhNTChjaGlsZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlZ2VuZDtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgTXVsdGlncmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbXVsdGlncmFwaC5qcycpKCQpO1xuXG4gICAgLy8gaWYgcGFyc2VYTUwgbWV0aG9kIGFscmVhZHkgaGFzIGJlZW4gZGVmaW5lZCwgd2hpY2ggd291bGQgYmUgdGhlIGNhc2UgaWYgdGhpc1xuICAgIC8vIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGNhbGxlZCwganVzdCByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICBpZiAodHlwZW9mKE11bHRpZ3JhcGgucGFyc2VYTUwpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBNdWx0aWdyYXBoOyB9O1xuXG4gICAgTXVsdGlncmFwaC5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwsIG11Z2wsIG1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHZhciBtdWx0aWdyYXBoID0gbmV3IE11bHRpZ3JhcGgoKSxcbiAgICAgICAgICAgIGdyYXBocyAgICAgPSBtdWx0aWdyYXBoLmdyYXBocygpLFxuICAgICAgICAgICAgR3JhcGggICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZ3JhcGguanMnKSxcbiAgICAgICAgICAgIGNoaWxkO1xuICAgICAgICBtdWx0aWdyYXBoLm11Z2wobXVnbCk7IC8vIHNldCB0aGUgbXVnbCB1cmxcbiAgICAgICAgaWYgKHhtbCkge1xuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcIj5ncmFwaFwiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKGNoaWxkLCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgICAgICBncmFwaHMuYWRkKCBHcmFwaC5wYXJzZVhNTCgkKGUpLCBtdWx0aWdyYXBoLCBtZXNzYWdlSGFuZGxlcikgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQubGVuZ3RoID09PSAwICYmIHhtbC5jaGlsZHJlbigpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBncmFwaHMuYWRkKCBHcmFwaC5wYXJzZVhNTCh4bWwsIG11bHRpZ3JhcGgsIG1lc3NhZ2VIYW5kbGVyKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtdWx0aWdyYXBoO1xuICAgIH07XG5cbiAgICByZXR1cm4gTXVsdGlncmFwaDtcbn07XG4iLCJ2YXIgUGFuID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wYW4uanMnKTtcblxuLy8gPHBhbiBhbGxvd2VkPVwidHJ1ZVwiIG1pbj1cIi0xMDBcIiBtYXg9XCIxMDBcIi8+XG5QYW4ucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sLCB0eXBlKSB7XG4gICAgdmFyIHBhbiAgICAgICAgICAgID0gbmV3IFBhbigpLFxuICAgICAgICBwRiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBEYXRhVmFsdWUgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBwYXJzZURhdGFWYWx1ZSA9IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIERhdGFWYWx1ZS5wYXJzZSh0eXBlLCB2KTsgfTtcbiAgICBpZiAoeG1sKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYWxsb3dlZFwiKSwgcGFuLmFsbG93ZWQsIHBGLnBhcnNlQm9vbGVhbik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwibWluXCIpLCAgICAgcGFuLm1pbiwgICAgIHBhcnNlRGF0YVZhbHVlKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJtYXhcIiksICAgICBwYW4ubWF4LCAgICAgcGFyc2VEYXRhVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcGFuO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYW47XG4iLCIvLyBUaGlzIGZpbGUgdXNlcyBqUXVlcnkuICBBIHZhbGlkIGpRdWVyeSBvYmplY3QgbXVzdCBiZSBwYXNzZWQgdG8gdGhlXG4vLyBmdW5jdGlvbiByZXR1cm5lZCBieSByZXF1aXJpbmcgdGhpcyBmaWxlLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkKSB7XG4gICAgdmFyIFBsb3QgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3Bsb3QuanMnKTtcblxuICAgIC8vIGlmIHBhcnNlWE1MIG1ldGhvZCBhbHJlYWR5IGhhcyBiZWVuIGRlZmluZWQsIHdoaWNoIHdvdWxkIGJlIHRoZSBjYXNlIGlmIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBjYWxsZWQsIGp1c3QgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKHR5cGVvZihQbG90LnBhcnNlWE1MKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gUGxvdDsgfTtcblxuICAgIC8vIDxwbG90PlxuICAgIC8vICAgPGxlZ2VuZFxuICAgIC8vICAgICAgIHZpc2libGU9XCJCT09MRUFOXCJcbiAgICAvLyAgICAgICBsYWJlbD1cIlNUUklOR1wiPlxuICAgIC8vICAgPC9sZWdlbmQ+XG4gICAgLy8gICA8aG9yaXpvbnRhbGF4aXMgcmVmPVwiU1RSSU5HIVwiPlxuICAgIC8vICAgICA8dmFyaWFibGUgcmVmPVwiU1RSSU5HIVwiIC8+XG4gICAgLy8gICA8L2hvcml6b250YWxheGlzPlxuICAgIC8vICAgPHZlcnRpY2FsYXhpcyByZWY9XCJTVFJJTkchXCI+XG4gICAgLy8gICAgIDx2YXJpYWJsZSByZWY9XCJTVFJJTkdcIiAvPlxuICAgIC8vICAgICA8Y29uc3RhbnQgdmFsdWU9XCJEQVRBVkFMVUVcIi8+XG4gICAgLy8gICA8L3ZlcnRpY2FsYXhpcz5cbiAgICAvLyAgIDxyZW5kZXJlciB0eXBlPVwiUkVOREVSRVJUWVBFKGxpbmUpXCI+XG4gICAgLy8gICAgIDxvcHRpb24gbmFtZT1cIlNUUklORyFcIiB2YWx1ZT1cIlNUUklORyFcIiBtaW49XCJEQVRBVkFMVUVcIiBtYXg9XCJEQVRBVkFMVUVcIi8+XG4gICAgLy8gICAgIDxvcHRpb24gbmFtZT1cIlNUUklORyFcIiB2YWx1ZT1cIlNUUklORyFcIiBtaW49XCJEQVRBVkFMVUVcIiBtYXg9XCJEQVRBVkFMVUVcIi8+XG4gICAgLy8gICAgIC4uLlxuICAgIC8vICAgPC9yZW5kZXJlcj5cbiAgICAvLyAgIDxkYXRhdGlwcyBmb3JtYXQ9XCJTVFJJTkchXCIgYmdjb2xvcj1cIkNPTE9SXCIgYmdhbHBoYT1cIkRPVUJMRVwiIGJvcmRlcj1cIklOVEVHRVJcIiBib3JkZXJjb2xvcj1cIkNPTE9SXCIgcGFkPVwiSU5URUdFUlwiPlxuICAgIC8vICAgICA8dmFyaWFibGUgZm9ybWF0PVwiU1RSSU5HIVwiIC8+XG4gICAgLy8gICAgIDx2YXJpYWJsZSBmb3JtYXQ9XCJTVFJJTkchXCIgLz5cbiAgICAvLyAgICAgLi4uXG4gICAgLy8gICA8L2RhdGF0aXBzPlxuICAgIC8vIDwvcGxvdD5cbiAgICBQbG90LnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgZ3JhcGgsIG1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHZhciBEYXRhUGxvdCAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfcGxvdC5qcycpLFxuICAgICAgICAgICAgUGxvdExlZ2VuZCAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wbG90X2xlZ2VuZC5qcycpLFxuICAgICAgICAgICAgQ29uc3RhbnRQbG90ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb25zdGFudF9wbG90LmpzJyksXG4gICAgICAgICAgICBEYXRhVmFsdWUgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgICAgIFJlbmRlcmVyICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcmVuZGVyZXIuanMnKSxcbiAgICAgICAgICAgIEZpbHRlciAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZmlsdGVyLmpzJyksXG4gICAgICAgICAgICBEYXRhdGlwcyAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGF0aXBzLmpzJyksXG4gICAgICAgICAgICBwRiAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgICAgIHBsb3QsXG4gICAgICAgICAgICBoYXhpcyxcbiAgICAgICAgICAgIHZheGlzLFxuICAgICAgICAgICAgdmFyaWFibGUsXG4gICAgICAgICAgICBhdHRyLCBjaGlsZDtcbiAgICAgICAgaWYgKHhtbCkge1xuXG4gICAgICAgICAgICAvLyBwb3B1bGF0ZSB2ZXJ0aWNhbGF4aXMgZnJvbSB4bWxcbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCI+dmVydGljYWxheGlzXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA9PT0gMSAmJiBwRi5nZXRYTUxBdHRyKGNoaWxkLFwicmVmXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmF4aXMgPSBncmFwaC5heGlzQnlJZChwRi5nZXRYTUxBdHRyKGNoaWxkLFwicmVmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZheGlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgVmVydGljYWwgQXhpcyBFcnJvcjogVGhlIGdyYXBoIGRvZXMgbm90IGNvbnRhaW4gYW4gYXhpcyB3aXRoIGFuIGlkIG9mICdcIiArIHBGLmdldFhNTEF0dHIoY2hpbGQsXCJyZWZcIikgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJ2ZXJ0aWNhbGF4aXMgY29uc3RhbnRcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBjb25zdGFudFZhbHVlU3RyaW5nID0gcEYuZ2V0WE1MQXR0cihjaGlsZCxcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdGFudFZhbHVlU3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uc3RhbnQgUGxvdCBFcnJvcjogQSAndmFsdWUnIGF0dHJpYnV0ZSBpcyBuZWVkZWQgdG8gZGVmaW5lIGEgQ29uc3RhbnQgUGxvdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGxvdCA9IG5ldyBDb25zdGFudFBsb3QoRGF0YVZhbHVlLnBhcnNlKHZheGlzLnR5cGUoKSwgY29uc3RhbnRWYWx1ZVN0cmluZykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbG90ID0gbmV3IERhdGFQbG90KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBsb3QudmVydGljYWxheGlzKHZheGlzKTtcblxuICAgICAgICAgICAgLy8gcG9wdWxhdGUgaG9yaXpvbnRhbGF4aXMgZnJvbSB4bWxcbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCI+aG9yaXpvbnRhbGF4aXNcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID09PSAxICYmIHBGLmdldFhNTEF0dHIoY2hpbGQsXCJyZWZcIikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICBoYXhpcyA9IGdyYXBoLmF4aXNCeUlkKHBGLmdldFhNTEF0dHIoY2hpbGQsXCJyZWZcIikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGF4aXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5ob3Jpem9udGFsYXhpcyhoYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbG90IEhvcml6b250YWwgQXhpcyBFcnJvcjogVGhlIGdyYXBoIGRvZXMgbm90IGNvbnRhaW4gYW4gYXhpcyB3aXRoIGFuIGlkIG9mICdcIiArIHBGLmdldFhNTEF0dHIoY2hpbGQsXCJyZWZcIikgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBEYXRhUGxvdCwgcGFyc2UgdmFyaWFibGVzXG4gICAgICAgICAgICBpZiAocGxvdCBpbnN0YW5jZW9mIERhdGFQbG90KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBwcm92aWRlIGRlZmF1bHQgaG9yaXpvbnRhbGF4aXMgdmFyaWFibGUgaWYgbm90IHByZXNlbnQgaW4geG1sXG4gICAgICAgICAgICAgICAgaWYgKHhtbC5maW5kKFwiaG9yaXpvbnRhbGF4aXMgdmFyaWFibGVcIikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QudmFyaWFibGUoKS5hZGQobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vVE9ETzogZGVmZXIgcG9wdWxhdGlvbiBvZiB2YXJpYWJsZXMgdW50aWwgbm9ybWFsaXplciBoYXMgZXhlY3V0ZWRcbiAgICAgICAgICAgICAgICAvLyBwb3B1bGF0ZSBheGlzIHZhcmlhYmxlcyBmcm9tIHhtbFxuICAgICAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJob3Jpem9udGFsYXhpcyB2YXJpYWJsZSwgdmVydGljYWxheGlzIHZhcmlhYmxlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGNoaWxkLCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBwRi5nZXRYTUxBdHRyKCQoZSksXCJyZWZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUgPSBncmFwaC52YXJpYWJsZUJ5SWQoIGF0dHIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbG90LmRhdGEoIHZhcmlhYmxlLmRhdGEoKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbG90LnZhcmlhYmxlKCkuYWRkKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbG90IFZhcmlhYmxlIEVycm9yOiBObyBEYXRhIHRhZyBjb250YWlucyBhIHZhcmlhYmxlIHdpdGggYW4gaWQgb2YgJ1wiICsgYXR0ciArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHBvcHVsYXRlIGxlZ2VuZCBmcm9tIHhtbFxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcImxlZ2VuZFwiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcGxvdC5sZWdlbmQoUGxvdExlZ2VuZC5wYXJzZVhNTChjaGlsZCwgcGxvdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbG90LmxlZ2VuZChQbG90TGVnZW5kLnBhcnNlWE1MKHVuZGVmaW5lZCwgcGxvdCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwb3B1bGF0ZSByZW5kZXJlciBmcm9tIHhtbFxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcInJlbmRlcmVyXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwbG90LnJlbmRlcmVyKFJlbmRlcmVyLnBhcnNlWE1MKGNoaWxkLCBwbG90LCBtZXNzYWdlSGFuZGxlcikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwb3B1bGF0ZSBmaWx0ZXIgZnJvbSB4bWxcbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJmaWx0ZXJcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBsb3QuZmlsdGVyKEZpbHRlci5wYXJzZVhNTChjaGlsZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwb3B1bGF0ZSBkYXRhdGlwcyBmcm9tIHhtbFxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcImRhdGF0aXBzXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwbG90LmRhdGF0aXBzKERhdGF0aXBzLnBhcnNlWE1MKGNoaWxkKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxvdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBsb3Q7XG59O1xuIiwidmFyIFBsb3RMZWdlbmQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3Bsb3RfbGVnZW5kLmpzJyk7XG5cbi8vIDxsZWdlbmQgdmlzaWJsZT1cIkJPT0xFQU5cIiBsYWJlbD1cIlNUUklOR1wiIC8+XG5QbG90TGVnZW5kLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgcGxvdCkge1xuICAgIHZhciBsZWdlbmQgICAgICAgICAgID0gbmV3IFBsb3RMZWdlbmQoKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBUZXh0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS90ZXh0LmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgY2hpbGQ7XG4gICAgaWYgKHhtbCkge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcInZpc2libGVcIiksIGxlZ2VuZC52aXNpYmxlLCBwRi5wYXJzZUJvb2xlYW4pO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImxhYmVsXCIpLCAgIGxlZ2VuZC5sYWJlbCwgICBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBUZXh0KHZhbHVlKTsgfSk7XG4gICAgfVxuXG4gICAgaWYgKGxlZ2VuZC5sYWJlbCgpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgdWdseSBwYXRjaCB3aXRoIHNvbWV0aGluZyB0aGF0IHdvcmtzIHByb3Blcmx5XG4gICAgICAgIGlmICh0eXBlb2YocGxvdC52YXJpYWJsZSk9PT1cImZ1bmN0aW9uXCIgJiYgcGxvdC52YXJpYWJsZSgpLnNpemUoKSA+PSAyKSB7IFxuICAgICAgICAgICAgbGVnZW5kLmxhYmVsKG5ldyBUZXh0KHBsb3QudmFyaWFibGUoKS5hdCgxKS5pZCgpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWdlbmQubGFiZWwobmV3IFRleHQoXCJwbG90XCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbG90TGVnZW5kO1xuIiwidmFyIFBsb3RhcmVhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wbG90YXJlYS5qcycpO1xuXG4vLyAgPHBsb3RhcmVhXG4vLyAgICAgbWFyZ2luYm90dG9tPVwiSU5URUdFUigzNSlcIlxuLy8gICAgIG1hcmdpbmxlZnQ9XCJJTlRFR0VSKDM4KVwiXG4vLyAgICAgbWFyZ2ludG9wPVwiSU5URUdFUigxMClcIlxuLy8gICAgIG1hcmdpbnJpZ2h0PVwiSU5URUdFUigzNSlcIlxuLy8gICAgIGJvcmRlcj1cIklOVEVHRVIoMClcIlxuLy8gICAgIGJvcmRlcmNvbG9yPVwiQ09MT1IoMHhlZWVlZWUpXCJcbi8vICAgICBjb2xvcj1cIkNPTE9SXCI+XG4vLyAgPC9wbG90YXJlYT5cblBsb3RhcmVhLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCkge1xuICAgIHZhciBwbG90YXJlYSA9IG5ldyBQbG90YXJlYSgpLFxuICAgICAgICBtYXJnaW4gPSBwbG90YXJlYS5tYXJnaW4oKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgcGFyc2VSR0JDb2xvciAgICA9IFJHQkNvbG9yLnBhcnNlLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlSW50ZWdlciAgICAgPSBwRi5wYXJzZUludGVnZXI7XG4gICAgaWYgKHhtbCkge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcIm1hcmdpbmJvdHRvbVwiKSwgbWFyZ2luLmJvdHRvbSwgICAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwibWFyZ2lubGVmdFwiKSwgICBtYXJnaW4ubGVmdCwgICAgICAgICAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJtYXJnaW50b3BcIiksICAgIG1hcmdpbi50b3AsICAgICAgICAgICBwYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcIm1hcmdpbnJpZ2h0XCIpLCAgbWFyZ2luLnJpZ2h0LCAgICAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYm9yZGVyXCIpLCAgICAgICBwbG90YXJlYS5ib3JkZXIsICAgICAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJjb2xvclwiKSwgICAgICAgIHBsb3RhcmVhLmNvbG9yLCAgICAgICBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJib3JkZXJjb2xvclwiKSwgIHBsb3RhcmVhLmJvcmRlcmNvbG9yLCBwYXJzZVJHQkNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHBsb3RhcmVhO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbG90YXJlYTtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3JlbmRlcmVyLmpzJyk7XG5cbiAgICAvLyBpZiBwYXJzZVhNTCBtZXRob2QgYWxyZWFkeSBoYXMgYmVlbiBkZWZpbmVkLCB3aGljaCB3b3VsZCBiZSB0aGUgY2FzZSBpZiB0aGlzXG4gICAgLy8gZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkLCBqdXN0IHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0eXBlb2YoUmVuZGVyZXIucGFyc2VYTUwpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBSZW5kZXJlcjsgfTtcblxuICAgIC8vIDxyZW5kZXJlclxuICAgIC8vICAgICB0eXBlPVwiUkVOREVSRVJUWVBFKGxpbmUpXCI+XG4gICAgLy8gICA8b3B0aW9uXG4gICAgLy8gICAgICAgbmFtZT1cIlNUUklORyFcIlxuICAgIC8vICAgICAgIHZhbHVlPVwiU1RSSU5HIVwiXG4gICAgLy8gICAgICAgbWluPVwiREFUQVZBTFVFXCJcbiAgICAvLyAgICAgICBtYXg9XCJEQVRBVkFMVUVcIj5cbiAgICAvLyAgIDwvb3B0aW9uPlxuICAgIC8vICAgLi4uXG4gICAgLy8gPC9yZW5kZXJlcj5cbiAgICBSZW5kZXJlci5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwsIHBsb3QsIG1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHZhciBEYXRhVmFsdWUgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgICAgICAgICAgTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL251bWJlcl92YWx1ZS5qcycpLFxuICAgICAgICAgICAgV2FybmluZyAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3dhcm5pbmcuanMnKSxcbiAgICAgICAgICAgIHBGICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgICAgICByZW5kZXJlclR5cGUsXG4gICAgICAgICAgICByZW5kZXJlcixcbiAgICAgICAgICAgIG9wdDtcblxuICAgICAgICByZXF1aXJlKCcuLi8uLi9jb3JlL3JlbmRlcmVycy9hbGxfcmVuZGVyZXJzLmpzJyk7XG5cbiAgICAgICAgaWYgKHhtbCAmJiBwRi5nZXRYTUxBdHRyKHhtbCxcInR5cGVcIikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gUmVuZGVyZXIuVHlwZS5wYXJzZShwRi5nZXRYTUxBdHRyKHhtbCxcInR5cGVcIikpO1xuICAgICAgICAgICAgaWYgKCFSZW5kZXJlci5UeXBlLmlzSW5zdGFuY2UocmVuZGVyZXJUeXBlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gcmVuZGVyZXIgdHlwZSAnXCIgKyBwRi5nZXRYTUxBdHRyKHhtbCxcInR5cGVcIikgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlciA9IFJlbmRlcmVyLmNyZWF0ZShyZW5kZXJlclR5cGUpO1xuICAgICAgICAgICAgcmVuZGVyZXIucGxvdChwbG90KTtcbiAgICAgICAgICAgIGlmICh4bWwuZmluZChcIm9wdGlvblwiKS5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgc3VwcG9ydCBmb3IgZGVwcmVjYXRkIHRoZSBcIm1pc3Npbmd2YWx1ZVwiIGFuZFxuICAgICAgICAgICAgICAgIC8vIFwibWlzc2luZ29wXCIgcmVuZGVyZXIgb3B0aW9ucy4gIFRob3NlIG9wdGlvbnMgYXJlIG5vdCBvZmZpY2lhbGx5IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIC8vIGFueSBtb3JlOyBNVUdMIGZpbGVzIHNob3VsZCB1c2UgdGhlICBtaXNzaW5ndmFsdWUvbWlzc2luZ29wIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAvLyBvZiA8ZGF0YT48dmFyaWFibGU+IG9yIDxkYXRhPjx2YXJpYWJsZXM+IGluc3RlYWQuICBXaGVuIHdlJ3JlIHJlYWR5IHRvXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgc3VwcG9ydCwgZGVsZXRlIHRoZSBibG9jayBvZiBjb2RlOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChyZW5kZXJlciwgeG1sLCBwbG90LCBtZXNzYWdlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdWYWx1ZU9wdGlvbiA9IHhtbC5maW5kKFwib3B0aW9uW25hbWU9bWlzc2luZ3ZhbHVlXVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdPcE9wdGlvbiAgICA9IHhtbC5maW5kKFwib3B0aW9uW25hbWU9bWlzc2luZ29wXVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZU9wdGlvbi5sZW5ndGggPiAwIHx8IG1pc3NpbmdPcE9wdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHBsb3QuZGF0YSgpLmNvbHVtbnMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW47XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5zaXplKCk7ICArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zLmF0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSgpID09PSBEYXRhVmFsdWUuTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nVmFsdWVPcHRpb24ubGVuZ3RoID4gMCAmJiAoY29sdW1uLm1pc3Npbmd2YWx1ZSgpID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4ubWlzc2luZ3ZhbHVlKE51bWJlclZhbHVlLnBhcnNlKHBGLmdldFhNTEF0dHIobWlzc2luZ1ZhbHVlT3B0aW9uLFwidmFsdWVcIikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWlzc2luZ09wT3B0aW9uLmxlbmd0aCA+IDAgJiYgKGNvbHVtbi5taXNzaW5nb3AoKSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLm1pc3NpbmdvcChEYXRhVmFsdWUucGFyc2VDb21wYXJhdG9yKHBGLmdldFhNTEF0dHIobWlzc2luZ09wT3B0aW9uLFwidmFsdWVcIikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWlzc2luZ1ZhbHVlT3B0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLndhcm5pbmcoXCJSZW5kZXJlciBvcHRpb24gJ21pc3Npbmd2YWx1ZScgaXMgZGVwcmVjYXRlZDsgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVzZSAnbWlzc2luZ3ZhbHVlJyBhdHRyaWJ1dGUgb2YgJ2RhdGEnLyd2YXJpYWJsZSc7IGluc3RlYWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgeG1sIHNvIHRoYXQgdGhlIG9wdGlvbi1wcm9jZXNzaW5nIGNvZGUgYmVsb3cgZG9lc24ndCBzZWUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdWYWx1ZU9wdGlvbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWlzc2luZ09wT3B0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLndhcm5pbmcoXCJSZW5kZXJlciBvcHRpb24gJ21pc3NpbmdvcCcgaXMgZGVwcmVjYXRlZDsgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVzZSAnbWlzc2luZ3ZhbHVlJyBhdHRyaWJ1dGUgb2YgJ2RhdGEnLyd2YXJpYWJsZSc7IGluc3RlYWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgeG1sIHNvIHRoYXQgdGhlIG9wdGlvbi1wcm9jZXNzaW5nIGNvZGUgYmVsb3cgZG9lc24ndCBzZWUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdPcE9wdGlvbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0ocmVuZGVyZXIsIHhtbCwgcGxvdCwgbWVzc2FnZUhhbmRsZXIpKTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEVuZCBvZiBjb2RlIHRvIGRlbGV0ZSB3aGVuIHJlbW92aW5nIHN1cHBvcnQgZm9yIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAvLyBtaXNzaW5ndmFsdWUvbWlzc2luZ29wIHJlbmRlcmVyIG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgICAgICQuZWFjaCh4bWwuZmluZChcIj5vcHRpb25cIiksIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRPcHRpb25Gcm9tU3RyaW5nKHBGLmdldFhNTEF0dHIoJChlKSxcIm5hbWVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBGLmdldFhNTEF0dHIoJChlKSxcInZhbHVlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwRi5nZXRYTUxBdHRyKCQoZSksXCJtaW5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBGLmdldFhNTEF0dHIoJChlKSxcIm1heFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgV2FybmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLndhcm5pbmcoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgfTtcblxuICAgIHJldHVybiBSZW5kZXJlcjtcbn07XG4iLCJ2YXIgVGl0bGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RpdGxlLmpzJyk7XG5cbi8vICA8dGl0bGVcbi8vICAgICAgYmFzZT1cIlBPSU5UKDAsMSlcIlxuLy8gICAgICBhbmNob3I9XCJQT0lOVCgwLDEpXCJcbi8vICAgICAgcG9zaXRpb249XCJQT0lOVCgwLDApXCJcbi8vICAgICAgZnJhbWU9XCJGUkFNRShwYWRkaW5nKVwiXG4vLyAgICAgIGNvbG9yPVwiQ09MT1Iod2hpdGUpXCJcbi8vICAgICAgb3BhY2l0eT1cIkRPVUJMRSgxLjApXCJcbi8vICAgICAgYm9yZGVyPVwiSU5URUdFUigwKVwiXG4vLyAgICAgIGJvcmRlcmNvbG9yPVwiQ09MT1IoYmxhY2spXCJcbi8vICAgICAgcGFkZGluZz1cIklOVEVHRVIoMClcIlxuLy8gICAgICBjb3JuZXJyYWRpdXM9XCJJTlRFR0VSKDE1KVwiXG4vLyAgICAgIGZvbnRzaXplPVwiSU5URUdFUlwiPlxuLy8gIDwvdGl0bGU+XG5UaXRsZS5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwsIGdyYXBoKSB7XG4gICAgdmFyIFBvaW50ICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIFJHQkNvbG9yICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICBUZXh0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS90ZXh0LmpzJyksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VQb2ludCAgICAgICA9IFBvaW50LnBhcnNlLFxuICAgICAgICBwYXJzZVJHQkNvbG9yICAgID0gUkdCQ29sb3IucGFyc2UsXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgcGFyc2VJbnRlZ2VyICAgICA9IHBGLnBhcnNlSW50ZWdlcixcbiAgICAgICAgdGl0bGU7XG5cbiAgICBpZiAoeG1sKSB7XG4gICAgICAgIHZhciB0ZXh0ID0geG1sLnRleHQoKTtcbiAgICAgICAgaWYgKHRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRpdGxlID0gbmV3IFRpdGxlKG5ldyBUZXh0KHRleHQpLCBncmFwaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImZyYW1lXCIpLCAgICAgICAgdGl0bGUuZnJhbWUsICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJvcmRlclwiKSwgICAgICAgdGl0bGUuYm9yZGVyLCAgICAgICBwYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImNvbG9yXCIpLCAgICAgICAgdGl0bGUuY29sb3IsICAgICAgICBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJib3JkZXJjb2xvclwiKSwgIHRpdGxlLmJvcmRlcmNvbG9yLCAgcGFyc2VSR0JDb2xvcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwib3BhY2l0eVwiKSwgICAgICB0aXRsZS5vcGFjaXR5LCAgICAgIHBhcnNlRmxvYXQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcInBhZGRpbmdcIiksICAgICAgdGl0bGUucGFkZGluZywgICAgICBwYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImNvcm5lcnJhZGl1c1wiKSwgdGl0bGUuY29ybmVycmFkaXVzLCBwYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImFuY2hvclwiKSwgICAgICAgdGl0bGUuYW5jaG9yLCAgICAgICBwYXJzZVBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJiYXNlXCIpLCAgICAgICAgIHRpdGxlLmJhc2UsICAgICAgICAgcGFyc2VQb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwicG9zaXRpb25cIiksICAgICB0aXRsZS5wb3NpdGlvbiwgICAgIHBhcnNlUG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGl0bGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpdGxlO1xuIiwidmFyIFdpbmRvdyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvd2luZG93LmpzJyk7XG5cbi8vIDx3aW5kb3dcbi8vICAgICAgIHdpZHRoPVwiSU5URUdFUlwiXG4vLyAgICAgICBoZWlnaHQ9XCJJTlRFR0VSXCJcbi8vICAgICAgIGJvcmRlcj1cIklOVEVHRVIoMilcIlxuLy8gICAgICAgYm9yZGVyY29sb3I9XCJDT0xPUihibGFjaylcIlxuLy8gICAgICAgbWFyZ2luPVwiSU5URUdFUigyKVwiXG4vLyAgICAgICBwYWRkaW5nPVwiSU5URUdFUig1KVwiPlxuLy8gICA8L3dpbmRvdz5cbldpbmRvdy5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwpIHtcbiAgICB2YXIgdyA9IG5ldyBXaW5kb3coKSxcbiAgICAgICAgUkdCQ29sb3IgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBwYXJzZUludGVnZXIgICAgID0gcEYucGFyc2VJbnRlZ2VyLFxuICAgICAgICBhdHRyO1xuICAgIGlmICh4bWwpIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJ3aWR0aFwiKSwgIHcud2lkdGgsICBwYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImhlaWdodFwiKSwgdy5oZWlnaHQsIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYm9yZGVyXCIpLCB3LmJvcmRlciwgcGFyc2VJbnRlZ2VyKTtcblxuICAgICAgICBhdHRyID0gcEYuZ2V0WE1MQXR0cih4bWwsXCJtYXJnaW5cIik7XG4gICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgIHcubWFyZ2luKCkuc2V0KG0sbSxtLG0pO1xuICAgICAgICAgICAgfShwYXJzZUludChhdHRyLCAxMCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHIgPSBwRi5nZXRYTUxBdHRyKHhtbCxcInBhZGRpbmdcIik7XG4gICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgIHcucGFkZGluZygpLnNldChtLG0sbSxtKTtcbiAgICAgICAgICAgIH0ocGFyc2VJbnQoYXR0ciwgMTApKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmVkIGRlcHJlY2F0ZWQgY29sb3IgbmFtZSBjaGVjayBmcm9tIGNvbW1pdCAjMTc2NjVlMlxuICAgICAgICAvLyAgICBqcmZyaW1tZSBUdWVzIEFwciAyIDExOjQ3IDIwMTNcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJib3JkZXJjb2xvclwiKSwgdy5ib3JkZXJjb2xvciwgUkdCQ29sb3IucGFyc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2luZG93O1xuIiwidmFyIFpvb20gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3pvb20uanMnKTtcblxuLy8gPHpvb20gYWxsb3dlZD1cInRydWVcIiBtaW49XCIxMFwiIG1heD1cIjEwMFwiIGFuY2hvcj1cIjBcIi8+XG5ab29tLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgdHlwZSkge1xuICAgIHZhciB6b29tICAgICAgICAgICAgID0gbmV3IFpvb20oKSxcbiAgICAgICAgRGF0YVZhbHVlICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgICAgICBEYXRhTWVhc3VyZSAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX21lYXN1cmUuanMnKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlRGF0YU1lYXN1cmUgPSBmdW5jdGlvbih2KSB7IHJldHVybiBEYXRhTWVhc3VyZS5wYXJzZSh0eXBlLCB2KTsgfSwgLy9wRi5wYXJzZURhdGFNZWFzdXJlXG4gICAgICAgIGF0dHI7XG4gICAgaWYgKHhtbCkge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImFsbG93ZWRcIiksIHpvb20uYWxsb3dlZCwgcEYucGFyc2VCb29sZWFuKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJtaW5cIiksICAgICB6b29tLm1pbiwgICAgIHBhcnNlRGF0YU1lYXN1cmUpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcIm1heFwiKSwgICAgIHpvb20ubWF4LCAgICAgcGFyc2VEYXRhTWVhc3VyZSk7XG4gICAgICAgIGF0dHIgPSBwRi5nZXRYTUxBdHRyKHhtbCxcImFuY2hvclwiKTtcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICB6b29tLmFuY2hvcihudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgem9vbS5hbmNob3IoIERhdGFWYWx1ZS5wYXJzZSh0eXBlLCBhdHRyKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB6b29tO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBab29tO1xuIiwidmFyIFBhcnNpbmdGdW5jdGlvbnMgPSB7fTtcblxuLyoqXG4gKiBUaGUgVXRpbGl0eSBGdW5jdGlvbnMgbW9kdWxlIHByb3ZpZGVzIHV0aWxpdHkgZnVuY3Rpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gZ2VuZXJhbCBjb25jZXB0cy5cbiAqXG4gKiBAbW9kdWxlIG11bHRpZ3JhcGhcbiAqIEBzdWJtb2R1bGUgdXRpbGl0eWZ1bmN0aW9uc1xuICogQG1haW4gdXRpbGl0eWZ1bmN0aW9uc1xuICovXG5cbi8qKlxuICogRnVuY3Rpb25zIHdoaWNoIHByb3ZpZGUgYWJzdHJhY3Rpb25zIGZvciB0aGUgcGFyc2VyLlxuICpcbiAqIEBjbGFzcyBQYXJzaW5nRnVuY3Rpb25zXG4gKiBAZm9yIFBhcnNpbmdGdW5jdGlvbnNcbiAqIEBzdGF0aWNcbiAqL1xuXG4vKipcbiAqIEFic3RyYWN0IGZ1bmN0aW9uIGZvciBwYXJzaW5nIGFuZCBzZXR0aW5nIGplcm1haW5lIGF0dHJpYnV0ZXMgd2hpY2ggZG8gbm90IHJlcXVpcmVcbiAqIGV4dHJlbWVseSBjb21wbGljYXRlZCBsb2dpYyB0byBkZXRlcm1pbmUgdGhlaXIgdmFsdWVzLiBBbnkgYXR0cmlidXRlcyB3aGljaCByZXF1aXJlXG4gKiBjb21wbGV4IGxvZ2ljIHRvIGRldGVybWluZSB0aGVpciBwcm9wZXIgdmFsdWVzIHNob3VsZCBiZSBleHBsaWNpdGx5IHNldCBpbiB0aGUgcGFyc2VyLlxuICpcbiAqIEBtZXRob2QgcGFyc2VBdHRyaWJ1dGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXR0cmlidXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVwcm9jZXNzb3JcbiAqIEBzdGF0aWNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBhcnNpbmdGdW5jdGlvbnMucGFyc2VBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodmFsdWUsIGF0dHJpYnV0ZSwgcHJlcHJvY2Vzc29yKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXR0cmlidXRlKChwcmVwcm9jZXNzb3IgIT09IHVuZGVmaW5lZCkgPyBwcmVwcm9jZXNzb3IodmFsdWUpIDogdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgYXJndW1lbnQgd2l0aCBhIHJhZGl4IG9mIDEwIGFuZCByZXR1cm5zIGFuIGludGVnZXIuXG4gKlxuICogQG1ldGhvZCBwYXJzZUludGVnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHN0YXRpY1xuICogQHJldHVybiB7SW50ZWdlcn1cbiAqL1xuUGFyc2luZ0Z1bmN0aW9ucy5wYXJzZUludGVnZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbn07XG5cbi8vbWJwXG4vLy8qKlxuLy8gKiBSZXR1cm5zIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IHBhcnNlcyBhIHZhbHVlIGludG8gYSBEYXRhVmFsdWUgb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxuLy8gKlxuLy8gKiBAbWV0aG9kIHBhcnNlRGF0YVZhbHVlXG4vLyAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4vLyAqIEBzdGF0aWNcbi8vICogQHJldHVybiB7RnVuY3Rpb259XG4vLyAqL1xuLy9QYXJzaW5nRnVuY3Rpb25zLnBhcnNlRGF0YVZhbHVlID0gZnVuY3Rpb24gKHR5cGUpIHtcbi8vICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbi8vICAgICAgICByZXR1cm4gd2luZG93Lm11bHRpZ3JhcGguY29yZS5EYXRhVmFsdWUucGFyc2UodHlwZSwgdmFsdWUpO1xuLy8gICAgfTtcbi8vfTtcblxuLy9tYnBcbi8vLyoqXG4vLyAqIFJldHVybnMgYSBjdXJyaWVkIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgdmFsdWUgaW50byBhIERhdGFNZWFzdXJlIG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cbi8vICpcbi8vICogQG1ldGhvZCBwYXJzZURhdGFNZWFzdXJlXG4vLyAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4vLyAqIEBzdGF0aWNcbi8vICogQHJldHVybiB7RnVuY3Rpb259XG4vLyAqL1xuLy9QYXJzaW5nRnVuY3Rpb25zLnBhcnNlRGF0YU1lYXN1cmUgPSBmdW5jdGlvbiAodHlwZSkge1xuLy8gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuLy8gICAgICAgIHJldHVybiB3aW5kb3cubXVsdGlncmFwaC5jb3JlLkRhdGFNZWFzdXJlLnBhcnNlKHR5cGUsIHZhbHVlKTtcbi8vICAgIH07XG4vL307XG5cbi8qKlxuICogUGFyc2VzIHRoZSBhbGxvd2VkIEJvb2xlYW4gU3RyaW5ncyBhbmQgcmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgdmFsdWUuIElmIHRoZSBwYXJhbWV0ZXJcbiAqIGlzIG5vdCBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzIHRoZW4gdGhlIHBhcmFtZXRlciBpcyByZXR1cm5lZCBhcyBhbiBlcnJvciBtaWdodCBub3RcbiAqIG5lZWQgdG8gYmUgdGhyb3duIGltbWVkaWF0ZWx5LlxuICpcbiAqIEBtZXRob2QgcGFyc2VCb29sZWFuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1cbiAqIEBzdGF0aWNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBhcnNpbmdGdW5jdGlvbnMucGFyc2VCb29sZWFuID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgaWYgKHR5cGVvZihwYXJhbSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3dpdGNoIChwYXJhbS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgIGNhc2UgXCJ5ZXNcIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIFwiZmFsc2VcIjpcbiAgICAgICAgY2FzZSBcIm5vXCI6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfVxufTtcblxuLypcbiAqIFRoZSBQYXJzaW5nRnVuY3Rpb25zLmdldFhNTEF0dHIoKSBmdW5jdGlvbiByZXR1cm5zIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgZm9yXG4gKiBhbiBYTUwgZG9jdW1lbnQgbm9kZS5cbiAqIFxuICogVGhlIGBub2RlYCBhcmd1bWVudCBzaG91bGQgYmUgYSBub2RlIGluIGFuIFhNTCBkb2N1bWVudCBhcyByZXR1cm5lZCBieSB0aGUgalF1ZXJ5XG4gKiBwYXJzZVhNTCBmdW5jdGlvbi5cbiAqIFxuICogVGhlIGBhdHRybmFtZWAgYXJndW1lbnQgc2hvdWxkIGJlIGEgc3RyaW5nIHdoaWNoIGlzIHRoZSBuYW1lIG9mIGFuIGF0dHJpYnV0ZS5cbiAqIFxuICogVGhpcyBmdW5jdGlvbiBlbnN1cmVzIHRvIHJldHVybiBcInVuZGVmaW5lZFwiIGlmIHRoZSBub2RlIGRvZXMgbm90IGhhdmUgdGhlIGF0dHJpYnV0ZS5cbiAqIFxuICogVGhpcyBmdW5jdGlvbiBpdHNlbGYgZG9lcyBub3QgZGVwZW5kIG9uIGpRdWVyeSwgd2hpY2ggaXMgd2h5IGl0IGlzIGxvY2F0ZWQgaW4gdGhpc1xuICogZmlsZSAtLSBzbyB0aGF0IGNvZGUgbmVlZGluZyB0byB1c2UgdGhpcyBmdW5jdGlvbiBkb24ndCBoYXZlIHRvIHJlcXVpcmUgalF1ZXJ5IGp1c3RcbiAqIGZvciB0aGlzIGZ1bmN0aW9uLiAgKFRoZSB1c2Ugb2YgdGhpcyBmdW5jdGlvbiBkb2VzIHJlcXVpcmUgalF1ZXJ5IGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBwcm9ncmFtLCBiZWNhdXNlIHRoaXMgYG5vZGVgIG9iamVjdCBtdXN0IGJlIGEgalF1ZXJ5IG9iamVjdCByZXByZXNlbnRpbmcgYW4gWE1MXG4gKiBkb2N1bWVudC4pXG4gKiBcbiAqIFRoZSByZWFzb24gd2UgaGF2ZSB0aGlzIGZ1bmN0aW9uIGZvciBleHRyYWN0aW5nIGF0dHJpYnV0ZSB2YWx1ZXMsIHJhdGhlciB0aGFuXG4gKiBqdXN0IGNhbGxpbmcgbm9kZS5hdHRyKGF0dHJuYW1lKSBkaXJlY3RseSwgaXMgdGhhdCBpbiBzb21lIGNhc2VzIG5vZGUuYXR0cigpXG4gKiByZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcgZm9yIGF0dHJpYnV0ZXMgd2hpY2ggaGF2ZSBub3QgYmVlbiBzZXQuICBUaGlzIGZ1bmN0aW9uXG4gKiB1c2VzIHRoZSBoYXNBdHRyaWJ1dGUoKSBtZXRob2QgdG8gY2hlY2sgdG8gc2VlIHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSB2YWx1ZVxuICogaXMgcHJlc2VudCwgYW5kIGFsd2F5cyByZXR1cm5zIGB1bmRlZmluZWRgIGlmIGl0IGlzIG5vdC5cbiAqL1xuUGFyc2luZ0Z1bmN0aW9ucy5nZXRYTUxBdHRyID0gZnVuY3Rpb24obm9kZSwgYXR0cm5hbWUpIHtcbiAgICBpZiAobm9kZS5sZW5ndGggPj0gMSAmJiBub2RlWzBdLmhhc0F0dHJpYnV0ZShhdHRybmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuYXR0cihhdHRybmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNpbmdGdW5jdGlvbnM7XG4iLCJ1dGlsaXR5RnVuY3Rpb25zID0ge307XG5cbi8vIFdoeSBub3QgdXNlIE9iamVjdC5nZXRLZXlzKCkgPz8gIG1icCBGcmkgTWFyIDEzIDAwOjIxOjU3IDIwMTVcbnV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIga2V5cyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG4vLyBjb2VyY2UgYSB2YWx1ZSB0byBhIHN0cmluZywgYnV0IG5vdCBpZiBpdCBpcyB0aGUgdW5kZWZpbmVkIHZhbHVlXG51dGlsaXR5RnVuY3Rpb25zLmNvZXJjZVRvU3RyaW5nID0gZnVuY3Rpb24ocykge1xuICAgIGlmICh0eXBlb2YocykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcocyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxufTtcblxudXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyA9IGZ1bmN0aW9uIChlbGVtLCBkZWZhdWx0cywgYXR0cmlidXRlcykge1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkZWZhdWx0c1thdHRyaWJ1dGVzW2ldXSAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2YoZGVmYXVsdHNbYXR0cmlidXRlc1tpXV0pICE9PSBcIm9iamVjdFwiIHx8IGRlZmF1bHRzW2F0dHJpYnV0ZXNbaV1dID09PSBudWxsKSkge1xuICAgICAgICAgICAgaWYgKGVsZW0uYXR0cmlidXRlcygpLmluZGV4T2YoYXR0cmlidXRlc1tpXSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGVsZW0uYXR0cmlidXRlKGF0dHJpYnV0ZXNbaV0pLmRlZmF1bHRzVG8oZGVmYXVsdHNbYXR0cmlidXRlc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtO1xufTtcblxuXG4vLyBUaGlzIHNob3VsZCBiZSByZW5hbWVkOyB0aGUgbmFtZSAnZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QnIGlzIGEgaG9sZG92ZXIgZnJvbSB3aGVuIHdlXG4vLyBoYWQgYW4gWFNEIHRoYXQgY29udGFpbmVkIGRlZmF1bHQgdmFsdWVzLCBhbmQgdGhpcyBmdW5jdGlvbiBjb25zdWx0ZWQgaXQuICBPciBtYXliZVxuLy8gd2UgbmV2ZXIgYWN0dWFsbHkgaGFkIHRoYXQsIGJ1dCBpbnRlbmRlZCB0byBpbXBsZW1lbnQgaXQ/ICBJbiBhbnkgY2FzZSwgaXQgc2VlbXMgY2xlYXJcbi8vIHdlIHdvbid0IGJlIHVzaW5nIGFuIFhTRCBoZXJlLCBzbyB0aGlzIHNob3VsZCBiZSByZW5hbWVkLiAgbWJwIEZyaSBNYXIgMTMgMDA6MjM6NDIgMjAxNVxudXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCA9IGZ1bmN0aW9uICgpIHtcbiAgICBcbiAgICB2YXIgRGF0ZXRpbWVWYWx1ZSA9IHJlcXVpcmUoJy4uL2NvcmUvZGF0ZXRpbWVfdmFsdWUuanMnKSxcbiAgICAgICAgTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuLi9jb3JlL251bWJlcl92YWx1ZS5qcycpLFxuICAgICAgICBEaXNwbGFjZW1lbnQgPSByZXF1aXJlKCcuLi9tYXRoL2Rpc3BsYWNlbWVudC5qcycpLFxuICAgICAgICBJbnNldHMgPSByZXF1aXJlKCcuLi9tYXRoL2luc2V0cy5qcycpLFxuICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICAgICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi9tYXRoL3JnYl9jb2xvci5qcycpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJ3aW5kb3dcIjoge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIFwid2lkdGhcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFwiYm9yZGVyXCI6IDIsXG4gICAgICAgICAgICBcIm1hcmdpblwiIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEluc2V0cygvKnRvcCovMiwgLypsZWZ0Ki8yLCAvKmJvdHRvbSovMiwgLypyaWdodCovMik7IH0sXG4gICAgICAgICAgICBcInBhZGRpbmdcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEluc2V0cygvKnRvcCovNSwgLypsZWZ0Ki81LCAvKmJvdHRvbSovNSwgLypyaWdodCovNSk7IH0sXG4gICAgICAgICAgICBcImJvcmRlcmNvbG9yXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBSR0JDb2xvci5wYXJzZShcIjB4MDAwMDAwXCIpOyB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibGVnZW5kXCI6IHtcbiAgICAgICAgICAgIFwiaWNvblwiIDoge1xuICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IDMwLFxuICAgICAgICAgICAgICAgIFwid2lkdGhcIjogNDAsXG4gICAgICAgICAgICAgICAgXCJib3JkZXJcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidmlzaWJsZVwiOiBudWxsLFxuICAgICAgICAgICAgXCJiYXNlXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgxLDEpOyB9LFxuICAgICAgICAgICAgXCJhbmNob3JcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDEsMSk7IH0sXG4gICAgICAgICAgICBcInBvc2l0aW9uXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgwLDApOyB9LFxuICAgICAgICAgICAgXCJmcmFtZVwiOiBcInBsb3RcIixcbiAgICAgICAgICAgIFwiY29sb3JcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJHQkNvbG9yLnBhcnNlKFwiMHhmZmZmZmZcIik7IH0sXG4gICAgICAgICAgICBcImJvcmRlcmNvbG9yXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBSR0JDb2xvci5wYXJzZShcIjB4MDAwMDAwXCIpOyB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IDEuMCxcbiAgICAgICAgICAgIFwiYm9yZGVyXCI6IDEsXG4gICAgICAgICAgICBcInJvd3NcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgXCJjb2x1bW5zXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFwiY29ybmVycmFkaXVzXCI6IDAsXG4gICAgICAgICAgICBcInBhZGRpbmdcIjogMFxuICAgICAgICB9LFxuICAgICAgICBcImJhY2tncm91bmRcIjoge1xuICAgICAgICAgICAgXCJpbWdcIjoge1xuICAgICAgICAgICAgICAgIFwic3JjXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcImFuY2hvclwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoLTEsLTEpOyB9LFxuICAgICAgICAgICAgICAgIFwiYmFzZVwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoLTEsLTEpOyB9LFxuICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsMCk7IH0sXG4gICAgICAgICAgICAgICAgXCJmcmFtZVwiOiBcInBhZGRpbmdcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29sb3JcIjogXCIweGZmZmZmZlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicGxvdGFyZWFcIjoge1xuICAgICAgICAgICAgXCJtYXJnaW5cIiA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJbnNldHMoLyp0b3AqLzEwICwgLypsZWZ0Ki8zOCwgLypib3R0b20qLzM1LCAvKnJpZ2h0Ki8zNSk7IH0sXG4gICAgICAgICAgICBcImJvcmRlclwiOiAwLFxuICAgICAgICAgICAgXCJjb2xvclwiIDogbnVsbCxcbiAgICAgICAgICAgIFwiYm9yZGVyY29sb3JcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJHQkNvbG9yLnBhcnNlKFwiMHhlZWVlZWVcIik7IH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0aXRsZVwiOiB7XG4gICAgICAgICAgICBcInRleHRcIiAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgXCJmcmFtZVwiICAgICAgICA6IFwicGFkZGluZ1wiLFxuICAgICAgICAgICAgXCJib3JkZXJcIiAgICAgICA6IDAsXG4gICAgICAgICAgICBcImNvbG9yXCIgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJHQkNvbG9yLnBhcnNlKFwiMHhmZmZmZmZcIik7IH0sXG4gICAgICAgICAgICBcImJvcmRlcmNvbG9yXCIgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJHQkNvbG9yLnBhcnNlKFwiMHgwMDAwMDBcIik7IH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIiAgICAgIDogMS4wLFxuICAgICAgICAgICAgXCJwYWRkaW5nXCIgICAgICA6IDAsXG4gICAgICAgICAgICBcImNvcm5lcnJhZGl1c1wiIDogMTUsXG4gICAgICAgICAgICBcImFuY2hvclwiICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsMSk7IH0sXG4gICAgICAgICAgICBcImJhc2VcIiAgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsMSk7IH0sXG4gICAgICAgICAgICBcInBvc2l0aW9uXCIgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsMCk7IH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJob3Jpem9udGFsYXhpc1wiOiB7XG4gICAgICAgICAgICBcInRpdGxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNvbnRlbnRcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImZvbnRuYW1lXCI6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImZvbnRzaXplXCI6IFwiMTJcIixcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJmb250Y29sb3JcIjogXCIweDAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwiYW5jaG9yXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcImJhc2VcIiA6IDAsXG4gICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICAgICAgICBcInBvc2l0aW9uLWhvcml6b250YWwtdG9wXCIgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwgMTUpOyB9LFxuICAgICAgICAgICAgICAgIFwicG9zaXRpb24taG9yaXpvbnRhbC1ib3R0b21cIiA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgwLCAtMTgpOyB9LFxuICAgICAgICAgICAgICAgIFwicG9zaXRpb24tdmVydGljYWwtcmlnaHRcIiAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgzMywgMCk7IH0sXG4gICAgICAgICAgICAgICAgXCJwb3NpdGlvbi12ZXJ0aWNhbC1sZWZ0XCIgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KC0yNSwgMCk7IH0sXG5cbiAgICAgICAgICAgICAgICBcImFuY2hvci1ob3Jpem9udGFsLXRvcFwiICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwgLTEpOyB9LFxuICAgICAgICAgICAgICAgIFwiYW5jaG9yLWhvcml6b250YWwtYm90dG9tXCIgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgwLCAxKTsgfSxcbiAgICAgICAgICAgICAgICBcImFuY2hvci12ZXJ0aWNhbC1yaWdodFwiICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoLTEsIDApOyB9LFxuICAgICAgICAgICAgICAgIFwiYW5jaG9yLXZlcnRpY2FsLWxlZnRcIiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgxLCAwKTsgfSxcblxuICAgICAgICAgICAgICAgIFwiYW5nbGVcIjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibGFiZWxzXCI6IHtcbiAgICAgICAgICAgICAgICBcImxhYmVsXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJmb3JtYXRcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGUgTGFiZWxlciBvYmplY3QncyBkZWZhdWx0IHZhbHVlcyBmb3IgcG9zaXRpb24gYW5kIGFuY2hvciBzaG91bGQgYmUgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBJZiB0aG9zZSBhdHRyaWJ1dGVzIGFyZSBub3Qgc3BlY2lmaWVkIGluIHRoZSBNVUdMLCB0aGUgTGFiZWxlcidzXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGluaXRpYWxpemVHZW9tZXRyeSgpIG1ldGhvZCBzZXRzIHRoZW0gdG8gb25lIG9mIHRoZSBjb250ZXh0LWRlcGVuZGVudCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcImFuY2hvclwiOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICAgICAgICAgICAgXCJwb3NpdGlvbi1ob3Jpem9udGFsLXRvcFwiICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsIDUpOyB9LFxuICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uLWhvcml6b250YWwtYm90dG9tXCIgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwgLTUpOyB9LFxuICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uLXZlcnRpY2FsLXJpZ2h0XCIgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoNSwgMCk7IH0sXG4gICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb24tdmVydGljYWwtbGVmdFwiICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgtOCwgMCk7IH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJhbmNob3ItaG9yaXpvbnRhbC10b3BcIiAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsIC0xKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhbmNob3ItaG9yaXpvbnRhbC1ib3R0b21cIiAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsIDEpOyB9LFxuICAgICAgICAgICAgICAgICAgICBcImFuY2hvci12ZXJ0aWNhbC1yaWdodFwiICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoLTEsIDApOyB9LFxuICAgICAgICAgICAgICAgICAgICBcImFuY2hvci12ZXJ0aWNhbC1sZWZ0XCIgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMSwgMCk7IH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJhbmdsZVwiOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIFwic3BhY2luZ1wiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZGVuc2l0eWZhY3RvclwiOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIiA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBSR0JDb2xvci5wYXJzZShcIjB4MDAwMDAwXCIpOyB9LFxuICAgICAgICAgICAgICAgICAgICBcInZpc2libGVcIiA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBcImZvbnRuYW1lXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBcImZvbnRzaXplXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBcImZvbnRjb2xvclwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImZvbnRuYW1lXCI6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImZvbnRzaXplXCI6IFwiMTJcIixcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJmb250Y29sb3JcIjogXCIweDAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImZvcm1hdFwiOiBcIiUxZFwiLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcInZpc2libGVcIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICAgICAgXCJzdGFydC1udW1iZXJcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE51bWJlclZhbHVlKDApOyB9LFxuICAgICAgICAgICAgICAgIFwic3RhcnQtZGF0ZXRpbWVcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERhdGV0aW1lVmFsdWUoMCk7IH0sXG4gICAgICAgICAgICAgICAgXCJhbmdsZVwiOiAwLjAsXG4gICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwwKTsgfSxcbiAgICAgICAgICAgICAgICBcImFuY2hvclwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwwKTsgfSxcbiAgICAgICAgICAgICAgICBcImNvbG9yXCIgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUkdCQ29sb3IucGFyc2UoXCIweDAwMDAwMFwiKTsgfSxcbiAgICAgICAgICAgICAgICBcInZpc2libGVcIiA6IHRydWUsXG4gICAgICAgICAgICAgICAgLy9cImRlZmF1bHROdW1iZXJTcGFjaW5nXCI6IFwiMTAwMDAgNTAwMCAyMDAwIDEwMDAgNTAwIDIwMCAxMDAgNTAgMjAgMTAgNSAyIDEgMC4xIDAuMDEgMC4wMDFcIixcbiAgICAgICAgICAgICAgICAvL1wiZGVmYXVsdERhdGV0aW1lU3BhY2luZ1wiOiBcIjEwMDBZIDUwMFkgMjAwWSAxMDBZIDUwWSAyMFkgMTBZIDVZIDJZIDFZIDZNIDNNIDJNIDFNIDdEIDNEIDJEIDFEIDEySCA2SCAzSCAySCAxSFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdE51bWJlclNwYWNpbmdcIjogWzEwMDAwLCA1MDAwLCAyMDAwLCAxMDAwLCA1MDAsIDIwMCwgMTAwLCA1MCwgMjAsIDEwLCA1LCAyLCAxLCAwLjEsIDAuMDEsIDAuMDAxXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHREYXRldGltZVNwYWNpbmdcIjogW1wiMTAwMFlcIiwgXCI1MDBZXCIsIFwiMjAwWVwiLCBcIjEwMFlcIiwgXCI1MFlcIiwgXCIyMFlcIiwgXCIxMFlcIiwgXCI1WVwiLCBcIjJZXCIsIFwiMVlcIiwgXCI2TVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiM01cIiwgXCIyTVwiLCBcIjFNXCIsIFwiN0RcIiwgXCIzRFwiLCBcIjJEXCIsIFwiMURcIiwgXCIxMkhcIiwgXCI2SFwiLCBcIjNIXCIsIFwiMkhcIiwgXCIxSFwiXSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcImRlbnNpdHlmYWN0b3JcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJncmlkXCI6IHtcbiAgICAgICAgICAgICAgICBcImNvbG9yXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBSR0JDb2xvci5wYXJzZShcIjB4ZWVlZWVlXCIpOyB9LFxuICAgICAgICAgICAgICAgIFwidmlzaWJsZVwiOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGFuXCI6IHtcbiAgICAgICAgICAgICAgICBcImFsbG93ZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1pblwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwibWF4XCI6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInpvb21cIjoge1xuICAgICAgICAgICAgICAgIFwiYWxsb3dlZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWluXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcIm1heFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJhbmNob3JcIjogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYmluZGluZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJtaW5cIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwibWF4XCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaWRcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBcImxlbmd0aFwiOiAxLjAsXG4gICAgICAgICAgICBcImxlbmd0aFwiIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERpc3BsYWNlbWVudCgxLDApOyB9LFxuICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwwKTsgfSxcbiAgICAgICAgICAgIFwicHJlZ2FwXCI6IDAsXG4gICAgICAgICAgICBcInBvc3RnYXBcIjogMCxcbiAgICAgICAgICAgIFwiYW5jaG9yXCI6IC0xLFxuICAgICAgICAgICAgXCJiYXNlXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgtMSwtMSk7IH0sXG4gICAgICAgICAgICBcIm1pblwiOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwibWlub2Zmc2V0XCI6IDAsXG4gICAgICAgICAgICAvL1wibWlucG9zaXRpb25cIjogLTEsXG4gICAgICAgICAgICBcIm1pbnBvc2l0aW9uXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEaXNwbGFjZW1lbnQoLTEsMCk7IH0sXG4gICAgICAgICAgICBcIm1heFwiOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwibWF4b2Zmc2V0XCI6IDAsXG4gICAgICAgICAgICAvL1wibWF4cG9zaXRpb25cIjogMSxcbiAgICAgICAgICAgIFwibWF4cG9zaXRpb25cIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERpc3BsYWNlbWVudCgxLDApOyB9LFxuICAgICAgICAgICAgXCJwb3NpdGlvbmJhc2VcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgXCJjb2xvclwiOiBcIjB4MDAwMDAwXCIsXG4gICAgICAgICAgICBcImNvbG9yXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBSR0JDb2xvcigwLDAsMCk7IH0sXG4gICAgICAgICAgICBcInRpY2ttaW5cIjogLTMsXG4gICAgICAgICAgICBcInRpY2ttYXhcIjogMyxcbiAgICAgICAgICAgIFwidGlja2NvbG9yXCI6IG51bGwsXG4gICAgICAgICAgICBcImhpZ2hsaWdodHN0eWxlXCI6IFwiYXhpc1wiLFxuICAgICAgICAgICAgXCJsaW5ld2lkdGhcIjogMSxcbiAgICAgICAgICAgIFwib3JpZW50YXRpb25cIjogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIFwidmVydGljYWxheGlzXCI6IHtcbiAgICAgICAgICAgIFwidGl0bGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY29udGVudFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwiZm9udG5hbWVcIjogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwiZm9udHNpemVcIjogXCIxMlwiLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImZvbnRjb2xvclwiOiBcIjB4MDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgXCJhbmNob3JcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsLTIwKTsgfSxcbiAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgwLDEpOyB9LFxuICAgICAgICAgICAgICAgIFwiYW5nbGVcIjogXCIwXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImxhYmVsc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJsYWJlbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiZm9ybWF0XCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgXCJzdGFydFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYW5nbGVcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhbmNob3JcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcInNwYWNpbmdcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcImRlbnNpdHlmYWN0b3JcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250bmFtZVwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250c2l6ZVwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250Y29sb3JcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJmb250bmFtZVwiOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJmb250c2l6ZVwiOiBcIjEyXCIsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwiZm9udGNvbG9yXCI6IFwiMHgwMDAwMDBcIixcbiAgICAgICAgICAgICAgICBcImZvcm1hdFwiOiBcIiUxZFwiLFxuICAgICAgICAgICAgICAgIFwidmlzaWJsZVwiOiBcInRydWVcIixcbiAgICAgICAgICAgICAgICBcInN0YXJ0XCI6IFwiMFwiLFxuICAgICAgICAgICAgICAgIFwiYW5nbGVcIjogXCIwLjBcIixcbiAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiMCAwXCIsXG4gICAgICAgICAgICAgICAgXCJhbmNob3JcIjogXCIwIDBcIixcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJzcGFjaW5nXCI6IFwiMTAwMDAgNTAwMCAyMDAwIDEwMDAgNTAwIDIwMCAxMDAgNTAgMjAgMTAgNSAyIDEgMC4xIDAuMDEgMC4wMDFcIixcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJkZWZhdWx0RGF0ZXRpbWVTcGFjaW5nXCI6IFwiMTAwMFkgNTAwWSAyMDBZIDEwMFkgNTBZIDIwWSAxMFkgNVkgMlkgMVkgNk0gM00gMk0gMU0gN0QgM0QgMkQgMUQgMTJIIDZIIDNIIDJIIDFIXCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJkZW5zaXR5ZmFjdG9yXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ3JpZFwiOiB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogXCIweGVlZWVlZVwiLFxuICAgICAgICAgICAgICAgIFwidmlzaWJsZVwiOiBcImZhbHNlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBhblwiOiB7XG4gICAgICAgICAgICAgICAgXCJhbGxvd2VkXCI6IFwieWVzXCIsXG4gICAgICAgICAgICAgICAgXCJtaW5cIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwibWF4XCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiem9vbVwiOiB7XG4gICAgICAgICAgICAgICAgXCJhbGxvd2VkXCI6IFwieWVzXCIsXG4gICAgICAgICAgICAgICAgXCJtaW5cIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwibWF4XCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcImFuY2hvclwiOiBcIm5vbmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYmluZGluZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJtaW5cIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwibWF4XCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaWRcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBcImxlbmd0aFwiOiBcIjEuMFwiLFxuICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBcIjAgMFwiLFxuICAgICAgICAgICAgXCJwcmVnYXBcIjogXCIwXCIsXG4gICAgICAgICAgICBcInBvc3RnYXBcIjogXCIwXCIsXG4gICAgICAgICAgICBcImFuY2hvclwiOiBcIi0xXCIsXG4gICAgICAgICAgICBcImJhc2VcIjogXCItMSAxXCIsXG4gICAgICAgICAgICBcIm1pblwiOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwibWlub2Zmc2V0XCI6IFwiMFwiLFxuICAgICAgICAgICAgXCJtaW5wb3NpdGlvblwiOiBcIi0xXCIsXG4gICAgICAgICAgICBcIm1heFwiOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwibWF4b2Zmc2V0XCI6IFwiMFwiLFxuICAgICAgICAgICAgXCJtYXhwb3NpdGlvblwiOiBcIjFcIixcbiAgICAgICAgICAgIFwicG9zaXRpb25iYXNlXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIFwiY29sb3JcIjogXCIweDAwMDAwMFwiLFxuICAgICAgICAgICAgXCJ0aWNrbWluXCI6IFwiLTNcIixcbiAgICAgICAgICAgIFwidGlja21heFwiOiBcIjNcIixcbiAgICAgICAgICAgIFwiaGlnaGxpZ2h0c3R5bGVcIjogXCJheGlzXCIsXG4gICAgICAgICAgICBcImxpbmV3aWR0aFwiOiBcIjFcIixcbiAgICAgICAgICAgIFwib3JpZW50YXRpb25cIjogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIFwicGxvdFwiOiB7XG4gICAgICAgICAgICBcImxlZ2VuZFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ2aXNpYmxlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJsYWJlbFwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImhvcml6b250YWxheGlzXCI6IHtcbiAgICAgICAgICAgICAgICBcInZhcmlhYmxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJyZWZcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcImZhY3RvclwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY29uc3RhbnRcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJyZWZcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ2ZXJ0aWNhbGF4aXNcIjoge1xuICAgICAgICAgICAgICAgIFwidmFyaWFibGVcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInJlZlwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZmFjdG9yXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjb25zdGFudFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJlZlwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZpbHRlclwiOiB7XG4gICAgICAgICAgICAgICAgXCJvcHRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVuZGVyZXJcIjp7XG4gICAgICAgICAgICAgICAgXCJvcHRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgXCJtaW5cIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcIm1heFwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4uL2NvcmUvcmVuZGVyZXIuanMnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlbmRlcmVyLlR5cGUucGFyc2UoXCJsaW5lXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImRhdGF0aXBzXCI6e1xuICAgICAgICAgICAgICAgIFwidmFyaWFibGVcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImZvcm1hdFN0cmluZy1udW1iZXJcIiA6IFwiJS4yZlwiLFxuICAgICAgICAgICAgICAgICAgICBcImZvcm1hdFN0cmluZy1kYXRldGltZVwiIDogXCIlZCAlbiAlWVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmxlXCI6IFwiZmFsc2VcIixcbiAgICAgICAgICAgICAgICBcImZvcm1hdFN0cmluZ1wiOiBcInswfTogezF9XCIsXG4gICAgICAgICAgICAgICAgXCJiZ2NvbG9yXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJHQkNvbG9yLnBhcnNlKFwiMHhlZWVlZWVcIik7IH0sXG4gICAgICAgICAgICAgICAgXCJiZ2FscGhhXCI6IDEuMCxcbiAgICAgICAgICAgICAgICBcImJvcmRlclwiOiAxLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyY29sb3JcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gUkdCQ29sb3IucGFyc2UoXCIweDAwMDAwMFwiKTsgfSxcbiAgICAgICAgICAgICAgICBcInBhZFwiOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBcInRocm90dGxlXCI6IHtcbiAgICAgICAgICAgIFwicGF0dGVyblwiICAgIDogXCJcIixcbiAgICAgICAgICAgIFwicmVxdWVzdHNcIiAgIDogMCxcbiAgICAgICAgICAgIFwicGVyaW9kXCIgICAgIDogMCxcbiAgICAgICAgICAgIFwiY29uY3VycmVudFwiIDogMFxuICAgICAgICB9LFxuICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJ2YXJpYWJsZXNcIjoge1xuICAgICAgICAgICAgICAgIFwidmFyaWFibGVcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImlkXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgXCJjb2x1bW5cIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaXNzaW5ndmFsdWVcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcIm1pc3NpbmdvcFwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibWlzc2luZ3ZhbHVlXCI6IFwiLTkwMDBcIixcbiAgICAgICAgICAgICAgICBcIm1pc3NpbmdvcFwiOiBcImVxXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjb250ZW50XCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY3N2XCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2VydmljZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvblwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxpdHlGdW5jdGlvbnM7XG5cbiIsInZhciBWYWxpZGF0aW9uRnVuY3Rpb25zID0ge307XG5cblZhbGlkYXRpb25GdW5jdGlvbnMudmFsaWRhdGVOdW1iZXJSYW5nZSA9IGZ1bmN0aW9uIChudW1iZXIsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgICByZXR1cm4gdHlwZW9mKG51bWJlcikgPT09IFwibnVtYmVyXCIgJiYgbnVtYmVyID49IGxvd2VyQm91bmQgJiYgbnVtYmVyIDw9IHVwcGVyQm91bmQ7XG59O1xuXG4vLyBUaGlzIGZ1bmN0aW9uLCBmcm9tIGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vcmVtZWRpYWwuaHRtbCwgc2hvdWxkIGNvcnJlY3RseVxuLy8gcmV0dXJuICdhcnJheScgZm9yIGFueSBBcnJheSBvYmplY3QsIGluY2x1ZGluZyBbXS5cbi8vIFJldHVybnMgJ29iamVjdCcgZm9yIGFueSBKUyBvYmplY3QuXG5WYWxpZGF0aW9uRnVuY3Rpb25zLnR5cGVPZiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgLy9OT1RFOiBDcm9ja2ZvcmQgdXNlZCBcIj09XCIgICA/Pz8/PyEhISEhICBtYnAgRnJpIFNlcCAyOCAwODo0NDozNCAyMDEyXG4gICAgICAgICAgICAvL2lmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgcyA9ICdhcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gJ251bGwnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzO1xufTtcblxuVmFsaWRhdGlvbkZ1bmN0aW9ucy5pc051bWJlck5vdE5hTiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gKHR5cGVvZih4KSA9PT0gXCJudW1iZXJcIikgJiYgKHggPT09IHgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWYWxpZGF0aW9uRnVuY3Rpb25zO1xuIl19
