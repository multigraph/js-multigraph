(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * ajaxthrottle.js
 * 
 * Usage:
 * 
 *     var t = $.ajaxthrottle({
 *        numRequestsPerTimePeriod : N,
 *        timePeriod               : P,
 *        maxConcurrent            : M
 *     });
 *    
 *     t.ajax(args);
 *
 * This is just like calling $.ajax(args), except that requests are throttled
 * so that no more than N are initiated in any time period of P milliseconds,
 * and no more than M concurrent (outstanding at the same time) requests are allowed.
 * If N or P is 0, there is no time period based constraint, and if M is 0, there
 * is no constraint on the number of concurrent requests.
 * 
 * Mark Phillips <mphillip@unca.edu>
 * Thu Dec 20 11:04:19 2012
 */
(function($) {
    $.ajaxthrottle = function(options) {

        var timeout,

            settings = $.extend({
                numRequestsPerTimePeriod : 0,
                timePeriod               : 0,
                maxConcurrent            : 1
            }, options),

            time = function() {
                return (new Date()).getTime();
            },

            // Array of outstanding requests; these are requests that have
            // been initiated with a call to $.ajax() but that have not
            // completed yet.  Each entry in this array is an object of the form
            //    {
            //         arguments: the original arguments list passed to .ajax()
            //              time: the time this request was passed to $.ajax()
            //          deferred: the jQuery deferred object for this request
            //    }
            outstanding_reqs = [],

            // Array of initiated requests; each entry in this array
            // is an object just like the ones in the outstanding_reqs
            // array above, but this array keeps track of all
            // requests, regardless of whether they have completed.
            // This list is used to keep track of how many requests
            // have been initiated in settings.timePeriod.  Requests
            // that are older than settings.timePeriod milliseconds
            // get removed from this list when it is purged.
            initiated_reqs = [],

            // Array of requests waiting to be initiated
            waiting_reqs = [],

            // Purge the initiated reqs list so that it doesn't contain any
            // reqs from more than settings.timePeriod ms ago.  Return the
            // amount of time that needs to be waited until the oldest remaining
            // (after purging) req in the list will be settings.timePeriod ms old.
            // Do all of this relative to the passed in 'now' value.
            purge_initiated_reqs = function(now) {
                if (settings.timePeriod >= 0) {
                    while ((initiated_reqs.length > 0)
                           &&
                           (initiated_reqs[0].time + settings.timePeriod - now <= 0)) {
                        initiated_reqs.shift();
                    }
                    if (initiated_reqs.length > 0) {
                        return initiated_reqs[0].time + settings.timePeriod - now;
                    }
                }
                return 0;
            },

            // remove a req from the outstanding_reqs list
            remove_outstanding_req = function(obj) {
                $.each(outstanding_reqs, function(i) {
                    if (outstanding_reqs[i] === obj) {
                        outstanding_reqs.splice(i,1);
                        return false;
                    }
                    return true;
                });
            },

            // Initiate the next request on the waiting list, unless we need to wait
            // till some time has passed or some outstanding requests have completed.
            process_waiting = function() {
                var now = time(),
                    delay, req, deferred;

                if (waiting_reqs.length <= 0) {
                    return;
                }

                delay = purge_initiated_reqs(now);

                // If we have a timePeriod constraint, and the max number of allowed
                // requests have gone out in that time period, arrange to wait for
                // 'delay' ms
                if ((settings.numRequestsPerTimePeriod > 0) && (settings.timePeriod > 0)
                    &&
                    (delay > 0)
                    &&
                    (initiated_reqs.length >= settings.numRequestsPerTimePeriod)) {
                    // clear any existing timeout first, because this one will
                    // require waiting till after it would finish anyway
                    if (timeout !== undefined) {
                        clearTimeout(timeout);
                    }
                    timeout = setTimeout(function() {
                        timeout = undefined;
                        process_waiting();
                    }, delay);
                    return;
                }

                // If the max number of allowed requests is outstanding, do nothing;
                // process_waiting() will get called again when a request completes.
                if ((settings.maxConcurrent > 0)
                           &&
                           (outstanding_reqs.length >= settings.maxConcurrent)) {
                    return;
                }

                // If we make it to here, then it's OK to initiate the next
                // request in the waiting list
                req = waiting_reqs.shift();
                req.time = time();
                initiated_reqs.push(req);
                outstanding_reqs.push(req);
                $.ajax.apply($,req.arguments).done(function() {
                    req.deferred.resolve.apply(req.deferred, arguments);
                }).fail(function() {
                    req.deferred.reject.apply(req.deferred, arguments);
                }).always(function() {
                    remove_outstanding_req(req);
                    process_waiting();
                });
                
            }
        ;

        return {
            ajax : function() {
                var deferred = $.Deferred();
                waiting_reqs.push({ arguments : arguments, deferred : deferred });
                process_waiting();
                return deferred.promise();
            }
        };
    };
}(jQuery));

},{}],2:[function(require,module,exports){
(function ($) {
    "use strict";

    var methods = {
        on : function(on) {
            if (on === undefined) {
                return $(this).data('busy_spinner').on;
            } else {
                return this.each(function() {
                    if (on) {
                        $(this).data('busy_spinner').on    = true;
                        $(this).data('busy_spinner').level = 1;
                        $(this).show();
                    } else {
                        $(this).data('busy_spinner').on    = false;
                        $(this).data('busy_spinner').level = 0;
                        $(this).hide();
                    }
                    return this;
                });
            }            
        },

        level : function(delta) {
            if (delta === undefined) {
                return $(this).data('busy_spinner').level;
            } else {
                return this.each(function() {
                    if ($(this).data('busy_spinner').level + delta >= 0) {
                        $(this).data('busy_spinner').level = $(this).data('busy_spinner').level + delta;
                        if ($(this).data('busy_spinner').level === 1) {
                            $(this).busy_spinner('on', true);
                        } else if ($(this).data('busy_spinner').level === 0) {
                            $(this).busy_spinner('on', false);
                        }
                    }
                    return this;
                });
            }
        },

        init : function(options) {
            return this.each(function() {
                var $this = $(this),
                    data = $this.data('busy_spinner'),
                    settings = $.extend({
                        on : false
                    }, options);
                if ( ! data ) {
                    $this.data('busy_spinner', {
                        on    : settings.on,
                        level : 0
                    });
                    if (settings.on) {
                        $(this).show();
                    } else {
                        $(this).hide();
                    }
                    $(this).css({
                        width  : 32,
                        height : 32
                    }).append($('<img src="data:image/gif;base64,R0lGODlhIAAgAPMAAP///wAAAMbGxoSEhLa2tpqamjY2NlZWVtjY2OTk5Ly8vB4eHgQEBAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAAACwAAAAAIAAgAAAE5xDISWlhperN52JLhSSdRgwVo1ICQZRUsiwHpTJT4iowNS8vyW2icCF6k8HMMBkCEDskxTBDAZwuAkkqIfxIQyhBQBFvAQSDITM5VDW6XNE4KagNh6Bgwe60smQUB3d4Rz1ZBApnFASDd0hihh12BkE9kjAJVlycXIg7CQIFA6SlnJ87paqbSKiKoqusnbMdmDC2tXQlkUhziYtyWTxIfy6BE8WJt5YJvpJivxNaGmLHT0VnOgSYf0dZXS7APdpB309RnHOG5gDqXGLDaC457D1zZ/V/nmOM82XiHRLYKhKP1oZmADdEAAAh+QQJCgAAACwAAAAAIAAgAAAE6hDISWlZpOrNp1lGNRSdRpDUolIGw5RUYhhHukqFu8DsrEyqnWThGvAmhVlteBvojpTDDBUEIFwMFBRAmBkSgOrBFZogCASwBDEY/CZSg7GSE0gSCjQBMVG023xWBhklAnoEdhQEfyNqMIcKjhRsjEdnezB+A4k8gTwJhFuiW4dokXiloUepBAp5qaKpp6+Ho7aWW54wl7obvEe0kRuoplCGepwSx2jJvqHEmGt6whJpGpfJCHmOoNHKaHx61WiSR92E4lbFoq+B6QDtuetcaBPnW6+O7wDHpIiK9SaVK5GgV543tzjgGcghAgAh+QQJCgAAACwAAAAAIAAgAAAE7hDISSkxpOrN5zFHNWRdhSiVoVLHspRUMoyUakyEe8PTPCATW9A14E0UvuAKMNAZKYUZCiBMuBakSQKG8G2FzUWox2AUtAQFcBKlVQoLgQReZhQlCIJesQXI5B0CBnUMOxMCenoCfTCEWBsJColTMANldx15BGs8B5wlCZ9Po6OJkwmRpnqkqnuSrayqfKmqpLajoiW5HJq7FL1Gr2mMMcKUMIiJgIemy7xZtJsTmsM4xHiKv5KMCXqfyUCJEonXPN2rAOIAmsfB3uPoAK++G+w48edZPK+M6hLJpQg484enXIdQFSS1u6UhksENEQAAIfkECQoAAAAsAAAAACAAIAAABOcQyEmpGKLqzWcZRVUQnZYg1aBSh2GUVEIQ2aQOE+G+cD4ntpWkZQj1JIiZIogDFFyHI0UxQwFugMSOFIPJftfVAEoZLBbcLEFhlQiqGp1Vd140AUklUN3eCA51C1EWMzMCezCBBmkxVIVHBWd3HHl9JQOIJSdSnJ0TDKChCwUJjoWMPaGqDKannasMo6WnM562R5YluZRwur0wpgqZE7NKUm+FNRPIhjBJxKZteWuIBMN4zRMIVIhffcgojwCF117i4nlLnY5ztRLsnOk+aV+oJY7V7m76PdkS4trKcdg0Zc0tTcKkRAAAIfkECQoAAAAsAAAAACAAIAAABO4QyEkpKqjqzScpRaVkXZWQEximw1BSCUEIlDohrft6cpKCk5xid5MNJTaAIkekKGQkWyKHkvhKsR7ARmitkAYDYRIbUQRQjWBwJRzChi9CRlBcY1UN4g0/VNB0AlcvcAYHRyZPdEQFYV8ccwR5HWxEJ02YmRMLnJ1xCYp0Y5idpQuhopmmC2KgojKasUQDk5BNAwwMOh2RtRq5uQuPZKGIJQIGwAwGf6I0JXMpC8C7kXWDBINFMxS4DKMAWVWAGYsAdNqW5uaRxkSKJOZKaU3tPOBZ4DuK2LATgJhkPJMgTwKCdFjyPHEnKxFCDhEAACH5BAkKAAAALAAAAAAgACAAAATzEMhJaVKp6s2nIkolIJ2WkBShpkVRWqqQrhLSEu9MZJKK9y1ZrqYK9WiClmvoUaF8gIQSNeF1Er4MNFn4SRSDARWroAIETg1iVwuHjYB1kYc1mwruwXKC9gmsJXliGxc+XiUCby9ydh1sOSdMkpMTBpaXBzsfhoc5l58Gm5yToAaZhaOUqjkDgCWNHAULCwOLaTmzswadEqggQwgHuQsHIoZCHQMMQgQGubVEcxOPFAcMDAYUA85eWARmfSRQCdcMe0zeP1AAygwLlJtPNAAL19DARdPzBOWSm1brJBi45soRAWQAAkrQIykShQ9wVhHCwCQCACH5BAkKAAAALAAAAAAgACAAAATrEMhJaVKp6s2nIkqFZF2VIBWhUsJaTokqUCoBq+E71SRQeyqUToLA7VxF0JDyIQh/MVVPMt1ECZlfcjZJ9mIKoaTl1MRIl5o4CUKXOwmyrCInCKqcWtvadL2SYhyASyNDJ0uIiRMDjI0Fd30/iI2UA5GSS5UDj2l6NoqgOgN4gksEBgYFf0FDqKgHnyZ9OX8HrgYHdHpcHQULXAS2qKpENRg7eAMLC7kTBaixUYFkKAzWAAnLC7FLVxLWDBLKCwaKTULgEwbLA4hJtOkSBNqITT3xEgfLpBtzE/jiuL04RGEBgwWhShRgQExHBAAh+QQJCgAAACwAAAAAIAAgAAAE7xDISWlSqerNpyJKhWRdlSAVoVLCWk6JKlAqAavhO9UkUHsqlE6CwO1cRdCQ8iEIfzFVTzLdRAmZX3I2SfZiCqGk5dTESJeaOAlClzsJsqwiJwiqnFrb2nS9kmIcgEsjQydLiIlHehhpejaIjzh9eomSjZR+ipslWIRLAgMDOR2DOqKogTB9pCUJBagDBXR6XB0EBkIIsaRsGGMMAxoDBgYHTKJiUYEGDAzHC9EACcUGkIgFzgwZ0QsSBcXHiQvOwgDdEwfFs0sDzt4S6BK4xYjkDOzn0unFeBzOBijIm1Dgmg5YFQwsCMjp1oJ8LyIAACH5BAkKAAAALAAAAAAgACAAAATwEMhJaVKp6s2nIkqFZF2VIBWhUsJaTokqUCoBq+E71SRQeyqUToLA7VxF0JDyIQh/MVVPMt1ECZlfcjZJ9mIKoaTl1MRIl5o4CUKXOwmyrCInCKqcWtvadL2SYhyASyNDJ0uIiUd6GGl6NoiPOH16iZKNlH6KmyWFOggHhEEvAwwMA0N9GBsEC6amhnVcEwavDAazGwIDaH1ipaYLBUTCGgQDA8NdHz0FpqgTBwsLqAbWAAnIA4FWKdMLGdYGEgraigbT0OITBcg5QwPT4xLrROZL6AuQAPUS7bxLpoWidY0JtxLHKhwwMJBTHgPKdEQAACH5BAkKAAAALAAAAAAgACAAAATrEMhJaVKp6s2nIkqFZF2VIBWhUsJaTokqUCoBq+E71SRQeyqUToLA7VxF0JDyIQh/MVVPMt1ECZlfcjZJ9mIKoaTl1MRIl5o4CUKXOwmyrCInCKqcWtvadL2SYhyASyNDJ0uIiUd6GAULDJCRiXo1CpGXDJOUjY+Yip9DhToJA4RBLwMLCwVDfRgbBAaqqoZ1XBMHswsHtxtFaH1iqaoGNgAIxRpbFAgfPQSqpbgGBqUD1wBXeCYp1AYZ19JJOYgH1KwA4UBvQwXUBxPqVD9L3sbp2BNk2xvvFPJd+MFCN6HAAIKgNggY0KtEBAAh+QQJCgAAACwAAAAAIAAgAAAE6BDISWlSqerNpyJKhWRdlSAVoVLCWk6JKlAqAavhO9UkUHsqlE6CwO1cRdCQ8iEIfzFVTzLdRAmZX3I2SfYIDMaAFdTESJeaEDAIMxYFqrOUaNW4E4ObYcCXaiBVEgULe0NJaxxtYksjh2NLkZISgDgJhHthkpU4mW6blRiYmZOlh4JWkDqILwUGBnE6TYEbCgevr0N1gH4At7gHiRpFaLNrrq8HNgAJA70AWxQIH1+vsYMDAzZQPC9VCNkDWUhGkuE5PxJNwiUK4UfLzOlD4WvzAHaoG9nxPi5d+jYUqfAhhykOFwJWiAAAIfkECQoAAAAsAAAAACAAIAAABPAQyElpUqnqzaciSoVkXVUMFaFSwlpOCcMYlErAavhOMnNLNo8KsZsMZItJEIDIFSkLGQoQTNhIsFehRww2CQLKF0tYGKYSg+ygsZIuNqJksKgbfgIGepNo2cIUB3V1B3IvNiBYNQaDSTtfhhx0CwVPI0UJe0+bm4g5VgcGoqOcnjmjqDSdnhgEoamcsZuXO1aWQy8KAwOAuTYYGwi7w5h+Kr0SJ8MFihpNbx+4Erq7BYBuzsdiH1jCAzoSfl0rVirNbRXlBBlLX+BP0XJLAPGzTkAuAOqb0WT5AH7OcdCm5B8TgRwSRKIHQtaLCwg1RAAAOwAAAAAAAAAAAA==" width="32" height="32" alt="ajax loading">'));
                }

                return this;
            });
        }
    };

    $.fn.busy_spinner = function( method ) {
        if ( methods[method] ) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.busy_spinner' );
            return null;
        }    
    };
    
}(jQuery));

},{}],3:[function(require,module,exports){
(function ($) {
    "use strict";

    var errorDisplayHtml = (
        ''
            + '<div class="errorDisplay">'
            +   '<span class="errorDisplayOptions">'
            +     '<button class="errorDisplayDetailsButton">See Details</button>'
            +     '<a href="" class="errorDisplayXButton">&#10006;</a>'
            +   '</span>'
            +   '<span class="errorDisplayShortMessage"></span>'
            + '</div>'
            + '<span class="errorDisplayRetriever"></span>'
    );
    
    var detailDisplayHtml = (
        ''
            + '<div class="errorDisplayDetails">'
            +   '<span class="errorDisplayOptions">'
            +     '<a href="" class="errorDisplayXButton">&#10006;</a>'
            +   '</span>'
            +   '<span class="errorDisplayFullMessageArea"></span>'
            + '</div>'
    );
    
    var detailDisplayListHtml = (
        ''
            + '<ul class="errorDisplayFullMessageList">'
            + '</ul>'
    );
    
    var methods = {
        init : function(options) {
            return this.each(function() {
                var $this = $(this),
                    data = $this.data('errorDisplay'),
                    settings = $.extend({
                        'fontColor' : '#ff0000',
                        'backgroundColor' : '#ffffff',
                        'displayTime' : 1000,
                        'indicatorColor' : '#ff0000'
                    }, options);
                
                if ( ! data ) {
                    
                    $this.append(errorDisplayHtml);
                    $this.find('.errorDisplay').width($this.width()-6);  
                    
                    var detailDisplay = $(detailDisplayHtml).appendTo($("body"));
                    var detailDisplayList = $(detailDisplayListHtml);
                    
                    $(detailDisplay).find('.errorDisplayXButton').click(function(event) {
                        event.preventDefault();
                        $(detailDisplay).find('.errorDisplayOptions').hide();   
                        $(detailDisplay).hide();
                        $this.find('.errorDisplayRetriever').css('background-color', settings.indicatorColor).show();
                    });         
                    
                    $this.data('errorDisplay', {
                        'detailDisplay' : detailDisplay,
                        'detailDisplayList' : detailDisplayList,
                        'fontColor' : settings.fontColor,
                        'backgroundColor' : settings.backgroundColor,
                        'displayTime' : settings.displayTime,
                        'indicatorColor' : settings.indicatorColor
                    });
                    
                    
                    $this.find('.errorDisplayXButton').click(function(event) {
                        event.preventDefault(); 
                        $this.find('.errorDisplayOptions').hide();
                        $this.find('.errorDisplay').slideUp(settings.displayTime, function(){
                            $this.find('.errorDisplayRetriever').show();
                        });
                    });         
                    
                    
                    $this.find('.errorDisplayDetailsButton').click(function(event) {
                        event.preventDefault(); 
                        $this.find('.errorDisplay').off(); //stops mouseleaveevent when details button is clicked
                        $this.find('.errorDisplay').hide();                 
                        $this.find('.errorDisplayRetriever').hide();
                        $(detailDisplay).find('.errorDisplayFullMessageArea').empty().append($(detailDisplayList));
                        $(detailDisplay).find('.errorDisplayOptions').show();
                        $(detailDisplay).show();                     
                    });
                    
                }
                return this;
            });
        }, // init() method
        
        displayError : function(fullMessage, shortMessage, options) {
            return this.each(function() {
                var $this = $(this),
                    data = $this.data('errorDisplay'),
                    settings = $.extend({
                        'fontColor' : data.fontColor,
                        'backgroundColor' : data.backgroundColor,
                        'displayTime' : data.displayTime,
                        'indicatorColor' : data.indicatorColor
                    }, options);
                $this.find('.errorDisplayRetriever').hide();
                $this.find('.errorDisplayOptions').hide();
                $this.find('.errorDisplayShortMessage').css('color', settings.fontColor);   
                $this.find('.errorDisplay').css('background-color', settings.backgroundColor);
                  $this.find('.errorDisplayOptions').css('background-color', settings.backgroundColor);           
                  $this.find('.errorDisplayShortMessage').text(shortMessage);
                  $this.find('.errorDisplay').show();
                  $this.find('.errorDisplayRetriever').css('background-color', settings.indicatorColor);
                  
               if(settings.displayTime != -1){   
                  $this.find('.errorDisplay').slideUp(settings.displayTime, function(){
                      $this.find('.errorDisplayRetriever').show();
                  });                              
              }
                
               else{                   
                   $this.find('.errorDisplayOptions').show();
                   $this.find('.errorDisplay').show();
                 }
                
                $(data.detailDisplayList).append($('<li>'+fullMessage+'</li>').css('color', settings.fontColor));
                
                $this.find('.errorDisplayRetriever').hover(function(event) {
                    event.preventDefault();                 
                    $this.find('.errorDisplayOptions').hide();
                    $this.find('.errorDisplayShortMessage').text(shortMessage).css('color', settings.fontColor);                        
                    $this.find('.errorDisplay').slideDown(function(){
                      $this.find('.errorDisplayOptions').show();
                      $this.find('.errorDisplay').mouseleave(function(event){
                        event.preventDefault(); 
                        $this.find('.errorDisplayOptions').hide();
                        $this.find('.errorDisplay').slideUp(settings.displayTime, function(){
                            $this.find('.errorDisplayRetriever').show();
                        });                     
                      });     
                    });                   
                    $this.find('.errorDisplayRetriever').hide();
                });
            });

        } // displayError() method


    };

    $.fn.errorDisplay = function( method ) {
        if ( methods[method] ) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.errorDisplay' );
            return null;
        }    
    };

}(jQuery));
jQuery('head').append(jQuery('<style type="text/css">.errorDisplay { font-family: Helvetica, sans-serif; color: #32446B; background-color: white; text-align: left; font-size: 12px; line-height: 12px; height: 45px; position: absolute; bottom: 0px; left: 0px; width: inherit; width: expression(this.parentNode.currentStyle[\'width\']); border: solid; border-color: #A9BADE; border-style: ridge; display: none; } .errorDisplayRetriever{ height: 8px; background-color: #ff0000; border-top-right-radius: 10px; width: 8px; position: absolute; bottom: 0px; left: 0px; display: none; } .errorDisplayShortMessage{ overflow-x: hidden; overflow-y: hidden; white-space: nowrap; position: absolute; bottom: 0px; left: 0px; width: 95%; margin-top: 20px; margin-left: 10px; margin-bottom: 5px; } .errorDisplayXButton { text-decoration: none; font-size: 15px; margin-top: 2px; position: absolute; right: 3px; top: 0px; color: #4D68A3; } .errorDisplayDetailsButton { margin-left: 10px; margin-right: 10px; position: relative; } .errorDisplayDetails{ position: fixed; top: 25%; height: 100px; width: 75%; text-align: left; border: solid; border-color: #A9BADE; border-style: ridge; background-color: white; display: none; } .errorDisplayFullMessageArea { font-family: Helvetica, sans-serif; font-size: .833em; color: #32446B; height: 80px; width: inherit; width: expression(this.parentNode.currentStyle[\'width\']); position: fixed; margin-top: 15px; } .errorDisplayFullMessageList { overflow: auto; white-space: nowrap; height: 80px; margin-top: 5px; } .errorDisplayOptions{ background-color: #FFFFFF; display: inline; } </style>'));

},{}],4:[function(require,module,exports){
/**
 * Attr
 * 
 * Creates an encapsulated, chainable attribute that are validated by 
 * user-specified validation functions and can be attached to an arbitrary
 * JavaScript object. They can also call user-specified listeners upon being
 * accessed or changed.
 *
 * Jermaine models hold and manipulate Attr (and AttrList) objects until they
 * are attached to an object.
 */

/*!
 *
 * Notes and ToDos:
 * + what about isNotGreaterThan()?, isNotLessThan()?  Or, better still: a
 *   general 'not' operator, as in jasmine?
 *
 * + Attr should be decoupled from AttrList, see the clone() method
 *
 * + See issue 24 on github
 */
"use strict";
 
var Attr = function (name) {
    var AttrList = require('./attr_list.js'),
        Validator = require('./validator.js');

    var validators = [],
        that = this,
        errorMessage = "invalid setter call for " + name,
        defaultValueOrFunction,
        i,
        prop,
        addValidator,
        immutable = false,
        validator,
        listeners = {};

    // check for errors with constructor parameters
    if (name === undefined || typeof(name) !== 'string') {
        throw new Error("Attr: constructor requires a name parameter " +
                        "which must be a string");
    }

    // set up the validator that combines all validators
    validator = function (thingBeingValidated) {
        for (i = 0; i < validators.length; ++i) {
            validators[i](thingBeingValidated);
        }
        return true;
    };


    ////////////////////////////////////////////////////////////////////////
    /////////////////////////// MODIFIERS //////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    /**
     * Validate this attribute with the given validator. This also allows
     * this.message to be overridden to specify the error message on
     * validation failure.
     *
     * Examples:
     *
     *     age.validatesWith(function (age) {
     *         this.message = "age must be between 18 and 99, " + age +
     *                        " fails.";
     *         return age >= 18 && age <= 99;
     *     });
     *
     *     name.validatesWith(function (name) {
     *         this.message = "name must be a string and contain at least" +
     *                        " 3 letters, " + name + " fails.";
     *         return typeof(name) === "string && name.length >= 3;
     *     });
     *
     *
     * @param {Function} returns true if the argument passes validation 
     */
    this.validatesWith = function (v) {
        if (typeof(v) === 'function') {
            validators.push(new Validator(v));
            return this;
        } else {
            throw new Error("Attr: validator must be a function");
        }
    };

    /**
     * Assign a default value to all attributes of this type. The default
     * value may be an explicit value or object, or it may be a function
     * that returns a default value.
     *
     * Examples:
     *
     * @param {value} the explicit default value, or a function that
     *                returns the default value
     */
    this.defaultsTo = function (value) {
        defaultValueOrFunction = value;
        return this;
    };

    /**
     * Make this attribute read-only. If a setter is called on this
     * attribute, it will throw an error
     *
     * Examples:
     */
    this.isReadOnly = function () {
        immutable = true;
        return this;
    };

    /**
     * Make this attribute writable. Note that this is the default for all 
     * attributes, but this may be called if an attribute has been set to
     * read only and then needs to be changed back
     *
     * Examples:
     */
    this.isWritable = function () {
        immutable = false;
        return this;
    };

    /**
     * Sets up a listener for 'sets' or 'gets' to this attribute. It throws
     * an error if the event is not "set" or "get", and if a setter is
     * already set up for the event, it overrides it.
     *
     * Examples:
     *
     * @param {event} String that can only be "set" or "get"
     * @param {listener} Function that is called when the event occurs
     */
    this.on = function (event, listener) {
        if (event !== "set" && event !== "get") {
            throw new Error("Attr: first argument to the 'on' method " +
                            "should be 'set' or 'get'");
        } else if (typeof(listener) !== "function") {
            throw new Error("Attr: second argument to the 'on' method " +
                            "should be a function");
        } else {
            listeners[event] = listener;
        }
    };

    ////////////////////////////////////////////////////////////////////////
    /////////////////////////// END MODIFIERS //////////////////////////////
    ////////////////////////////////////////////////////////////////////////



    ////////////////////////////////////////////////////////////////////////
    /////////////////////// GETTERS ////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    /**
     * Returns the name of this attribute
     */
    this.name = function () {
        return name;
    };

    /**
     * Returns a function that combines all of the validators into
     * a single function that returns true or false.
     */
    this.validator = function () {
        return validator;
    };

    ////////////////////////////////////////////////////////////////////////
    /////////////////////// END GETTERS ////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////



    ////////////////////////////////////////////////////////////////////////
    /////////////////////// SYNTACTIC SUGAR ////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    /**
     * An alias for this object, for readability when calling multiple
     * modifiers
     *
     * Examples:
     */
    this.and = this;

    /**
     * An alias for this object, for readability.
     *
     * Examples:
     */
    this.which = this;

    /**
     * An alias for isReadOnly
     */
    this.isImmutable = this.isReadOnly;

    /**
     * An alias for isWritable
     */
    this.isMutable = this.isWritable;

    ////////////////////////////////////////////////////////////////////////
    /////////////////////// END SYNTACTIC SUGAR ////////////////////////////
    ////////////////////////////////////////////////////////////////////////



    ////////////////////////////////////////////////////////////////////////
    /////////////////////// UTILITIES //////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    /**
     * Returns an attribute with the same modifiers, defaultValue, and
     * validators. This is used in Jermaine's approach to inheritance.
     *
     * Examples:
     */
    this.clone = function () {
        var result,
            i;

        // set the result to the default attribute or attribute list
        // TODO: figure out how to make this work without explicitly
        //       knowing about AttrList so it can be decoupled from this
        //       code
        result = this instanceof AttrList?new AttrList(name):new Attr(name);

        // add this attributes validators to the new attribute
        for (i = 0; i < validators.length; ++i) {
            result.validatesWith(validators[i]);
        }

        // set up the same default for the new attribute
        result.defaultsTo(defaultValueOrFunction);

        // if the this attr is immutable, the cloned attr should also be
        // immutable
        if (immutable) {
            result.isImmutable();
        }

        return result;
    };

    /**
     * This attaches the attribute to a concrete object. It adds the
     * getter/setter function to the object, and captures the actual
     * value of the attribute in a closure.
     *
     * The resulting getter/setter calls all validators on the parameter
     * and calls the appropriate listener on this attribute. It also
     * returns the object itself so that attribute setters can be chained.
     *
     * Examples:
     *
     * @param {obj} the object to which this attribute will be attached
     */
    this.addTo = function (obj) {
        var attribute,
            listener,
            defaultValue;

        if (!obj || typeof(obj) !== 'object') {
            throw new Error("Attr: addAttr method requires an object " +
                            "parameter");
        }

        // This is the attribute getter/setter method that gets addded to
        // the object
        obj[name] = function (newValue) {
            var preValue;

            if (newValue !== undefined) {
                // setter
                if (immutable && attribute !== undefined) {
                    throw new Error("cannot set the immutable property " +
                                    name + " after it has been set");
                } else if (!validator(newValue)) {
                    throw new Error(errorMessage);
                } else {
                    // get the oldValue
                    preValue = attribute;

                    // first set the value
                    attribute = newValue;

                    // call the set listener
                    if (listeners.set !== undefined) {
                        listeners.set.call(obj, newValue, preValue);
                    }
                }
                return obj;
            } else {
                // call the get listener
                if (listeners.get !== undefined) {
                    listeners.get.call(obj, attribute);
                }
                return attribute;
            }
        };


        // assign the default value, depends on whether it is a function
        // or an explicit value
        defaultValue = typeof(defaultValueOrFunction) === 'function'?
            defaultValueOrFunction():
            defaultValueOrFunction;

        // call the setter with the defaultValue upon attaching it to the
        // object
        if (defaultValue !== undefined && validator(defaultValue)) {
            obj[name](defaultValue);
        } else if (defaultValue !== undefined && !validator(defaultValue)) {
            throw new Error("Attr: Default value of " + defaultValue +
                            " does not pass validation for " + name);
        }
    };

    ////////////////////////////////////////////////////////////////////////
    /////////////////////// END UTILITIES //////////////////////////////////
    ////////////////////////////////////////////////////////////////////////



    ////////////////////////////////////////////////////////////////////////
    /////////////////////// VALIDATOR RELATED //////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    // add a single validator object to the attribute
    addValidator = function (name) {
        that[name] = function (param) {
            validators.push(Validator.getValidator(name)(param));
            return that;
        };
    };

    // the Validator object contains several default validators
    // that need to be attached to all Attrs
    for (i = 0; i < Validator.validators().length; ++i) {
        addValidator(Validator.validators()[i]);
    }

    ////////////////////////////////////////////////////////////////////////
    /////////////////////// END VALIDATOR RELATED //////////////////////////
    ////////////////////////////////////////////////////////////////////////
};

module.exports = Attr;

},{"./attr_list.js":5,"./validator.js":8}],5:[function(require,module,exports){
"use strict";

var Attr = require('./attr.js');

var AttrList = function(name) {
    var that = this,
        listeners = {};


    //this is where the inheritance happens now
    Attr.call(this, name);

    var delegate = function (obj, func) {
        return function () { return obj[func].apply(obj, arguments); };
    };

    //syntactic sugar to keep things grammatically correct
    this.validateWith = this.validatesWith;

    //disable defaultsTo and isImmutable until we figure out how to make it make sense
    this.defaultsTo = function () {
        //no op
    };

    this.isImmutable = function () {
        //no op
    };

    this.isMutable = function () {
        //no op
    };

    this.eachOfWhich = this;

    this.on = function (event, listener) {
        if (event !== "add") {
            throw new Error("AttrList: 'on' only responds to 'add' event");
        }

        if (typeof(listener) !== "function") {
            throw new Error("AttrList: 'on' requires a listener function as the second parameter");
        }

        listeners[event] = listener;
    };


    this.addTo = function (obj) {
        var prop,
            arr = [],
            actualList = {};
        if(!obj || typeof(obj) !== 'object') {
            throw new Error("AttrList: addTo method requires an object parameter");                
        } else {
            actualList.pop = delegate(arr, "pop");
            
            actualList.add = function (item) {
                if ((that.validator())(item)) {
                    arr.push(item);
                    if (listeners.add !== undefined) {
                        //listeners.add.call();
                        listeners.add.call(obj, item, actualList.size());
                    }
                    return this;         
                } else {
                    throw new Error(that.errorMessage());
                }
            };

            actualList.replace = function (index, obj) {
                if ((typeof(index) !== 'number') || (parseInt(index, 10) !== index)) {
                    throw new Error("AttrList: replace method requires index parameter to be an integer");
                }

                if (index < 0 || index >= this.size()) {
                    throw new Error("AttrList: replace method index parameter out of bounds");
                }

                if (!(that.validator())(obj)) {
                    throw new Error(that.errorMessage());
                }

                arr[index] = obj;
                return this;
            };

            actualList.at = function (index) {
                if (index < 0 || index >= this.size()) {
                    throw new Error("AttrList: Index out of bounds");
                }
                return arr[index];
            };

            //to keep things more java-y
            actualList.get = actualList.at;

            actualList.size = function () {
                return arr.length;
            };

            actualList.toJSON = function (JSONreps) {
                var result = [], 
                    i, j;

                //check to make sure the current list is not in JSONreps
                if (JSONreps !== undefined) {
                    for (i = 0;i < JSONreps.length; ++i) {
                        if (JSONreps[i].object === this) {
                            result = JSONreps[i].JSONrep;
                        }
                    }
                }
                
                for (i = 0; i < arr.length; ++i) {
                    if (arr[i].toJSON) {
                        result.push(arr[i].toJSON(JSONreps));
                    } else {
                        result.push(arr[i]);
                    }
                }
                return result;
            };

            obj[name] = function () {
                return actualList;
            };
        }
    };
};

// //this needs to stay if we're going to use instanceof
// //but note we override all of the methods via delegation
// //so it's not doing anything except for making an AttrList
// //an instance of Attr
//AttrList.prototype = new Attr(name);
AttrList.prototype = new Attr("???");

module.exports = AttrList;

},{"./attr.js":4}],6:[function(require,module,exports){
"use strict";

var Method = function (name, method) {
    if (!name || typeof(name) !== "string") { 
        throw new Error("Method: constructor requires a name parameter which must be a string");
    } else if (!method || typeof(method) !== "function") {
        throw new Error("Method: second parameter must be a function");
    }
    
    this.addTo = function (obj) {
        if (!obj || typeof(obj) !== 'object') {
            throw new Error("Method: addTo method requires an object parameter");
        }
        
        obj[name] = method;
    };
};

module.exports = Method;

},{}],7:[function(require,module,exports){
"use strict";

require('../util/index_of.js');

var models = {};

/**
 * this function return a model associated with a name
 */
var getModel = function (name) {
    if (typeof(name) !== "string") {
        throw new Error("Jermaine: argument to getModel must be a string");
    }

    if (models[name] === undefined) {
        throw new Error("No model by the name of " + name + " found");
    } else {
        return models[name];
    }
};

/**
 * this function returns an array of all model names stored by
 * jermaine
 */
var getModels = function (name) {
    var model,
        result = [];
    
    for (model in models) {
        result.push(model);
    }
    return result;
};

/**
 * This is the model constructor
 */

var Model = function (specification) {
    var methods = {},
        attributes = {},
        pattern,
        modelName,
        modified = true,
        requiredConstructorArgs = [],
        optionalConstructorArgs = [],
        parents = [],
        Method = require('./method.js'),
        Attr = require('./attr.js'),
        AttrList = require('./attr_list.js'),
        EventEmitter = require('../util/event_emitter.js'),
        property,
        listProperties,
        updateConstructor,
        isImmutable,
        initializer = function () {},
        constructor = function () {},
        model = function () {
            if (modified) {
                //validate the model if it has been modified
                model.validate();
                updateConstructor();
            }
            return constructor.apply(this, arguments);
        };

    if (arguments.length === 1) {
        if (typeof(specification) === "string") {
            modelName = specification;
            specification = undefined;
        }
    }

    if (arguments.length > 1) {
        modelName = specification;
        specification = arguments[arguments.length-1];
    }

    //handle specification function
    if (specification && typeof(specification) === "function") {
        model = new Model(modelName);
        specification.call(model);
        return model;
    } else if (specification) {
        throw new Error("Model: specification parameter must be a function");
    }

    //handle model name
    if (modelName !== undefined && typeof(modelName) === "string") {
        models[modelName] = model;
    } else if (modelName !== undefined) {
        throw new Error("Model: model name must be a string");
    }

    
    /********** BEGIN PRIVATE METHODS ****************/
    /* private method that abstracts hasA/hasMany */
    var hasAProperty = function (type, name) {
        var Property,
            methodName,
            attribute;

        //Property is one of Attr or AttrList
        Property = type==="Attr"?Attr:AttrList;

        //methodName is either hasA or hasMany
        methodName = type==="Attr"?"hasA":"hasMany";

        modified = true;
        
        if (typeof(name) === 'string') {
            attribute = new Property(name);
            attributes[name] = attribute;
            return attribute;
        } else {
            throw new Error("Model: " + methodName + " parameter must be a string");
        }
    };

    /* private method that abstracts attribute/method */
    property = function (type, name) {
        var result;

        if (typeof(name) !== "string") {
            throw new Error("Model: expected string argument to " + type + " method, but recieved " + name);
        }

        result = type==="attribute" ? attributes[name] : methods[name];

        if (result === undefined) {
            throw new Error("Model: " + type + " " + name  + " does not exist!");
        }

        return result;
    };

    /* private method that abstracts attributes/methods */
    listProperties = function (type) {
        var i,
            list = [],
            properties = type==="attributes"?attributes:methods;

        for (i in properties) {
            if (properties.hasOwnProperty(i)) {
                list.push(i);
            }
        }

        return list;
    };

    /* private function that updates the constructor */
    updateConstructor = function () {
        constructor = function () {
            var i, j,
                err,
                attribute,
                attributeList = model.attributes(), 
                methodList = model.methods(), 
                emitter = new EventEmitter(),
                attr,
                attrChangeListeners = {},
                changeHandler,
                addProperties,
                that = this;

            if (!(this instanceof model)) {
                if (arguments.length > 0) {
                    //bad form, but hopefully temporary
                    /*jshint newcap:false */
                    return new model(arguments);
                } else {
                    //bad form, but hopefully temporary
                    /*jshint newcap:false */
                    return new model();
                }
                //throw new Error("Model: instances must be created using the new operator");
            }


            ////////////////////////////////////////////////////////////////
            ////////////// PUBLIC API FOR ALL INSTANCES ////////////////////
            ////////////////////////////////////////////////////////////////

            // this is a method associated with unit test
            // it("should not increment the listeners associated with the last object created"
            // it has been removed now that the bug has been fixed
            /*this.attrChangeListeners = function () {
             return attrChangeListeners;
             };*/

            /**
             * Returns the EventEmitter associated with this instance.
             *
             */
            this.emitter = function () {
                return emitter;
            };

            /**
             * Wrapper methods added to the internal EventEmitter object
             * 
             */

            this.emitter().removeJermaineChangeListener = function (attrName, obj) {
                if (typeof(attrName) !== "string") {
                    throw new Error("attrName must be a string");
                } else if (typeof(obj) !== "object" || obj.toJSON === undefined ||
                           obj.emitter === undefined) {
                    throw new Error("obj must be a jermaine object");
                } else {
                    obj.emitter().removeListener("change", attrChangeListeners[attrName]);
                }
            };

            this.emitter().addJermaineChangeListener = function (attrName, obj) {
                if (typeof(attrName) !== "string") {
                    throw new Error("attrName must be a string");
                } else if (typeof(obj) !== "object" || obj.toJSON === undefined ||
                           obj.emitter === undefined) {
                    throw new Error("obj must be a jermaine object");
                } else {
                    if (attrChangeListeners[attrName] === undefined) {
                        attrChangeListeners[attrName] = function (data) {
                            var newData = [],
                                emit = true;
                            
                            for (i = 0; i < data.length && emit === true; ++i) {
                                newData.push(data[i]);
                                if (data[i].origin === that) {
                                    emit = false;
                                }
                            }
                            
                            if (emit) {
                                newData.push({key:attrName, origin:that});
                                that.emit("change", newData);
                            }
                        };
                        
                    }
                    obj.emitter().on("change", attrChangeListeners[attrName]);
                }
            };


            /**
             * Registers a listener for this instance's changes.
             *
             */
            this.on = this.emitter().on;

            /**
             * Emits an event
             */
            this.emit = this.emitter().emit;

            /**
             * Returns a JSON representation of this instance.
             *
             */
            this.toJSON = function (JSONreps) {
                var attributeValue,
                    i, j,
                    thisJSONrep = {},
                    attributeJSONrep;

                if (JSONreps === undefined) {
                    // first call
                    JSONreps = [];
                    JSONreps.push({object:this, JSONrep:thisJSONrep});
                } else if (typeof(JSONreps) !== "object") {
                    // error condition 
                    throw new Error("Instance: toJSON should not take a parameter (unless called recursively)");
                } else {
                    // find the current JSON representation of this object, if it exists
                    for (i = 0; i < JSONreps.length; ++i) {
                        if (JSONreps[i].object === this) {
                            thisJSONrep = JSONreps[i].JSONrep;
                        }
                    }
                }

                for (i = 0; i < attributeList.length; ++i) {
                    attributeJSONrep = null;
                    // get the attribute
                    attributeValue = this[attributeList[i]]();
                    
                    // find the current JSON representation for the attribute, if it exists
                    for (j = 0; j < JSONreps.length; ++j) {
                        if (JSONreps[j].object === attributeValue) {
                            attributeJSONrep = JSONreps[j].JSONrep;
                        }
                    }

                    if (attributeValue !== undefined && attributeValue !== null && attributeValue.toJSON !== undefined && attributeJSONrep === null) {
                        // create a new entry for the attribute
                        attributeJSONrep = (attributes[attributeList[i]] instanceof AttrList)?[]:{};
                        JSONreps.push({object:attributeValue, JSONrep:attributeJSONrep});
                        JSONreps[JSONreps.length-1].JSONrep = attributeValue.toJSON(JSONreps);
                    }

                    // fill out the JSON representation for this object
                    if(attributeJSONrep === null) {
                        thisJSONrep[attributeList[i]] = attributeValue;
                    } else {
                        thisJSONrep[attributeList[i]] = attributeJSONrep;
                    }
                }
                return thisJSONrep;
            };

            /**
             * Returns a String representation of this instance
             *
             */
            this.toString = (pattern !== undefined)?pattern:function () {
                return "Jermaine Model Instance";
            };


            ////////////////////////////////////////////////////////////////
            ////////////// END PUBLIC API FOR ALL INSTANCES ////////////////
            ////////////////////////////////////////////////////////////////


            /**
             * This is a private method that sets up handling for the setter
             * It attaches a change listener on new objects
             * and it removes the change listener from old objects
             */
            changeHandler = function (attr) {
                if (!(attr instanceof AttrList)) {
                    //when set handler is called, this should be the current object
                    attr.on("set", function (newValue, preValue) {
                        // if preValue is a model instance, we need to remove the listener from it
                        if (preValue !== undefined && preValue !== null && preValue.on !== undefined &&
                            preValue.toJSON !== undefined && preValue.emitter !== undefined) {
                            // we now assume preValue is a model instance
                            
                            // sanity check 1
                            if (preValue.emitter().listeners("change").length < 1) {
                                throw new Error("preValue should always have a listener defined if it is a model");
                            }
                            
                            this.emitter().removeJermaineChangeListener(attr.name(), preValue);
                        }
                        
                        // if newValue is a model instance, we need to attach a listener to it
                        if (newValue !== undefined && newValue !== null && newValue.on !== undefined &&
                            newValue.toJSON !== undefined && newValue.emitter !== undefined) {
                            // we now assume newValue is a model instance
                            
                            // attach a listener
                            this.emitter().addJermaineChangeListener(attr.name(), newValue);
                        }

                        // finally emit that a change has happened
                        this.emit("change", [{key:attr.name(), value:newValue, origin:this}]);
                    });
                } else {
                    attr.on("add", function (newValue, newSize) {
                        this.emit("change", [{action:"add", key:attr.name(), value:newValue, origin:this}]);
                    });
                }
            };

            //set up event handling for sub objects
            for (i = 0; i < attributeList.length;  ++i) {
                attr = model.attribute(attributeList[i]);

                // temporarily not adding handlers to attr lists
                // until we get the bugs sorted out
                // see model test "should not add change listeners to attr list"
                //if (!(attr instanceof AttrList)) {
                changeHandler.call(this, attr);
                //}
            }


            // add all of the attributes and the methods to the object
            for (i = 0; i < attributeList.length + methodList.length; ++i)  {
                if (i < attributeList.length) {
                    //if the object is immutable, all attributes should be immutable
                    if (isImmutable) {
                        model.attribute(attributeList[i]).isImmutable();
                    }
                    model.attribute(attributeList[i]).addTo(this);
                } else {
                    model.method(methodList[i-attributeList.length]).addTo(this);
                }
            }

            // build the object using the constructor arguments
            if(arguments.length > 0) {
                if (arguments.length < requiredConstructorArgs.length) {
                    //construct and throw error
                    err = "Constructor requires ";
                    for(i = 0; i < requiredConstructorArgs.length; ++i) {
                        err += requiredConstructorArgs[i];
                        err += i===requiredConstructorArgs.length-1?"":", ";
                    }
                    err += " to be specified";
                    throw new Error(err);
                } if (arguments.length > requiredConstructorArgs.length + optionalConstructorArgs.length) {
                    throw new Error("Too many arguments to constructor. Expected " + requiredConstructorArgs.length + " required arguments and " +
                                    optionalConstructorArgs.length + " optional arguments");
                }
                else {
                    for (i = 0; i < arguments.length; ++i) {
                        attribute = i < requiredConstructorArgs.length?
                            requiredConstructorArgs[i]:
                            optionalConstructorArgs[i-requiredConstructorArgs.length];

                        if (model.attribute(attribute) instanceof AttrList) {
                            //make sure that arguments[i] is an array
                            if (Object.prototype.toString.call(arguments[i]) !== "[object Array]") {
                                throw new Error("Model: Constructor requires 'names' attribute to be set with an Array");
                            } else {
                                //iterate over the array adding the elements
                                for (j = 0; j < arguments[i].length; ++j) {
                                    this[attribute]().add(arguments[i][j]);
                                }
                            }
                        } else {
                            //go ahead and set it like normal
                            this[attribute](arguments[i]);
                        }
                    }
                }
            }

            // finally, call the initializer
            initializer.call(this);
        };
    };
    /*********** END PRIVATE METHODS **************/


    /*********** BEGIN PUBLIC API *****************/
    model.hasA = function (attr) {
        return hasAProperty("Attr", attr);
    };
    
    model.hasAn = model.hasA;
    model.hasSome = model.hasA;
    
    model.hasMany = function (attrs) {
        return hasAProperty("AttrList", attrs);
    };

    model.isA = function (parent) {
        var i,
            parentAttributes,
            parentMethods,
            isAModel;

        modified = true;

        //checks to make sure a potentialModel has all attributes of a model
        isAModel = function (potentialModel) {
            var i,
                M = new Model();
            for (i in M) {
                if (M.hasOwnProperty(i) && typeof(potentialModel[i]) !== typeof(M[i])) {
                    return false;
                }
            }
            return true;
        };

        //confirm parent is a model via duck-typing
        if (typeof (parent) !== "function" || !isAModel(parent)) {
            throw new Error("Model: parameter sent to isA function must be a Model");
        }

        //only allow single inheritance for now
        if (parents.length === 0) {
            parents.push(parent);
        } else {
            throw new Error("Model: Model only supports single inheritance at this time");
        }

        //add attributes and methods to current model
        parentAttributes = parents[0].attributes();
        for (i = 0; i < parentAttributes.length; ++i) {
            if (attributes[parentAttributes[i]] === undefined) {
                attributes[parentAttributes[i]] = parents[0].attribute(parentAttributes[i]).clone();
                //subclass attributes are mutable by default
                attributes[parentAttributes[i]].isMutable();
            }
        }

        parentMethods = parents[0].methods();
        for (i = 0; i < parentMethods.length; ++i) {
            if (methods[parentMethods[i]] === undefined) {
                methods[parentMethods[i]] = parents[0].method(parentMethods[i]);
            }
        }            

        for (i = 0; i < parents.length; i++) {
            model.prototype = new parents[i]();
        }
    };

    model.isAn = model.isA;

    model.parent = function () {
        return parents[0].apply(this, arguments);
    };

    model.attribute = function (attr) {
        return property("attribute", attr);
    };

    model.attributes = function () {
        return listProperties("attributes");
    };

    model.method = function (m) {
        return property("method", m);
    };
    
    model.methods = function () {
        return listProperties("methods");
    };

    model.isBuiltWith = function () {
        var optionalParamFlag = false,
            i;

        modified = true;
        requiredConstructorArgs = [];
        optionalConstructorArgs = [];

        for (i = 0; i < arguments.length; ++i) {
            if (typeof(arguments[i]) === "string" && arguments[i].charAt(0) !== '%') {
                //in required parms
                if (optionalParamFlag) {
                    //throw error
                    throw new Error("Model: isBuiltWith requires parameters preceded with a % to be the final parameters before the optional function");
                } else {
                    //insert into required array
                    requiredConstructorArgs.push(arguments[i]);
                }
            } else if(typeof(arguments[i]) === "string" && arguments[i].charAt(0) === '%') {
                //in optional parms
                optionalParamFlag = true;
                //insert into optional array
                optionalConstructorArgs.push(arguments[i].slice(1));
            } else if(typeof(arguments[i]) === "function" && i === arguments.length - 1) {
                //init function
                initializer = arguments[i];
            } else {
                throw new Error("Model: isBuiltWith parameters must be strings except for a function as the optional final parameter");
            }
        }
    };
    
    model.isImmutable = function () {
        isImmutable = true;
    };

    model.looksLike = function (p) {
        modified = true;
        pattern = p;
    };

    model.respondsTo = function (methodName, methodBody) {
        var m = new Method(methodName, methodBody);
        modified = true;
        methods[methodName] = m;
    };
    
    model.validate = function () {
        var i,
            attributes = this.attributes(),
            methods = this.methods();

        //check to make sure that isBuiltWith has actual attributes
        for (i = 0; i < requiredConstructorArgs.length; ++i) {
            try {
                this.attribute(requiredConstructorArgs[i]);
            } catch (e) {
                throw new Error(requiredConstructorArgs[i] + ", specified in the isBuiltWith method, is not an attribute");
            }
        }

        for (i = 0; i < optionalConstructorArgs.length; ++i) {
            try {
                this.attribute(optionalConstructorArgs[i]);
            } catch (e) {
                throw new Error(optionalConstructorArgs[i] + ", specified in the isBuiltWith method, is not an attribute");
            }
        }

        //check for method/attribute collisions
        for (i = 0; i < attributes.length; i++) {
            if (methods.indexOf(attributes[i]) > -1) {
                throw new Error("Model: invalid model specification to " + attributes[i] + " being both an attribute and method");
            }
        }

        //check to make sure that all attributes are requiredConstructorArgs if the object is immutable
        if (isImmutable) {
            for (i = 0; i < attributes.length; i++) {
                if (requiredConstructorArgs.indexOf(attributes[i]) < 0) {
                    throw new Error("immutable objects must have all attributes required in a call to isBuiltWith");
                }
            }
        }

        //set modifiedSinceLastValidation to false
        modified = false;
    };
    /************** END PUBLIC API ****************/
    
    //here we are returning our model object
    //which is a function with a bunch of methods that
    //manipulate how the function behaves
    return model;
};

//ns.getModel = getModel;
//ns.getModels = getModels;

Model.getModel = getModel;
Model.getModels = getModels;

module.exports = Model;



},{"../util/event_emitter.js":10,"../util/index_of.js":11,"./attr.js":4,"./attr_list.js":5,"./method.js":6}],8:[function(require,module,exports){
/**
 * Validator
 * 
 * Creates a named function that can be attached to attribute for validation.
 * The Validator function allows for customization of the thrown error message.
 *
 * This source file also handles all default validators that come packaged with
 * Jermaine. This includes isA, isOneOf, isGreaterThan, isLessThan, etc.
 *
 * Simple example:
 *
 * isGreaterThan = new Validator(function (number) {
 *     //this.message points to the error message
 *     //that will be thrown
 *     this.message = "Validation Error: " + 
 *                    this.param + " should be greater than " + number;
 *
 *     //this.param points to the actual parameter sent to the validator
 *     //return true if the validation passes, false otherwise
 *     return this.param > number;
 * });
 *
 * Later, a validator can be attached to the attribute object.
 *
 * Attr.isGreaterThan = isGreaterThan;
 *
 * and can be used when creating attributes:
 *
 * var age = new Attr("age").which.isGreaterThan(0);
 *
 */

"use strict";

require('../util/index_of.js');

var Model = require('./model.js');

var validators = {};  //the set of static validators

/**
 * Validator 'Constructor'
 *
 * This simply returns a validation function that handles the custom error
 * message and can be attached to an attribute. So it's not really
 * technically a constructor. This is only important to know so that you
 * don't try something like this:
 *
 * var v = new Validator( ... );
 * 
 * //this will always fail, bc v is not an object
 * if (v instanceof Validator) { ... }
 * 
 * The spec function is just a specification for the validator. It allows
 * for a couple of things to be attached to "this" that will be used
 * in the return function. This includes "this.message" and "this.param".
 * The message is the error string that is thrown on failure and
 * this.param is the actual parameter that gets sent in to be validated.
 */
var Validator = function (spec) {
    // this is the actual function that is returned
    var validatorFunction = function (arg) {
        var result, 
            resultObject = {},
            errorMessage;

        // spec is called on the argument with 'this' pointing
        // to an empty object (resultObject),
        // note the validator will return either true or false
        result = spec.call(resultObject, arg);

        // if it's false, the parameter has failed validation
        if (!result) {
            // throw the error
            errorMessage = resultObject.message ||
                "validator failed with parameter " + arg;
            throw new Error(errorMessage);
        }
        return result;
    };

    // see? all that's being returned is a function
    // also note that since 'this' is never used,
    // we can call this constructor with or without 'new'
    return validatorFunction;
};

/**
 * This static function adds a named validator to the list of
 * validators. The second argument is a validation function
 * that simply returns a Validator function created as above.
 *
 * The nice thing about adding a Validator this way is that
 * you can actually validate the parameter sent to the validator!
 * Why might that be important? Well, consider the following:
 *
 * var isGreaterThanInteger = new Validator(function (val) {
 *     this.message = this.param + " should be greater than " + val;
 *     return this.param > val;
 * });
 *
 * Now we can call isGreaterThanNumber like this:
 *
 * isGreaterThanNumber(5)(6); // will pass validation
 * isGreaterThanNumber(5)(3); // will throw
 * isGreaterThanNumber("dog")(3); // ???
 *
 * So we need to confirm that the user sends in an integer as a parameter.
 * You might want to try something like this:
 *
 * var isGreaterThanInteger = new Validator(function (val) {
 *     if (typeof(val) !== "number") throw Error("Not cool!");
 *     this.message = this.param + " should be greater than " + val;
 *     return this.param > val;
 * });
 *
 * This will actually work on the example above:
 *
 * isGreaterThanNumber("dog")(3); // throws error now
 *
 * The problem is that with Jermaine, we create the validator
 * and then don't actually call it until an attribute is about to be
 * set. So, in other words:
 *
 * var a = new Attr("thing").which.isGreaterThanNumber("dog"); //no error (yet)
 *
 * will not cause an error until it's attached to an object and thing
 * is attempted to be set.
 *
 * So a temporary workaround is to validate the validator in the
 * addValidator function below. That's handled by the argValidator
 * validator. (Phew, this is getting really meta)
 *
 * I'm not sure this is the best solution. Seems like there should be
 * a way to validate the argument in the constructor function, but
 * that might require some rewiring that breaks multigraph. This is
 * the best I could come up with for now.
 *
 * @name The name of the validator for the attribute, must be a string
 *       or an error will be thrown
 *
 * @v The validator specification (returns a boolean)
 *    must be a function or an error will be thrown
 *
 * @argValidator optional function that checks the types of args sent
 *           to the validator, must be a function or an error will be thrown
 *
 * So an error will be thrown in the cases that "name" is not a string,
 * v is not a function, argValidator is not a function, or if the static
 * validator is already defined.
 */
Validator.addValidator = function (name, v, argValidator) {
    if (name === undefined || typeof(name) !== "string") {
        throw new Error("addValidator requires a name to be specified as the first parameter");
    }

    if (v === undefined || typeof(v) !== "function") {
        throw new Error("addValidator requires a function as the second parameter");
    }

    // optional third argument to validate the 
    // expected value that gets sent to the validator
    // for example, isA("number") works but isA("nmber")
    // doesn't work
    if (argValidator !== undefined && typeof(argValidator) !== "function") {
        throw new Error("addValidator third optional argument must be a "+
                        "function");
    }

    if (validators[name] === undefined) {
        validators[name] = function (expected) {
            if (argValidator !== undefined) {
                if (!argValidator(expected)) {
                    throw new Error ("Validator: Invalid argument for " +
                                     name + " validator");
                }
            }
            return new Validator(function (val) {
                var resultObject = {"actual":val, "param":val},
                    result = v.call(resultObject, expected);
                this.message = resultObject.message;
                return result;
            });
        };
    } else {
        throw new Error("Validator '" + name +"' already defined");
    }
};


/**
 * Get the built-in validator by its name.
 *
 * @name a string representing the name of the validator to return
 * 
 * throws an error if name is not a string
 */
Validator.getValidator = function (name) {
    var result;

    if (name === undefined) {
        throw new Error("Validator: getValidator method requires a string parameter");
    } else if (typeof (name) !== "string") {
        throw new Error("Validator: parameter to getValidator method must be a string");
    }

    result = validators[name];

    if (result === undefined) {
        throw new Error("Validator: '" + name + "' does not exist");
    }

    return result;
};



/**
 * return an array of of static validator names
 */
Validator.validators = function () {
    var prop,
        result = [];
    for (prop in validators) {
        if (validators.hasOwnProperty(prop)) {
            result.push(prop);
        }
    }

    return result;
};

/**
 * Built-In validators. Hopefully these are self-explanatory
 * Will document them more later.
 */
Validator.addValidator("isGreaterThan", function (val) {
    this.message = this.param + " should be greater than " + val;
    return this.param > val;
});

Validator.addValidator("isLessThan", function (val) {
    this.message = this.param + " should be less than " + val;
    return this.param < val;
});


// TODO: add array validation for val
Validator.addValidator("isOneOf", function (val) {
    this.message = this.param + " should be one of the set: " + val;
    return val.indexOf(this.param) > -1;
});

/**
 * This one is the only one that uses an argument validator. It confirms
 * that the argument is a primitive javascript type or a named Jermaine
 * model.
 */
Validator.addValidator("isA", function (val) {
    var types = ["string", "number", "boolean", "function", "object"],
        models = Model.getModels();
    if (typeof(val) === "string" && types.indexOf(val) > -1) {
        this.message = this.param + " should be a " + val;
        return typeof(this.param) === val;
    } else if (typeof(val) === "string" && models.indexOf(val) > -1) {
        this.message = "parameter should be an instance of " + val;
        return this.param instanceof Model.getModel(val);
    } else if (val === 'integer') {
        // special case for 'integer'; since javascript has no integer type,
        // just check for number type and check that it's numerically an int
        if (this.param.toString !== undefined)  {
            this.message = this.param.toString() + " should be an integer";
        } else {
            this.message = "parameter should be an integer";
        }
        return (typeof(this.param) === 'number') && (parseInt(this.param,10) === this.param);
    } /*else if (typeof(val) === "string") {
       throw new Error("Validator: isA accepts a string which is one of " + types);
       } else {
       throw new Error("Validator: isA only accepts a string for a primitive types for the time being");
       }*/
},
                       //argument validator
                       function (val) {
                           var typesAndModels = ["string", "number", "boolean", "function",
                                                 "object", "integer"].concat(Model.getModels());
                           return typesAndModels.indexOf(val) >= 0;
                       });


// grammatical alias for isA
validators.isAn = validators.isA;

module.exports = Validator;

},{"../util/index_of.js":11,"./model.js":7}],9:[function(require,module,exports){
require('./util/index_of.js');

var Model = require('./core/model.js');

module.exports = {
    'Attr'      : require('./core/attr.js'),
    'AttrList'  : require('./core/attr_list.js'),
    'Model'     : Model,
    'getModel'  : Model.getModel,
    'getModels' : Model.getModels,
    'Validator' : require('./core/validator.js'),
    'Method'    : require('./core/method.js'),
    'util'      : {
        'EventEmitter' : require('./util/event_emitter.js'),
        'namespace'    : require('./util/namespace.js')
    }
};

},{"./core/attr.js":4,"./core/attr_list.js":5,"./core/method.js":6,"./core/model.js":7,"./core/validator.js":8,"./util/event_emitter.js":10,"./util/index_of.js":11,"./util/namespace.js":12}],10:[function(require,module,exports){
"use strict";

require('./index_of.js');

var EventEmitter = function () {
    var that = this,
        listeners = {};

    //an registers event and a listener
    this.on = function (event, listener) {
        if (typeof(event) !== "string") {
            throw new Error("EventEmitter: first argument to 'on' should be a string");
        }
        if (typeof(listener) !== "function") {
            throw new Error("EventEmitter: second argument to 'on' should be a function");
        }
        if (!listeners[event]) {
            listeners[event] = [];
        }
        listeners[event].push(listener);
        return that;
    };

    //alias addListener
    this.addListener = this.on;
    
    this.once = function (event, listener) {
        var f = function () {
            listener(arguments);
            that.removeListener(event, f);
        };

        that.on(event, f);
        return that;
    };

    this.removeListener = function (event, listener) {
        var index;

        if (typeof(event) !== "string") {
            throw new Error("EventEmitter: first parameter to removeListener method must be a string representing an event");
        }
        if (typeof(listener) !== "function") {
            throw new Error("EventEmitter: second parameter must be a function to remove as an event listener");
        }
        if (listeners[event] === undefined || listeners[event].length === 0) {
            throw new Error("EventEmitter: there are no listeners registered for the '" + event + "' event");
        }

        index = listeners[event].indexOf(listener);

        if (index !== -1) {
            //remove it from the list
            listeners[event].splice(index,1);
        }

        return that;
    };

    this.removeAllListeners = function (event) {
        if (typeof(event) !== "string") {
            throw new Error("EventEmitter: parameter to removeAllListeners should be a string representing an event");
        }

        if (listeners[event] !== undefined) {
            listeners[event] = [];
        }
        
        return that;
    };
    
    this.setMaxListeners = function (number) {
        return that;
    };

    //get the listeners for an event
    this.listeners = function (event) {
        if (typeof(event) !== 'string') {
            throw new Error("EventEmitter: listeners method must be called with the name of an event");
        } else if (listeners[event] === undefined) {
            return [];
        }
        return listeners[event];
    };

    //execute each of the listeners in order with the specified arguments
    this.emit = function (event, data) {
        var i,
            params;


        if (arguments.length > 1) {
            params = [];
        }

        for (i = 1; i < arguments.length; ++i) {
            params.push(arguments[i]);
        }

        if (listeners[event] !== undefined) {
            for (i = 0; i < listeners[event].length; i=i+1) {
                listeners[event][i].apply(this, params);
            }
        }
    };

    return that;
}; //end EventEmitter

module.exports = EventEmitter;

},{"./index_of.js":11}],11:[function(require,module,exports){
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
        "use strict";
        if (this === null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (len === 0) {
            return -1;
        }
        var n = 0;
        if (arguments.length > 0) {
            n = Number(arguments[1]);
            if (n !== n) { // shortcut for verifying if it's NaN
                n = 0;
            } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
        }
        if (n >= len) {
            return -1;
        }
        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
        for (; k < len; k++) {
            if (k in t && t[k] === searchElement) {
                return k;
            }
        }
        return -1;
    };
}

module.exports = undefined;

},{}],12:[function(require,module,exports){
module.exports = function namespace (ns, aliases, func) {
    var nsRegExp = /^([a-zA-Z]+)(\.[a-zA-Z]*)*$/,
        nsArray,
        currentNS,
        i;

    //check to assure ns is a properly formatted namespace string
    if (ns.match(nsRegExp) === null || ns === "window") {
        throw new Error("namespace: " + ns + " is a malformed namespace string");
    }

    //check to assure that if alias is defined that func is defined
    if (aliases !== undefined && func === undefined) {
        if (typeof (aliases) === "function") {
            func = aliases;
            aliases = undefined;
        } else if (typeof (aliases) === "object") {
            throw new Error("namespace: if second argument exists, final function argument must exist");
        } else if (typeof (aliases) !== "object") {
            throw new Error("namespace: second argument must be an object of aliased local namespaces");
        }
    } else if (typeof (aliases) !== "object" && typeof (func) === "function") {
        throw new Error("namespace: second argument must be an object of aliased local namespaces");
    }

    //parse namespace string
    nsArray = ns.split(".");

    //set the root namespace to window (if it's not explictly stated)
    if (nsArray[0] === "window") {
        currentNS = window;
    } else {
        currentNS = (window[nsArray[0]] === undefined) ? window[nsArray[0]] = {} : window[nsArray[0]];
    }

    //confirm func is actually a function
    if (func !== undefined && typeof (func) !== "function") {
        throw new Error("namespace: last parameter must be a function that accepts a namespace parameter");
    }

    //build namespace
    for (i = 1; i < nsArray.length; i = i + 1) {
        if (currentNS[nsArray[i]] === undefined) {
            currentNS[nsArray[i]] = {};
        }
        currentNS = currentNS[nsArray[i]];
    }

    //namespaces.push(currentNS);
    //namespace = currentNS;

    //if the function was defined, but no aliases run it on the current namespace
    if (aliases === undefined && func) {
        func(currentNS);
    } else if (func) {
        for (i in aliases) {
            if (aliases.hasOwnProperty(i)) {
                aliases[i] = namespace(aliases[i]);
            }
        }
        func.call(aliases, currentNS);
    }

    //return namespace
    return currentNS;
};

},{}],13:[function(require,module,exports){
/*! jQuery v1.8.2 jquery.com | jquery.org/license */
(function(a,b){function G(a){var b=F[a]={};return p.each(a.split(s),function(a,c){b[c]=!0}),b}function J(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(I,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:+d+""===d?+d:H.test(d)?p.parseJSON(d):d}catch(f){}p.data(a,c,d)}else d=b}return d}function K(a){var b;for(b in a){if(b==="data"&&p.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function ba(){return!1}function bb(){return!0}function bh(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function bi(a,b){do a=a[b];while(a&&a.nodeType!==1);return a}function bj(a,b,c){b=b||0;if(p.isFunction(b))return p.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return p.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=p.grep(a,function(a){return a.nodeType===1});if(be.test(b))return p.filter(b,d,!c);b=p.filter(b,d)}return p.grep(a,function(a,d){return p.inArray(a,b)>=0===c})}function bk(a){var b=bl.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function bC(a,b){return a.getElementsByTagName(b)[0]||a.appendChild(a.ownerDocument.createElement(b))}function bD(a,b){if(b.nodeType!==1||!p.hasData(a))return;var c,d,e,f=p._data(a),g=p._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;d<e;d++)p.event.add(b,c,h[c][d])}g.data&&(g.data=p.extend({},g.data))}function bE(a,b){var c;if(b.nodeType!==1)return;b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase(),c==="object"?(b.parentNode&&(b.outerHTML=a.outerHTML),p.support.html5Clone&&a.innerHTML&&!p.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):c==="input"&&bv.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):c==="option"?b.selected=a.defaultSelected:c==="input"||c==="textarea"?b.defaultValue=a.defaultValue:c==="script"&&b.text!==a.text&&(b.text=a.text),b.removeAttribute(p.expando)}function bF(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bG(a){bv.test(a.type)&&(a.defaultChecked=a.checked)}function bY(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=bW.length;while(e--){b=bW[e]+c;if(b in a)return b}return d}function bZ(a,b){return a=b||a,p.css(a,"display")==="none"||!p.contains(a.ownerDocument,a)}function b$(a,b){var c,d,e=[],f=0,g=a.length;for(;f<g;f++){c=a[f];if(!c.style)continue;e[f]=p._data(c,"olddisplay"),b?(!e[f]&&c.style.display==="none"&&(c.style.display=""),c.style.display===""&&bZ(c)&&(e[f]=p._data(c,"olddisplay",cc(c.nodeName)))):(d=bH(c,"display"),!e[f]&&d!=="none"&&p._data(c,"olddisplay",d))}for(f=0;f<g;f++){c=a[f];if(!c.style)continue;if(!b||c.style.display==="none"||c.style.display==="")c.style.display=b?e[f]||"":"none"}return a}function b_(a,b,c){var d=bP.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function ca(a,b,c,d){var e=c===(d?"border":"content")?4:b==="width"?1:0,f=0;for(;e<4;e+=2)c==="margin"&&(f+=p.css(a,c+bV[e],!0)),d?(c==="content"&&(f-=parseFloat(bH(a,"padding"+bV[e]))||0),c!=="margin"&&(f-=parseFloat(bH(a,"border"+bV[e]+"Width"))||0)):(f+=parseFloat(bH(a,"padding"+bV[e]))||0,c!=="padding"&&(f+=parseFloat(bH(a,"border"+bV[e]+"Width"))||0));return f}function cb(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=!0,f=p.support.boxSizing&&p.css(a,"boxSizing")==="border-box";if(d<=0||d==null){d=bH(a,b);if(d<0||d==null)d=a.style[b];if(bQ.test(d))return d;e=f&&(p.support.boxSizingReliable||d===a.style[b]),d=parseFloat(d)||0}return d+ca(a,b,c||(f?"border":"content"),e)+"px"}function cc(a){if(bS[a])return bS[a];var b=p("<"+a+">").appendTo(e.body),c=b.css("display");b.remove();if(c==="none"||c===""){bI=e.body.appendChild(bI||p.extend(e.createElement("iframe"),{frameBorder:0,width:0,height:0}));if(!bJ||!bI.createElement)bJ=(bI.contentWindow||bI.contentDocument).document,bJ.write("<!doctype html><html><body>"),bJ.close();b=bJ.body.appendChild(bJ.createElement(a)),c=bH(b,"display"),e.body.removeChild(bI)}return bS[a]=c,c}function ci(a,b,c,d){var e;if(p.isArray(b))p.each(b,function(b,e){c||ce.test(a)?d(a,e):ci(a+"["+(typeof e=="object"?b:"")+"]",e,c,d)});else if(!c&&p.type(b)==="object")for(e in b)ci(a+"["+e+"]",b[e],c,d);else d(a,b)}function cz(a){return function(b,c){typeof b!="string"&&(c=b,b="*");var d,e,f,g=b.toLowerCase().split(s),h=0,i=g.length;if(p.isFunction(c))for(;h<i;h++)d=g[h],f=/^\+/.test(d),f&&(d=d.substr(1)||"*"),e=a[d]=a[d]||[],e[f?"unshift":"push"](c)}}function cA(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h,i=a[f],j=0,k=i?i.length:0,l=a===cv;for(;j<k&&(l||!h);j++)h=i[j](c,d,e),typeof h=="string"&&(!l||g[h]?h=b:(c.dataTypes.unshift(h),h=cA(a,c,d,e,h,g)));return(l||!h)&&!g["*"]&&(h=cA(a,c,d,e,"*",g)),h}function cB(a,c){var d,e,f=p.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((f[d]?a:e||(e={}))[d]=c[d]);e&&p.extend(!0,a,e)}function cC(a,c,d){var e,f,g,h,i=a.contents,j=a.dataTypes,k=a.responseFields;for(f in k)f in d&&(c[k[f]]=d[f]);while(j[0]==="*")j.shift(),e===b&&(e=a.mimeType||c.getResponseHeader("content-type"));if(e)for(f in i)if(i[f]&&i[f].test(e)){j.unshift(f);break}if(j[0]in d)g=j[0];else{for(f in d){if(!j[0]||a.converters[f+" "+j[0]]){g=f;break}h||(h=f)}g=g||h}if(g)return g!==j[0]&&j.unshift(g),d[g]}function cD(a,b){var c,d,e,f,g=a.dataTypes.slice(),h=g[0],i={},j=0;a.dataFilter&&(b=a.dataFilter(b,a.dataType));if(g[1])for(c in a.converters)i[c.toLowerCase()]=a.converters[c];for(;e=g[++j];)if(e!=="*"){if(h!=="*"&&h!==e){c=i[h+" "+e]||i["* "+e];if(!c)for(d in i){f=d.split(" ");if(f[1]===e){c=i[h+" "+f[0]]||i["* "+f[0]];if(c){c===!0?c=i[d]:i[d]!==!0&&(e=f[0],g.splice(j--,0,e));break}}}if(c!==!0)if(c&&a["throws"])b=c(b);else try{b=c(b)}catch(k){return{state:"parsererror",error:c?k:"No conversion from "+h+" to "+e}}}h=e}return{state:"success",data:b}}function cL(){try{return new a.XMLHttpRequest}catch(b){}}function cM(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function cU(){return setTimeout(function(){cN=b},0),cN=p.now()}function cV(a,b){p.each(b,function(b,c){var d=(cT[b]||[]).concat(cT["*"]),e=0,f=d.length;for(;e<f;e++)if(d[e].call(a,b,c))return})}function cW(a,b,c){var d,e=0,f=0,g=cS.length,h=p.Deferred().always(function(){delete i.elem}),i=function(){var b=cN||cU(),c=Math.max(0,j.startTime+j.duration-b),d=1-(c/j.duration||0),e=0,f=j.tweens.length;for(;e<f;e++)j.tweens[e].run(d);return h.notifyWith(a,[j,d,c]),d<1&&f?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:p.extend({},b),opts:p.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:cN||cU(),duration:c.duration,tweens:[],createTween:function(b,c,d){var e=p.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(e),e},stop:function(b){var c=0,d=b?j.tweens.length:0;for(;c<d;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;cX(k,j.opts.specialEasing);for(;e<g;e++){d=cS[e].call(j,a,k,j.opts);if(d)return d}return cV(j,k),p.isFunction(j.opts.start)&&j.opts.start.call(a,j),p.fx.timer(p.extend(i,{anim:j,queue:j.opts.queue,elem:a})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}function cX(a,b){var c,d,e,f,g;for(c in a){d=p.camelCase(c),e=b[d],f=a[c],p.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=p.cssHooks[d];if(g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}}function cY(a,b,c){var d,e,f,g,h,i,j,k,l=this,m=a.style,n={},o=[],q=a.nodeType&&bZ(a);c.queue||(j=p._queueHooks(a,"fx"),j.unqueued==null&&(j.unqueued=0,k=j.empty.fire,j.empty.fire=function(){j.unqueued||k()}),j.unqueued++,l.always(function(){l.always(function(){j.unqueued--,p.queue(a,"fx").length||j.empty.fire()})})),a.nodeType===1&&("height"in b||"width"in b)&&(c.overflow=[m.overflow,m.overflowX,m.overflowY],p.css(a,"display")==="inline"&&p.css(a,"float")==="none"&&(!p.support.inlineBlockNeedsLayout||cc(a.nodeName)==="inline"?m.display="inline-block":m.zoom=1)),c.overflow&&(m.overflow="hidden",p.support.shrinkWrapBlocks||l.done(function(){m.overflow=c.overflow[0],m.overflowX=c.overflow[1],m.overflowY=c.overflow[2]}));for(d in b){f=b[d];if(cP.exec(f)){delete b[d];if(f===(q?"hide":"show"))continue;o.push(d)}}g=o.length;if(g){h=p._data(a,"fxshow")||p._data(a,"fxshow",{}),q?p(a).show():l.done(function(){p(a).hide()}),l.done(function(){var b;p.removeData(a,"fxshow",!0);for(b in n)p.style(a,b,n[b])});for(d=0;d<g;d++)e=o[d],i=l.createTween(e,q?h[e]:0),n[e]=h[e]||p.style(a,e),e in h||(h[e]=i.start,q&&(i.end=i.start,i.start=e==="width"||e==="height"?1:0))}}function cZ(a,b,c,d,e){return new cZ.prototype.init(a,b,c,d,e)}function c$(a,b){var c,d={height:a},e=0;b=b?1:0;for(;e<4;e+=2-b)c=bV[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function da(a){return p.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}var c,d,e=a.document,f=a.location,g=a.navigator,h=a.jQuery,i=a.$,j=Array.prototype.push,k=Array.prototype.slice,l=Array.prototype.indexOf,m=Object.prototype.toString,n=Object.prototype.hasOwnProperty,o=String.prototype.trim,p=function(a,b){return new p.fn.init(a,b,c)},q=/[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,r=/\S/,s=/\s+/,t=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,u=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^[\],:{}\s]*$/,x=/(?:^|:|,)(?:\s*\[)+/g,y=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,z=/"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,A=/^-ms-/,B=/-([\da-z])/gi,C=function(a,b){return(b+"").toUpperCase()},D=function(){e.addEventListener?(e.removeEventListener("DOMContentLoaded",D,!1),p.ready()):e.readyState==="complete"&&(e.detachEvent("onreadystatechange",D),p.ready())},E={};p.fn=p.prototype={constructor:p,init:function(a,c,d){var f,g,h,i;if(!a)return this;if(a.nodeType)return this.context=this[0]=a,this.length=1,this;if(typeof a=="string"){a.charAt(0)==="<"&&a.charAt(a.length-1)===">"&&a.length>=3?f=[null,a,null]:f=u.exec(a);if(f&&(f[1]||!c)){if(f[1])return c=c instanceof p?c[0]:c,i=c&&c.nodeType?c.ownerDocument||c:e,a=p.parseHTML(f[1],i,!0),v.test(f[1])&&p.isPlainObject(c)&&this.attr.call(a,c,!0),p.merge(this,a);g=e.getElementById(f[2]);if(g&&g.parentNode){if(g.id!==f[2])return d.find(a);this.length=1,this[0]=g}return this.context=e,this.selector=a,this}return!c||c.jquery?(c||d).find(a):this.constructor(c).find(a)}return p.isFunction(a)?d.ready(a):(a.selector!==b&&(this.selector=a.selector,this.context=a.context),p.makeArray(a,this))},selector:"",jquery:"1.8.2",length:0,size:function(){return this.length},toArray:function(){return k.call(this)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=p.merge(this.constructor(),a);return d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")"),d},each:function(a,b){return p.each(this,a,b)},ready:function(a){return p.ready.promise().done(a),this},eq:function(a){return a=+a,a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(k.apply(this,arguments),"slice",k.call(arguments).join(","))},map:function(a){return this.pushStack(p.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:j,sort:[].sort,splice:[].splice},p.fn.init.prototype=p.fn,p.extend=p.fn.extend=function(){var a,c,d,e,f,g,h=arguments[0]||{},i=1,j=arguments.length,k=!1;typeof h=="boolean"&&(k=h,h=arguments[1]||{},i=2),typeof h!="object"&&!p.isFunction(h)&&(h={}),j===i&&(h=this,--i);for(;i<j;i++)if((a=arguments[i])!=null)for(c in a){d=h[c],e=a[c];if(h===e)continue;k&&e&&(p.isPlainObject(e)||(f=p.isArray(e)))?(f?(f=!1,g=d&&p.isArray(d)?d:[]):g=d&&p.isPlainObject(d)?d:{},h[c]=p.extend(k,g,e)):e!==b&&(h[c]=e)}return h},p.extend({noConflict:function(b){return a.$===p&&(a.$=i),b&&a.jQuery===p&&(a.jQuery=h),p},isReady:!1,readyWait:1,holdReady:function(a){a?p.readyWait++:p.ready(!0)},ready:function(a){if(a===!0?--p.readyWait:p.isReady)return;if(!e.body)return setTimeout(p.ready,1);p.isReady=!0;if(a!==!0&&--p.readyWait>0)return;d.resolveWith(e,[p]),p.fn.trigger&&p(e).trigger("ready").off("ready")},isFunction:function(a){return p.type(a)==="function"},isArray:Array.isArray||function(a){return p.type(a)==="array"},isWindow:function(a){return a!=null&&a==a.window},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):E[m.call(a)]||"object"},isPlainObject:function(a){if(!a||p.type(a)!=="object"||a.nodeType||p.isWindow(a))return!1;try{if(a.constructor&&!n.call(a,"constructor")&&!n.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||n.call(a,d)},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},error:function(a){throw new Error(a)},parseHTML:function(a,b,c){var d;return!a||typeof a!="string"?null:(typeof b=="boolean"&&(c=b,b=0),b=b||e,(d=v.exec(a))?[b.createElement(d[1])]:(d=p.buildFragment([a],b,c?null:[]),p.merge([],(d.cacheable?p.clone(d.fragment):d.fragment).childNodes)))},parseJSON:function(b){if(!b||typeof b!="string")return null;b=p.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(w.test(b.replace(y,"@").replace(z,"]").replace(x,"")))return(new Function("return "+b))();p.error("Invalid JSON: "+b)},parseXML:function(c){var d,e;if(!c||typeof c!="string")return null;try{a.DOMParser?(e=new DOMParser,d=e.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(f){d=b}return(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&p.error("Invalid XML: "+c),d},noop:function(){},globalEval:function(b){b&&r.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(A,"ms-").replace(B,C)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,c,d){var e,f=0,g=a.length,h=g===b||p.isFunction(a);if(d){if(h){for(e in a)if(c.apply(a[e],d)===!1)break}else for(;f<g;)if(c.apply(a[f++],d)===!1)break}else if(h){for(e in a)if(c.call(a[e],e,a[e])===!1)break}else for(;f<g;)if(c.call(a[f],f,a[f++])===!1)break;return a},trim:o&&!o.call("﻿ ")?function(a){return a==null?"":o.call(a)}:function(a){return a==null?"":(a+"").replace(t,"")},makeArray:function(a,b){var c,d=b||[];return a!=null&&(c=p.type(a),a.length==null||c==="string"||c==="function"||c==="regexp"||p.isWindow(a)?j.call(d,a):p.merge(d,a)),d},inArray:function(a,b,c){var d;if(b){if(l)return l.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=c.length,e=a.length,f=0;if(typeof d=="number")for(;f<d;f++)a[e++]=c[f];else while(c[f]!==b)a[e++]=c[f++];return a.length=e,a},grep:function(a,b,c){var d,e=[],f=0,g=a.length;c=!!c;for(;f<g;f++)d=!!b(a[f],f),c!==d&&e.push(a[f]);return e},map:function(a,c,d){var e,f,g=[],h=0,i=a.length,j=a instanceof p||i!==b&&typeof i=="number"&&(i>0&&a[0]&&a[i-1]||i===0||p.isArray(a));if(j)for(;h<i;h++)e=c(a[h],h,d),e!=null&&(g[g.length]=e);else for(f in a)e=c(a[f],f,d),e!=null&&(g[g.length]=e);return g.concat.apply([],g)},guid:1,proxy:function(a,c){var d,e,f;return typeof c=="string"&&(d=a[c],c=a,a=d),p.isFunction(a)?(e=k.call(arguments,2),f=function(){return a.apply(c,e.concat(k.call(arguments)))},f.guid=a.guid=a.guid||p.guid++,f):b},access:function(a,c,d,e,f,g,h){var i,j=d==null,k=0,l=a.length;if(d&&typeof d=="object"){for(k in d)p.access(a,c,k,d[k],1,g,e);f=1}else if(e!==b){i=h===b&&p.isFunction(e),j&&(i?(i=c,c=function(a,b,c){return i.call(p(a),c)}):(c.call(a,e),c=null));if(c)for(;k<l;k++)c(a[k],d,i?e.call(a[k],k,c(a[k],d)):e,h);f=1}return f?a:j?c.call(a):l?c(a[0],d):g},now:function(){return(new Date).getTime()}}),p.ready.promise=function(b){if(!d){d=p.Deferred();if(e.readyState==="complete")setTimeout(p.ready,1);else if(e.addEventListener)e.addEventListener("DOMContentLoaded",D,!1),a.addEventListener("load",p.ready,!1);else{e.attachEvent("onreadystatechange",D),a.attachEvent("onload",p.ready);var c=!1;try{c=a.frameElement==null&&e.documentElement}catch(f){}c&&c.doScroll&&function g(){if(!p.isReady){try{c.doScroll("left")}catch(a){return setTimeout(g,50)}p.ready()}}()}}return d.promise(b)},p.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){E["[object "+b+"]"]=b.toLowerCase()}),c=p(e);var F={};p.Callbacks=function(a){a=typeof a=="string"?F[a]||G(a):p.extend({},a);var c,d,e,f,g,h,i=[],j=!a.once&&[],k=function(b){c=a.memory&&b,d=!0,h=f||0,f=0,g=i.length,e=!0;for(;i&&h<g;h++)if(i[h].apply(b[0],b[1])===!1&&a.stopOnFalse){c=!1;break}e=!1,i&&(j?j.length&&k(j.shift()):c?i=[]:l.disable())},l={add:function(){if(i){var b=i.length;(function d(b){p.each(b,function(b,c){var e=p.type(c);e==="function"&&(!a.unique||!l.has(c))?i.push(c):c&&c.length&&e!=="string"&&d(c)})})(arguments),e?g=i.length:c&&(f=b,k(c))}return this},remove:function(){return i&&p.each(arguments,function(a,b){var c;while((c=p.inArray(b,i,c))>-1)i.splice(c,1),e&&(c<=g&&g--,c<=h&&h--)}),this},has:function(a){return p.inArray(a,i)>-1},empty:function(){return i=[],this},disable:function(){return i=j=c=b,this},disabled:function(){return!i},lock:function(){return j=b,c||l.disable(),this},locked:function(){return!j},fireWith:function(a,b){return b=b||[],b=[a,b.slice?b.slice():b],i&&(!d||j)&&(e?j.push(b):k(b)),this},fire:function(){return l.fireWith(this,arguments),this},fired:function(){return!!d}};return l},p.extend({Deferred:function(a){var b=[["resolve","done",p.Callbacks("once memory"),"resolved"],["reject","fail",p.Callbacks("once memory"),"rejected"],["notify","progress",p.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return p.Deferred(function(c){p.each(b,function(b,d){var f=d[0],g=a[b];e[d[1]](p.isFunction(g)?function(){var a=g.apply(this,arguments);a&&p.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f+"With"](this===e?c:this,[a])}:c[f])}),a=null}).promise()},promise:function(a){return a!=null?p.extend(a,d):d}},e={};return d.pipe=d.then,p.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[a^1][2].disable,b[2][2].lock),e[f[0]]=g.fire,e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=k.call(arguments),d=c.length,e=d!==1||a&&p.isFunction(a.promise)?d:0,f=e===1?a:p.Deferred(),g=function(a,b,c){return function(d){b[a]=this,c[a]=arguments.length>1?k.call(arguments):d,c===h?f.notifyWith(b,c):--e||f.resolveWith(b,c)}},h,i,j;if(d>1){h=new Array(d),i=new Array(d),j=new Array(d);for(;b<d;b++)c[b]&&p.isFunction(c[b].promise)?c[b].promise().done(g(b,j,c)).fail(f.reject).progress(g(b,i,h)):--e}return e||f.resolveWith(j,c),f.promise()}}),p.support=function(){var b,c,d,f,g,h,i,j,k,l,m,n=e.createElement("div");n.setAttribute("className","t"),n.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",c=n.getElementsByTagName("*"),d=n.getElementsByTagName("a")[0],d.style.cssText="top:1px;float:left;opacity:.5";if(!c||!c.length)return{};f=e.createElement("select"),g=f.appendChild(e.createElement("option")),h=n.getElementsByTagName("input")[0],b={leadingWhitespace:n.firstChild.nodeType===3,tbody:!n.getElementsByTagName("tbody").length,htmlSerialize:!!n.getElementsByTagName("link").length,style:/top/.test(d.getAttribute("style")),hrefNormalized:d.getAttribute("href")==="/a",opacity:/^0.5/.test(d.style.opacity),cssFloat:!!d.style.cssFloat,checkOn:h.value==="on",optSelected:g.selected,getSetAttribute:n.className!=="t",enctype:!!e.createElement("form").enctype,html5Clone:e.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",boxModel:e.compatMode==="CSS1Compat",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},h.checked=!0,b.noCloneChecked=h.cloneNode(!0).checked,f.disabled=!0,b.optDisabled=!g.disabled;try{delete n.test}catch(o){b.deleteExpando=!1}!n.addEventListener&&n.attachEvent&&n.fireEvent&&(n.attachEvent("onclick",m=function(){b.noCloneEvent=!1}),n.cloneNode(!0).fireEvent("onclick"),n.detachEvent("onclick",m)),h=e.createElement("input"),h.value="t",h.setAttribute("type","radio"),b.radioValue=h.value==="t",h.setAttribute("checked","checked"),h.setAttribute("name","t"),n.appendChild(h),i=e.createDocumentFragment(),i.appendChild(n.lastChild),b.checkClone=i.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=h.checked,i.removeChild(h),i.appendChild(n);if(n.attachEvent)for(k in{submit:!0,change:!0,focusin:!0})j="on"+k,l=j in n,l||(n.setAttribute(j,"return;"),l=typeof n[j]=="function"),b[k+"Bubbles"]=l;return p(function(){var c,d,f,g,h="padding:0;margin:0;border:0;display:block;overflow:hidden;",i=e.getElementsByTagName("body")[0];if(!i)return;c=e.createElement("div"),c.style.cssText="visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px",i.insertBefore(c,i.firstChild),d=e.createElement("div"),c.appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",f=d.getElementsByTagName("td"),f[0].style.cssText="padding:0;margin:0;border:0;display:none",l=f[0].offsetHeight===0,f[0].style.display="",f[1].style.display="none",b.reliableHiddenOffsets=l&&f[0].offsetHeight===0,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",b.boxSizing=d.offsetWidth===4,b.doesNotIncludeMarginInBodyOffset=i.offsetTop!==1,a.getComputedStyle&&(b.pixelPosition=(a.getComputedStyle(d,null)||{}).top!=="1%",b.boxSizingReliable=(a.getComputedStyle(d,null)||{width:"4px"}).width==="4px",g=e.createElement("div"),g.style.cssText=d.style.cssText=h,g.style.marginRight=g.style.width="0",d.style.width="1px",d.appendChild(g),b.reliableMarginRight=!parseFloat((a.getComputedStyle(g,null)||{}).marginRight)),typeof d.style.zoom!="undefined"&&(d.innerHTML="",d.style.cssText=h+"width:1px;padding:1px;display:inline;zoom:1",b.inlineBlockNeedsLayout=d.offsetWidth===3,d.style.display="block",d.style.overflow="visible",d.innerHTML="<div></div>",d.firstChild.style.width="5px",b.shrinkWrapBlocks=d.offsetWidth!==3,c.style.zoom=1),i.removeChild(c),c=d=f=g=null}),i.removeChild(n),c=d=f=g=h=i=n=null,b}();var H=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,I=/([A-Z])/g;p.extend({cache:{},deletedIds:[],uuid:0,expando:"jQuery"+(p.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){return a=a.nodeType?p.cache[a[p.expando]]:a[p.expando],!!a&&!K(a)},data:function(a,c,d,e){if(!p.acceptData(a))return;var f,g,h=p.expando,i=typeof c=="string",j=a.nodeType,k=j?p.cache:a,l=j?a[h]:a[h]&&h;if((!l||!k[l]||!e&&!k[l].data)&&i&&d===b)return;l||(j?a[h]=l=p.deletedIds.pop()||p.guid++:l=h),k[l]||(k[l]={},j||(k[l].toJSON=p.noop));if(typeof c=="object"||typeof c=="function")e?k[l]=p.extend(k[l],c):k[l].data=p.extend(k[l].data,c);return f=k[l],e||(f.data||(f.data={}),f=f.data),d!==b&&(f[p.camelCase(c)]=d),i?(g=f[c],g==null&&(g=f[p.camelCase(c)])):g=f,g},removeData:function(a,b,c){if(!p.acceptData(a))return;var d,e,f,g=a.nodeType,h=g?p.cache:a,i=g?a[p.expando]:p.expando;if(!h[i])return;if(b){d=c?h[i]:h[i].data;if(d){p.isArray(b)||(b in d?b=[b]:(b=p.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,f=b.length;e<f;e++)delete d[b[e]];if(!(c?K:p.isEmptyObject)(d))return}}if(!c){delete h[i].data;if(!K(h[i]))return}g?p.cleanData([a],!0):p.support.deleteExpando||h!=h.window?delete h[i]:h[i]=null},_data:function(a,b,c){return p.data(a,b,c,!0)},acceptData:function(a){var b=a.nodeName&&p.noData[a.nodeName.toLowerCase()];return!b||b!==!0&&a.getAttribute("classid")===b}}),p.fn.extend({data:function(a,c){var d,e,f,g,h,i=this[0],j=0,k=null;if(a===b){if(this.length){k=p.data(i);if(i.nodeType===1&&!p._data(i,"parsedAttrs")){f=i.attributes;for(h=f.length;j<h;j++)g=f[j].name,g.indexOf("data-")||(g=p.camelCase(g.substring(5)),J(i,g,k[g]));p._data(i,"parsedAttrs",!0)}}return k}return typeof a=="object"?this.each(function(){p.data(this,a)}):(d=a.split(".",2),d[1]=d[1]?"."+d[1]:"",e=d[1]+"!",p.access(this,function(c){if(c===b)return k=this.triggerHandler("getData"+e,[d[0]]),k===b&&i&&(k=p.data(i,a),k=J(i,a,k)),k===b&&d[1]?this.data(d[0]):k;d[1]=c,this.each(function(){var b=p(this);b.triggerHandler("setData"+e,d),p.data(this,a,c),b.triggerHandler("changeData"+e,d)})},null,c,arguments.length>1,null,!1))},removeData:function(a){return this.each(function(){p.removeData(this,a)})}}),p.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=p._data(a,b),c&&(!d||p.isArray(c)?d=p._data(a,b,p.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=p.queue(a,b),d=c.length,e=c.shift(),f=p._queueHooks(a,b),g=function(){p.dequeue(a,b)};e==="inprogress"&&(e=c.shift(),d--),e&&(b==="fx"&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return p._data(a,c)||p._data(a,c,{empty:p.Callbacks("once memory").add(function(){p.removeData(a,b+"queue",!0),p.removeData(a,c,!0)})})}}),p.fn.extend({queue:function(a,c){var d=2;return typeof a!="string"&&(c=a,a="fx",d--),arguments.length<d?p.queue(this[0],a):c===b?this:this.each(function(){var b=p.queue(this,a,c);p._queueHooks(this,a),a==="fx"&&b[0]!=="inprogress"&&p.dequeue(this,a)})},dequeue:function(a){return this.each(function(){p.dequeue(this,a)})},delay:function(a,b){return a=p.fx?p.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){var d,e=1,f=p.Deferred(),g=this,h=this.length,i=function(){--e||f.resolveWith(g,[g])};typeof a!="string"&&(c=a,a=b),a=a||"fx";while(h--)d=p._data(g[h],a+"queueHooks"),d&&d.empty&&(e++,d.empty.add(i));return i(),f.promise(c)}});var L,M,N,O=/[\t\r\n]/g,P=/\r/g,Q=/^(?:button|input)$/i,R=/^(?:button|input|object|select|textarea)$/i,S=/^a(?:rea|)$/i,T=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,U=p.support.getSetAttribute;p.fn.extend({attr:function(a,b){return p.access(this,p.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){p.removeAttr(this,a)})},prop:function(a,b){return p.access(this,p.prop,a,b,arguments.length>1)},removeProp:function(a){return a=p.propFix[a]||a,this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,f,g,h;if(p.isFunction(a))return this.each(function(b){p(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(s);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{f=" "+e.className+" ";for(g=0,h=b.length;g<h;g++)f.indexOf(" "+b[g]+" ")<0&&(f+=b[g]+" ");e.className=p.trim(f)}}}return this},removeClass:function(a){var c,d,e,f,g,h,i;if(p.isFunction(a))return this.each(function(b){p(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(s);for(h=0,i=this.length;h<i;h++){e=this[h];if(e.nodeType===1&&e.className){d=(" "+e.className+" ").replace(O," ");for(f=0,g=c.length;f<g;f++)while(d.indexOf(" "+c[f]+" ")>=0)d=d.replace(" "+c[f]+" "," ");e.className=a?p.trim(d):""}}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";return p.isFunction(a)?this.each(function(c){p(this).toggleClass(a.call(this,c,this.className,b),b)}):this.each(function(){if(c==="string"){var e,f=0,g=p(this),h=b,i=a.split(s);while(e=i[f++])h=d?h:!g.hasClass(e),g[h?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&p._data(this,"__className__",this.className),this.className=this.className||a===!1?"":p._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(O," ").indexOf(b)>=0)return!0;return!1},val:function(a){var c,d,e,f=this[0];if(!arguments.length){if(f)return c=p.valHooks[f.type]||p.valHooks[f.nodeName.toLowerCase()],c&&"get"in c&&(d=c.get(f,"value"))!==b?d:(d=f.value,typeof d=="string"?d.replace(P,""):d==null?"":d);return}return e=p.isFunction(a),this.each(function(d){var f,g=p(this);if(this.nodeType!==1)return;e?f=a.call(this,d,g.val()):f=a,f==null?f="":typeof f=="number"?f+="":p.isArray(f)&&(f=p.map(f,function(a){return a==null?"":a+""})),c=p.valHooks[this.type]||p.valHooks[this.nodeName.toLowerCase()];if(!c||!("set"in c)||c.set(this,f,"value")===b)this.value=f})}}),p.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,f=a.selectedIndex,g=[],h=a.options,i=a.type==="select-one";if(f<0)return null;c=i?f:0,d=i?f+1:h.length;for(;c<d;c++){e=h[c];if(e.selected&&(p.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!p.nodeName(e.parentNode,"optgroup"))){b=p(e).val();if(i)return b;g.push(b)}}return i&&!g.length&&h.length?p(h[f]).val():g},set:function(a,b){var c=p.makeArray(b);return p(a).find("option").each(function(){this.selected=p.inArray(p(this).val(),c)>=0}),c.length||(a.selectedIndex=-1),c}}},attrFn:{},attr:function(a,c,d,e){var f,g,h,i=a.nodeType;if(!a||i===3||i===8||i===2)return;if(e&&p.isFunction(p.fn[c]))return p(a)[c](d);if(typeof a.getAttribute=="undefined")return p.prop(a,c,d);h=i!==1||!p.isXMLDoc(a),h&&(c=c.toLowerCase(),g=p.attrHooks[c]||(T.test(c)?M:L));if(d!==b){if(d===null){p.removeAttr(a,c);return}return g&&"set"in g&&h&&(f=g.set(a,d,c))!==b?f:(a.setAttribute(c,d+""),d)}return g&&"get"in g&&h&&(f=g.get(a,c))!==null?f:(f=a.getAttribute(c),f===null?b:f)},removeAttr:function(a,b){var c,d,e,f,g=0;if(b&&a.nodeType===1){d=b.split(s);for(;g<d.length;g++)e=d[g],e&&(c=p.propFix[e]||e,f=T.test(e),f||p.attr(a,e,""),a.removeAttribute(U?e:c),f&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(Q.test(a.nodeName)&&a.parentNode)p.error("type property can't be changed");else if(!p.support.radioValue&&b==="radio"&&p.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}},value:{get:function(a,b){return L&&p.nodeName(a,"button")?L.get(a,b):b in a?a.value:null},set:function(a,b,c){if(L&&p.nodeName(a,"button"))return L.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,f,g,h=a.nodeType;if(!a||h===3||h===8||h===2)return;return g=h!==1||!p.isXMLDoc(a),g&&(c=p.propFix[c]||c,f=p.propHooks[c]),d!==b?f&&"set"in f&&(e=f.set(a,d,c))!==b?e:a[c]=d:f&&"get"in f&&(e=f.get(a,c))!==null?e:a[c]},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):R.test(a.nodeName)||S.test(a.nodeName)&&a.href?0:b}}}}),M={get:function(a,c){var d,e=p.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;return b===!1?p.removeAttr(a,c):(d=p.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase())),c}},U||(N={name:!0,id:!0,coords:!0},L=p.valHooks.button={get:function(a,c){var d;return d=a.getAttributeNode(c),d&&(N[c]?d.value!=="":d.specified)?d.value:b},set:function(a,b,c){var d=a.getAttributeNode(c);return d||(d=e.createAttribute(c),a.setAttributeNode(d)),d.value=b+""}},p.each(["width","height"],function(a,b){p.attrHooks[b]=p.extend(p.attrHooks[b],{set:function(a,c){if(c==="")return a.setAttribute(b,"auto"),c}})}),p.attrHooks.contenteditable={get:L.get,set:function(a,b,c){b===""&&(b="false"),L.set(a,b,c)}}),p.support.hrefNormalized||p.each(["href","src","width","height"],function(a,c){p.attrHooks[c]=p.extend(p.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),p.support.style||(p.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=b+""}}),p.support.optSelected||(p.propHooks.selected=p.extend(p.propHooks.selected,{get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}})),p.support.enctype||(p.propFix.enctype="encoding"),p.support.checkOn||p.each(["radio","checkbox"],function(){p.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),p.each(["radio","checkbox"],function(){p.valHooks[this]=p.extend(p.valHooks[this],{set:function(a,b){if(p.isArray(b))return a.checked=p.inArray(p(a).val(),b)>=0}})});var V=/^(?:textarea|input|select)$/i,W=/^([^\.]*|)(?:\.(.+)|)$/,X=/(?:^|\s)hover(\.\S+|)\b/,Y=/^key/,Z=/^(?:mouse|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=function(a){return p.event.special.hover?a:a.replace(X,"mouseenter$1 mouseleave$1")};p.event={add:function(a,c,d,e,f){var g,h,i,j,k,l,m,n,o,q,r;if(a.nodeType===3||a.nodeType===8||!c||!d||!(g=p._data(a)))return;d.handler&&(o=d,d=o.handler,f=o.selector),d.guid||(d.guid=p.guid++),i=g.events,i||(g.events=i={}),h=g.handle,h||(g.handle=h=function(a){return typeof p!="undefined"&&(!a||p.event.triggered!==a.type)?p.event.dispatch.apply(h.elem,arguments):b},h.elem=a),c=p.trim(_(c)).split(" ");for(j=0;j<c.length;j++){k=W.exec(c[j])||[],l=k[1],m=(k[2]||"").split(".").sort(),r=p.event.special[l]||{},l=(f?r.delegateType:r.bindType)||l,r=p.event.special[l]||{},n=p.extend({type:l,origType:k[1],data:e,handler:d,guid:d.guid,selector:f,needsContext:f&&p.expr.match.needsContext.test(f),namespace:m.join(".")},o),q=i[l];if(!q){q=i[l]=[],q.delegateCount=0;if(!r.setup||r.setup.call(a,e,m,h)===!1)a.addEventListener?a.addEventListener(l,h,!1):a.attachEvent&&a.attachEvent("on"+l,h)}r.add&&(r.add.call(a,n),n.handler.guid||(n.handler.guid=d.guid)),f?q.splice(q.delegateCount++,0,n):q.push(n),p.event.global[l]=!0}a=null},global:{},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,q,r=p.hasData(a)&&p._data(a);if(!r||!(m=r.events))return;b=p.trim(_(b||"")).split(" ");for(f=0;f<b.length;f++){g=W.exec(b[f])||[],h=i=g[1],j=g[2];if(!h){for(h in m)p.event.remove(a,h+b[f],c,d,!0);continue}n=p.event.special[h]||{},h=(d?n.delegateType:n.bindType)||h,o=m[h]||[],k=o.length,j=j?new RegExp("(^|\\.)"+j.split(".").sort().join("\\.(?:.*\\.|)")+"(\\.|$)"):null;for(l=0;l<o.length;l++)q=o[l],(e||i===q.origType)&&(!c||c.guid===q.guid)&&(!j||j.test(q.namespace))&&(!d||d===q.selector||d==="**"&&q.selector)&&(o.splice(l--,1),q.selector&&o.delegateCount--,n.remove&&n.remove.call(a,q));o.length===0&&k!==o.length&&((!n.teardown||n.teardown.call(a,j,r.handle)===!1)&&p.removeEvent(a,h,r.handle),delete m[h])}p.isEmptyObject(m)&&(delete r.handle,p.removeData(a,"events",!0))},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,f,g){if(!f||f.nodeType!==3&&f.nodeType!==8){var h,i,j,k,l,m,n,o,q,r,s=c.type||c,t=[];if($.test(s+p.event.triggered))return;s.indexOf("!")>=0&&(s=s.slice(0,-1),i=!0),s.indexOf(".")>=0&&(t=s.split("."),s=t.shift(),t.sort());if((!f||p.event.customEvent[s])&&!p.event.global[s])return;c=typeof c=="object"?c[p.expando]?c:new p.Event(s,c):new p.Event(s),c.type=s,c.isTrigger=!0,c.exclusive=i,c.namespace=t.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+t.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,m=s.indexOf(":")<0?"on"+s:"";if(!f){h=p.cache;for(j in h)h[j].events&&h[j].events[s]&&p.event.trigger(c,d,h[j].handle.elem,!0);return}c.result=b,c.target||(c.target=f),d=d!=null?p.makeArray(d):[],d.unshift(c),n=p.event.special[s]||{};if(n.trigger&&n.trigger.apply(f,d)===!1)return;q=[[f,n.bindType||s]];if(!g&&!n.noBubble&&!p.isWindow(f)){r=n.delegateType||s,k=$.test(r+s)?f:f.parentNode;for(l=f;k;k=k.parentNode)q.push([k,r]),l=k;l===(f.ownerDocument||e)&&q.push([l.defaultView||l.parentWindow||a,r])}for(j=0;j<q.length&&!c.isPropagationStopped();j++)k=q[j][0],c.type=q[j][1],o=(p._data(k,"events")||{})[c.type]&&p._data(k,"handle"),o&&o.apply(k,d),o=m&&k[m],o&&p.acceptData(k)&&o.apply&&o.apply(k,d)===!1&&c.preventDefault();return c.type=s,!g&&!c.isDefaultPrevented()&&(!n._default||n._default.apply(f.ownerDocument,d)===!1)&&(s!=="click"||!p.nodeName(f,"a"))&&p.acceptData(f)&&m&&f[s]&&(s!=="focus"&&s!=="blur"||c.target.offsetWidth!==0)&&!p.isWindow(f)&&(l=f[m],l&&(f[m]=null),p.event.triggered=s,f[s](),p.event.triggered=b,l&&(f[m]=l)),c.result}return},dispatch:function(c){c=p.event.fix(c||a.event);var d,e,f,g,h,i,j,l,m,n,o=(p._data(this,"events")||{})[c.type]||[],q=o.delegateCount,r=k.call(arguments),s=!c.exclusive&&!c.namespace,t=p.event.special[c.type]||{},u=[];r[0]=c,c.delegateTarget=this;if(t.preDispatch&&t.preDispatch.call(this,c)===!1)return;if(q&&(!c.button||c.type!=="click"))for(f=c.target;f!=this;f=f.parentNode||this)if(f.disabled!==!0||c.type!=="click"){h={},j=[];for(d=0;d<q;d++)l=o[d],m=l.selector,h[m]===b&&(h[m]=l.needsContext?p(m,this).index(f)>=0:p.find(m,this,null,[f]).length),h[m]&&j.push(l);j.length&&u.push({elem:f,matches:j})}o.length>q&&u.push({elem:this,matches:o.slice(q)});for(d=0;d<u.length&&!c.isPropagationStopped();d++){i=u[d],c.currentTarget=i.elem;for(e=0;e<i.matches.length&&!c.isImmediatePropagationStopped();e++){l=i.matches[e];if(s||!c.namespace&&!l.namespace||c.namespace_re&&c.namespace_re.test(l.namespace))c.data=l.data,c.handleObj=l,g=((p.event.special[l.origType]||{}).handle||l.handler).apply(i.elem,r),g!==b&&(c.result=g,g===!1&&(c.preventDefault(),c.stopPropagation()))}}return t.postDispatch&&t.postDispatch.call(this,c),c.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,c){var d,f,g,h=c.button,i=c.fromElement;return a.pageX==null&&c.clientX!=null&&(d=a.target.ownerDocument||e,f=d.documentElement,g=d.body,a.pageX=c.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=c.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?c.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0),a}},fix:function(a){if(a[p.expando])return a;var b,c,d=a,f=p.event.fixHooks[a.type]||{},g=f.props?this.props.concat(f.props):this.props;a=p.Event(d);for(b=g.length;b;)c=g[--b],a[c]=d[c];return a.target||(a.target=d.srcElement||e),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,f.filter?f.filter(a,d):a},special:{load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){p.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=p.extend(new p.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?p.event.trigger(e,null,b):p.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},p.event.handle=p.event.dispatch,p.removeEvent=e.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]=="undefined"&&(a[d]=null),a.detachEvent(d,c))},p.Event=function(a,b){if(this instanceof p.Event)a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?bb:ba):this.type=a,b&&p.extend(this,b),this.timeStamp=a&&a.timeStamp||p.now(),this[p.expando]=!0;else return new p.Event(a,b)},p.Event.prototype={preventDefault:function(){this.isDefaultPrevented=bb;var a=this.originalEvent;if(!a)return;a.preventDefault?a.preventDefault():a.returnValue=!1},stopPropagation:function(){this.isPropagationStopped=bb;var a=this.originalEvent;if(!a)return;a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=bb,this.stopPropagation()},isDefaultPrevented:ba,isPropagationStopped:ba,isImmediatePropagationStopped:ba},p.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){p.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj,g=f.selector;if(!e||e!==d&&!p.contains(d,e))a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b;return c}}}),p.support.submitBubbles||(p.event.special.submit={setup:function(){if(p.nodeName(this,"form"))return!1;p.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=p.nodeName(c,"input")||p.nodeName(c,"button")?c.form:b;d&&!p._data(d,"_submit_attached")&&(p.event.add(d,"submit._submit",function(a){a._submit_bubble=!0}),p._data(d,"_submit_attached",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&p.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){if(p.nodeName(this,"form"))return!1;p.event.remove(this,"._submit")}}),p.support.changeBubbles||(p.event.special.change={setup:function(){if(V.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")p.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),p.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),p.event.simulate("change",this,a,!0)});return!1}p.event.add(this,"beforeactivate._change",function(a){var b=a.target;V.test(b.nodeName)&&!p._data(b,"_change_attached")&&(p.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&p.event.simulate("change",this.parentNode,a,!0)}),p._data(b,"_change_attached",!0))})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){return p.event.remove(this,"._change"),!V.test(this.nodeName)}}),p.support.focusinBubbles||p.each({focus:"focusin",blur:"focusout"},function(a,b){var c=0,d=function(a){p.event.simulate(b,a.target,p.event.fix(a),!0)};p.event.special[b]={setup:function(){c++===0&&e.addEventListener(a,d,!0)},teardown:function(){--c===0&&e.removeEventListener(a,d,!0)}}}),p.fn.extend({on:function(a,c,d,e,f){var g,h;if(typeof a=="object"){typeof c!="string"&&(d=d||c,c=b);for(h in a)this.on(h,c,d,a[h],f);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=ba;else if(!e)return this;return f===1&&(g=e,e=function(a){return p().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=p.guid++)),this.each(function(){p.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,c,d){var e,f;if(a&&a.preventDefault&&a.handleObj)return e=a.handleObj,p(a.delegateTarget).off(e.namespace?e.origType+"."+e.namespace:e.origType,e.selector,e.handler),this;if(typeof a=="object"){for(f in a)this.off(f,c,a[f]);return this}if(c===!1||typeof c=="function")d=c,c=b;return d===!1&&(d=ba),this.each(function(){p.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){return p(this.context).on(a,this.selector,b,c),this},die:function(a,b){return p(this.context).off(a,this.selector||"**",b),this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length===1?this.off(a,"**"):this.off(b,a||"**",c)},trigger:function(a,b){return this.each(function(){p.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return p.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||p.guid++,d=0,e=function(c){var e=(p._data(this,"lastToggle"+a.guid)||0)%d;return p._data(this,"lastToggle"+a.guid,e+1),c.preventDefault(),b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),p.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){p.fn[b]=function(a,c){return c==null&&(c=a,a=null),arguments.length>0?this.on(b,null,a,c):this.trigger(b)},Y.test(b)&&(p.event.fixHooks[b]=p.event.keyHooks),Z.test(b)&&(p.event.fixHooks[b]=p.event.mouseHooks)}),function(a,b){function bc(a,b,c,d){c=c||[],b=b||r;var e,f,i,j,k=b.nodeType;if(!a||typeof a!="string")return c;if(k!==1&&k!==9)return[];i=g(b);if(!i&&!d)if(e=P.exec(a))if(j=e[1]){if(k===9){f=b.getElementById(j);if(!f||!f.parentNode)return c;if(f.id===j)return c.push(f),c}else if(b.ownerDocument&&(f=b.ownerDocument.getElementById(j))&&h(b,f)&&f.id===j)return c.push(f),c}else{if(e[2])return w.apply(c,x.call(b.getElementsByTagName(a),0)),c;if((j=e[3])&&_&&b.getElementsByClassName)return w.apply(c,x.call(b.getElementsByClassName(j),0)),c}return bp(a.replace(L,"$1"),b,c,d,i)}function bd(a){return function(b){var c=b.nodeName.toLowerCase();return c==="input"&&b.type===a}}function be(a){return function(b){var c=b.nodeName.toLowerCase();return(c==="input"||c==="button")&&b.type===a}}function bf(a){return z(function(b){return b=+b,z(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function bg(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}function bh(a,b){var c,d,f,g,h,i,j,k=C[o][a];if(k)return b?0:k.slice(0);h=a,i=[],j=e.preFilter;while(h){if(!c||(d=M.exec(h)))d&&(h=h.slice(d[0].length)),i.push(f=[]);c=!1;if(d=N.exec(h))f.push(c=new q(d.shift())),h=h.slice(c.length),c.type=d[0].replace(L," ");for(g in e.filter)(d=W[g].exec(h))&&(!j[g]||(d=j[g](d,r,!0)))&&(f.push(c=new q(d.shift())),h=h.slice(c.length),c.type=g,c.matches=d);if(!c)break}return b?h.length:h?bc.error(a):C(a,i).slice(0)}function bi(a,b,d){var e=b.dir,f=d&&b.dir==="parentNode",g=u++;return b.first?function(b,c,d){while(b=b[e])if(f||b.nodeType===1)return a(b,c,d)}:function(b,d,h){if(!h){var i,j=t+" "+g+" ",k=j+c;while(b=b[e])if(f||b.nodeType===1){if((i=b[o])===k)return b.sizset;if(typeof i=="string"&&i.indexOf(j)===0){if(b.sizset)return b}else{b[o]=k;if(a(b,d,h))return b.sizset=!0,b;b.sizset=!1}}}else while(b=b[e])if(f||b.nodeType===1)if(a(b,d,h))return b}}function bj(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function bk(a,b,c,d,e){var f,g=[],h=0,i=a.length,j=b!=null;for(;h<i;h++)if(f=a[h])if(!c||c(f,d,e))g.push(f),j&&b.push(h);return g}function bl(a,b,c,d,e,f){return d&&!d[o]&&(d=bl(d)),e&&!e[o]&&(e=bl(e,f)),z(function(f,g,h,i){if(f&&e)return;var j,k,l,m=[],n=[],o=g.length,p=f||bo(b||"*",h.nodeType?[h]:h,[],f),q=a&&(f||!b)?bk(p,m,a,h,i):p,r=c?e||(f?a:o||d)?[]:g:q;c&&c(q,r,h,i);if(d){l=bk(r,n),d(l,[],h,i),j=l.length;while(j--)if(k=l[j])r[n[j]]=!(q[n[j]]=k)}if(f){j=a&&r.length;while(j--)if(k=r[j])f[m[j]]=!(g[m[j]]=k)}else r=bk(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):w.apply(g,r)})}function bm(a){var b,c,d,f=a.length,g=e.relative[a[0].type],h=g||e.relative[" "],i=g?1:0,j=bi(function(a){return a===b},h,!0),k=bi(function(a){return y.call(b,a)>-1},h,!0),m=[function(a,c,d){return!g&&(d||c!==l)||((b=c).nodeType?j(a,c,d):k(a,c,d))}];for(;i<f;i++)if(c=e.relative[a[i].type])m=[bi(bj(m),c)];else{c=e.filter[a[i].type].apply(null,a[i].matches);if(c[o]){d=++i;for(;d<f;d++)if(e.relative[a[d].type])break;return bl(i>1&&bj(m),i>1&&a.slice(0,i-1).join("").replace(L,"$1"),c,i<d&&bm(a.slice(i,d)),d<f&&bm(a=a.slice(d)),d<f&&a.join(""))}m.push(c)}return bj(m)}function bn(a,b){var d=b.length>0,f=a.length>0,g=function(h,i,j,k,m){var n,o,p,q=[],s=0,u="0",x=h&&[],y=m!=null,z=l,A=h||f&&e.find.TAG("*",m&&i.parentNode||i),B=t+=z==null?1:Math.E;y&&(l=i!==r&&i,c=g.el);for(;(n=A[u])!=null;u++){if(f&&n){for(o=0;p=a[o];o++)if(p(n,i,j)){k.push(n);break}y&&(t=B,c=++g.el)}d&&((n=!p&&n)&&s--,h&&x.push(n))}s+=u;if(d&&u!==s){for(o=0;p=b[o];o++)p(x,q,i,j);if(h){if(s>0)while(u--)!x[u]&&!q[u]&&(q[u]=v.call(k));q=bk(q)}w.apply(k,q),y&&!h&&q.length>0&&s+b.length>1&&bc.uniqueSort(k)}return y&&(t=B,l=z),x};return g.el=0,d?z(g):g}function bo(a,b,c,d){var e=0,f=b.length;for(;e<f;e++)bc(a,b[e],c,d);return c}function bp(a,b,c,d,f){var g,h,j,k,l,m=bh(a),n=m.length;if(!d&&m.length===1){h=m[0]=m[0].slice(0);if(h.length>2&&(j=h[0]).type==="ID"&&b.nodeType===9&&!f&&e.relative[h[1].type]){b=e.find.ID(j.matches[0].replace(V,""),b,f)[0];if(!b)return c;a=a.slice(h.shift().length)}for(g=W.POS.test(a)?-1:h.length-1;g>=0;g--){j=h[g];if(e.relative[k=j.type])break;if(l=e.find[k])if(d=l(j.matches[0].replace(V,""),R.test(h[0].type)&&b.parentNode||b,f)){h.splice(g,1),a=d.length&&h.join("");if(!a)return w.apply(c,x.call(d,0)),c;break}}}return i(a,m)(d,b,f,c,R.test(a)),c}function bq(){}var c,d,e,f,g,h,i,j,k,l,m=!0,n="undefined",o=("sizcache"+Math.random()).replace(".",""),q=String,r=a.document,s=r.documentElement,t=0,u=0,v=[].pop,w=[].push,x=[].slice,y=[].indexOf||function(a){var b=0,c=this.length;for(;b<c;b++)if(this[b]===a)return b;return-1},z=function(a,b){return a[o]=b==null||b,a},A=function(){var a={},b=[];return z(function(c,d){return b.push(c)>e.cacheLength&&delete a[b.shift()],a[c]=d},a)},B=A(),C=A(),D=A(),E="[\\x20\\t\\r\\n\\f]",F="(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",G=F.replace("w","w#"),H="([*^$|!~]?=)",I="\\["+E+"*("+F+")"+E+"*(?:"+H+E+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+G+")|)|)"+E+"*\\]",J=":("+F+")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:"+I+")|[^:]|\\\\.)*|.*))\\)|)",K=":(even|odd|eq|gt|lt|nth|first|last)(?:\\("+E+"*((?:-\\d)?\\d*)"+E+"*\\)|)(?=[^-]|$)",L=new RegExp("^"+E+"+|((?:^|[^\\\\])(?:\\\\.)*)"+E+"+$","g"),M=new RegExp("^"+E+"*,"+E+"*"),N=new RegExp("^"+E+"*([\\x20\\t\\r\\n\\f>+~])"+E+"*"),O=new RegExp(J),P=/^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,Q=/^:not/,R=/[\x20\t\r\n\f]*[+~]/,S=/:not\($/,T=/h\d/i,U=/input|select|textarea|button/i,V=/\\(?!\\)/g,W={ID:new RegExp("^#("+F+")"),CLASS:new RegExp("^\\.("+F+")"),NAME:new RegExp("^\\[name=['\"]?("+F+")['\"]?\\]"),TAG:new RegExp("^("+F.replace("w","w*")+")"),ATTR:new RegExp("^"+I),PSEUDO:new RegExp("^"+J),POS:new RegExp(K,"i"),CHILD:new RegExp("^:(only|nth|first|last)-child(?:\\("+E+"*(even|odd|(([+-]|)(\\d*)n|)"+E+"*(?:([+-]|)"+E+"*(\\d+)|))"+E+"*\\)|)","i"),needsContext:new RegExp("^"+E+"*[>+~]|"+K,"i")},X=function(a){var b=r.createElement("div");try{return a(b)}catch(c){return!1}finally{b=null}},Y=X(function(a){return a.appendChild(r.createComment("")),!a.getElementsByTagName("*").length}),Z=X(function(a){return a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!==n&&a.firstChild.getAttribute("href")==="#"}),$=X(function(a){a.innerHTML="<select></select>";var b=typeof a.lastChild.getAttribute("multiple");return b!=="boolean"&&b!=="string"}),_=X(function(a){return a.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",!a.getElementsByClassName||!a.getElementsByClassName("e").length?!1:(a.lastChild.className="e",a.getElementsByClassName("e").length===2)}),ba=X(function(a){a.id=o+0,a.innerHTML="<a name='"+o+"'></a><div name='"+o+"'></div>",s.insertBefore(a,s.firstChild);var b=r.getElementsByName&&r.getElementsByName(o).length===2+r.getElementsByName(o+0).length;return d=!r.getElementById(o),s.removeChild(a),b});try{x.call(s.childNodes,0)[0].nodeType}catch(bb){x=function(a){var b,c=[];for(;b=this[a];a++)c.push(b);return c}}bc.matches=function(a,b){return bc(a,null,null,b)},bc.matchesSelector=function(a,b){return bc(b,null,null,[a]).length>0},f=bc.getText=function(a){var b,c="",d=0,e=a.nodeType;if(e){if(e===1||e===9||e===11){if(typeof a.textContent=="string")return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=f(a)}else if(e===3||e===4)return a.nodeValue}else for(;b=a[d];d++)c+=f(b);return c},g=bc.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?b.nodeName!=="HTML":!1},h=bc.contains=s.contains?function(a,b){var c=a.nodeType===9?a.documentElement:a,d=b&&b.parentNode;return a===d||!!(d&&d.nodeType===1&&c.contains&&c.contains(d))}:s.compareDocumentPosition?function(a,b){return b&&!!(a.compareDocumentPosition(b)&16)}:function(a,b){while(b=b.parentNode)if(b===a)return!0;return!1},bc.attr=function(a,b){var c,d=g(a);return d||(b=b.toLowerCase()),(c=e.attrHandle[b])?c(a):d||$?a.getAttribute(b):(c=a.getAttributeNode(b),c?typeof a[b]=="boolean"?a[b]?b:null:c.specified?c.value:null:null)},e=bc.selectors={cacheLength:50,createPseudo:z,match:W,attrHandle:Z?{}:{href:function(a){return a.getAttribute("href",2)},type:function(a){return a.getAttribute("type")}},find:{ID:d?function(a,b,c){if(typeof b.getElementById!==n&&!c){var d=b.getElementById(a);return d&&d.parentNode?[d]:[]}}:function(a,c,d){if(typeof c.getElementById!==n&&!d){var e=c.getElementById(a);return e?e.id===a||typeof e.getAttributeNode!==n&&e.getAttributeNode("id").value===a?[e]:b:[]}},TAG:Y?function(a,b){if(typeof b.getElementsByTagName!==n)return b.getElementsByTagName(a)}:function(a,b){var c=b.getElementsByTagName(a);if(a==="*"){var d,e=[],f=0;for(;d=c[f];f++)d.nodeType===1&&e.push(d);return e}return c},NAME:ba&&function(a,b){if(typeof b.getElementsByName!==n)return b.getElementsByName(name)},CLASS:_&&function(a,b,c){if(typeof b.getElementsByClassName!==n&&!c)return b.getElementsByClassName(a)}},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(V,""),a[3]=(a[4]||a[5]||"").replace(V,""),a[2]==="~="&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),a[1]==="nth"?(a[2]||bc.error(a[0]),a[3]=+(a[3]?a[4]+(a[5]||1):2*(a[2]==="even"||a[2]==="odd")),a[4]=+(a[6]+a[7]||a[2]==="odd")):a[2]&&bc.error(a[0]),a},PSEUDO:function(a){var b,c;if(W.CHILD.test(a[0]))return null;if(a[3])a[2]=a[3];else if(b=a[4])O.test(b)&&(c=bh(b,!0))&&(c=b.indexOf(")",b.length-c)-b.length)&&(b=b.slice(0,c),a[0]=a[0].slice(0,c)),a[2]=b;return a.slice(0,3)}},filter:{ID:d?function(a){return a=a.replace(V,""),function(b){return b.getAttribute("id")===a}}:function(a){return a=a.replace(V,""),function(b){var c=typeof b.getAttributeNode!==n&&b.getAttributeNode("id");return c&&c.value===a}},TAG:function(a){return a==="*"?function(){return!0}:(a=a.replace(V,"").toLowerCase(),function(b){return b.nodeName&&b.nodeName.toLowerCase()===a})},CLASS:function(a){var b=B[o][a];return b||(b=B(a,new RegExp("(^|"+E+")"+a+"("+E+"|$)"))),function(a){return b.test(a.className||typeof a.getAttribute!==n&&a.getAttribute("class")||"")}},ATTR:function(a,b,c){return function(d,e){var f=bc.attr(d,a);return f==null?b==="!=":b?(f+="",b==="="?f===c:b==="!="?f!==c:b==="^="?c&&f.indexOf(c)===0:b==="*="?c&&f.indexOf(c)>-1:b==="$="?c&&f.substr(f.length-c.length)===c:b==="~="?(" "+f+" ").indexOf(c)>-1:b==="|="?f===c||f.substr(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d){return a==="nth"?function(a){var b,e,f=a.parentNode;if(c===1&&d===0)return!0;if(f){e=0;for(b=f.firstChild;b;b=b.nextSibling)if(b.nodeType===1){e++;if(a===b)break}}return e-=d,e===c||e%c===0&&e/c>=0}:function(b){var c=b;switch(a){case"only":case"first":while(c=c.previousSibling)if(c.nodeType===1)return!1;if(a==="first")return!0;c=b;case"last":while(c=c.nextSibling)if(c.nodeType===1)return!1;return!0}}},PSEUDO:function(a,b){var c,d=e.pseudos[a]||e.setFilters[a.toLowerCase()]||bc.error("unsupported pseudo: "+a);return d[o]?d(b):d.length>1?(c=[a,a,"",b],e.setFilters.hasOwnProperty(a.toLowerCase())?z(function(a,c){var e,f=d(a,b),g=f.length;while(g--)e=y.call(a,f[g]),a[e]=!(c[e]=f[g])}):function(a){return d(a,0,c)}):d}},pseudos:{not:z(function(a){var b=[],c=[],d=i(a.replace(L,"$1"));return d[o]?z(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)if(f=g[h])a[h]=!(b[h]=f)}):function(a,e,f){return b[0]=a,d(b,null,f,c),!c.pop()}}),has:z(function(a){return function(b){return bc(a,b).length>0}}),contains:z(function(a){return function(b){return(b.textContent||b.innerText||f(b)).indexOf(a)>-1}}),enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&!!a.checked||b==="option"&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},parent:function(a){return!e.pseudos.empty(a)},empty:function(a){var b;a=a.firstChild;while(a){if(a.nodeName>"@"||(b=a.nodeType)===3||b===4)return!1;a=a.nextSibling}return!0},header:function(a){return T.test(a.nodeName)},text:function(a){var b,c;return a.nodeName.toLowerCase()==="input"&&(b=a.type)==="text"&&((c=a.getAttribute("type"))==null||c.toLowerCase()===b)},radio:bd("radio"),checkbox:bd("checkbox"),file:bd("file"),password:bd("password"),image:bd("image"),submit:be("submit"),reset:be("reset"),button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&a.type==="button"||b==="button"},input:function(a){return U.test(a.nodeName)},focus:function(a){var b=a.ownerDocument;return a===b.activeElement&&(!b.hasFocus||b.hasFocus())&&(!!a.type||!!a.href)},active:function(a){return a===a.ownerDocument.activeElement},first:bf(function(a,b,c){return[0]}),last:bf(function(a,b,c){return[b-1]}),eq:bf(function(a,b,c){return[c<0?c+b:c]}),even:bf(function(a,b,c){for(var d=0;d<b;d+=2)a.push(d);return a}),odd:bf(function(a,b,c){for(var d=1;d<b;d+=2)a.push(d);return a}),lt:bf(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:bf(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},j=s.compareDocumentPosition?function(a,b){return a===b?(k=!0,0):(!a.compareDocumentPosition||!b.compareDocumentPosition?a.compareDocumentPosition:a.compareDocumentPosition(b)&4)?-1:1}:function(a,b){if(a===b)return k=!0,0;if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,h=b.parentNode,i=g;if(g===h)return bg(a,b);if(!g)return-1;if(!h)return 1;while(i)e.unshift(i),i=i.parentNode;i=h;while(i)f.unshift(i),i=i.parentNode;c=e.length,d=f.length;for(var j=0;j<c&&j<d;j++)if(e[j]!==f[j])return bg(e[j],f[j]);return j===c?bg(a,f[j],-1):bg(e[j],b,1)},[0,0].sort(j),m=!k,bc.uniqueSort=function(a){var b,c=1;k=m,a.sort(j);if(k)for(;b=a[c];c++)b===a[c-1]&&a.splice(c--,1);return a},bc.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},i=bc.compile=function(a,b){var c,d=[],e=[],f=D[o][a];if(!f){b||(b=bh(a)),c=b.length;while(c--)f=bm(b[c]),f[o]?d.push(f):e.push(f);f=D(a,bn(e,d))}return f},r.querySelectorAll&&function(){var a,b=bp,c=/'|\\/g,d=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,e=[":focus"],f=[":active",":focus"],h=s.matchesSelector||s.mozMatchesSelector||s.webkitMatchesSelector||s.oMatchesSelector||s.msMatchesSelector;X(function(a){a.innerHTML="<select><option selected=''></option></select>",a.querySelectorAll("[selected]").length||e.push("\\["+E+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),a.querySelectorAll(":checked").length||e.push(":checked")}),X(function(a){a.innerHTML="<p test=''></p>",a.querySelectorAll("[test^='']").length&&e.push("[*^$]="+E+"*(?:\"\"|'')"),a.innerHTML="<input type='hidden'/>",a.querySelectorAll(":enabled").length||e.push(":enabled",":disabled")}),e=new RegExp(e.join("|")),bp=function(a,d,f,g,h){if(!g&&!h&&(!e||!e.test(a))){var i,j,k=!0,l=o,m=d,n=d.nodeType===9&&a;if(d.nodeType===1&&d.nodeName.toLowerCase()!=="object"){i=bh(a),(k=d.getAttribute("id"))?l=k.replace(c,"\\$&"):d.setAttribute("id",l),l="[id='"+l+"'] ",j=i.length;while(j--)i[j]=l+i[j].join("");m=R.test(a)&&d.parentNode||d,n=i.join(",")}if(n)try{return w.apply(f,x.call(m.querySelectorAll(n),0)),f}catch(p){}finally{k||d.removeAttribute("id")}}return b(a,d,f,g,h)},h&&(X(function(b){a=h.call(b,"div");try{h.call(b,"[test!='']:sizzle"),f.push("!=",J)}catch(c){}}),f=new RegExp(f.join("|")),bc.matchesSelector=function(b,c){c=c.replace(d,"='$1']");if(!g(b)&&!f.test(c)&&(!e||!e.test(c)))try{var i=h.call(b,c);if(i||a||b.document&&b.document.nodeType!==11)return i}catch(j){}return bc(c,null,null,[b]).length>0})}(),e.pseudos.nth=e.pseudos.eq,e.filters=bq.prototype=e.pseudos,e.setFilters=new bq,bc.attr=p.attr,p.find=bc,p.expr=bc.selectors,p.expr[":"]=p.expr.pseudos,p.unique=bc.uniqueSort,p.text=bc.getText,p.isXMLDoc=bc.isXML,p.contains=bc.contains}(a);var bc=/Until$/,bd=/^(?:parents|prev(?:Until|All))/,be=/^.[^:#\[\.,]*$/,bf=p.expr.match.needsContext,bg={children:!0,contents:!0,next:!0,prev:!0};p.fn.extend({find:function(a){var b,c,d,e,f,g,h=this;if(typeof a!="string")return p(a).filter(function(){for(b=0,c=h.length;b<c;b++)if(p.contains(h[b],this))return!0});g=this.pushStack("","find",a);for(b=0,c=this.length;b<c;b++){d=g.length,p.find(a,this[b],g);if(b>0)for(e=d;e<g.length;e++)for(f=0;f<d;f++)if(g[f]===g[e]){g.splice(e--,1);break}}return g},has:function(a){var b,c=p(a,this),d=c.length;return this.filter(function(){for(b=0;b<d;b++)if(p.contains(this,c[b]))return!0})},not:function(a){return this.pushStack(bj(this,a,!1),"not",a)},filter:function(a){return this.pushStack(bj(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?bf.test(a)?p(a,this.context).index(this[0])>=0:p.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c,d=0,e=this.length,f=[],g=bf.test(a)||typeof a!="string"?p(a,b||this.context):0;for(;d<e;d++){c=this[d];while(c&&c.ownerDocument&&c!==b&&c.nodeType!==11){if(g?g.index(c)>-1:p.find.matchesSelector(c,a)){f.push(c);break}c=c.parentNode}}return f=f.length>1?p.unique(f):f,this.pushStack(f,"closest",a)},index:function(a){return a?typeof a=="string"?p.inArray(this[0],p(a)):p.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.prevAll().length:-1},add:function(a,b){var c=typeof a=="string"?p(a,b):p.makeArray(a&&a.nodeType?[a]:a),d=p.merge(this.get(),c);return this.pushStack(bh(c[0])||bh(d[0])?d:p.unique(d))},addBack:function(a){return this.add(a==null?this.prevObject:this.prevObject.filter(a))}}),p.fn.andSelf=p.fn.addBack,p.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return p.dir(a,"parentNode")},parentsUntil:function(a,b,c){return p.dir(a,"parentNode",c)},next:function(a){return bi(a,"nextSibling")},prev:function(a){return bi(a,"previousSibling")},nextAll:function(a){return p.dir(a,"nextSibling")},prevAll:function(a){return p.dir(a,"previousSibling")},nextUntil:function(a,b,c){return p.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return p.dir(a,"previousSibling",c)},siblings:function(a){return p.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return p.sibling(a.firstChild)},contents:function(a){return p.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:p.merge([],a.childNodes)}},function(a,b){p.fn[a]=function(c,d){var e=p.map(this,b,c);return bc.test(a)||(d=c),d&&typeof d=="string"&&(e=p.filter(d,e)),e=this.length>1&&!bg[a]?p.unique(e):e,this.length>1&&bd.test(a)&&(e=e.reverse()),this.pushStack(e,a,k.call(arguments).join(","))}}),p.extend({filter:function(a,b,c){return c&&(a=":not("+a+")"),b.length===1?p.find.matchesSelector(b[0],a)?[b[0]]:[]:p.find.matches(a,b)},dir:function(a,c,d){var e=[],f=a[c];while(f&&f.nodeType!==9&&(d===b||f.nodeType!==1||!p(f).is(d)))f.nodeType===1&&e.push(f),f=f[c];return e},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var bl="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",bm=/ jQuery\d+="(?:null|\d+)"/g,bn=/^\s+/,bo=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bp=/<([\w:]+)/,bq=/<tbody/i,br=/<|&#?\w+;/,bs=/<(?:script|style|link)/i,bt=/<(?:script|object|embed|option|style)/i,bu=new RegExp("<(?:"+bl+")[\\s/>]","i"),bv=/^(?:checkbox|radio)$/,bw=/checked\s*(?:[^=]|=\s*.checked.)/i,bx=/\/(java|ecma)script/i,by=/^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,bz={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bA=bk(e),bB=bA.appendChild(e.createElement("div"));bz.optgroup=bz.option,bz.tbody=bz.tfoot=bz.colgroup=bz.caption=bz.thead,bz.th=bz.td,p.support.htmlSerialize||(bz._default=[1,"X<div>","</div>"]),p.fn.extend({text:function(a){return p.access(this,function(a){return a===b?p.text(this):this.empty().append((this[0]&&this[0].ownerDocument||e).createTextNode(a))},null,a,arguments.length)},wrapAll:function(a){if(p.isFunction(a))return this.each(function(b){p(this).wrapAll(a.call(this,b))});if(this[0]){var b=p(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return p.isFunction(a)?this.each(function(b){p(this).wrapInner(a.call(this,b))}):this.each(function(){var b=p(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=p.isFunction(a);return this.each(function(c){p(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){p.nodeName(this,"body")||p(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){(this.nodeType===1||this.nodeType===11)&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){(this.nodeType===1||this.nodeType===11)&&this.insertBefore(a,this.firstChild)})},before:function(){if(!bh(this[0]))return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=p.clean(arguments);return this.pushStack(p.merge(a,this),"before",this.selector)}},after:function(){if(!bh(this[0]))return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=p.clean(arguments);return this.pushStack(p.merge(this,a),"after",this.selector)}},remove:function(a,b){var c,d=0;for(;(c=this[d])!=null;d++)if(!a||p.filter(a,[c]).length)!b&&c.nodeType===1&&(p.cleanData(c.getElementsByTagName("*")),p.cleanData([c])),c.parentNode&&c.parentNode.removeChild(c);return this},empty:function(){var a,b=0;for(;(a=this[b])!=null;b++){a.nodeType===1&&p.cleanData(a.getElementsByTagName("*"));while(a.firstChild)a.removeChild(a.firstChild)}return this},clone:function(a,b){return a=a==null?!1:a,b=b==null?a:b,this.map(function(){return p.clone(this,a,b)})},html:function(a){return p.access(this,function(a){var c=this[0]||{},d=0,e=this.length;if(a===b)return c.nodeType===1?c.innerHTML.replace(bm,""):b;if(typeof a=="string"&&!bs.test(a)&&(p.support.htmlSerialize||!bu.test(a))&&(p.support.leadingWhitespace||!bn.test(a))&&!bz[(bp.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(bo,"<$1></$2>");try{for(;d<e;d++)c=this[d]||{},c.nodeType===1&&(p.cleanData(c.getElementsByTagName("*")),c.innerHTML=a);c=0}catch(f){}}c&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(a){return bh(this[0])?this.length?this.pushStack(p(p.isFunction(a)?a():a),"replaceWith",a):this:p.isFunction(a)?this.each(function(b){var c=p(this),d=c.html();c.replaceWith(a.call(this,b,d))}):(typeof a!="string"&&(a=p(a).detach()),this.each(function(){var b=this.nextSibling,c=this.parentNode;p(this).remove(),b?p(b).before(a):p(c).append(a)}))},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){a=[].concat.apply([],a);var e,f,g,h,i=0,j=a[0],k=[],l=this.length;if(!p.support.checkClone&&l>1&&typeof j=="string"&&bw.test(j))return this.each(function(){p(this).domManip(a,c,d)});if(p.isFunction(j))return this.each(function(e){var f=p(this);a[0]=j.call(this,e,c?f.html():b),f.domManip(a,c,d)});if(this[0]){e=p.buildFragment(a,this,k),g=e.fragment,f=g.firstChild,g.childNodes.length===1&&(g=f);if(f){c=c&&p.nodeName(f,"tr");for(h=e.cacheable||l-1;i<l;i++)d.call(c&&p.nodeName(this[i],"table")?bC(this[i],"tbody"):this[i],i===h?g:p.clone(g,!0,!0))}g=f=null,k.length&&p.each(k,function(a,b){b.src?p.ajax?p.ajax({url:b.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):p.error("no ajax"):p.globalEval((b.text||b.textContent||b.innerHTML||"").replace(by,"")),b.parentNode&&b.parentNode.removeChild(b)})}return this}}),p.buildFragment=function(a,c,d){var f,g,h,i=a[0];return c=c||e,c=!c.nodeType&&c[0]||c,c=c.ownerDocument||c,a.length===1&&typeof i=="string"&&i.length<512&&c===e&&i.charAt(0)==="<"&&!bt.test(i)&&(p.support.checkClone||!bw.test(i))&&(p.support.html5Clone||!bu.test(i))&&(g=!0,f=p.fragments[i],h=f!==b),f||(f=c.createDocumentFragment(),p.clean(a,c,f,d),g&&(p.fragments[i]=h&&f)),{fragment:f,cacheable:g}},p.fragments={},p.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){p.fn[a]=function(c){var d,e=0,f=[],g=p(c),h=g.length,i=this.length===1&&this[0].parentNode;if((i==null||i&&i.nodeType===11&&i.childNodes.length===1)&&h===1)return g[b](this[0]),this;for(;e<h;e++)d=(e>0?this.clone(!0):this).get(),p(g[e])[b](d),f=f.concat(d);return this.pushStack(f,a,g.selector)}}),p.extend({clone:function(a,b,c){var d,e,f,g;p.support.html5Clone||p.isXMLDoc(a)||!bu.test("<"+a.nodeName+">")?g=a.cloneNode(!0):(bB.innerHTML=a.outerHTML,bB.removeChild(g=bB.firstChild));if((!p.support.noCloneEvent||!p.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!p.isXMLDoc(a)){bE(a,g),d=bF(a),e=bF(g);for(f=0;d[f];++f)e[f]&&bE(d[f],e[f])}if(b){bD(a,g);if(c){d=bF(a),e=bF(g);for(f=0;d[f];++f)bD(d[f],e[f])}}return d=e=null,g},clean:function(a,b,c,d){var f,g,h,i,j,k,l,m,n,o,q,r,s=b===e&&bA,t=[];if(!b||typeof b.createDocumentFragment=="undefined")b=e;for(f=0;(h=a[f])!=null;f++){typeof h=="number"&&(h+="");if(!h)continue;if(typeof h=="string")if(!br.test(h))h=b.createTextNode(h);else{s=s||bk(b),l=b.createElement("div"),s.appendChild(l),h=h.replace(bo,"<$1></$2>"),i=(bp.exec(h)||["",""])[1].toLowerCase(),j=bz[i]||bz._default,k=j[0],l.innerHTML=j[1]+h+j[2];while(k--)l=l.lastChild;if(!p.support.tbody){m=bq.test(h),n=i==="table"&&!m?l.firstChild&&l.firstChild.childNodes:j[1]==="<table>"&&!m?l.childNodes:[];for(g=n.length-1;g>=0;--g)p.nodeName(n[g],"tbody")&&!n[g].childNodes.length&&n[g].parentNode.removeChild(n[g])}!p.support.leadingWhitespace&&bn.test(h)&&l.insertBefore(b.createTextNode(bn.exec(h)[0]),l.firstChild),h=l.childNodes,l.parentNode.removeChild(l)}h.nodeType?t.push(h):p.merge(t,h)}l&&(h=l=s=null);if(!p.support.appendChecked)for(f=0;(h=t[f])!=null;f++)p.nodeName(h,"input")?bG(h):typeof h.getElementsByTagName!="undefined"&&p.grep(h.getElementsByTagName("input"),bG);if(c){q=function(a){if(!a.type||bx.test(a.type))return d?d.push(a.parentNode?a.parentNode.removeChild(a):a):c.appendChild(a)};for(f=0;(h=t[f])!=null;f++)if(!p.nodeName(h,"script")||!q(h))c.appendChild(h),typeof h.getElementsByTagName!="undefined"&&(r=p.grep(p.merge([],h.getElementsByTagName("script")),q),t.splice.apply(t,[f+1,0].concat(r)),f+=r.length)}return t},cleanData:function(a,b){var c,d,e,f,g=0,h=p.expando,i=p.cache,j=p.support.deleteExpando,k=p.event.special;for(;(e=a[g])!=null;g++)if(b||p.acceptData(e)){d=e[h],c=d&&i[d];if(c){if(c.events)for(f in c.events)k[f]?p.event.remove(e,f):p.removeEvent(e,f,c.handle);i[d]&&(delete i[d],j?delete e[h]:e.removeAttribute?e.removeAttribute(h):e[h]=null,p.deletedIds.push(d))}}}}),function(){var a,b;p.uaMatch=function(a){a=a.toLowerCase();var b=/(chrome)[ \/]([\w.]+)/.exec(a)||/(webkit)[ \/]([\w.]+)/.exec(a)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(a)||/(msie) ([\w.]+)/.exec(a)||a.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},a=p.uaMatch(g.userAgent),b={},a.browser&&(b[a.browser]=!0,b.version=a.version),b.chrome?b.webkit=!0:b.webkit&&(b.safari=!0),p.browser=b,p.sub=function(){function a(b,c){return new a.fn.init(b,c)}p.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function c(c,d){return d&&d instanceof p&&!(d instanceof a)&&(d=a(d)),p.fn.init.call(this,c,d,b)},a.fn.init.prototype=a.fn;var b=a(e);return a}}();var bH,bI,bJ,bK=/alpha\([^)]*\)/i,bL=/opacity=([^)]*)/,bM=/^(top|right|bottom|left)$/,bN=/^(none|table(?!-c[ea]).+)/,bO=/^margin/,bP=new RegExp("^("+q+")(.*)$","i"),bQ=new RegExp("^("+q+")(?!px)[a-z%]+$","i"),bR=new RegExp("^([-+])=("+q+")","i"),bS={},bT={position:"absolute",visibility:"hidden",display:"block"},bU={letterSpacing:0,fontWeight:400},bV=["Top","Right","Bottom","Left"],bW=["Webkit","O","Moz","ms"],bX=p.fn.toggle;p.fn.extend({css:function(a,c){return p.access(this,function(a,c,d){return d!==b?p.style(a,c,d):p.css(a,c)},a,c,arguments.length>1)},show:function(){return b$(this,!0)},hide:function(){return b$(this)},toggle:function(a,b){var c=typeof a=="boolean";return p.isFunction(a)&&p.isFunction(b)?bX.apply(this,arguments):this.each(function(){(c?a:bZ(this))?p(this).show():p(this).hide()})}}),p.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bH(a,"opacity");return c===""?"1":c}}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":p.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!a||a.nodeType===3||a.nodeType===8||!a.style)return;var f,g,h,i=p.camelCase(c),j=a.style;c=p.cssProps[i]||(p.cssProps[i]=bY(j,i)),h=p.cssHooks[c]||p.cssHooks[i];if(d===b)return h&&"get"in h&&(f=h.get(a,!1,e))!==b?f:j[c];g=typeof d,g==="string"&&(f=bR.exec(d))&&(d=(f[1]+1)*f[2]+parseFloat(p.css(a,c)),g="number");if(d==null||g==="number"&&isNaN(d))return;g==="number"&&!p.cssNumber[i]&&(d+="px");if(!h||!("set"in h)||(d=h.set(a,d,e))!==b)try{j[c]=d}catch(k){}},css:function(a,c,d,e){var f,g,h,i=p.camelCase(c);return c=p.cssProps[i]||(p.cssProps[i]=bY(a.style,i)),h=p.cssHooks[c]||p.cssHooks[i],h&&"get"in h&&(f=h.get(a,!0,e)),f===b&&(f=bH(a,c)),f==="normal"&&c in bU&&(f=bU[c]),d||e!==b?(g=parseFloat(f),d||p.isNumeric(g)?g||0:f):f},swap:function(a,b,c){var d,e,f={};for(e in b)f[e]=a.style[e],a.style[e]=b[e];d=c.call(a);for(e in b)a.style[e]=f[e];return d}}),a.getComputedStyle?bH=function(b,c){var d,e,f,g,h=a.getComputedStyle(b,null),i=b.style;return h&&(d=h[c],d===""&&!p.contains(b.ownerDocument,b)&&(d=p.style(b,c)),bQ.test(d)&&bO.test(c)&&(e=i.width,f=i.minWidth,g=i.maxWidth,i.minWidth=i.maxWidth=i.width=d,d=h.width,i.width=e,i.minWidth=f,i.maxWidth=g)),d}:e.documentElement.currentStyle&&(bH=function(a,b){var c,d,e=a.currentStyle&&a.currentStyle[b],f=a.style;return e==null&&f&&f[b]&&(e=f[b]),bQ.test(e)&&!bM.test(b)&&(c=f.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),f.left=b==="fontSize"?"1em":e,e=f.pixelLeft+"px",f.left=c,d&&(a.runtimeStyle.left=d)),e===""?"auto":e}),p.each(["height","width"],function(a,b){p.cssHooks[b]={get:function(a,c,d){if(c)return a.offsetWidth===0&&bN.test(bH(a,"display"))?p.swap(a,bT,function(){return cb(a,b,d)}):cb(a,b,d)},set:function(a,c,d){return b_(a,c,d?ca(a,b,d,p.support.boxSizing&&p.css(a,"boxSizing")==="border-box"):0)}}}),p.support.opacity||(p.cssHooks.opacity={get:function(a,b){return bL.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=p.isNumeric(b)?"alpha(opacity="+b*100+")":"",f=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&p.trim(f.replace(bK,""))===""&&c.removeAttribute){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bK.test(f)?f.replace(bK,e):f+" "+e}}),p(function(){p.support.reliableMarginRight||(p.cssHooks.marginRight={get:function(a,b){return p.swap(a,{display:"inline-block"},function(){if(b)return bH(a,"marginRight")})}}),!p.support.pixelPosition&&p.fn.position&&p.each(["top","left"],function(a,b){p.cssHooks[b]={get:function(a,c){if(c){var d=bH(a,b);return bQ.test(d)?p(a).position()[b]+"px":d}}}})}),p.expr&&p.expr.filters&&(p.expr.filters.hidden=function(a){return a.offsetWidth===0&&a.offsetHeight===0||!p.support.reliableHiddenOffsets&&(a.style&&a.style.display||bH(a,"display"))==="none"},p.expr.filters.visible=function(a){return!p.expr.filters.hidden(a)}),p.each({margin:"",padding:"",border:"Width"},function(a,b){p.cssHooks[a+b]={expand:function(c){var d,e=typeof c=="string"?c.split(" "):[c],f={};for(d=0;d<4;d++)f[a+bV[d]+b]=e[d]||e[d-2]||e[0];return f}},bO.test(a)||(p.cssHooks[a+b].set=b_)});var cd=/%20/g,ce=/\[\]$/,cf=/\r?\n/g,cg=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,ch=/^(?:select|textarea)/i;p.fn.extend({serialize:function(){return p.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?p.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ch.test(this.nodeName)||cg.test(this.type))}).map(function(a,b){var c=p(this).val();return c==null?null:p.isArray(c)?p.map(c,function(a,c){return{name:b.name,value:a.replace(cf,"\r\n")}}):{name:b.name,value:c.replace(cf,"\r\n")}}).get()}}),p.param=function(a,c){var d,e=[],f=function(a,b){b=p.isFunction(b)?b():b==null?"":b,e[e.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=p.ajaxSettings&&p.ajaxSettings.traditional);if(p.isArray(a)||a.jquery&&!p.isPlainObject(a))p.each(a,function(){f(this.name,this.value)});else for(d in a)ci(d,a[d],c,f);return e.join("&").replace(cd,"+")};var cj,ck,cl=/#.*$/,cm=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,cn=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,co=/^(?:GET|HEAD)$/,cp=/^\/\//,cq=/\?/,cr=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,cs=/([?&])_=[^&]*/,ct=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,cu=p.fn.load,cv={},cw={},cx=["*/"]+["*"];try{ck=f.href}catch(cy){ck=e.createElement("a"),ck.href="",ck=ck.href}cj=ct.exec(ck.toLowerCase())||[],p.fn.load=function(a,c,d){if(typeof a!="string"&&cu)return cu.apply(this,arguments);if(!this.length)return this;var e,f,g,h=this,i=a.indexOf(" ");return i>=0&&(e=a.slice(i,a.length),a=a.slice(0,i)),p.isFunction(c)?(d=c,c=b):c&&typeof c=="object"&&(f="POST"),p.ajax({url:a,type:f,dataType:"html",data:c,complete:function(a,b){d&&h.each(d,g||[a.responseText,b,a])}}).done(function(a){g=arguments,h.html(e?p("<div>").append(a.replace(cr,"")).find(e):a)}),this},p.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){p.fn[b]=function(a){return this.on(b,a)}}),p.each(["get","post"],function(a,c){p[c]=function(a,d,e,f){return p.isFunction(d)&&(f=f||e,e=d,d=b),p.ajax({type:c,url:a,data:d,success:e,dataType:f})}}),p.extend({getScript:function(a,c){return p.get(a,b,c,"script")},getJSON:function(a,b,c){return p.get(a,b,c,"json")},ajaxSetup:function(a,b){return b?cB(a,p.ajaxSettings):(b=a,a=p.ajaxSettings),cB(a,b),a},ajaxSettings:{url:ck,isLocal:cn.test(cj[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded; charset=UTF-8",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":cx},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":p.parseJSON,"text xml":p.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:cz(cv),ajaxTransport:cz(cw),ajax:function(a,c){function y(a,c,f,i){var k,s,t,u,w,y=c;if(v===2)return;v=2,h&&clearTimeout(h),g=b,e=i||"",x.readyState=a>0?4:0,f&&(u=cC(l,x,f));if(a>=200&&a<300||a===304)l.ifModified&&(w=x.getResponseHeader("Last-Modified"),w&&(p.lastModified[d]=w),w=x.getResponseHeader("Etag"),w&&(p.etag[d]=w)),a===304?(y="notmodified",k=!0):(k=cD(l,u),y=k.state,s=k.data,t=k.error,k=!t);else{t=y;if(!y||a)y="error",a<0&&(a=0)}x.status=a,x.statusText=(c||y)+"",k?o.resolveWith(m,[s,y,x]):o.rejectWith(m,[x,y,t]),x.statusCode(r),r=b,j&&n.trigger("ajax"+(k?"Success":"Error"),[x,l,k?s:t]),q.fireWith(m,[x,y]),j&&(n.trigger("ajaxComplete",[x,l]),--p.active||p.event.trigger("ajaxStop"))}typeof a=="object"&&(c=a,a=b),c=c||{};var d,e,f,g,h,i,j,k,l=p.ajaxSetup({},c),m=l.context||l,n=m!==l&&(m.nodeType||m instanceof p)?p(m):p.event,o=p.Deferred(),q=p.Callbacks("once memory"),r=l.statusCode||{},t={},u={},v=0,w="canceled",x={readyState:0,setRequestHeader:function(a,b){if(!v){var c=a.toLowerCase();a=u[c]=u[c]||a,t[a]=b}return this},getAllResponseHeaders:function(){return v===2?e:null},getResponseHeader:function(a){var c;if(v===2){if(!f){f={};while(c=cm.exec(e))f[c[1].toLowerCase()]=c[2]}c=f[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){return v||(l.mimeType=a),this},abort:function(a){return a=a||w,g&&g.abort(a),y(0,a),this}};o.promise(x),x.success=x.done,x.error=x.fail,x.complete=q.add,x.statusCode=function(a){if(a){var b;if(v<2)for(b in a)r[b]=[r[b],a[b]];else b=a[x.status],x.always(b)}return this},l.url=((a||l.url)+"").replace(cl,"").replace(cp,cj[1]+"//"),l.dataTypes=p.trim(l.dataType||"*").toLowerCase().split(s),l.crossDomain==null&&(i=ct.exec(l.url.toLowerCase())||!1,l.crossDomain=i&&i.join(":")+(i[3]?"":i[1]==="http:"?80:443)!==cj.join(":")+(cj[3]?"":cj[1]==="http:"?80:443)),l.data&&l.processData&&typeof l.data!="string"&&(l.data=p.param(l.data,l.traditional)),cA(cv,l,c,x);if(v===2)return x;j=l.global,l.type=l.type.toUpperCase(),l.hasContent=!co.test(l.type),j&&p.active++===0&&p.event.trigger("ajaxStart");if(!l.hasContent){l.data&&(l.url+=(cq.test(l.url)?"&":"?")+l.data,delete l.data),d=l.url;if(l.cache===!1){var z=p.now(),A=l.url.replace(cs,"$1_="+z);l.url=A+(A===l.url?(cq.test(l.url)?"&":"?")+"_="+z:"")}}(l.data&&l.hasContent&&l.contentType!==!1||c.contentType)&&x.setRequestHeader("Content-Type",l.contentType),l.ifModified&&(d=d||l.url,p.lastModified[d]&&x.setRequestHeader("If-Modified-Since",p.lastModified[d]),p.etag[d]&&x.setRequestHeader("If-None-Match",p.etag[d])),x.setRequestHeader("Accept",l.dataTypes[0]&&l.accepts[l.dataTypes[0]]?l.accepts[l.dataTypes[0]]+(l.dataTypes[0]!=="*"?", "+cx+"; q=0.01":""):l.accepts["*"]);for(k in l.headers)x.setRequestHeader(k,l.headers[k]);if(!l.beforeSend||l.beforeSend.call(m,x,l)!==!1&&v!==2){w="abort";for(k in{success:1,error:1,complete:1})x[k](l[k]);g=cA(cw,l,c,x);if(!g)y(-1,"No Transport");else{x.readyState=1,j&&n.trigger("ajaxSend",[x,l]),l.async&&l.timeout>0&&(h=setTimeout(function(){x.abort("timeout")},l.timeout));try{v=1,g.send(t,y)}catch(B){if(v<2)y(-1,B);else throw B}}return x}return x.abort()},active:0,lastModified:{},etag:{}});var cE=[],cF=/\?/,cG=/(=)\?(?=&|$)|\?\?/,cH=p.now();p.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=cE.pop()||p.expando+"_"+cH++;return this[a]=!0,a}}),p.ajaxPrefilter("json jsonp",function(c,d,e){var f,g,h,i=c.data,j=c.url,k=c.jsonp!==!1,l=k&&cG.test(j),m=k&&!l&&typeof i=="string"&&!(c.contentType||"").indexOf("application/x-www-form-urlencoded")&&cG.test(i);if(c.dataTypes[0]==="jsonp"||l||m)return f=c.jsonpCallback=p.isFunction(c.jsonpCallback)?c.jsonpCallback():c.jsonpCallback,g=a[f],l?c.url=j.replace(cG,"$1"+f):m?c.data=i.replace(cG,"$1"+f):k&&(c.url+=(cF.test(j)?"&":"?")+c.jsonp+"="+f),c.converters["script json"]=function(){return h||p.error(f+" was not called"),h[0]},c.dataTypes[0]="json",a[f]=function(){h=arguments},e.always(function(){a[f]=g,c[f]&&(c.jsonpCallback=d.jsonpCallback,cE.push(f)),h&&p.isFunction(g)&&g(h[0]),h=g=b}),"script"}),p.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){return p.globalEval(a),a}}}),p.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),p.ajaxTransport("script",function(a){if(a.crossDomain){var c,d=e.head||e.getElementsByTagName("head")[0]||e.documentElement;return{send:function(f,g){c=e.createElement("script"),c.async="async",a.scriptCharset&&(c.charset=a.scriptCharset),c.src=a.url,c.onload=c.onreadystatechange=function(a,e){if(e||!c.readyState||/loaded|complete/.test(c.readyState))c.onload=c.onreadystatechange=null,d&&c.parentNode&&d.removeChild(c),c=b,e||g(200,"success")},d.insertBefore(c,d.firstChild)},abort:function(){c&&c.onload(0,1)}}}});var cI,cJ=a.ActiveXObject?function(){for(var a in cI)cI[a](0,1)}:!1,cK=0;p.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&cL()||cM()}:cL,function(a){p.extend(p.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(p.ajaxSettings.xhr()),p.support.ajax&&p.ajaxTransport(function(c){if(!c.crossDomain||p.support.cors){var d;return{send:function(e,f){var g,h,i=c.xhr();c.username?i.open(c.type,c.url,c.async,c.username,c.password):i.open(c.type,c.url,c.async);if(c.xhrFields)for(h in c.xhrFields)i[h]=c.xhrFields[h];c.mimeType&&i.overrideMimeType&&i.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(h in e)i.setRequestHeader(h,e[h])}catch(j){}i.send(c.hasContent&&c.data||null),d=function(a,e){var h,j,k,l,m;try{if(d&&(e||i.readyState===4)){d=b,g&&(i.onreadystatechange=p.noop,cJ&&delete cI[g]);if(e)i.readyState!==4&&i.abort();else{h=i.status,k=i.getAllResponseHeaders(),l={},m=i.responseXML,m&&m.documentElement&&(l.xml=m);try{l.text=i.responseText}catch(a){}try{j=i.statusText}catch(n){j=""}!h&&c.isLocal&&!c.crossDomain?h=l.text?200:404:h===1223&&(h=204)}}}catch(o){e||f(-1,o)}l&&f(h,j,l,k)},c.async?i.readyState===4?setTimeout(d,0):(g=++cK,cJ&&(cI||(cI={},p(a).unload(cJ)),cI[g]=d),i.onreadystatechange=d):d()},abort:function(){d&&d(0,1)}}}});var cN,cO,cP=/^(?:toggle|show|hide)$/,cQ=new RegExp("^(?:([-+])=|)("+q+")([a-z%]*)$","i"),cR=/queueHooks$/,cS=[cY],cT={"*":[function(a,b){var c,d,e=this.createTween(a,b),f=cQ.exec(b),g=e.cur(),h=+g||0,i=1,j=20;if(f){c=+f[2],d=f[3]||(p.cssNumber[a]?"":"px");if(d!=="px"&&h){h=p.css(e.elem,a,!0)||c||1;do i=i||".5",h=h/i,p.style(e.elem,a,h+d);while(i!==(i=e.cur()/g)&&i!==1&&--j)}e.unit=d,e.start=h,e.end=f[1]?h+(f[1]+1)*c:c}return e}]};p.Animation=p.extend(cW,{tweener:function(a,b){p.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");var c,d=0,e=a.length;for(;d<e;d++)c=a[d],cT[c]=cT[c]||[],cT[c].unshift(b)},prefilter:function(a,b){b?cS.unshift(a):cS.push(a)}}),p.Tween=cZ,cZ.prototype={constructor:cZ,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(p.cssNumber[c]?"":"px")},cur:function(){var a=cZ.propHooks[this.prop];return a&&a.get?a.get(this):cZ.propHooks._default.get(this)},run:function(a){var b,c=cZ.propHooks[this.prop];return this.options.duration?this.pos=b=p.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):cZ.propHooks._default.set(this),this}},cZ.prototype.init.prototype=cZ.prototype,cZ.propHooks={_default:{get:function(a){var b;return a.elem[a.prop]==null||!!a.elem.style&&a.elem.style[a.prop]!=null?(b=p.css(a.elem,a.prop,!1,""),!b||b==="auto"?0:b):a.elem[a.prop]},set:function(a){p.fx.step[a.prop]?p.fx.step[a.prop](a):a.elem.style&&(a.elem.style[p.cssProps[a.prop]]!=null||p.cssHooks[a.prop])?p.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},cZ.propHooks.scrollTop=cZ.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},p.each(["toggle","show","hide"],function(a,b){var c=p.fn[b];p.fn[b]=function(d,e,f){return d==null||typeof d=="boolean"||!a&&p.isFunction(d)&&p.isFunction(e)?c.apply(this,arguments):this.animate(c$(b,!0),d,e,f)}}),p.fn.extend({fadeTo:function(a,b,c,d){return this.filter(bZ).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=p.isEmptyObject(a),f=p.speed(b,c,d),g=function(){var b=cW(this,p.extend({},a),f);e&&b.stop(!0)};return e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,c,d){var e=function(a){var b=a.stop;delete a.stop,b(d)};return typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,c=a!=null&&a+"queueHooks",f=p.timers,g=p._data(this);if(c)g[c]&&g[c].stop&&e(g[c]);else for(c in g)g[c]&&g[c].stop&&cR.test(c)&&e(g[c]);for(c=f.length;c--;)f[c].elem===this&&(a==null||f[c].queue===a)&&(f[c].anim.stop(d),b=!1,f.splice(c,1));(b||!d)&&p.dequeue(this,a)})}}),p.each({slideDown:c$("show"),slideUp:c$("hide"),slideToggle:c$("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){p.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),p.speed=function(a,b,c){var d=a&&typeof a=="object"?p.extend({},a):{complete:c||!c&&b||p.isFunction(a)&&a,duration:a,easing:c&&b||b&&!p.isFunction(b)&&b};d.duration=p.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in p.fx.speeds?p.fx.speeds[d.duration]:p.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";return d.old=d.complete,d.complete=function(){p.isFunction(d.old)&&d.old.call(this),d.queue&&p.dequeue(this,d.queue)},d},p.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},p.timers=[],p.fx=cZ.prototype.init,p.fx.tick=function(){var a,b=p.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||p.fx.stop()},p.fx.timer=function(a){a()&&p.timers.push(a)&&!cO&&(cO=setInterval(p.fx.tick,p.fx.interval))},p.fx.interval=13,p.fx.stop=function(){clearInterval(cO),cO=null},p.fx.speeds={slow:600,fast:200,_default:400},p.fx.step={},p.expr&&p.expr.filters&&(p.expr.filters.animated=function(a){return p.grep(p.timers,function(b){return a===b.elem}).length});var c_=/^(?:body|html)$/i;p.fn.offset=function(a){if(arguments.length)return a===b?this:this.each(function(b){p.offset.setOffset(this,a,b)});var c,d,e,f,g,h,i,j={top:0,left:0},k=this[0],l=k&&k.ownerDocument;if(!l)return;return(d=l.body)===k?p.offset.bodyOffset(k):(c=l.documentElement,p.contains(c,k)?(typeof k.getBoundingClientRect!="undefined"&&(j=k.getBoundingClientRect()),e=da(l),f=c.clientTop||d.clientTop||0,g=c.clientLeft||d.clientLeft||0,h=e.pageYOffset||c.scrollTop,i=e.pageXOffset||c.scrollLeft,{top:j.top+h-f,left:j.left+i-g}):j)},p.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;return p.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(p.css(a,"marginTop"))||0,c+=parseFloat(p.css(a,"marginLeft"))||0),{top:b,left:c}},setOffset:function(a,b,c){var d=p.css(a,"position");d==="static"&&(a.style.position="relative");var e=p(a),f=e.offset(),g=p.css(a,"top"),h=p.css(a,"left"),i=(d==="absolute"||d==="fixed")&&p.inArray("auto",[g,h])>-1,j={},k={},l,m;i?(k=e.position(),l=k.top,m=k.left):(l=parseFloat(g)||0,m=parseFloat(h)||0),p.isFunction(b)&&(b=b.call(a,c,f)),b.top!=null&&(j.top=b.top-f.top+l),b.left!=null&&(j.left=b.left-f.left+m),"using"in b?b.using.call(a,j):e.css(j)}},p.fn.extend({position:function(){if(!this[0])return;var a=this[0],b=this.offsetParent(),c=this.offset(),d=c_.test(b[0].nodeName)?{top:0,left:0}:b.offset();return c.top-=parseFloat(p.css(a,"marginTop"))||0,c.left-=parseFloat(p.css(a,"marginLeft"))||0,d.top+=parseFloat(p.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(p.css(b[0],"borderLeftWidth"))||0,{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||e.body;while(a&&!c_.test(a.nodeName)&&p.css(a,"position")==="static")a=a.offsetParent;return a||e.body})}}),p.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,c){var d=/Y/.test(c);p.fn[a]=function(e){return p.access(this,function(a,e,f){var g=da(a);if(f===b)return g?c in g?g[c]:g.document.documentElement[e]:a[e];g?g.scrollTo(d?p(g).scrollLeft():f,d?f:p(g).scrollTop()):a[e]=f},a,e,arguments.length,null)}}),p.each({Height:"height",Width:"width"},function(a,c){p.each({padding:"inner"+a,content:c,"":"outer"+a},function(d,e){p.fn[e]=function(e,f){var g=arguments.length&&(d||typeof e!="boolean"),h=d||(e===!0||f===!0?"margin":"border");return p.access(this,function(c,d,e){var f;return p.isWindow(c)?c.document.documentElement["client"+a]:c.nodeType===9?(f=c.documentElement,Math.max(c.body["scroll"+a],f["scroll"+a],c.body["offset"+a],f["offset"+a],f["client"+a])):e===b?p.css(c,d,e,h):p.style(c,d,e,h)},c,g?e:b,g,null)}})}),a.jQuery=a.$=p,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return p})})(window);

},{}],14:[function(require,module,exports){
/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */

(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

if ($.event.fixHooks) {
    for ( var i=types.length; i; ) {
        $.event.fixHooks[ types[--i] ] = $.event.mouseHooks;
    }
}

$.event.special.mousewheel = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },
    
    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    mousewheel: function(fn) {
        return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
    },
    
    unmousewheel: function(fn) {
        return this.unbind("mousewheel", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "mousewheel";
    
    // Old school scrollwheel delta
    if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta/120; }
    if ( orgEvent.detail     ) { delta = -orgEvent.detail/3; }
    
    // New school multidimensional scroll (touchpads) deltas
    deltaY = delta;
    
    // Gecko
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }
    
    // Webkit
    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }
    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120; }
    
    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);
    
    return ($.event.dispatch || $.event.handle).apply(this, args);
}

})(jQuery);

},{}],15:[function(require,module,exports){
(function ($) {
    var defaults = {
        fullscreen : false,
        scale : false,
        defaultEventHandling : true,
        preopen : function () {},
        postopen : function () {},
        preclose : function () {},
        postclose : function () {},
        preresize : function () {},
        postresize : function () {}
    };

    var methods = {
        open : function () {
            var clone = this.clone(true),
                data = this.data("lightbox"),
                w, h;

            data.contents = clone;
            data.preopen.call(this);
            clone = data.contents; // data.contents might have been altered by data.preopen
            var cloneData = clone.data("lightbox");

            data.overlay = $("<div/>")
                .css({
                    "position"         : "fixed",
                    "left"             : "0px",
                    "top"              : "0px",
                    "height"           : "100%",
                    "min-height"       : "100%",
                    "width"            : "100%",
                    "z-index"          : "9999",
                    "background-color" : "black",
                    "opacity"          : "0.5"
                })
                .appendTo("body");

            data.box = $("<div/>")
                .css({
                    "position"         : "fixed",
                    "z-index"          : "9999"
                })
                .appendTo("body");
            

            data.box.append(clone);

            if (data.fullscreen === true) {
                w = window.innerWidth;
                h = window.innerHeight;
            } else {
                w = clone.width();
                h = clone.height();
                if (data.scale === true) {
                    var r = computeRatio(w, h);
                    w = parseInt(w * r, 10);
                    h = parseInt(h * r, 10);
                }
            }

            scaleElement(data.box, w, h);
            positionElement(data.box, w, h);

            scaleElement(clone, w, h);
            positionElement(clone, w, h);
            clone.css("position", "fixed")
                .css("z-index", 9999);

            data.box.append(
                $("<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NkY4OUE4QUE2MDEyMTFFMkFBMEM4Q0Y2RTlFNkI4QzEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NkY4OUE4QUI2MDEyMTFFMkFBMEM4Q0Y2RTlFNkI4QzEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2Rjg5QThBODYwMTIxMUUyQUEwQzhDRjZFOUU2QjhDMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2Rjg5QThBOTYwMTIxMUUyQUEwQzhDRjZFOUU2QjhDMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PvXC/ukAAAcjSURBVHjaxFlpTFVXEJ7HDrIIUkCRzYitQJQK/kBTxAop2EQhaqkEqjZqK9FGa+2Cf2pabdIlEbE0FEkTArFaF6CAKCCStG5BokXAglpUIkKqgn0KyNb5jve+PB9vfyyTfIF7373nzJkzZ76ZuYqRkRGyUKwYoYwQxqsMD4aj9FsPo4Nxg1HP6LR0Mhsz37NlxDNSGLHt7e2e9+/fpwcPHtDTp0/p+fPn4iFHR0eaOnUqTZ8+nQICAsjV1bWJb5cwChiN5kysMNHCsNwHjE+uXr3qe+nSJWpsbCSlUmnUyzNmzKDw8HCKiooiX1/fGr61l1E9XgonMjLPnDnjX1NTI6xpiURGRtLSpUspJCSklC8/YvwzVgo7M7Lr6+vTzp49S9evX6exlISEBEpOTsYWfcgotFRhX0ZFeXl52JEjR2i8JDg4mJYtWwZXyeTLjxnD5ig8m1F17NixgJKSEhpvsbGxoZSUFIqNjf2VL1MZQ6Yo7M34o7CwcPapU6doImXdunUUFxf3E/+bbqzCCFm1x48fjzpx4gRNhmzYsAGWxkHM0hb0NeWrioqKKFaYsJjJwOnTp6HH94zXDSkczth59OjRSVMWYCKi3NxcO9blZ4a1PqbL5AdtwFa6ZM6cOWRvb09WVlakUChU95uamlQMpynu7u4gCvEOIEtnZyd1dHRofaeqqopmzZoVydHjfb7M1aZwDLNWdGVlpV7/6u3tpSVLlgjKtbW1Vd338vKSt/IlsbOzE8w2c+ZMcnNzU73z5MkTOnToEOkLq0xSCHdf8L+/MAY1Fd6JCYeHh/Uq3NbWRq2trbR8+XJhOdlisCDyiWvXrr30/Pz588VvgYGB5OnpSdbWL3Y4MzOT9O0k5NatW3ThwoUgXnASX/6m7sNeSGYuXrxolI9hu27fvi1cYsqUKeTs7CyUx+n28PBQPRcUFERz584VOYSPjw+SH/FsbW0tMXMaNde5c+eg33uahy6JrWszMDAgLGwM8vPz6d69e9Tf3y8GgOW8vb1py5Yt4ncoFhERIRQFkLlhgTdv3hSuYOw8V65cwfBvMVzUFY5paGgwehDg0aNHxCwo/g4ODr4I4OyfsOiKFSsE/Pz8hHVhWbgO/H///v0mzQMjstJw/DfUFV7U3Nxscvipq6sjJEQ4QLLvI4KsWrVKWBd+CxcB7UI4AtHdu3dNnufGDeT/FCUfOieGX1dXF5lTfRQXFwtLQkH4s+zXcuiTla2urhan3hzBIllekxUO5BsKQ9FBlzx79owKCgrI399fuAQUhT/L0QACIsjLyyNzyzEp9w6SXcIVk5riV5qAQkg/u7u7aWhoaFTcRgh7/Pix2eNL4c9VtrCdHB0sEQz68OFDcnFxIScnJ9V9BwcHsQhLxpcikb1s4X5spSUWBiEsXLhQe8LNPr1t2zaxCHPHl9ixV1a4B4fE3EQFPsv5K02bNk0A16PKFmY65LnmzoFdYvlPdok2PuVwPGtzti0mJkZECeQKYDv1w6ZKsNlCWBQSJLCkqYJYztIqW7gPSoOlTF15aGioinrhFnJic/LkSVH+I3vDc3ALMN369euRgZk8DwzC8rc6cZznctskv0J2tnjx4lHU29LSIths3759In729fW9yAE4JuOd9PR0k304LCwMQ/yprnD1ggULTBoEPQX4JqyLyCBT765du8TvUDY7O1tQN6KQXGjCMBs3bjR6HrgYk1K/psLFCQkJ/RjQmC2CssjEoCz8VmazrKwsEdrk5y5fviyYsKenRxWfcSgTExPF7hgzF56T2lu96gp3Q2kcDEMrRsWBrg2UxRbLUYHrQCoqKhr1PFgQOTLISfZnhLitW7eK7M7QfPHxaOFRvraa7rukpCSD4YWrWeGzaPBhYiiANHPPnj0630M6CRfRTEW3b9+udz704djCaBqWayuR6vjElyUnJ799+PBhreEFHUhUG6BgHC45hCEh1xcSkezn5OTQvHnzVIuEIIpgx6RsbJTAgKji1TtBmn2JYMZfK1eudNBVHE6UrF27lnbs2IFy403GiK4yH8H5y7S0tEkt87ETrKxSau2OGGpof7t69eoYpVIZj1M/0YLqBAWA1M1sMabzgxW9y6zUsGnTpgm1LCIOiIVD7F5drVd93UsfRiUn3mEHDx4cd8siTIK616xZ8wM6/Ob2h90ZRRw1oqG0oT6CuRIdHU0HDhyAIp/DJS3twMPPv2Z8mpGRoSgrKxszRUHnaAts3ry5C01L9Xg7Ft84FjF+ZEYLRzkk9QvMbl7jYO3evRvxNY+Rwfh3PL4i4ZC+w/iMc9vw0tJStJJEc8SQ4ECBuZA/p6amDkitp28YJn00UVjwYTFCau3HcYEZCqXv3LkjEh18BkNuDFYDBaM/wSyK5OU843cGqLRrIr7T6ZJXpK+hwdKXUDcwLwPBv11KvpulYsEiGSuFJ0z+F2AAyCap34M2ukUAAAAASUVORK5CYII=\" alt=\"close\"/>")
                    .css({
                        "position" : "absolute",
                        "right"    : "-9px",
                        "top"      : "-8px",
                        "width"    : "44px",
                        "height"   : "44px",
                        "z-index"  : "10000"
                    })
                    .click(function () {
                        clone.lightbox("close");
                    })
            );

            cloneData.contentWidth = w;
            cloneData.contentHeight = h;
            cloneData.opened = true;
            cloneData.resizeHandler = function () {
                clone.lightbox("resize");
            };

            $(window).on("resize", cloneData.resizeHandler);
            $(window).on("orientationchange", cloneData.resizeHandler);

            data.postopen.call(this);

            return this;
        },
                
        close : function () {
            var data = this.data("lightbox");

            data.preclose.call(this);

            $(window).off("resize", data.resizeHandler);
            $(window).off("orientationchange", data.resizeHandler);

            data.opened = false;
            data.overlay.remove();
            data.overlay = undefined;

            data.postclose.call(this);

            data.box.remove();
            return this;
        },
                
        resize : function () {
            var data = this.data("lightbox"),
                w, h;

            data.preresize.call(this);

            if (data.fullscreen === true) {
                w = window.innerWidth;
                h = window.innerHeight;
            } else {
                w = data.contentWidth;
                h = data.contentHeight;
                if (data.scale === true) {
                    var r = computeRatio(w, h);
                    w = parseInt(w * r, 10);
                    h = parseInt(h * r, 10);
                }
            }

            scaleElement(data.box, w, h);
            positionElement(data.box, w, h);

            scaleElement(data.contents, w, h);
            positionElement(data.contents, w, h);

            data.contentWidth = w;
            data.contentHeight = h;

            data.postresize.call(this);

            return this;
        },

        toggle : function () {
            if (this.data("lightbox").opened === true) {
                this.lightbox("close");
            } else {
                this.lightbox("open");
            }
            return this;
        },

        init : function (options) {
            return this.each(function() {
                var $this = $(this),
                data = $this.data("lightbox");
                if ( !data ) {
                    var settings = $.extend(defaults, options, { opened : false });
                    $this.data("lightbox", settings);
                }

                if ($this.data("lightbox").defaultEventHandling === true) {
                    // modified from ecmanaut's answer at
                    // http://stackoverflow.com/questions/3103842/safari-ipad-prevent-zoom-on-double-tap
                    $this.on("touchstart", function (e) {
                        var t2 = e.timeStamp,
                            t1 = $this.data("lightbox").lastTouch || t2,
                            dt = t2 - t1,
                            fingers = e.originalEvent.touches.length;
                        $this.data("lightbox").lastTouch = t2;
                        if (!dt || dt > 500 || fingers > 1) {
                            return;
                        }
                        e.preventDefault(); // double tap - prevent the zoom
                        $this.lightbox("toggle");
                    });
                }

                return this;
            });
        }
    };

    $.fn.lightbox = function (method) {
        if ( methods[method] ) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === "object" || !method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( "Method " +  method + " does not exist on jQuery.lightbox" );
            return null;
        }
    };

    var computeRatio = function (originalWidth, originalHeight) {
        var wr = (originalWidth > 0) ? window.innerWidth / originalWidth : 1,
            hr = (originalHeight > 0) ? window.innerHeight / originalHeight : 1,
            r = Math.min(wr, hr);
        return r;
    };

    var scaleElement = function (elem, width, height) {
        elem.css("width", width + "px")
            .css("height", height + "px");
    };

    var positionElement = function (elem, width, height) {
        var left = (window.innerWidth  - width) / 2,
            top = (window.innerHeight - height) / 2;
        if (left < 0) {
            left = 0;
        }
        if (top < 0) {
            top = 0;
        }

        elem.css("left", left + "px")
            .css("top", top + "px");
    };

}(jQuery));

},{}],16:[function(require,module,exports){
(function() {
    "use strict";

    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
 
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }
 
    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
    }
}());

},{}],17:[function(require,module,exports){
/**
sprintf() for JavaScript 0.7-beta1
http://www.diveintojavascript.com/projects/javascript-sprintf

Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of sprintf() for JavaScript nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Changelog:
2010.11.07 - 0.7-beta1-node
  - converted it to a node.js compatible module

2010.09.06 - 0.7-beta1
  - features: vsprintf, support for named placeholders
  - enhancements: format cache, reduced global namespace pollution

2010.05.22 - 0.6:
 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
 Note:
 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
 who warned me about a bug in 0.5, I discovered that the last update was
 a regress. I appologize for that.

2010.05.09 - 0.5:
 - bug fix: 0 is now preceeded with a + sign
 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
 - switched from GPL to BSD license

2007.10.21 - 0.4:
 - unit test and patch (David Baird)

2007.09.17 - 0.3:
 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)

2007.09.11 - 0.2:
 - feature: added argument swapping

2007.04.03 - 0.1:
 - initial release
**/

var sprintf = (function() {
	function get_type(variable) {
		return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
	}
	function str_repeat(input, multiplier) {
		for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
		return output.join('');
	}

	var str_format = function() {
		if (!str_format.cache.hasOwnProperty(arguments[0])) {
			str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
		}
		return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
	};

	// convert object to simple one line string without indentation or
	// newlines. Note that this implementation does not print array
	// values to their actual place for sparse arrays. 
	//
	// For example sparse array like this
	//    l = []
	//    l[4] = 1
	// Would be printed as "[1]" instead of "[, , , , 1]"
	// 
	// If argument 'seen' is not null and array the function will check for 
	// circular object references from argument.
	str_format.object_stringify = function(obj, depth, maxdepth, seen) {
		var str = '';
		if (obj != null) {
			switch( typeof(obj) ) {
			case 'function': 
				return '[Function' + (obj.name ? ': '+obj.name : '') + ']';
			    break;
			case 'object':
				if ( obj instanceof Error) { return '[' + obj.toString() + ']' };
				if (depth >= maxdepth) return '[Object]'
				if (seen) {
					// add object to seen list
					seen = seen.slice(0)
					seen.push(obj);
				}
				if (obj.length != null) { //array
					str += '[';
					var arr = []
					for (var i in obj) {
						if (seen && seen.indexOf(obj[i]) >= 0) arr.push('[Circular]');
						else arr.push(str_format.object_stringify(obj[i], depth+1, maxdepth, seen));
					}
					str += arr.join(', ') + ']';
				} else if ('getMonth' in obj) { // date
					return 'Date(' + obj + ')';
				} else { // object
					str += '{';
					var arr = []
					for (var k in obj) { 
						if(obj.hasOwnProperty(k)) {
							if (seen && seen.indexOf(obj[k]) >= 0) arr.push(k + ': [Circular]');
							else arr.push(k +': ' +str_format.object_stringify(obj[k], depth+1, maxdepth, seen)); 
						}
					}
					str += arr.join(', ') + '}';
				}
				return str;
				break;
			case 'string':				
				return '"' + obj + '"';
				break
			}
		}
		return '' + obj;
	}

	str_format.format = function(parse_tree, argv) {
		var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
		for (i = 0; i < tree_length; i++) {
			node_type = get_type(parse_tree[i]);
			if (node_type === 'string') {
				output.push(parse_tree[i]);
			}
			else if (node_type === 'array') {
				match = parse_tree[i]; // convenience purposes only
				if (match[2]) { // keyword argument
					arg = argv[cursor];
					for (k = 0; k < match[2].length; k++) {
						if (!arg.hasOwnProperty(match[2][k])) {
							throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
						}
						arg = arg[match[2][k]];
					}
				}
				else if (match[1]) { // positional argument (explicit)
					arg = argv[match[1]];
				}
				else { // positional argument (implicit)
					arg = argv[cursor++];
				}

				if (/[^sO]/.test(match[8]) && (get_type(arg) != 'number')) {
					throw new Error(sprintf('[sprintf] expecting number but found %s "' + arg + '"', get_type(arg)));
				}
				switch (match[8]) {
					case 'b': arg = arg.toString(2); break;
					case 'c': arg = String.fromCharCode(arg); break;
					case 'd': arg = parseInt(arg, 10); break;
					case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
					case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
				    case 'O': arg = str_format.object_stringify(arg, 0, parseInt(match[7]) || 5); break;
					case 'o': arg = arg.toString(8); break;
					case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
					case 'u': arg = Math.abs(arg); break;
					case 'x': arg = arg.toString(16); break;
					case 'X': arg = arg.toString(16).toUpperCase(); break;
				}
				arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
				pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
				pad_length = match[6] - String(arg).length;
				pad = match[6] ? str_repeat(pad_character, pad_length) : '';
				output.push(match[5] ? arg + pad : pad + arg);
			}
		}
		return output.join('');
	};

	str_format.cache = {};

	str_format.parse = function(fmt) {
		var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
		while (_fmt) {
			if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
				parse_tree.push(match[0]);
			}
			else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
				parse_tree.push('%');
			}
			else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosOuxX])/.exec(_fmt)) !== null) {
				if (match[2]) {
					arg_names |= 1;
					var field_list = [], replacement_field = match[2], field_match = [];
					if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
						field_list.push(field_match[1]);
						while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
							if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
								field_list.push(field_match[1]);
							}
							else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
								field_list.push(field_match[1]);
							}
							else {
								throw new Error('[sprintf] ' + replacement_field);
							}
						}
					}
					else {
                        throw new Error('[sprintf] ' + replacement_field);
					}
					match[2] = field_list;
				}
				else {
					arg_names |= 2;
				}
				if (arg_names === 3) {
					throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
				}
				parse_tree.push(match);
			}
			else {
				throw new Error('[sprintf] ' + _fmt);
			}
			_fmt = _fmt.substring(match[0].length);
		}
		return parse_tree;
	};

	return str_format;
})();

var vsprintf = function(fmt, argv) {
	var argvClone = argv.slice();
	argvClone.unshift(fmt);
	return sprintf.apply(null, argvClone);
};

module.exports = sprintf;
sprintf.sprintf = sprintf;
sprintf.vsprintf = vsprintf;

},{}],18:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Data = require('./data.js'),
    DataValue = require('./data_value.js');

/**
 * @class ArrayData
 * @for ArrayData
 * @constructor
 * @param {array} columns A array of DataVariables
 * @param {array} stringArray A array of strings which will later be parsed into DataValues
 */
var ArrayData = new jermaine.Model(function () {
    var ArrayData = this; // huh?  This shadows the ArrayData defined on the previous line.
    //                       Is that intended/correct?  Probably, but need to check for sure.
    //                       mbp Wed Feb 25 18:31:15 2015

    this.isA(Data);
    this.hasAn("array");
    this.hasA("stringArray");
    this.isBuiltWith("columns", "stringArray", function () {
        this.init();
        this.addListener("listenerAdded", function (event) {
            if (event.targetType === "dataReady") {
                var data = this.array();
                event.listener(data[0][0], data[data.length-1][0]);
            }
        });
    });

    /**
     * 
     *
     * @method getIterator
     * @param {string array} columnIDs
     * @param {DataValue} min
     * @param {DataValue} max
     * @param {Integer} buffer
     * @author jrfrimme
     */
    this.respondsTo("getIterator", function (columnIds, min, max, buffer) {
        return ArrayData.getArrayDataIterator(this, columnIds, min, max, buffer);
    });

    /**
     * Determines the upper and lower bounds of a column in a dataset.
     *
     * @method getBounds
     * @param {Integer} columnNumber Column in the dataset to have its bounds determined.
     * @return {array} Array in the form: [lowerBound, upperBound].
     * @author jrfrimme
     */
    this.respondsTo("getBounds", function (columnNumber) {
        var data = this.array(),
            min = data[0][columnNumber],
            max = min,
            i;

        for (i = 1; i < data.length; i++) {
            if (data[i][columnNumber] < min) {
                min = data[i][columnNumber];
            }
            if (data[i][columnNumber] > max) {
                max = data[i][columnNumber];
            }
        }

        return [min, max];
    });

    /**
     * @method onReady
     * @param callback
     */

    /**
     * @method getArrayDataIterator
     * @static
     * @param {ArrayData} arrayData
     * @param {string array} columnIDs
     * @param {DataValue} min
     * @param {DataValue} max
     * @param {Integer} buffer
     * @return iter
     * @author jrfrimme
     */
    ArrayData.getArrayDataIterator = function (arrayData, columnIds, min, max, buffer) {

        var i, j,
            firstIndex, lastIndex,
            currentIndex,
            columnIndices,
            array = arrayData.array();

        buffer = buffer || 0;

        // columnIds argument should be an array of strings
        if (Object.prototype.toString.apply(columnIds) !== "[object Array]") {
            throw new Error("ArrayData: getIterator method requires that the first parameter be an array of strings");
        } else {
            for (i = 0; i < columnIds.length; ++i) {
                if (typeof(columnIds[i]) !== "string") {
                    throw new Error("ArrayData: getIterator method requires that the first parameter be an array of strings");
                }
            }
        }

        //min,max arguments should be data values
        if (!DataValue.isInstance(min) || !DataValue.isInstance(max)) {
            throw new Error("ArrayData: getIterator method requires the second and third argument to be number values");
        }

        //buffer argument should be an integer
        if (typeof(buffer) !== "number") {
            throw new Error("ArrayData: getIterator method requires last argument to be an integer");
        }

        // if we have no data, return an empty iterator
        if (array.length === 0) {
            return {
                "next"    : function () {},
                "hasNext" : function () { return false; }
            };
        }

        // find the index of the first row in the array whose column0 value is >= min
        for (firstIndex = 0; firstIndex < array.length; ++firstIndex) {
            if (array[firstIndex][0].ge(min)) {
                break;
            }
        }
        // back up 'buffer' steps
        firstIndex = firstIndex - buffer;
        if (firstIndex < 0) {
            firstIndex = 0;
        }
        
        // find the index of the last row in the array whose column0 value is <= max
        if (firstIndex === array.length-1) {
            lastIndex = firstIndex;
        } else {
            for (lastIndex = firstIndex; lastIndex < array.length-1; ++lastIndex) {
                if (array[lastIndex+1][0].gt(max)) {
                    break;
                }
            }
        }
        // move forward 'buffer' steps
        lastIndex = lastIndex + buffer;
        if (lastIndex > array.length-1) {
            lastIndex = array.length-1;
        }

        columnIndices = [];
        for (j = 0; j < columnIds.length; ++j) {
            var k = arrayData.columnIdToColumnNumber(columnIds[j]);
            columnIndices.push( k );
        }

        currentIndex = firstIndex;
        
        return {
            next : function () {
                var projection = [],
                    i;
                if (currentIndex > lastIndex) {
                    return null;
                }
                for (i = 0; i < columnIndices.length; ++i) {
                    projection.push(array[currentIndex][columnIndices[i]]);
                }
                ++currentIndex;
                return projection;
            },
            hasNext : function () {
                return currentIndex <= lastIndex;
            }
        };
    };

    /**
     * @method textToDataValuesArray
     * @static
     * @param {array} dataVariableArray
     * @param {string} text
     * @return {array} dataValues
     * @author jrfrimme
     * @todo If the number of comma-separated values on the current line is not the same as the number of columns in the metadata, should throw an error.
     */
    ArrayData.textToDataValuesArray = function (dataVariableArray, text) {
        //IMPORTANT NOTE: dataVariableArray is a plain javascript array of DataVariable instances; it
        //is NOT a jermaine attr_list.
        var dataValues = [],
            lines = text.split("\n"),
            i;
        for (i = 0; i < lines.length; ++i) {
            if (/\d/.test(lines[i])) { // skip line unless it contains a digit
                var stringValuesThisRow = lines[i].split(/\s*,\s*/),
                    dataValuesThisRow = [],
                    j;
                if (stringValuesThisRow.length === dataVariableArray.length) {
                    for (j = 0; j < stringValuesThisRow.length; ++j) {
                        dataValuesThisRow.push(DataValue.parse(dataVariableArray[j].type(), stringValuesThisRow[j]));
                    }
                    dataValues.push( dataValuesThisRow );
                    //} else {
                    // we get here if the number of comma-separated values on the current line
                    // (lines[i]) is not the same as the number of columns in the metadata.  This
                    // should probably throw an error, or something like that.  For now, though, we
                    // just ignore it.
                    //console.log('bad line: ' + lines[i]);
                }
            }
        }
        return dataValues;
    };

    /**
     * @method textToStringArray
     * @static
     * @param {string} text 
     * @return {array} stringValues
     * @author jrfrimme
     */
    ArrayData.textToStringArray = function (dataVariables, text) {
        var stringValues = [],
            lines = text.split("\n"),
            stringValuesThisRow,
            numColumns,
            i;

        // clean up each line
        for (i = 0; i < lines.length; ++i) {
            lines[i] = lines[i]
                .replace(/^\s+/,     "")   // remove leading whitespace
                .replace(/\s+$/,     "")   // remove trailing whitespace
                .replace(/\s*,\s*/g, ",")  // remove any whitespace next to commas
                .replace(/\s+/g,     ","); // replace any remaining whitespace runs with a comma
            // now line consists of comma-separated values, with no whitespace
        }

        for (i = 0; i < lines.length; ++i) {
            if (/\d/.test(lines[i])) { // skip line unless it contains a digit
                numColumns = lines[i].split(/,/).length;
                break;
            }
        }

        for (i = 0; i < lines.length; ++i) {
            if (/\d/.test(lines[i])) { // skip line unless it contains a digit
                stringValuesThisRow = lines[i].split(/,/);
                if (stringValuesThisRow.length === numColumns) {
                    stringValues.push( stringValuesThisRow );
                } else {
                    throw new Error("Data Parsing Error: The line '" + lines[i] + "' has " + stringValuesThisRow.length + " data columns when it requires " + numColumns + " columns");
                }
            }
        }
        return stringValues;
    };

    /**
     * Parses an array of strings into an array of DataValues.
     * 
     * @method textToStringArray
     * @static
     * @param {array} dataVariableArray plain javascript array of DataVariables
     * @param {array} stringArray plain javascript array of strings
     * @return {array} plain javascript array of DataValue instances
     * @author jrfrimme
     */
    ArrayData.stringArrayToDataValuesArray = function (dataVariableArray, stringArray) {
        //IMPORTANT NOTE: dataVariableArray is a plain javascript array of DataVariable instances; it
        //is NOT a jermaine attr_list.

        var dataValues = [],
            dataValuesThisRow,
            i,
            j;

        for (i = 0; i < stringArray.length; ++i) {
            dataValuesThisRow = [];
            for (j = 0; j < stringArray[i].length; ++j) {
                dataValuesThisRow.push(DataValue.parse(dataVariableArray[j].type(), stringArray[i][j]));
            }
            dataValues.push( dataValuesThisRow );
        }
        return dataValues;
    };

});

module.exports = ArrayData;


},{"../../lib/jermaine/src/jermaine.js":9,"./data.js":27,"./data_value.js":31}],19:[function(require,module,exports){
//var jermaine = require('../../lib/jermaine/src/jermaine.js');
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.horizontalaxis),
    Displacement = require('../math/displacement.js'),
    Point = require('../math/point.js'),
    DataMeasure = require('../core/data_measure.js'),
    RGBColor = require('../math/rgb_color.js'),
    Enum = require('../math/enum.js'),
    EventEmitter = require('./event_emitter.js'),
    Text = require('../core/text.js'),
    AxisBinding = require('./axis_binding.js'),
    AxisTitle = require('./axis_title.js'),
    DataValue = require('./data_value.js'),
    Grid = require('./grid.js'),
    Labeler = require('./labeler.js'),
    Pan = require('./pan.js'),
    Zoom = require('./zoom.js'),

    Util = require('../math/util.js'),

    Orientation = new Enum("AxisOrientation");

var Axis = new jermaine.Model("Axis", function () {

    this.isA(EventEmitter);

    this.hasA("title").which.validatesWith(function (title) {
        return title instanceof AxisTitle;
    });
    this.hasMany("labelers").eachOfWhich.validateWith(function (labelers) {
        return labelers instanceof Labeler;
    });
    this.hasA("grid").which.validatesWith(function (grid) {
        return grid instanceof Grid;
    });
    this.hasA("pan").which.validatesWith(function (pan) {
        return pan instanceof Pan;
    });
    this.hasA("zoom").which.validatesWith(function (zoom) {
        return zoom instanceof Zoom;
    });
    this.hasA("binding").which.validatesWith(function (binding) {
        return binding === null || binding instanceof AxisBinding;
    });
    this.hasAn("id").which.isA("string");
    this.hasA("type").which.isOneOf(DataValue.types());
    this.hasA("length").which.validatesWith(function (length) {
        return length instanceof Displacement;
    });
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });
    this.hasA("pregap").which.isA("number");
    this.hasA("postgap").which.isA("number");
    this.hasAn("anchor").which.isA("number");
    this.hasA("base").which.validatesWith(function (base) {
        return base instanceof Point;
    });

    this.hasA("visible").which.isA("boolean").and.which.defaultsTo(true);

    /**
     * Stores the "min" value from the mugl file as a string, if there was one.
     * This value is stored as a string, rather than as a number or a DataValue,
     * because it might have the value "auto".
     */
    this.hasA("min").which.isA("string");

    /**
     * The current min DataValue for the axis.
     *
     * @property dataMin
     * @type {DataValue}
     * @author jrfrimme
     */
    this.hasA("dataMin").which.validatesWith(DataValue.isInstance);
    /**
     * Convenience method for checking to see if dataMin has been set or not
     *
     * @method hasDataMin
     * @author jrfrimme
     * @return {Boolean}
     */
    this.respondsTo("hasDataMin", function () {
        return this.dataMin() !== undefined;
    });

    
    this.hasA("minoffset").which.isA("number");
    this.hasA("minposition").which.validatesWith(function (minposition) {
        return minposition instanceof Displacement;
    });

    /**
     * Stores the "max" value from the mugl file as a string, if there was one.
     * This value is stored as a string, rather than as a number or a DataValue,
     * because it might have the value "auto".
     */
    this.hasA("max").which.isA("string");

    /**
     * The current max DataValue for the axis.
     *
     * @property dataMax
     * @type {DataValue}
     * @author jrfrimme
     */
    this.hasA("dataMax").which.validatesWith(DataValue.isInstance);
    /**
     * Convenience method for checking to see if dataMax has been set or not.
     *
     * @method hasDataMax
     * @author jrfrimme
     * @return {Boolean}
     */
    this.respondsTo("hasDataMax", function () {
        return this.dataMax() !== undefined;
    });



    this.hasA("maxoffset").which.isA("number");
    this.hasA("maxposition").which.validatesWith(function (maxposition) {
        return maxposition instanceof Displacement;
    });


    this.hasA("positionbase").which.isA("string"); // deprecated
    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    });
    this.hasA("tickcolor").which.validatesWith(function (color) {
        return color === null || color instanceof RGBColor;
    });
    this.hasA("tickwidth").which.isA("integer");
    this.hasA("tickmin").which.isA("integer");
    this.hasA("tickmax").which.isA("integer");
    this.hasA("highlightstyle").which.validatesWith(function (highlightstyle) {
        return typeof(highlightstyle) === "string";
    });
    this.hasA("linewidth").which.isA("integer");
    this.hasA("orientation").which.validatesWith(Orientation.isInstance);
    this.isBuiltWith("orientation", function () {
        this.grid(new Grid());
        this.zoom(new Zoom());
        this.pan(new Pan());
    });

    this.hasA("pixelLength").which.isA("number");
    this.hasA("parallelOffset").which.isA("number");
    this.hasA("perpOffset").which.isA("number");

    this.hasA("axisToDataRatio").which.isA("number");

    this.respondsTo("initializeGeometry", function (graph, graphicsContext) {
        var plotBox = graph.plotBox(),
            position = this.position(),
            base     = this.base(),
            pixelLength,
            i;
        if (this.orientation() === Axis.HORIZONTAL) {
            pixelLength = this.length().calculateLength( plotBox.width() );
            this.pixelLength(pixelLength);
            this.parallelOffset( position.x() + (base.x() + 1) * plotBox.width()/2 - (this.anchor() + 1) * pixelLength / 2 );
            this.perpOffset( position.y() + (base.y() + 1) * plotBox.height() / 2 );
        } else {
            pixelLength = this.length().calculateLength( plotBox.height() );
            this.pixelLength(pixelLength);
            this.parallelOffset( position.y() + (base.y() + 1) * plotBox.height()/2 - (this.anchor() + 1) * pixelLength / 2 );
            this.perpOffset( position.x() + (base.x() + 1) * plotBox.width() / 2 );
        }
        this.minoffset(this.minposition().calculateCoordinate(pixelLength));
        this.maxoffset(pixelLength - this.maxposition().calculateCoordinate(pixelLength));
        if (this.hasDataMin() && this.hasDataMax()) {
            this.computeAxisToDataRatio();
        }
        for (i = 0; i < this.labelers().size(); ++i) {
            this.labelers().at(i).initializeGeometry(graph);
        }
        if (this.title()) {
            this.title().initializeGeometry(graph, graphicsContext);
        }
    });

    this.respondsTo("computeAxisToDataRatio", function () {
        if (this.hasDataMin() && this.hasDataMax()) {
            this.axisToDataRatio((this.pixelLength() - this.maxoffset() - this.minoffset()) / (this.dataMax().getRealValue() - this.dataMin().getRealValue()));
        }
    });

    this.respondsTo("dataValueToAxisValue", function (v) {
        return this.axisToDataRatio() * ( v.getRealValue() - this.dataMin().getRealValue() ) + this.minoffset() + this.parallelOffset();
    });

    this.respondsTo("axisValueToDataValue", function (a) {
        return DataValue.create( this.type(),
                                 ( this.dataMin().getRealValue() +
                                   ( a - this.minoffset() - this.parallelOffset() ) / this.axisToDataRatio()) );
    });

    this.hasA("currentLabeler").which.validatesWith(function (labeler) {
        return labeler===null || labeler instanceof Labeler;
    });
    this.hasA("currentLabelDensity").which.isA("number");
    this.hasA("currentLabelerIndex").which.isA("number");

    /**
     * Decides which labeler to use: take the one with the largest density <= 0.8.
     * Unless all have density > 0.8, in which case we take the first one.  This assumes
     * that the labelers list is ordered in increasing order of label density.
     * This function sets the `currentLabeler` and `currentLabelDensity` attributes.
     *
     * @method prepareRender
     * @param {Object} graphicsContext
     * @author jrfrimme
     */
    this.respondsTo("prepareRender", function (graphicsContext) {
        if (!this.hasDataMin() || !this.hasDataMax()) {
            // if either endpoint dataMin() or dataMax() hasn't been specified yet,
            // return immediately without doing anything
            return;
        }
        var currentLabeler,
            currentLabelDensity = 0,
            storedDensity = 0,
            densityThreshold = 0.8,
            labelers  = this.labelers(),
            nlabelers = labelers.size(),
            index     = this.currentLabelerIndex(),
            storedIndex;

        if (nlabelers <= 0) {
            currentLabeler = null;
        } else {
            var flag = true,
                lastLabelerIndex = labelers.size() - 1;

            if (index === undefined) {
                index = 0;
            }
            storedIndex = index;
            currentLabelDensity = labelers.at(index).getLabelDensity(graphicsContext);

            if (currentLabelDensity > densityThreshold) {
                if (index === 0) { // use labeler at position 0
                    flag = false;
                } else { // check the prior labeler
                    storedDensity = currentLabelDensity;
                    index--;
                }
            } else if (currentLabelDensity < densityThreshold) { // check the next labeler
                storedDensity = currentLabelDensity;
                if (index === lastLabelerIndex) {
                    flag = false;
                } else {
                    index++;
                }
            } else if (currentLabelDensity === densityThreshold) { // use labeler at position 0
                flag = false;
            }

            while (flag) {
                currentLabelDensity = labelers.at(index).getLabelDensity(graphicsContext);
                if (currentLabelDensity > densityThreshold) { // labeler before current one
                    if (index === 0) { // use labeler at position 0
                        break;
                    } else if (storedIndex > index) { // going backwards through labelers
                        storedIndex = index;
                        storedDensity = currentLabelDensity;
                        index--;
                    } else { // the prior labeler had density < threshold and was checking the next labeler
                        index = storedIndex;
                        currentLabelDensity = storedDensity;
                        break;
                    }
                } else if (currentLabelDensity < densityThreshold) { // this labeler or one after it
                    if (storedIndex > index) { // going backwards through labelers so prior labeler had density > threshold
                        break;
                    } else if (index === lastLabelerIndex) {
                        break;
                    } else { // check next labeler to see if it has density < threshold
                        storedIndex = index;
                        storedDensity = currentLabelDensity;
                        index++;
                    }
                } else if (currentLabelDensity === densityThreshold) {
                    break;
                }
            }
        }
        currentLabeler = labelers.at(index);

        this.currentLabeler(currentLabeler);
        this.currentLabelerIndex(index);
        this.currentLabelDensity(currentLabelDensity);
    });

    this.respondsTo("toRealValue", function (value) {
        if (typeof(value) === "number") {
            return value;
        } else if (DataValue.isInstance(value)) {
            return value.getRealValue();
        } else {
            throw new Error("unknown value type for axis value " + value);
        }
    });

    this.respondsTo("toDataValue", function (value) {
        if (typeof(value) === "number") {
            return DataValue.create(this.type(), value);
        } else if (DataValue.isInstance(value)) {
            return value;
        } else {
            throw new Error("unknown value type for axis value " + value);
        }
    });

    this.respondsTo("setDataRangeNoBind", function(min, max, dispatch) {

        // NOTE: min and max may either be plain numbers, or
        // DataValue instances.  If they're plain numbers, they
        // get converted to DataValue instances here before being
        // passed to the dataMin()/dataMax() setters below.

        var dataValueMin = this.toDataValue(min),
            dataValueMax = this.toDataValue(max);

        this.dataMin(dataValueMin);
        this.dataMax(dataValueMax);
        // if (_graph != null) { _graph.invalidateDisplayList(); }
        if (dispatch === undefined) {
            dispatch = true;
        }

        this.emit({'type' : 'dataRangeSet',
                   'min'  : dataValueMin,
                   'max'  : dataValueMax});
        /*
         if (dispatch) {
         //dispatchEvent(new AxisEvent(AxisEvent.CHANGE,min,max));  
         }
         */
    });

    this.respondsTo("setDataRange", function (min, max, dispatch) {
        if (this.binding()) {
            this.binding().setDataRange(this, min, max, dispatch);
        } else {
            this.setDataRangeNoBind(min, max, dispatch);
        }
    });

    this.respondsTo("doPan", function (pixelBase, pixelDisplacement) {
        var pan = this.pan(),
            panMin = pan.min(),
            panMax = pan.max(),
            offset,
            newRealMin,
            newRealMax;

        if (!pan.allowed()) { return; }
        offset = pixelDisplacement / this.axisToDataRatio();
        newRealMin = this.dataMin().getRealValue() - offset;
        newRealMax = this.dataMax().getRealValue() - offset;
        
        if (panMin && newRealMin < panMin.getRealValue()) {
            newRealMax += (panMin.getRealValue() - newRealMin);
            newRealMin = panMin.getRealValue();
        }
        if (panMax && newRealMax > panMax.getRealValue()) {
            newRealMin -= (newRealMax - panMax.getRealValue());
            newRealMax = panMax.getRealValue();
        }
        this.setDataRange(DataValue.create(this.type(), newRealMin),
                          DataValue.create(this.type(), newRealMax));
    });

    this.respondsTo("doZoom", function (pixelBase, pixelDisplacement) {
        var zoom = this.zoom(),
            pan  = this.pan(),
            type = this.type(),
            dataMin = this.dataMin(),
            dataMax = this.dataMax(),
            panMin  = pan.min(),
            panMax  = pan.max(),
            zoomMin = zoom.min(),
            zoomMax = zoom.max(),
            baseRealValue,
            factor,
            newMin,
            newMax,
            d;
        if (!zoom.allowed()) {
            return;
        }
        baseRealValue = this.axisValueToDataValue(pixelBase).getRealValue();
        if (DataValue.isInstance(zoom.anchor())) {
            baseRealValue = zoom.anchor().getRealValue();
        }
        factor = 10 * Math.abs(pixelDisplacement / (this.pixelLength() - this.maxoffset() - this.minoffset()));
        /*TODO: uncomment after this.reversed() has been implemented
         if (this.reversed()) { factor = -factor; }
         */
        if (pixelDisplacement <= 0) {
            newMin = DataValue.create(type,
                                      (dataMin.getRealValue() - baseRealValue) * ( 1 + factor ) + baseRealValue);
            newMax = DataValue.create(type,
                                      (dataMax.getRealValue() - baseRealValue) * ( 1 + factor ) + baseRealValue);
        } else {
            newMin = DataValue.create(type,
                                      (dataMin.getRealValue() - baseRealValue) * ( 1 - factor ) + baseRealValue);
            newMax = DataValue.create(type,
                                      (dataMax.getRealValue() - baseRealValue) * ( 1 - factor ) + baseRealValue);
        }
        if (panMin && newMin.lt(panMin)) {
            newMin = panMin;
        }
        if (panMax && newMax.gt(panMax)) {
            newMax = panMax;
        }
        
        if ((dataMin.le(dataMax) && newMin.lt(newMax)) ||
            (dataMin.ge(dataMax) && newMin.gt(newMax))) {
            if (zoomMax && (newMax.gt(newMin.add(zoomMax)))) {
                d = (newMax.getRealValue() - newMin.getRealValue() - zoomMax.getRealValue()) / 2;
                newMax = newMax.addRealValue(-d);
                newMin = newMin.addRealValue(d);
            } else if (zoomMin && (newMax.lt(newMin.add(zoomMin)))) {
                d = (zoomMin.getRealValue() - (newMax.getRealValue() - newMin.getRealValue())) / 2;
                newMax = newMax.addRealValue(d);
                newMin = newMin.addRealValue(-d);
            }
            this.setDataRange(newMin, newMax);
        }
    });

    /**
     * Compute the distance from an axis to a point.  The point
     * (x,y) is expressed in pixel coordinates in the same
     * coordinate system as the axis.
     * 
     * We use two different kinds of computations depending on
     * whether the point lies inside or outside the region bounded
     * by the two lines perpendicular to the axis through its
     * endpoints.  If the point lies inside this region, the
     * distance is simply the difference in the perpendicular
     * coordinate of the point and the perpendicular coordinate of
     * the axis.
     * 
     * If the point lies outside the region, then the distance is
     * the L2 distance between the point and the closest endpoint
     * of the axis.
     *
     * @method distanceToPoint
     * @param {} x
     * @param {} y
     * @author jrfrimme
     */
    this.respondsTo("distanceToPoint", function (x, y) {
        var perpCoord     = (this.orientation() === Axis.HORIZONTAL) ? y : x,
            parallelCoord = (this.orientation() === Axis.HORIZONTAL) ? x : y,
            parallelOffset = this.parallelOffset(),
            perpOffset     = this.perpOffset(),
            pixelLength    = this.pixelLength(),
            l2dist         = Util.l2dist;

        if (parallelCoord < parallelOffset) {
            // point is under or left of the axis; return L2 distance to bottom or left axis endpoint
            return l2dist(parallelCoord, perpCoord, parallelOffset, perpOffset);
        }
        if (parallelCoord > parallelOffset + pixelLength) {
            // point is above or right of the axis; return L2 distance to top or right axis endpoint
            return l2dist(parallelCoord, perpCoord, parallelOffset + pixelLength, perpOffset);
        }
        // point is between the axis endpoints; return difference in perpendicular coords
        return Math.abs(perpCoord - perpOffset);
    });


    this.respondsTo("normalize", function (graph) {
        var i,
            title,
            label;

        //
        // Handles title tags
        //
        if (this.title() && this.title().content() === undefined) {
            this.title().content(new Text(this.id()));
        }

        //
        // Handles missing labelers
        //
        if (this.labelers().size() === 0) {
            var defaultValues = (utilityFunctions.getDefaultValuesFromXSD()).horizontalaxis.labels,
                defaultSpacings = this.type() === DataValue.NUMBER ?
                    defaultValues.defaultNumberSpacing :
                    defaultValues.defaultDatetimeSpacing;

            for (i = 0; i < defaultSpacings.length; i++) {
                label = new Labeler(this);
                label.spacing(DataMeasure.parse(this.type(), defaultSpacings[i]));
                this.labelers().add(label);
            }
        }

        //
        // normalizes the labelers
        //
        for (i = 0; i < this.labelers().size(); i++) {
            this.labelers().at(i).normalize();
        }

    });

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis, attributes);
});

Axis.HORIZONTAL = new Orientation("horizontal");
Axis.VERTICAL   = new Orientation("vertical");

Axis.Orientation = Orientation;

module.exports = Axis;

},{"../../lib/jermaine/src/jermaine.js":9,"../core/data_measure.js":29,"../core/text.js":65,"../math/displacement.js":103,"../math/enum.js":104,"../math/point.js":106,"../math/rgb_color.js":107,"../math/util.js":108,"../util/utilityFunctions.js":159,"./axis_binding.js":20,"./axis_title.js":21,"./data_value.js":31,"./event_emitter.js":39,"./grid.js":43,"./labeler.js":46,"./pan.js":53,"./zoom.js":72}],20:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var AxisBinding = new jermaine.Model("AxisBinding", function () {
    var AxisBinding = this;
    
    AxisBinding.instances = {};

    /**
     * 
     *
     * @property id
     * @type {String}
     * @author jrfrimme
     */
    this.hasA("id").which.isA("string");

    /**
     * 
     *
     * @property axes
     * @type {Array}
     * @author jrfrimme
     */
    this.hasA("axes"); // js array

    this.isBuiltWith("id", function() {
        AxisBinding.instances[this.id()] = this;
        this.axes([]);
    });

    /**
     * 
     *
     * @method addAxis
     * @param {Axis} axis
     * @param {number|DataValue} min
     * @param {number|DataValue} max
     * @author jrfrimme
     */
    this.respondsTo("addAxis", function(axis, min, max, multigraph/*optional*/) {
        // NOTE: min/max can be either numbers, or DataValue
        // instances, but they CANNOT be strings.

        if (axis.binding()) {
            axis.binding().removeAxis(axis);
        }
        axis.binding(this);

        // convert min/max to numbers
        min = axis.toRealValue(min);
        max = axis.toRealValue(max);

        this.axes().push({
            axis       : axis,
            multigraph : multigraph,
            factor     : 1 / (max - min),
            offset     : -min / (max - min),
            min        : min,
            max        : max
        });
    });

    /**
     * 
     *
     * @method removeAxis
     * @param {Axis} axis
     * @author jrfrimme
     */
    this.respondsTo("removeAxis", function(axis) {
        var axes = this.axes(),
            i;
        for (i=0; i<axes.length(); ++i) {
            if (axes[i].axis === axis) {
                axes.splice(i,1);
                break;
            }
        }
    });

    /**
     * Force all the axes in this binding to sync up with each
     * other, if possible.
     * 
     * This is done by looking for an axis in this binding which
     * has its dataMin and dataMax values set, and then calling
     * its setDataRange() method with those values.  The main
     * purpose of this method is to facilitate the initial setting
     * of dataMin/dataMax values for axes in a binding that do not
     * already have dataMin/dataMax values set; this forces them
     * to be set based on the binding, as determined by another
     * axis in the binding.
     * 
     * Note that this method is NOT the normal way for bound axes
     * to interact with each other once initialization is
     * complete; that is done via the axes' own setDataRange()
     * method.
     * 
     * @method sync
     * 
     * @return {boolean} a value indicating whether the sync was
     *                   done; this will be true if and only if
     *                   there is at least one axis in the binding
     *                   having both its dataMin and dataMax
     *                   values set.
     */
    this.respondsTo("sync", function() {
        var i,
            axes = this.axes(),
            axis;
        for (i=0; i<axes.length; ++i) {
            axis = axes[i].axis;
            if (axis.hasDataMin() && axis.hasDataMax()) {
                axis.setDataRange(axis.dataMin(), axis.dataMax());
                return true;
            }

        }
        return false;
    });

    /**
     * 
     *
     * @method setDataRange
     * @param {Axis} initiatingAxis
     * @param {number|DataValue} min
     * @param {number|DataValue} max
     * @param {Boolean} dispatch
     * @author jrfrimme
     */
    this.respondsTo("setDataRange", function(initiatingAxis, min, max, dispatch) {

        // NOTE: min and max may either be plain numbers, or
        // DataValue instances.  If they're DataValue instances,
        // get converted to numbers here before being
        // passed to the individual axes' setDataRangeNoBind()
        // method below.

        var initiatingAxisIndex,
            i, j,
            axes = this.axes(),
            axis,
            minRealValue = initiatingAxis.toRealValue(min),
            maxRealValue = initiatingAxis.toRealValue(max),
            redrawn_multigraphs = [],
            redrawn;

        if (dispatch === undefined) {
            dispatch = true; // dispatch defaults to true
        }

        for (i=0; i<axes.length; ++i) {
            if (axes[i].axis === initiatingAxis) {
                initiatingAxisIndex = i;
                redrawn_multigraphs = [ axes[i].multigraph ];
                break;
            }
        }
        for (i=0; i<axes.length; ++i) {
            axis = axes[i];
            if (i === initiatingAxisIndex) {
                axis.axis.setDataRangeNoBind(minRealValue, maxRealValue, dispatch);
            } else {
                axis.axis.setDataRangeNoBind(
                    (minRealValue * axes[initiatingAxisIndex].factor + axes[initiatingAxisIndex].offset - axis.offset) / axis.factor,
                    (maxRealValue * axes[initiatingAxisIndex].factor + axes[initiatingAxisIndex].offset - axis.offset) / axis.factor,
                    dispatch
                );
                if (axis.multigraph !== undefined) {
                    // If this axis has a multigraph stored with it, and if that multigraph isn't already in the `redrawn_multigraphs`
                    // array, call its `redraw` method, and add it to the array.
                    redrawn = false;
                    for (j=0; j<redrawn_multigraphs.length; ++j) {
                        if (axis.multigraph === redrawn_multigraphs[j]) {
                            redrawn = true;
                            break;
                        }
                    }
                    if (!redrawn) {
                        axis.multigraph.redraw();
                        redrawn_multigraphs.push(axis.multigraph);
                    }
                }
            }
        }
    });

    /**
     * 
     *
     * @method getInstanceById
     * @static
     * @param id
     * @author jrfrimme
     */
    AxisBinding.getInstanceById = function(id) {
        return AxisBinding.instances[id];
    };

    /**
     * 
     *
     * @method findByIdOrCreateNew
     * @static
     * @param id
     * @author jrfrimme
     */
    AxisBinding.findByIdOrCreateNew = function(id) {
        var binding = AxisBinding.getInstanceById(id);
        if (!binding) {
            binding = new AxisBinding(id);
        }
        return binding;
    };

    /**
     * 
     *
     * @method syncAllBindings
     * @static
     * @author jrfrimme
     */
    AxisBinding.syncAllBindings = function() {
        var id;
        for (id in AxisBinding.instances) {
            AxisBinding.instances[id].sync();
        }
    };

    /**
     * 
     *
     * @method forgetAllBindings
     * @static
     * @author jrfrimme
     */
    AxisBinding.forgetAllBindings = function() {

        // This function is just for use in testing, so we can clear out the global list
        // of bindings to get a fresh start between tests.

        var id,j,binding;

        // loop over all bindings, all axes, setting the axis binding to null
        for (id in AxisBinding.instances) {
            binding = AxisBinding.instances[id];
            for (j=0; j<binding.axes().length; ++j) {
                binding.axes()[j].axis.binding(null);
            }
        }

        // reset the global binding list
        AxisBinding.instances = {};
    };

});

module.exports = AxisBinding;

},{"../../lib/jermaine/src/jermaine.js":9}],21:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues    = utilityFunctions.getDefaultValuesFromXSD(),
    attributes       = utilityFunctions.getKeys(defaultValues.horizontalaxis.title),
    Point            = require('../math/point.js');

/**
 * Axis Title is a Jermaine model that supports the rendering of Axis Titles.
 *
 * @class AxisTitle
 * @for AxisTitle
 * @constructor
 * @param {Axis} axis
 */
var AxisTitle = new jermaine.Model("AxisTitle", function () {
    
    /**
     * Pointer to the Title's parent Axis jermiane model.
     *
     * @property axis
     * @type {Axis}
     * @author jrfrimme
     */
    this.hasA("axis").which.validatesWith(function (axis) {
        var Axis = require('./axis.js');
        return axis instanceof Axis;
    });
    /**
     * The value which is used as the title string.
     *
     * @property content
     * @type {Text}
     * @author jrfrimme
     */
    this.hasA("content").which.validatesWith(function (content) {
        var Text = require('./text.js');
        return content instanceof Text;
    });
    /**
     * The value which gives the location of the Title's anchor point to be attached to the
     * base point.
     *
     * @property anchor
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("anchor").which.validatesWith(function (anchor) {
        return anchor instanceof Point;
    });
    /**
     * The value which gives the location of the base point relative to the Title's Axis.
     *
     * @property base
     * @type {Number}
     * @author jrfrimme
     */
    this.hasA("base").which.isA("number");
    /**
     * A coordinate pair of pixel offsets for the base point.
     *
     * @property position
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });
    /**
     * The value which determines the rotation of the Title in degrees.
     *
     * @property angle
     * @type {Number}
     * @author jrfrimme
     */
    this.hasA("angle").which.isA("number");

    this.hasA("font").which.isA("string").and.which.defaultsTo("");

    this.isBuiltWith("axis");

    /**
     * Determines values for the `position` and `anchor` attributes if they were not set; determines the
     * geometry of the `content` attribute. Called by `Axis.initializeGeometry()`.
     *
     * @method initializeGeometry
     * @param {Graph} graph
     * @param {Object} graphicsContext
     * @chainable
     * @author jrfrimme
     */
    this.respondsTo("initializeGeometry", function (graph, graphicsContext) {
        var Axis = require('./axis.js');
        var titleDefaults = defaultValues.horizontalaxis.title,
            axis     = this.axis(),
            position = this.position,
            anchor   = this.anchor,
            plotBox  = graph.plotBox(),
            axisPerpOffset   = axis.perpOffset(),
            axisIsHorizontal = (axis.orientation() === Axis.HORIZONTAL);

        var getValue = function (valueOrFunction) {
            if (typeof(valueOrFunction) === "function") {
                return valueOrFunction();
            } else {
                return valueOrFunction;
            }
        };

        if (position() === undefined) {
            if (axisIsHorizontal) {
                if (axisPerpOffset > plotBox.height()/2) {
                    position( getValue(titleDefaults["position-horizontal-top"]) );
                } else {
                    position( getValue(titleDefaults["position-horizontal-bottom"]) );
                }
            } else {
                if (axisPerpOffset > plotBox.width()/2) {
                    position( getValue(titleDefaults["position-vertical-right"]) );
                } else {
                    position( getValue(titleDefaults["position-vertical-left"]) );
                }
            }
        }

        if (anchor() === undefined) {
            if (axisIsHorizontal) {
                if (axisPerpOffset > plotBox.height()/2) {
                    anchor( getValue(titleDefaults["anchor-horizontal-top"]) );
                } else {
                    anchor( getValue(titleDefaults["anchor-horizontal-bottom"]) );
                }
            } else {
                if (axisPerpOffset > plotBox.width()/2) {
                    anchor( getValue(titleDefaults["anchor-vertical-right"]) );
                } else {
                    anchor( getValue(titleDefaults["anchor-vertical-left"]) );
                }
            }
        }

        graphicsContext.angle = this.angle();
        this.content().initializeGeometry(graphicsContext);

        return this;
    });

    /**
     * Renders the Axis Title. Overridden by implementations in graphics drivers.
     *
     * @method render
     * @private
     * @author jrfrimme
     */
    this.respondsTo("render", function () {});

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis.title, attributes);
});

module.exports = AxisTitle;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/point.js":106,"../util/utilityFunctions.js":159,"./axis.js":19,"./text.js":65}],22:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues    = utilityFunctions.getDefaultValuesFromXSD(),
    attributes       = utilityFunctions.getKeys(defaultValues.background),
    RGBColor         = require('../math/rgb_color.js'),
    Img              = require('./img.js');

var Background = new jermaine.Model("Background", function () {
    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    }).defaultsTo(RGBColor.parse(defaultValues.background.color));
    this.hasA("img").which.validatesWith(function (img) {
        return img instanceof Img;
    });
});

module.exports = Background;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/rgb_color.js":107,"../util/utilityFunctions.js":159,"./img.js":45}],23:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');
var vF = require('../util/validationFunctions.js');

var CategoryFormatter = function (formatValues) {
    if (vF.typeOf(formatValues) !== "array") {
        throw new Error("formatValues must be an array");
    }
    this.formatValues = formatValues;
    this.length = Math.max.apply(this, this.formatValues.map(function(s) { return s.length; }));
};

CategoryFormatter.prototype.format = function (value) {
    var i = Math.round(value.getRealValue());
    var k = this.formatValues.length;
    return this.formatValues[((i % k) + k) % k];
};

CategoryFormatter.prototype.getMaxLength = function () {
    return this.length;
};

CategoryFormatter.prototype.getFormatString = function () {
    return this.formatValues;
};

module.exports = CategoryFormatter;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/validationFunctions.js":160}],24:[function(require,module,exports){
var ConsecutiveDistanceFilter = function (options) {
    this.options = options;
    this.prevPx = undefined;
    this.prevPy = undefined;
    this.havePrev = false;
    this.distance = ("distance" in options) ? options.distance : 5;
};

ConsecutiveDistanceFilter.prototype.reset = function () {
    this.havePrev = false;
};

ConsecutiveDistanceFilter.prototype.filter = function (datap, pixelp) {
    var filterOut = false;
      if (this.havePrev) {
          var dx = Math.abs(pixelp[0] - this.prevPx);
          var dy = Math.abs(pixelp[1] - this.prevPy);
          filterOut = (dx + dy < this.distance);
          if (!filterOut) {
              this.prevPx = pixelp[0];
              this.prevPy = pixelp[1];
          }
      } else {
          this.prevPx = pixelp[0];
          this.prevPy = pixelp[1];
      }
    this.havePrev = true;
    return filterOut;
};

module.exports = ConsecutiveDistanceFilter;

},{}],25:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');


var ConstantPlot = new jermaine.Model("ConstantPlot", function () {
    var utilityFunctions = require('../util/utilityFunctions.js'),
        defaultValues    = utilityFunctions.getDefaultValuesFromXSD(),
        attributes       = utilityFunctions.getKeys(defaultValues.plot),
        Plot             = require('./plot.js'),
        DataValue        = require('./data_value.js');

    this.isA(Plot);
    this.hasA("constantValue").which.validatesWith(DataValue.isInstance);

    this.isBuiltWith("constantValue");

    utilityFunctions.insertDefaults(this, defaultValues.plot, attributes);

    this.respondsTo("render", function (graph, graphicsContext) {
        // graphicsContext is an optional argument passed to ConstantPlot.render() by the
        // graphics driver, and used by that driver's implementation of Renderer.begin().
        // It can be any object used by the driver -- usually some kind of graphics
        // context object.  It can also be omitted if a driver does not need it.

        if (!this.visible()) { return; }

        var haxis = this.horizontalaxis(),
            renderer = this.renderer(),
            constantValue = this.constantValue();

        if (!haxis.hasDataMin() || !haxis.hasDataMax()) {
            return;
        }

        renderer.setUpMissing(); //TODO: this is awkward -- figure out a better way!
        renderer.begin(graphicsContext);
        renderer.dataPoint([ haxis.dataMin(), constantValue ]);
        renderer.dataPoint([ haxis.dataMax(), constantValue ]);
        renderer.end();

    });

});

module.exports = ConstantPlot;


},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":159,"./data_value.js":31,"./plot.js":55}],26:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
var CSVData;
module.exports = function($) {
    if (typeof(CSVData) !== "undefined") { return CSVData; }

    var jermaine = require('../../lib/jermaine/src/jermaine.js'),
        ArrayData = require('./array_data.js');

    CSVData = new jermaine.Model(function () {

        this.isA(ArrayData);
        this.hasA("filename").which.isA("string");
        this.hasA("messageHandler");
        this.hasA("ajaxthrottle");
        this.hasA("dataIsReady").which.isA("boolean").and.defaultsTo(false);

        this.respondsTo("getIterator", function (columnIds, min, max, buffer) {
            if (this.dataIsReady()) {
                return ArrayData.getArrayDataIterator(this, columnIds, min, max, buffer);
            } else {
                return {
                    "next"    : function () {},
                    "hasNext" : function () { return false; }
                };
            }
        });

        this.respondsTo("_displayError", function (e) {
            if (this.messageHandler()) {
                this.messageHandler().error(e);
            } else {
                throw e;
            }
        });

        this.isBuiltWith("columns", "filename", "%messageHandler", "%ajaxthrottle", function () {
            var that         = this,
                ajaxthrottle = this.ajaxthrottle();

            if (ajaxthrottle === undefined) {
                ajaxthrottle = $;
            }

            this.adapter(ArrayData);
            this.init();

            if (that.filename() !== undefined) {
                that.emit({type : 'ajaxEvent', action : 'start'});
                ajaxthrottle.ajax({
                    url : that.filename(),

                    success : function (data) {
                        //parse the data
                        var dataValues = that.adapter().textToStringArray(that.getColumns(), data);
                        that.stringArray(dataValues);
                        // renormalize & populate array
                        that.ajaxNormalize();
                        that.dataIsReady(true);
                        that.emit({type : "dataReady"});
                    },

                    error : function (jqXHR, textStatus, errorThrown) {
                        var message = errorThrown;
                        if (jqXHR.statusCode().status === 404) {
                            message = "File not found: '" + that.filename() + '"';
                        } else {
                            if (textStatus) {
                                message = textStatus + ": " + message;
                            }
                        }
                        that._displayError(new Error(message));
                    },

                    // 'complete' callback gets called after either 'success' or 'error', whichever:
                    complete : function (jqXHR, textStatus) {
                        that.emit({type : 'ajaxEvent', action : 'complete'});
                    }

                });
            }
        });
    });

    return CSVData;
};

},{"../../lib/jermaine/src/jermaine.js":9,"./array_data.js":18}],27:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var EventEmitter = require('./event_emitter.js'),
    DataValue = require('../core/data_value.js'),
    DataVariable = require('./data_variable.js');

var Data = new jermaine.Model(function () {
    
    this.isA(EventEmitter);

    this.hasAn("id").which.isA("string");

    /**
     * Searches through a jermaine attr_list of DataVariables (columns) for
     * an entry having a given id or column number.
     *
     * @method find
     * @private
     * @param {String} attrName The name of the attribute to search on;
     *     should be either "id" or "column".
     * @param {String|Integer} attrValue The value to search for. If attrName
     *     is "id", this value should be a string.  If attrName is "column",
     *     this value should be an int.
     * @param {DataVariable Attr_List} columns The attr_list to search through.
     * @static
     * @return {Integer} The index (an int) of the DataVariable entry having
     *     the given attribute value, if any, or -1 if none was found
     * @author jrfrimme
     *
     * @example
     *
     *     find("id", "x", columns)
     *
     *         finds the index of the DataVariable in the columns attr_list
     *         having an id of "x"
     *
     *     find("column", 1, columns)
     *
     *         finds the index of the DataVariable in the columns attr_list
     *         having a "column" attribute of 1
     */
    var find = function (attrName, attrValue, columns) {
        var result = -1,
            i;
        for (i = 0; i < columns.size(); ++i) {
            if (columns.at(i)[attrName]() === attrValue) {
                result = i;
                break;
            }
        }
        return result;
    };

    /**
     * Set the `data` attribute of each of this data object's columns
     * to point to the data object itself.
     *
     * @method initializeColumns
     * @author jrfrimme
     */
    this.respondsTo("initializeColumns", function () {
        var i;
        for (i = 0; i < this.columns().size(); ++i) {
            this.columns().at(i).data(this);
        }
    });

    this.hasMany("columns").eachOfWhich.validateWith(function (column) {
        this.message = "Data: constructor parameter should be an array of DataVariable objects";
        return column instanceof DataVariable;
    });

    this.hasA("defaultMissingvalue").which.isA("string");
    this.hasA("defaultMissingop").which.isA("string").and.defaultsTo("eq");
    this.hasAn("adapter");

    /**
     * Initialization function --- should be called from isBuiltWith initializer.  This is split
     * off into a separate function so that it can be called from submodel's isBuiltWith initializers
     * as well, since Jermaine does not provide a way to call the parent models' isBuiltWith initializer
     * function.
     *
     * @method init
     * @author jrfrimme
     */
    this.respondsTo("init", function() {
        this.initializeColumns();
    });

    this.isBuiltWith("columns", function () {
        this.init();
    });

    this.respondsTo("columnIdToColumnNumber", function (id) {
        if (typeof(id) !== "string") {
            throw new Error("Data: columnIdToColumnNumber expects parameter to be a string");
        }

        var columnIndex = find("id", id, this.columns()),
            column = undefined;

        if (columnIndex >= 0) {
            column = this.columns().at(columnIndex);
        }

        if (column === undefined) {
            throw new Error("Data: no column with the label " + id);
        }
        
        return column.column();
    });

    this.respondsTo("columnIdToDataVariable", function (id) {
        if (typeof(id) !== "string") {
            throw new Error("Data: columnIdToDataVariable requires a string parameter");
        }
        
        var columns = this.columns(),
            dv = find("id", id, columns) !== -1 ? columns.at(find("id", id, columns)) : undefined;

        if (dv === undefined) {
            throw new Error("Data: no column with the label " + id);
        }

        return dv;
    });

    this.respondsTo("getColumnId", function (column) {
        if (typeof(column) !== "number") {
            throw new Error("Data: getColumnId method expects an integer");
        }

        var result = find("column", column, this.columns());

        if (result === -1) {
            throw new Error("Data: column " + column + " does not exist");
        }
        
        return this.columns().at(result).id();
    });

    this.respondsTo("getColumns", function () {
        var result = [],
            columns = this.columns(),
            i;

        for (i = 0; i < columns.size(); ++i) {
            result.push(columns.at(i));
        }

        return result;
    });

    this.respondsTo("getBounds", function (columnNumber) {
        // submodels must implement this
    });

    this.respondsTo("getIterator", function () {
        // submodels must implement this
    });

    /*
     * The "onReady" contract:
     * 
     * Each submodel of this Data model should do the following:
     * 
     * 1. Emit an "onReady" event whenever new data is available.
     *    The arguments to the event listener are the min and max
     *    values of the range of (newly) available data.
     * 
     * 2. Optionally, register a listener for its own "listenerAdded"
     *    events, which performs whatever actions are needed, if any,
     *    when a new "onReady" listener is registered.
     */

    this.respondsTo("pause", function() {
        //no op
    });
    this.respondsTo("resume", function() {
        //no op
    });

    this.respondsTo("isMissing", function (value, i) {
        // This method should return true if the DataValue "value" meets the "missing" criteria of
        // the i-th column
        var column;
        if (i < 0 || i >= this.columns().size()) {
            throw new Error("metadata.isMissing(): index out of range");
        }
        column = this.columns().at(i);
        if (!column.missingvalue() || !column.missingop()) {
            return false;
        }
        return value[column.missingop()](column.missingvalue());
    });

    // Sorts variables into appropriate order
    var sortVariables = function (data, sortedVariables, unsortedVariables) {
        var columns = data.columns(),
            column,
            i;
        for (i = 0; i < columns.size(); i++) {
            column = columns.at(i);
            if (column.column() !== undefined) {
                sortedVariables[column.column()] = column;
            } else {
                unsortedVariables.push(column);
            }
        }
    };

    // creates placeholder variables
    var createPlaceholderVariables = function (data, unsortedVariables) {
        var numMissingVariables = data.stringArray()[0].length - data.columns().size(),
            i;
        if (numMissingVariables > 0) {
            for (i = 0; i < numMissingVariables; i++) {
                unsortedVariables.push(null);
            }
        }
    };

    // inserts unsorted variables into the correct location
    var insertUnsortedVariables = function (sortedVariables, unsortedVariables) {
        var index, i;
        for (i = 0, index = 0; i < unsortedVariables.length; i++) {
            while (true) {
                if (sortedVariables[index] === undefined) {
                    break;
                }
                index++;
            }
            sortedVariables[index] = unsortedVariables[i];
        }
    };

    // checks that columns were correctly specified
    var checkColumnIndicies = function (data, sortedVariables) {
        var length = data.stringArray()[0].length,
            i;
        if (sortedVariables.length > length) {
            for (i = 0; i < sortedVariables.length; i++) {
                if (sortedVariables[i] instanceof DataVariable && sortedVariables[i].column() > length) {
                    throw new Error("Data Variable Error: Attempting to specify column '" + sortedVariables[i].column() + "' for a variable, while there are only " + length + " data columns available");
                }
            }                    
        }
    };

    // Handles missing attributes
    // creates the appropriate variables if missing
    var handleMissingAttributes = function (sortedVariables, defaultMissingop, defaultMissingvalue) {
        var defaultid,
            i;
        defaultMissingop = DataValue.parseComparator(defaultMissingop);
        for (i = 0; i < sortedVariables.length; i++) {
            if (!sortedVariables[i]) {
                if (i === 0) {
                    defaultid = "x";
                } else if (i === 1) {
                    defaultid = "y";
                } else {
                    defaultid = "y" + (i-1);
                }
                sortedVariables[i] = new DataVariable(defaultid, i, DataValue.NUMBER);
            } else {
                if (sortedVariables[i].column() === undefined) {
                    sortedVariables[i].column(i);
                }
                if (sortedVariables[i].type() === undefined) {
                    sortedVariables[i].type(DataValue.NUMBER);
                }
            }

            if (defaultMissingvalue !== undefined) {
                if (sortedVariables[i].missingvalue() === undefined) {
                    sortedVariables[i].missingvalue(DataValue.parse(sortedVariables[i].type(), defaultMissingvalue));
                }
            }
            if (sortedVariables[i].missingop() === undefined) {
                sortedVariables[i].missingop(defaultMissingop);
            }
        }
    };

    // Inserts the normalized variables into the data instance
    var insertNormalizedVariables = function (data, sortedVariables) {
        var columns = data.columns(),
            i;
        while (columns.size() > 0) {
            columns.pop();
        }
        for (i = 0; i < sortedVariables.length; i++) {
            columns.add(sortedVariables[i]);
        }
        data.initializeColumns();
    };


    // parses string values into the proper data types
    // If there was actual data, validate that the number of values found in stringArray
    // as large as the the number of variables declared.  ArrayData.textToStringArray(),
    // which is the function that constructed stringArray, has already guaranteed that
    // every row in stringArray is of the same length, so we can use the length of the
    // first row as the number of variables.
    var createDataValueArray = function (data, sortedVariables) {
        var ArrayData = require('./array_data.js');
        var stringArray = data.stringArray();
        if (stringArray.length > 0) {
            if (stringArray[0].length < sortedVariables.length) {
                throw new Error("data contains only " + stringArray[0].length + " column(s), but should contain " + sortedVariables.length);
            }
        }

        var dataValues = ArrayData.stringArrayToDataValuesArray(sortedVariables, stringArray);

        data.array(dataValues);
        data.stringArray([]);
    };

    this.prototype.normalize = function () {
        var ArrayData = require('./array_data.js'),
            sortedVariables   = [],
            unsortedVariables = [],
            //  mbp Tue Mar  3 10:51:40 2015:
            //    avoid requiring web_service_data.js and csv_data.js here because they have
            //    a dependency on jQuery; also avoid instanceof
            //CSVData = require('./csv_data.js'),
            //WebServiceData = require('./web_service_data.js'),
            //isCsvOrWebService = this instanceof CSVData || this instanceof WebServiceData,
            isWebServiceData = (typeof(this.serviceaddress) === "function"),
            isCSVData = (typeof(this.filename) === "function"),
            isCsvOrWebService = isWebServiceData || isCSVData;

        // Handles missing variable tags if the data tag has a 'csv' or 'service' tag
        if (isCsvOrWebService) {
            if (this.columns().size() === 0) {
                throw new Error("Data Normalization: Data gotten from csv and web service sources require variables to be specified in the mugl.");
            }
        }

        sortVariables(this, sortedVariables, unsortedVariables);

        // creates placeholder variables if the data tag has a 'values' tag
        if (this instanceof ArrayData === true && !isCsvOrWebService) {
            createPlaceholderVariables(this, unsortedVariables);
        }

        insertUnsortedVariables(sortedVariables, unsortedVariables);

        // checks that columns were correctly specified for 'values' data tags
        if (this instanceof ArrayData === true && !isCsvOrWebService) {
            checkColumnIndicies(this, sortedVariables);
        }

        handleMissingAttributes(sortedVariables, this.defaultMissingop(), this.defaultMissingvalue());
        insertNormalizedVariables(this, sortedVariables);

        // parses string values into the proper data types if the data tag has a 'values' tag
        if (this instanceof ArrayData === true && !isCsvOrWebService) {
            createDataValueArray(this, sortedVariables);
        }
    };

    this.prototype.ajaxNormalize = function () {
        var sortedVariables   = [],
            unsortedVariables = [];

        sortVariables(this, sortedVariables, unsortedVariables);
        createPlaceholderVariables(this, unsortedVariables);
        insertUnsortedVariables(sortedVariables, unsortedVariables);
        checkColumnIndicies(this, sortedVariables);
        handleMissingAttributes(sortedVariables, this.defaultMissingop(), this.defaultMissingvalue());
        insertNormalizedVariables(this, sortedVariables);
        createDataValueArray(this, sortedVariables);
    };

});

module.exports = Data;

},{"../../lib/jermaine/src/jermaine.js":9,"../core/data_value.js":31,"./array_data.js":18,"./data_variable.js":32,"./event_emitter.js":39}],28:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataValue = require('./data_value.js'),
    NumberFormatter = require('./number_formatter.js'),
    DatetimeFormatter = require('./datetime_formatter.js');

var DataFormatter = {};
/*
 * Return true or false depending on whether obj is an instance of a DataFormatter type
 */
DataFormatter.isInstance = function (obj) {
    return (obj && (typeof(obj.format) === "function") && (typeof(obj.getMaxLength) === "function"));
};

/*
 * Create a new DataFormatter subtype of a given type
 */
DataFormatter.create = function (type, format) {
    if (type === DataValue.NUMBER) {
        return new NumberFormatter(format);
    } else if (type === DataValue.DATETIME) {
        return new DatetimeFormatter(format);
    }
    throw new Error("attempt to create an unknown DataFormatter type");
};

module.exports = DataFormatter;

},{"../../lib/jermaine/src/jermaine.js":9,"./data_value.js":31,"./datetime_formatter.js":35,"./number_formatter.js":50}],29:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataValue = require('./data_value.js'),
    NumberMeasure = require('./number_measure.js'),
    DatetimeMeasure = require('./datetime_measure.js');

var DataMeasure = {};

/*
 * Return true or false depending on whether obj is an instance of a DataMeasure type
 */
DataMeasure.isInstance = function (obj) {
    return (obj && (typeof(obj.getRealValue) === "function") && (!obj.compareTo));
};

/*
 * Create a new DataMeasure subtype of a given type by parsing a string
 */
DataMeasure.parse = function (type, string) {
    if (type === DataValue.NUMBER) {
        return NumberMeasure.parse(string);
    } else if (type === DataValue.DATETIME) {
        return DatetimeMeasure.parse(string);
    }
    throw new Error("attempt to parse an unknown DataMeasure type");
};

module.exports = DataMeasure;

},{"../../lib/jermaine/src/jermaine.js":9,"./data_value.js":31,"./datetime_measure.js":36,"./number_measure.js":51}],30:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Plot = require('./plot.js'),
    DataVariable = require('./data_variable.js'),
    Filter = require('./filter.js'),
    Datatips = require('./datatips.js'),
    Data = require('./data.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot);

var graphCoordsToPixelCoords = function (graphCoords, graph, height) {
    return [
        graphCoords[0] + graph.x0(),
        height - (graphCoords[1] + graph.y0())
    ];
};

var DataPlot = new jermaine.Model("DataPlot", function () {
    this.isA(Plot);
    this.hasMany("variable").eachOfWhich.validateWith(function (variable) {
        return variable instanceof DataVariable || variable === null;
    });
    this.hasA("filter").which.validatesWith(function (filter) {
        return filter instanceof Filter;
    });
    this.hasA("datatips").which.validatesWith(function (datatips) {
        return datatips instanceof Datatips;
    });
    this.hasA("data").which.validatesWith(function (data) {
        return data instanceof Data;
    });

    utilityFunctions.insertDefaults(this, defaultValues.plot, attributes);

    this.respondsTo("render", function (graph, graphicsContext) {
        // graphicsContext is an optional argument passed to DataPlot.render() by the
        // graphics driver, and used by that driver's implementation of Renderer.begin().
        // It can be any objectded by the driver -- usually some kind of graphics
        // context object.  It can also be omitted if a driver does not need it.
        //var data = this.data().arraydata();

        if (!this.visible()) { return; }

        var data = this.data();
        if (! data) { return; }

        var haxis = this.horizontalaxis(),
            vaxis = this.verticalaxis();

        if (!haxis.hasDataMin() || !haxis.hasDataMax()) {
            // if this plot's horizontal axis does not have a min or max value yet,
            // return immediately without doing anything
            return;
        }

        var variables   = this.variable(),
            variableIds = [],
            i;
        for (i = 0; i < variables.size(); ++i) {
            variableIds.push( variables.at(i).id() );
        }

        var iter = data.getIterator(variableIds, haxis.dataMin(), haxis.dataMax(), 1),
            renderer = this.renderer();

        renderer.setUpMissing(); //TODO: this is awkward -- figure out a better way!
        renderer.begin(graphicsContext);
        while (iter.hasNext()) {
            var datap = iter.next();
            renderer.dataPoint(datap);
        }
        renderer.end();

    });


    this.respondsTo("getDatatipsData", function (loc, graphWidth, graphHeight, graph, testElem) {
        var datatips = this.datatips();
        if (!datatips) {
            return;
        }

        var data = this.data();

        if (!data) { return; }

        var haxis = this.horizontalaxis(),
            vaxis = this.verticalaxis();

        if (!haxis.hasDataMin() || !haxis.hasDataMax()) {
            // if this plot's horizontal axis does not have a min or max value yet,
            // return immediately without doing anything
            return;
        }

        var variables   = this.variable(),
            variableIds = [],
            i;

        for (i = 0; i < variables.size(); i++) {
            variableIds.push( variables.at(i).id() );
        }

        var iter        = data.getIterator(variableIds, haxis.dataMin(), haxis.dataMax(), 1),
            renderer    = this.renderer(),
            points      = [],
            x           = loc.x(),
            y           = loc.y(),
            maxDistance = 20,
            curDist,
            datap;

        while (iter.hasNext()) {
            datap = renderer.transformPoint(iter.next());
            curDist = window.multigraph.math.util.l2dist(x, y, datap[0], datap[1]);
            if (curDist < maxDistance) {
                points.push({
                    "datap"  : datap,
                    "dist"   : curDist
                });
            }
        }

        if (points.length === 0) {
            return;
        }

        var minIndex = 0,
            minDist  = points[0].dist;

        // determine index of closest point to mouse
        for (i = 1; i < points.length; i++) {
            if (points[i].dist < minDist) {
                minIndex = i;
                minDist = points[i].dist;
            }
        }

        // cache closest point to mouse
        var point      = points[minIndex],
            axisValues = [];

        // cache data for point
        datap = point.datap;

        // determine pixel location of data point
        point.pixelp = graphCoordsToPixelCoords(datap, graph, graphHeight);

        // determine real DataValues for the datapoint
        axisValues[0] = haxis.axisValueToDataValue(datap[0]);
        for (i = 1; i < datap.length; i++) {
            axisValues[i] = vaxis.axisValueToDataValue(datap[i]);
        }

        var content    = datatips.format(axisValues),
            dimensions = datatips.computeDimensions(content, testElem);

        point.content = content;
        point.dimensions = dimensions;

        // for now just use the first item in the results
        point.type = datatips.computeOrientation(point, graphWidth, graphHeight)[0];

        return point;
    });

    this.respondsTo("createDatatip", function (data) {
        var $           = window.multigraph.jQuery,
            content     = data.content,
            type        = data.type,
            dimensions  = data.dimensions,
            pixelp      = data.pixelp,
            w           = dimensions.width,
            h           = dimensions.height,
            x           = pixelp[0],
            y           = pixelp[1],
            arrowLength = data.arrow,
            offset      = determineOffsets(type, x, y, w, h, arrowLength),
            datatips    = this.datatips(),
            bordercolor = datatips.bordercolor().getHexString("#");

        var box     = $("<div>" + content + "</div>"),
            arrow   = $("<div>&nbsp</div>"),
            datatip = $("<div></div>");

        switch (type) {
        case Datatips.DOWN:
            arrow.css({
                "left"          : ((w/2) - 5) + "px",
                "border-bottom" : arrowLength + "px solid " + bordercolor,
                "border-left"   : "5px solid transparent",
                "border-right"  : "5px solid transparent",
                "border-top"    : "0px"
            });
            datatip.append(arrow);
            datatip.append(box);
            break;
        case Datatips.RIGHT:
            arrow.css({
                "top"           : ((h/2) - 5) + "px",
                "border-bottom" : "5px solid transparent",
                "border-top"    : "5px solid transparent",
                "border-right"  : arrowLength + "px solid " + bordercolor,
                "border-left"   : "0px",
                "float"         : "left"
            });
            box.css("float", "left");
            datatip.append(arrow);
            datatip.append(box);
            break;
        case Datatips.UP:
            arrow.css({
                "left"          : ((w/2) - 5) + "px",
                "border-top"    : arrowLength + "px solid " + bordercolor,
                "border-left"   : "5px solid transparent",
                "border-right"  : "5px solid transparent",
                "border-bottom" : "0px"
            });
            datatip.append(box);
            datatip.append(arrow);
            break;
        case Datatips.LEFT:
            arrow.css({
                "top"           : ((h/2) - 5) + "px",
                "border-bottom" : "5px solid transparent",
                "border-top"    : "5px solid transparent",
                "border-left"   : arrowLength + "px solid " + bordercolor,
                "border-right"  : "0px",
                "float"         : "left"
            });
            box.css("float", "left");
            datatip.append(box);
            datatip.append(arrow);
            break;
        }

        datatip.css({
            "text-align" : "left",
            "position"   : "absolute",
            "clear"      : "both",
            "left"       : offset[0] + "px",
            "top"        : offset[1] + "px",
            "margin"     : "0px",
            "padding"    : "0px"
        });

        box.css({
            "display"          : "inline-block",
            "position"         : "relative",
            "background-color" : datatips.bgcolor().toRGBA(datatips.bgalpha()),
            "text-align"       : "left",
            "margin"           : "0px",
            "padding-left"     : "5px",
            "padding-right"    : "5px",
            "padding-top"      : "1px",
            "padding-bottom"   : "1px",
            "border"           : datatips.border() + "px solid " + bordercolor,
            "border-radius"    : "5px"
        }),

        arrow.css({
            "height"     : "0px",
            "width"      : "0px",
            "position"   : "relative",
            "text-align" : "left",
            "margin"     : "0px",
            "padding"    : "0px"
        });

        return datatip;
    });

    var determineOffsets = function (type, x, y, w, h, arrowLength) {
        switch (type) {
        case Datatips.DOWN:
            return [x - w/2, y];
        case Datatips.RIGHT:
            return [x, y - h/2];
        case Datatips.UP:
            return [x - w/2, y - h - arrowLength];
        case Datatips.LEFT:
            return [x - w - arrowLength, y - h/2];
        }
    };


});

module.exports = DataPlot;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":159,"./data.js":27,"./data_variable.js":32,"./datatips.js":33,"./filter.js":40,"./plot.js":55}],31:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/*
 * DataValue is a POJSO (plain old javascript object) that simply
 * serves as an ecapsulation for several generic
 * data-value-related constants and functions.  There is no actual
 * DataValue model that can be instantiated; all data values are
 * instances of either the NumberValue or DatetimeValue model.
 */

var DataValue = {};

DataValue.NUMBER = "number";
DataValue.DATETIME = "datetime";
DataValue.UNKNOWN = "unknown";

/*
 * Return a list of the type constants above
 */
DataValue.types = function () {
    return [ DataValue.NUMBER, DataValue.DATETIME, DataValue.UNKNOWN ];
};

/*
 * Create a new DataValue subtype of a given type by parsing a string
 */
DataValue.parseType = function (string) {
    if (string.toLowerCase() === DataValue.NUMBER) { return DataValue.NUMBER; }
    if (string.toLowerCase() === DataValue.DATETIME) { return DataValue.DATETIME; }
    throw new Error("unknown DataValue type: " + string);
};

/*
 * This function converts a "type" enum object to a string.  In reality, the objects ARE
 * the strings, so we just return the object.
 */
DataValue.serializeType = function (type) {
    return type;
};

/*
 * Return true or false depending on whether obj is an instance of a DataValue type
 */
DataValue.isInstance = function (obj) {
    return (obj && (typeof(obj.getRealValue) === "function") && (typeof(obj.compareTo) === "function"));
};

/*
 * Same as DataValue.isInstance, but also allows the null value
 */
DataValue.isInstanceOrNull = function (obj) {
    return ((obj===null) || DataValue.isInstance(obj));
};

/*
 * Create a new DataValue subtype of a given type from a real value
 */
DataValue.create = function (type, realValue) {
    var NumberValue = require('./number_value.js'),
        DatetimeValue = require('./datetime_value.js');

    if (type === DataValue.NUMBER) {
        return new NumberValue(realValue);
    } else if (type === DataValue.DATETIME) {
        return new DatetimeValue(realValue);
    }
    throw new Error("attempt to parse an unknown DataValue type");
};

/*
 * Create a new DataValue subtype of a given type by parsing a string
 */
DataValue.parse = function (type, string) {
    var NumberValue = require('./number_value.js'),
        DatetimeValue = require('./datetime_value.js');

    if (type === DataValue.NUMBER) {
        return NumberValue.parse(string);
    } else if (type === DataValue.DATETIME) {
        return DatetimeValue.parse(string);
    }
    throw new Error("attempt to parse an unknown DataValue type");
};

/*
 * Enum values for comparison operators.  These should be lowercase strings --- they're used as
 * actual method names below.
 */
DataValue.LT = "lt";
DataValue.LE = "le";
DataValue.EQ = "eq";
DataValue.GE = "ge";
DataValue.GT = "gt";
DataValue.NE = "ne";

var comparatorFuncs = {};
comparatorFuncs[DataValue.LT] = function (x) { return this.compareTo(x)   < 0; };
comparatorFuncs[DataValue.LE] = function (x) { return this.compareTo(x)  <= 0; };
comparatorFuncs[DataValue.EQ] = function (x) { return this.compareTo(x) === 0; };
comparatorFuncs[DataValue.GE] = function (x) { return this.compareTo(x)  >= 0; };
comparatorFuncs[DataValue.GT] = function (x) { return this.compareTo(x)   > 0; };
comparatorFuncs[DataValue.NE] = function (x) { return this.compareTo(x) !== 0; };

/*
 * Mix the 5 comparator function into another object:
 */
DataValue.mixinComparators = function (obj) {
    obj[DataValue.LT] = comparatorFuncs[DataValue.LT];
    obj[DataValue.LE] = comparatorFuncs[DataValue.LE];
    obj[DataValue.EQ] = comparatorFuncs[DataValue.EQ];
    obj[DataValue.GE] = comparatorFuncs[DataValue.GE];
    obj[DataValue.GT] = comparatorFuncs[DataValue.GT];
    obj[DataValue.NE] = comparatorFuncs[DataValue.NE];
};

/*
 * The comparators function returns a list of the 5 comparator
 * functions, to be used like an enum type.
 */
DataValue.comparators = function () {
    return [ DataValue.LT, DataValue.LE, DataValue.EQ, DataValue.GE, DataValue.GT, DataValue.NE ];
};

/*
 * Convert a string to a comparator enum object:
 */
DataValue.parseComparator = function (string) {
    if (typeof(string) === "string") {
        switch (string.toLowerCase()) {
        case "lt": return DataValue.LT;
        case "le": return DataValue.LE;
        case "eq": return DataValue.EQ;
        case "ge": return DataValue.GE;
        case "gt": return DataValue.GT;
        case "ne": return DataValue.NE;
        }
    }
    throw new Error(string + " should be one of 'lt', 'le', 'eq', 'ge', 'gt', 'ne'.");
};

module.exports = DataValue;

},{"../../lib/jermaine/src/jermaine.js":9,"./datetime_value.js":38,"./number_value.js":52}],32:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataValue = require('./data_value.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.data.variables.variable);

var DataVariable = new jermaine.Model("DataVariable", function () {
    this.hasA("id").which.isA("string");
    this.hasA("column").which.isA("integer");
    this.hasA("type").which.isOneOf(DataValue.types()).and.defaultsTo(DataValue.NUMBER);
    this.hasA("data").which.validatesWith(function (data) {
        var Data = require('./data.js');
        return data instanceof Data;
    });
    this.hasA("missingvalue").which.validatesWith(DataValue.isInstance);

    this.hasA("missingop").which.isOneOf(DataValue.comparators());
    this.isBuiltWith("id", "%column", "%type");

    utilityFunctions.insertDefaults(this, defaultValues.data.variables.variable, attributes);
});

module.exports = DataVariable;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":159,"./data.js":27,"./data_value.js":31}],33:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DatatipsVariable = require('./datatips_variable.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    DataValue = require('./data_value.js'),
    DataFormatter = require('./data_formatter.js'),
    RGBColor = require('../math/rgb_color.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.datatips);

var Datatips = new jermaine.Model("Datatips", function () {
    this.hasMany("variables").eachOfWhich.validateWith(function (variable) {
        return variable instanceof DatatipsVariable;
    });
    this.hasA("formatString").which.isA("string");
    this.hasA("bgcolor").which.validatesWith(function (bgcolor) {
        return bgcolor instanceof RGBColor;
    });
    this.hasA("bgalpha").which.isA("number");
    this.hasA("border").which.isA("integer");
    this.hasA("bordercolor").which.validatesWith(function (bordercolor) {
        return bordercolor instanceof RGBColor;
    });
    this.hasA("pad").which.isA("integer");

    this.respondsTo("format", function (data) {
        var formattedData = [],
            replacementPatterns = [],
            output = this.formatString(),
            i, l = data.length;

        for (i = 0; i < l; i++) {
            formattedData.push(this.variables().at(i).formatter().format(data[i]));
            replacementPatterns.push(new RegExp("\\{" + i + "\\}", "g"));
        }

        for (i = 0; i < l; i++) {
            output = output.replace(replacementPatterns[i], formattedData[i]);
        }

        output = output.replace(/[\n|\r]/g, "<br/>");

        return output;
    });

    this.respondsTo("computeDimensions", function (content, elem) {
        var paddingWidth  = parseInt(elem.css("padding-left"), 10) + parseInt(elem.css("padding-right"), 10),
            paddingHeight = parseInt(elem.css("padding-top"), 10)  + parseInt(elem.css("padding-bottom"), 10),
            border        = 2 * this.border();

        elem.html(content);

        return {
            "width"  : elem.width()  + border + paddingWidth,
            "height" : elem.height() + border + paddingHeight
        };
    });

    this.respondsTo("computeOrientation", function (data, graphWidth, graphHeight) {
        var dimensions    = data.dimensions,
            pixelp        = data.pixelp,
            datatipWidth  = dimensions.width,
            datatipHeight = dimensions.height,
            baseX         = pixelp[0],
            baseY         = pixelp[1],
            offset        = 20,
            offsetWidth   = datatipWidth  + offset,
            offsetHeight  = datatipHeight + offset;

        baseY = graphHeight - baseY; // remove this line when baseY is taken from the lower left corner being the origin

        if ( // center
            baseX       - offsetWidth  >= 0 &&
                graphWidth  - baseX        >= offsetWidth &&
                baseY       - offsetHeight >= 0 &&
                graphHeight - baseY        >= offsetHeight
        ) {
            return [Datatips.UP, Datatips.DOWN, Datatips.RIGHT, Datatips.LEFT];
        } else if ( // top
            baseX       - offsetWidth  >= 0 &&
                graphWidth  - baseX        >= offsetWidth &&
                baseY                      >= graphHeight - offsetHeight &&
                graphHeight                >= baseY
        ) {
            return [Datatips.DOWN, Datatips.RIGHT, Datatips.LEFT, Datatips.UP];
        } else if ( // bottom
            baseX      - offsetWidth >= 0 &&
                graphWidth - baseX       >= offsetWidth &&
                offsetHeight             >= baseY &&
                baseY                    >= 0
        ) {
            return [Datatips.UP, Datatips.RIGHT, Datatips.LEFT, Datatips.DOWN];
        } else if ( // left
            baseX                      >= 0 &&
                offsetWidth                >= baseX &&
                baseY       - offsetHeight >= 0 &&
                graphHeight - baseY        >= offsetHeight
        ) {
            return [Datatips.RIGHT, Datatips.UP, Datatips.DOWN, Datatips.LEFT];
        } else if ( // right
            graphWidth                 >= baseX &&
                offsetWidth                >= graphWidth - baseX &&
                baseY       - offsetHeight >= 0 &&
                graphHeight - baseY        >= offsetHeight
        ) {
            return [Datatips.LEFT, Datatips.UP, Datatips.DOWN, Datatips.RIGHT];
        } else {
            var preferences = [];
            if (baseX < graphWidth / 2) { // left side of graph
                if (baseY > graphHeight / 2) { // top-left corner of graph
                    if (baseX - datatipWidth/2 < (graphHeight - baseY) - datatipHeight/2) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.RIGHT);
                        preferences.push(Datatips.DOWN);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.DOWN);
                        preferences.push(Datatips.RIGHT);
                    }
                    if (baseX - offsetWidth < (graphHeight - baseY) - offsetHeight) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.UP);
                        preferences.push(Datatips.LEFT);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.LEFT);
                        preferences.push(Datatips.UP);
                    }
                } else { // bottom-left corner of graph
                    if (baseX - datatipWidth/2 < baseY - datatipHeight/2) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.RIGHT);
                        preferences.push(Datatips.UP);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.UP);
                        preferences.push(Datatips.RIGHT);
                    }
                    if (baseX - offsetWidth < baseY - offsetHeight) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.DOWN);
                        preferences.push(Datatips.LEFT);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.LEFT);
                        preferences.push(Datatips.DOWN);
                    }
                }
            } else { // right side of graph
                if (baseY > graphHeight / 2) { // top-right corner of graph
                    if ((graphWidth - baseX) - datatipWidth/2 < (graphHeight - baseY) - datatipHeight/2) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.LEFT);
                        preferences.push(Datatips.DOWN);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.DOWN);
                        preferences.push(Datatips.LEFT);
                    }
                    if ((graphWidth - baseX) - offsetWidth < (graphHeight - baseY) - offsetHeight) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.UP);
                        preferences.push(Datatips.RIGHT);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.RIGHT);
                        preferences.push(Datatips.UP);
                    }
                } else { // bottom-right corner of graph
                    if ((graphWidth - baseX) - datatipWidth/2 < baseY - datatipHeight/2) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.LEFT);
                        preferences.push(Datatips.UP);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.UP);
                        preferences.push(Datatips.LEFT);
                    }
                    if ((graphWidth - baseX) - offsetWidth < baseY - offsetWidth) {
                        // more is lost off the horizontal side than the vertical side
                        preferences.push(Datatips.DOWN);
                        preferences.push(Datatips.RIGHT);
                    } else {
                        // more is lost off the vertical side than the horizontal side
                        preferences.push(Datatips.RIGHT);
                        preferences.push(Datatips.DOWN);
                    }
                }
            }
            return preferences;
        }
    });



    this.respondsTo("normalize", function (plot) {
        var datatipsVariables = this.variables(),
            plotVariables     = plot.variable(),
            variable,
            type,
            i;

        // creates missing variables for the datatip                                                                                                 
        if (datatipsVariables.size() < plotVariables.size()) {
            for (i = datatipsVariables.size(); i < plotVariables.size(); i++) {
                datatipsVariables.add(new DatatipsVariable());
            }
        }

        // sets up formatters for datatips variables                                                                                                 
        for (i = 0; i < datatipsVariables.size(); i++) {
            variable = datatipsVariables.at(i);
            type = plotVariables.at(i).type();
            if (variable.formatString() === undefined) {
                if (type === DataValue.NUMBER) {
                    variable.formatString(defaultValues["formatString-number"]);
                } else {
                    variable.formatString(defaultValues["formatString-datetime"]);
                }
            }
            variable.formatter(DataFormatter.create(type, variable.formatString()));
        }
    });


    utilityFunctions.insertDefaults(this, defaultValues.plot.datatips, attributes);
});

Datatips.UP    = "u";
Datatips.DOWN  = "d";
Datatips.LEFT  = "l";
Datatips.RIGHT = "r";

module.exports = Datatips;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/rgb_color.js":107,"../util/utilityFunctions.js":159,"./data_formatter.js":28,"./data_value.js":31,"./datatips_variable.js":34}],34:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.datatips.variable),
    DataFormatter = require('./data_formatter.js');

var DatatipsVariable = new jermaine.Model("DatatipsVariable", function () {
    this.hasA("formatString").which.isA("string");
    this.hasA("formatter").which.validatesWith(DataFormatter.isInstance);

    utilityFunctions.insertDefaults(this, defaultValues.plot.datatips.variable, attributes);
});

module.exports = DatatipsVariable;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":159,"./data_formatter.js":28}],35:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var sprintf = require('sprintf');

var DatetimeFormatter = function (format) {
    var testString;
    if (typeof(format) !== "string") {
        throw new Error("format must be a string");
    }
    this.formatString = format;
    testString = DatetimeFormatter.formatInternally(format, new Date(0));
    this.length = testString.length;
};

DatetimeFormatter.prototype.format = function (value) {
    return DatetimeFormatter.formatInternally(this.formatString, value.value);
};

DatetimeFormatter.prototype.getMaxLength = function () {
    return this.length;
};

DatetimeFormatter.prototype.getFormatString = function () {
    return this.formatString;
};

DatetimeFormatter.formatInternally = function (formatString, date) {
    var dayNames = {
        "shortNames": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        "longNames": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
        monthNames = {
            "shortNames": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "longNames": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        },
        state = 0,
        c,
        i,
        t,
        output = "";

    for (i = 0; i < formatString.length; i++) {
        c = formatString.charAt(i);
        switch (state) {
        case 0:
            if (c === "%") {
                state = 1;
            } else {
                output += c;
            }
            break;
        case 1:
            switch (c) {
            case "Y":
                // four digit year
                output += date.getUTCFullYear().toString();
                break;
            case "y":
                // two digit year
                output += date.getUTCFullYear().toString().substr(2, 2);
                break;
            case "M":
                // 2-digit month number with leading zero
                output += sprintf("%02s", (date.getUTCMonth() + 1).toString());
                break;
            case "m":
                // month number without leading zero
                output += (date.getUTCMonth() + 1).toString();
                break;
            case "N":
                // month name, spelled out
                output += monthNames.longNames[date.getUTCMonth()];
                break;
            case "n":
                // month name, 3 letter abbreviation
                output += monthNames.shortNames[date.getUTCMonth()];
                break;
            case "D":
                // two-digit day of month with leading zero
                output += sprintf("%02s", date.getUTCDate().toString());
                break;
            case "d":
                // day of month without leading zero
                output += date.getUTCDate().toString();
                break;
            case "W":
                // weekday name, spelled out
                output += dayNames.longNames[date.getUTCDay()];
                break;
            case "w":
                // weekday name, 3-letter abbreviation
                output += dayNames.shortNames[date.getUTCDay()];
                break;
            case "H":
                // hour of day, 24 hour clock
                output += sprintf("%02s", date.getUTCHours().toString());
                break;
            case "h":
                // hour of day, 12 hour clock
                t = date.getUTCHours() % 12;
                if (t === 0) {
                    output += "12";
                } else {
                    output += t.toString();
                }
                break;
            case "i":
                // minutes
                output += sprintf("%02s", date.getUTCMinutes().toString());
                break;
            case "s":
                // seconds
                output += sprintf("%02s", date.getUTCSeconds().toString());
                break;
            case "v":
                // deciseconds (10ths of a second)
                output += sprintf("%03s", date.getUTCMilliseconds().toString()).substr(0, 1);
                break;
            case "V":
                // centiseconds (100ths of a second)
                output += sprintf("%03s", date.getUTCMilliseconds().toString()).substr(0, 2);
                break;
            case "q":
                // milliseconds (1000ths of a second)
                output += sprintf("%03s", date.getUTCMilliseconds().toString());
                break;
            case "P":
                // AM or PM
                t = date.getUTCHours();
                if (t < 12) {
                    output += "AM";
                } else {
                    output += "PM";
                }
                break;
            case "p":
                // am or pm
                t = date.getUTCHours();
                if (t < 12) {
                    output += "am";
                } else {
                    output += "pm";
                }
                break;
            case "L":
                // newline
                output += "\n";
                break;
            case "%":
                // %
                output += "%";
                break;
            default:
                throw new Error("Invalid character code for datetime formatting string");
            }
            state = 0;
            break;
        }
    }
    return output;
};

module.exports = DatetimeFormatter;

},{"../../lib/jermaine/src/jermaine.js":9,"sprintf":17}],36:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DatetimeValue = require('./datetime_value.js'),
    Enum = require('../math/enum.js');

var DatetimeUnit = require('./datetime_unit.js');

var DatetimeMeasure = function (measure, unit) {
    if (typeof(measure) !== "number" || DatetimeMeasure.isUnit(unit) !== true) {
        throw new Error("Improper input for Datetime Measure's constructor");
    } else if (arguments.length !== 2) {
        throw new Error("Datetime Measure's contructor requires exactly two arguments");
    }
    this.measure = measure;
    this.unit    = unit;
};

DatetimeMeasure.isUnit = function (unit) {
    return DatetimeUnit.isInstance(unit);
};

DatetimeMeasure.prototype.negative = function () {
    return new DatetimeMeasure(-this.measure, this.unit);
};

DatetimeMeasure.prototype.getRealValue = function () {
    var factor;
    switch (this.unit) {
    case DatetimeUnit.MILLISECOND:
        factor = 1;
        break;
    case DatetimeUnit.SECOND:
        factor = 1000;
        break;
    case DatetimeUnit.MINUTE:
        factor = 60000;
        break;
    case DatetimeUnit.HOUR:
        factor = 3600000;
        break;
    case DatetimeUnit.DAY:
        factor = 86400000;
        break;
    case DatetimeUnit.WEEK:
        factor = 604800000;
        break;
    case DatetimeUnit.MONTH:
        factor = 2592000000;
        break;
    case DatetimeUnit.YEAR:
        factor = 31536000000;
        break;
    }
    return this.measure * factor;
};

DatetimeMeasure.parse = function (s) {
    var re, measure, unit;

    if (typeof(s) !== "string" || s.match(/\s*-?(([0-9]+\.?[0-9]*)|([0-9]*\.?[0-9]+))\s*(ms|s|m|H|D|W|M|Y){1}\s*$/) === null) {
        throw new Error("Improper input for Datetime Measure's parse method");
    }

    re      = /ms|s|m|H|D|W|M|Y/;
    measure = parseFloat(s.replace(re, ""));
    unit    = s.match(re); // returns an array

    unit = DatetimeUnit.parse(unit[0]);

    return new DatetimeMeasure(measure, unit);
};

DatetimeMeasure.findTickmarkWithMillisecondSpacing = function (/*number(milliseconds)*/value, /*number(milliseconds)*/alignment, /*number(milliseconds)*/spacing) {
    var offset = value - alignment,
        d      = Math.floor( offset / spacing );
    if (offset % spacing !== 0) {
        ++d;
    }
    return new DatetimeValue(alignment + d * spacing);
};

DatetimeMeasure.findTickmarkWithMonthSpacing = function (/*DatetimeValue*/value, /*DatetimeValue*/alignment, /*number(months)*/monthSpacing) {
    var valueD = value.value,       //NOTE: ".value" property of DatetimeValue is a javascript Date object
        alignD = alignment.value,   //NOTE: ".value" property of DatetimeValue is a javascript Date object
        monthOffset = 12 * (valueD.getUTCFullYear() - alignD.getUTCFullYear()) + (valueD.getUTCMonth() - alignD.getUTCMonth()),
        d = Math.floor( monthOffset / monthSpacing );

    if (monthOffset % monthSpacing !== 0) { ++d; }
    else if (valueD.getUTCDate() > alignD.getUTCDate()) { ++d; }
    else if (valueD.getUTCDate() === alignD.getUTCDate() && valueD.getUTCHours() > alignD.getUTCHours()) { ++d; }
    else if (valueD.getUTCDate() === alignD.getUTCDate() && valueD.getUTCHours() === alignD.getUTCHours() && valueD.getUTCMinutes() > alignD.getUTCMinutes()) { ++d; }
    else if (valueD.getUTCDate() === alignD.getUTCDate() && valueD.getUTCHours() === alignD.getUTCHours() && valueD.getUTCMinutes() === alignD.getUTCMinutes() && valueD.getUTCSeconds() > alignD.getUTCSeconds()) { ++d; }
    else if (valueD.getUTCDate() === alignD.getUTCDate() && valueD.getUTCHours() === alignD.getUTCHours() && valueD.getUTCMinutes() === alignD.getUTCMinutes() && valueD.getUTCSeconds() === alignD.getUTCSeconds() && valueD.getUTCMilliseconds() > alignD.getUTCMilliseconds()) { ++d; }

    return alignment.add( DatetimeMeasure.parse((d * monthSpacing) + "M") );
};


/**
 * Consider the regular lattice of points on the Datetime line separated from each other
 * by `this` DatetimeMeasure, and aligned at the DatetimeValue `alignment`.  This function
 * return the smallest DatetimeValue in that lattice which is greater than or equal to
 * `value`.
 * 
 * return: a DatetimeValue
 */
DatetimeMeasure.prototype.firstSpacingLocationAtOrAfter = function (/*DatetimeValue*/value, /*DatetimeValue*/alignment)  {
    switch (this.unit) {
    case DatetimeUnit.MONTH:
        return DatetimeMeasure.findTickmarkWithMonthSpacing(value, alignment, this.measure);
    case DatetimeUnit.YEAR:
        return DatetimeMeasure.findTickmarkWithMonthSpacing(value, alignment, this.measure * 12);
    default:
        return DatetimeMeasure.findTickmarkWithMillisecondSpacing(value.getRealValue(), alignment.getRealValue(), this.getRealValue());
    }
};

/**
 * This function is just like `firstSpacingLocationAtOrAfter` above, but returns the
 * greatest DatetimeValue in the lattice that is less than or equal to `value`.
 * 
 * return: a DatetimeValue
 */
DatetimeMeasure.prototype.lastSpacingLocationAtOrBefore = function (/*DatetimeValue*/value, /*DatetimeValue*/alignment)  {
    var x = this.firstSpacingLocationAtOrAfter(value, alignment);
    if (x.eq(value)) {
        return x;
    }
    var y = x.add(this.negative());
    return y;
};

DatetimeMeasure.prototype.toString = function () {
    return this.measure.toString() + this.unit.toString();
};


module.exports = DatetimeMeasure;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/enum.js":104,"./datetime_unit.js":37,"./datetime_value.js":38}],37:[function(require,module,exports){
var Enum = require('../math/enum.js');

var DatetimeUnit = new Enum("DatetimeUnit");

DatetimeUnit.MILLISECOND = new DatetimeUnit("ms");
DatetimeUnit.SECOND      = new DatetimeUnit("s");
DatetimeUnit.MINUTE      = new DatetimeUnit("m");
DatetimeUnit.HOUR        = new DatetimeUnit("H");
DatetimeUnit.DAY         = new DatetimeUnit("D");
DatetimeUnit.WEEK        = new DatetimeUnit("W");
DatetimeUnit.MONTH       = new DatetimeUnit("M");
DatetimeUnit.YEAR        = new DatetimeUnit("Y");

module.exports = DatetimeUnit;

},{"../math/enum.js":104}],38:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataValue = require('./data_value.js'),
    DatetimeUnit = require('./datetime_unit.js'),
    sprintf = require('sprintf');

var DatetimeValue = function (value) {
    if (typeof(value) !== "number") {
        throw new Error("DatetimeValue requires its parameter to be a number");
    }
    this.value = new Date(value);
};

DatetimeValue.prototype.getRealValue = function () {
    return this.value.getTime();
};

DatetimeValue.prototype.type = DataValue.DATETIME;

DatetimeValue.prototype.clone = function() {
    return new DatetimeValue(this.getRealValue());
};

DatetimeValue.parse = function (string) {
    var Y = 0,
        M = 0,
        D = 1,
        H = 0,
        m = 0,
        s = 0,
        ms = 0;
    if (typeof(string) === "string") {
        string = string.replace(/[\.\-\:\s]/g, "");
        if (string.length === 4) {
            Y = parseInt(string, 10);
        } else if (string.length === 6) {
            Y = parseInt(string.substring(0,4), 10);
            M = parseInt(string.substring(4,6), 10) - 1;
        } else if (string.length === 8) {
            Y = parseInt(string.substring(0,4), 10);
            M = parseInt(string.substring(4,6), 10) - 1;
            D = parseInt(string.substring(6,8), 10);
        } else if (string.length === 10) {
            Y = parseInt(string.substring(0,4), 10);
            M = parseInt(string.substring(4,6), 10) - 1;
            D = parseInt(string.substring(6,8), 10);
            H = parseInt(string.substring(8,10), 10);
        } else if (string.length === 12) {
            Y = parseInt(string.substring(0,4), 10);
            M = parseInt(string.substring(4,6), 10) - 1;
            D = parseInt(string.substring(6,8), 10);
            H = parseInt(string.substring(8,10), 10);
            m = parseInt(string.substring(10,12), 10);
        } else if (string.length === 14) {
            Y = parseInt(string.substring(0,4), 10);
            M = parseInt(string.substring(4,6), 10) - 1;
            D = parseInt(string.substring(6,8), 10);
            H = parseInt(string.substring(8,10), 10);
            m = parseInt(string.substring(10,12), 10);
            s = parseInt(string.substring(12,14), 10);
        } else if (string.length === 15 || string.length === 16 || string.length === 17) {
            Y  = parseInt(string.substring(0,4), 10);
            M  = parseInt(string.substring(4,6), 10) - 1;
            D  = parseInt(string.substring(6,8), 10);
            H  = parseInt(string.substring(8,10), 10);
            m  = parseInt(string.substring(10,12), 10);
            s  = parseInt(string.substring(12,14), 10);
            ms = parseInt(string.substring(14,17), 10);
        } else if (string === "0") {
            // handles the case of "0", which parser should convert to the Unix epoch
            Y = 1970;
        } else {
            throw new Error("Incorrect input format for Datetime Value's parse method:" + string);
        }
    } else {
        throw new Error("Datetime Value's parse method requires its parameter to be a string");
    }
    return new DatetimeValue(Date.UTC(Y, M, D, H, m, s, ms));
};


DatetimeValue.prototype.toString = function () {
    var Y, M, D, H, m, s, ms;

    Y  = sprintf("%04s", this.value.getUTCFullYear().toString());
    M  = sprintf("%02s", (this.value.getUTCMonth() + 1).toString());
    D  = sprintf("%02s", this.value.getUTCDate().toString());
    H  = sprintf("%02s", this.value.getUTCHours().toString());
    m  = sprintf("%02s", this.value.getUTCMinutes().toString());
    s  = sprintf("%02s", this.value.getUTCSeconds().toString());
    ms = "." + sprintf("%03s", this.value.getUTCMilliseconds().toString());

    if (ms === ".000") {
        ms = "";
    }
    
    return Y + M + D + H + m + s + ms;
};


DatetimeValue.prototype.compareTo = function (x) {
    if (this.getRealValue() < x.getRealValue()) {
        return -1;
    } else if (this.getRealValue() > x.getRealValue()) {
        return 1;
    }
    return 0;
};

DatetimeValue.prototype.addRealValue = function ( realValueIncr ) {
    return new DatetimeValue(this.value.getTime() + realValueIncr);
};

DatetimeValue.prototype.add = function ( /*DataMeasure*/ measure) {
    var date = new DatetimeValue(this.getRealValue());
    switch (measure.unit) {
    case DatetimeUnit.MILLISECOND:
        date.value.setUTCMilliseconds(date.value.getUTCMilliseconds() + measure.measure);
        break;
    case DatetimeUnit.SECOND:
        date.value.setUTCSeconds(date.value.getUTCSeconds() + measure.measure);
        break;
    case DatetimeUnit.MINUTE:
        date.value.setUTCMinutes(date.value.getUTCMinutes() + measure.measure);
        break;
    case DatetimeUnit.HOUR:
        date.value.setUTCHours(date.value.getUTCHours() + measure.measure);
        break;
    case DatetimeUnit.DAY:
        date.value.setUTCDate(date.value.getUTCDate() + measure.measure);
        break;
    case DatetimeUnit.WEEK:
        date.value.setUTCDate(date.value.getUTCDate() + measure.measure * 7);
        break;
    case DatetimeUnit.MONTH:
        date.value.setUTCMonth(date.value.getUTCMonth() + measure.measure);
        break;
    case DatetimeUnit.YEAR:
        date.value.setUTCFullYear(date.value.getUTCFullYear() + measure.measure);
        break;
    }
    return date;
};

DataValue.mixinComparators(DatetimeValue.prototype);

module.exports = DatetimeValue;

},{"../../lib/jermaine/src/jermaine.js":9,"./data_value.js":31,"./datetime_unit.js":37,"sprintf":17}],39:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/**
 * EventEmitter is a Jermaine model that supports basic event emitting /
 * handling for Jermaine objects.
 *
 * Events are represented as plain old JavaScript objects with at least
 * the following two properties:
 *
 *   **type**
 *
 *   > a string giving the type of the event; this can be any
 *     arbitrary string.  The event type is not restricted to be
 *     from some predetermined list; applications are free to
 *     use whatever strings they want for their event types.
 *
 *   **target**
 *
 *   > a reference to the object that emitted the event
 *
 * Event objects may also contain arbitrary other properties that are specific to
 * a particular event type.
 *
 * Any Jermaine model can declare itself to be an event emitter by saying
 * "this.isA(EventEmitter)" in its model declaration.
 *
 * This adds three methods to the model:
 *  
 *   **addListener(eventType, listenerFunction)**
 *
 *   > Registers listenerFunction as a listener for events of type
 *     eventType (a string).  listenerFunction should be a function
 *     that accepts a single argument which will be a reference to an
 *     event object as described above.  When the object emits the
 *     event, the listener function will be invoked in the context
 *     where its "this" keyword refers to the object that emitted the
 *     event (the event target).  If listenerFunction is already
 *     registered as a listener for eventType, this function does
 *     nothing --- each listener function can be registered only once.
 *
 *   **removeListener(eventType, listenerFunction)**
 *
 *   > Removes the given listenerFunction from the list of listeners
 *     for this object for events of type eventType.
 *
 *   **emit(event)**
 *
 *   > Causes the object to emit the given event.  The argument can be
 *     either a string, in which case it is assumed to be an event type
 *     and is converted to an event object with the given 'type'
 *     property, or an event object with a 'type' property and any
 *     other desired properties.  The emit() method automatically adds
 *     a 'target' property to the event object, whose value is a
 *     reference to the object emitting the event.
 *
 * In most cases the emit() method is only called from within the
 * implementation of an EventEmitter object, and code external to the
 * object's model will use its addListener() and removeListener() methods
 * to process events that the object emits.  All three of these methods
 * are public methods, though, so it's also possible for code outside of
 * an object's implementation to cause it to emit an event, or for the
 * object's own code to listen for and process its own events.
 *
 * Two special types of events are always present for every EventEmitter
 * object: the "listenerAdded" and "listenerRemoved" events.  These
 * events make it possible to monitor the addition or removal of event
 * listeners.  The "listenerAdded" event is emitted whenever a new
 * listener function is added, and the "listenerRemoved" event is emitted
 * whenever a listener is removed.  Each of these events contain the
 * following properties:
 *
 *   **targetType**
 *
 *   > the event type associated with the listener
 *     being added or removed
 *
 *   **listener**
 *
 *   > the listener function being added or removed
 *
 * @class EventEmitter
 * @for EventEmitter
 * @constructor
 * @example
 *     var Person = new jermaine.Model(function() {
 *         this.isA(EventEmitter);
 *         this.hasA("name").which.isA("string");
 *         this.respondsTo("say", function(something) {
 *             console.log(this.name() + ' says ' + something);
 *             this.emit({type : "say", message : something});
 *         });
 *     });
 *     var person = new Person().name("Mark");
 *
 *     var sayListener = function(event) {
 *         console.log(event.target.name() + ' said ' + event.message);
 *     };
 *
 *     person.say('Hello');
 *     person.addListener("say", sayListener);
 *     person.say('Alright');
 *     person.removeListener("say", sayListener);
 *     person.say('Goodbye');
 *
 *
 *     OUTPUT:
 *
 *         Mark says Hello
 *         Mark says Alright
 *         Mark said Alright
 *         Mark said Goodbye
 */
var EventEmitter = new jermaine.Model(function () {
    // listeners is a plain old JS object whose keys are events
    // types (strings); the value associated with each key is the
    // list of registered listener functions for that event type.
    this.hasA("listeners").which.defaultsTo( function() {
        // Use a function that returns an empty object as the
        // default value, so we get a new listeners object
        // created for each EventEmitter instance.
        return {};
    });

    /**
     * Adds a listener function for events of a specific type
     * emitted by this object.
     * 
     * @method addListener
     * @param {string} eventType the type of event
     * @param {function} listener a listener function
     * @return {boolean} a value indicating whether the listener
     *         was actually added (a listener is not added if it
     *         is already registered for the eventType)
     */
    this.respondsTo("addListener", function (eventType, listener) {
        var listeners = this.listeners(),
            i;

        if (listeners[eventType] === undefined) {
            listeners[eventType] = [];
        }
        for (i=0; i<listeners[eventType].length; ++i) {
            if (listeners[eventType][i] === listener) {
                return false;
            }
        }
        listeners[eventType].push(listener);
        this.emit({ type       : "listenerAdded",
                    targetType : eventType,
                    listener   : listener});
        return true;
    });

    /**
     * Removes a listener function for events of a specific type
     * emitted by this object.
     * 
     * @method removeListener
     * @param {string} eventType the type of event
     * @param {function} listener the listener function to remove
     * @return {boolean} a value indicating whether the listener
     *         was actually removed.
     */
    this.respondsTo("removeListener", function (eventType, listener) {
        var listeners = this.listeners(),
            i;

        if (listeners[eventType] !== undefined) {
            for (i=0; i<listeners[eventType].length; ++i) {
                if (listeners[eventType][i] === listener) {
                    listeners[eventType][i] = null;
                    this.emit({ type       : "listenerRemoved",
                                targetType : eventType,
                                listener   : listener});
                    return true;
                }
            }
        }
        return false;
    });

    /**
     * Call this objects listeners for a specific event.  If the "event"
     * argument is a string, it is converted to an Object having
     * that string as the value of its "type" attribute; otherwise
     * the "event" argument should be an event Object having a
     * "type" attribute and any other attributes approriate for
     * that event type.  In either case, all (if there are any) of
     * the current listeners on this object for events of the
     * given type will be invoked, being passed an event object.
     * 
     * @method emit
     * @param {Object|string} event either a string representing an event type, or an event
     *                                 object with a 'type' attribute.
     * @return (nothing)
     */
    this.respondsTo("emit", function (event) {
        var listeners,
            i,
            nulls = [];

        if (typeof(event) === "string") {
            event = { type : event };
        }
        if (!event.target) {
            event.target = this;
        }
        if (!event.type) {
            throw new Error("Event object missing 'type' property");
        }

        listeners = this.listeners()[event.type];

        if (!listeners) {
            // no listeners registered for this event type
            return;
        }

        // call all the listeners for this event type, except for
        // nulls, which we keep track of
        for (i = 0; i < listeners.length; i++) {
            if (listeners[i] !== null) {
                listeners[i].call(this, event);
            } else {
                nulls.push(i);
            }
        }

        // remove any nulls from the listeners list; work from the end
        // of the list backwards so that removing an item doesn't change
        // the index of other items to be removed
        if (nulls.length > 0) {
            for (i=nulls.length-1; i>=0; --i) {
                listeners.splice(nulls[i],1);
            }
        }

    });


});

module.exports = EventEmitter;

},{"../../lib/jermaine/src/jermaine.js":9}],40:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var FilterOption = require('./filter_option.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.filter);

var Filter = new jermaine.Model("Filter", function () {
    this.hasMany("options").eachOfWhich.validatesWith(function (option) {
        return option instanceof FilterOption;
    });
    this.hasA("type").which.validatesWith(function (type) {
        return typeof(type) === "string";
    });

    utilityFunctions.insertDefaults(this, defaultValues.plot.filter, attributes);
});

module.exports = Filter;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":159,"./filter_option.js":41}],41:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.filter.option);

var FilterOption = new jermaine.Model("FilterOption", function () {
    this.hasA("name").which.validatesWith(function (name) {
        return typeof(name) === "string";
    });
    this.hasA("value").which.validatesWith(function (value) {
        return typeof(value) === "string";
    });

    utilityFunctions.insertDefaults(this, defaultValues.plot.filter.option, attributes);
});

module.exports = FilterOption;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":159}],42:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Axis = require('./axis.js'),
    Background = require('./background.js'),
    Data = require('./data.js'),
    Legend = require('./legend.js'),
    Plot = require('./plot.js'),
    Plotarea = require('./plotarea.js'),
    Title = require('./title.js'),
    Window = require('./window.js'),
    Box = require('../math/box.js'),
    DataPlot = require('../core/data_plot.js'),
    AxisBinding = require('../core/axis_binding.js'),
    varaible_id_regex = /^([^\.]+)\.(.+)$/;


/**
 * The Graph Jermaine model controls the properties for an individual Graph.
 *
 * @class Graph
 * @for Graph
 * @constructor
 */
var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues);

var Graph = new jermaine.Model("Graph", function () {
    /**
     * Child model which controls the properties of the Graph's Window.
     *
     * @property window
     * @type {Window}
     * @author jrfrimme
     */
    this.hasA("window").which.validatesWith(function (w) {
        return w instanceof Window;
    });
    /**
     * Child model which controls the properties of the Graph's Plotarea.
     *
     * @property plotarea
     * @type {Plotarea}
     * @author jrfrimme
     */
    this.hasA("plotarea").which.validatesWith(function (plotarea) {
        return plotarea instanceof Plotarea;
    });


    /**
     * Child model which controls the properties of the Graph's Legend.
     *
     * @property legend
     * @type {Legend}
     * @author jrfrimme
     */
    this.hasA("legend").which.validatesWith(function (legend) {
        return legend instanceof Legend;
    });
    /**
     * Child model which controls the properties of the Graph's Background.
     *
     * @property background
     * @type {Background}
     * @author jrfrimme
     */
    this.hasA("background").which.validatesWith(function (background) {
        return background instanceof Background;
    });

    /**
     * Child model which controls the properties of the Graph's Title.
     *
     * @property title
     * @type {Title}
     * @author jrfrimme
     */
    this.hasA("title").which.validatesWith(function (title) {
        return title instanceof Title;
    });
    /**
     * Jermaine Attr_List of the Graph's Axes.
     *
     * @property axes
     * @type {Axis}
     * @author jrfrimme
     */
    this.hasMany("axes").eachOfWhich.validateWith(function (axis) {
        return axis instanceof Axis;
    });
    /**
     * Jermiane Attr_List of the Graph's Plots.
     *
     * @property plots
     * @type {Plot}
     * @author jrfrimme
     */
    this.hasMany("plots").eachOfWhich.validateWith(function (plot) {
        return plot instanceof Plot;
    });
    /**
     * Jermiane Attr_List of the Graph's Data sets.
     *
     * @property data
     * @type {Data}
     * @author jrfrimme
     */
    this.hasMany("data").eachOfWhich.validateWith(function (data) {
        return data instanceof Data;
    });

    /**
     * Stores the computed width and height of the Graph's windowBox.
     *
     * @property windowBox
     * @type {}
     * @author jrfrimme
     */
    this.hasA("windowBox").which.validatesWith(function (val) {
        return val instanceof Box;
    });
    /**
     * Stores the computed width and height of the Graph's paddingBox.
     *
     * @property paddingBox
     * @type {}
     * @author jrfrimme
     */
    this.hasA("paddingBox").which.validatesWith(function (val) {
        return val instanceof Box;
    });
    /**
     * Stores the computed width and height of the Graph's plotBox.
     *
     * @property plotBox
     * @type {}
     * @author jrfrimme
     */
    this.hasA("plotBox").which.validatesWith(function (val) {
        return val instanceof Box;
    });

    /**
     * The containing Multigraph object
     *
     * @property multigraph
     * @type {}
     * @author mbp
     */
    this.hasA("multigraph").which.validatesWith(function (val) {
        //avoid using instanceof, so we don't have to require('multigraph.js') above!!!
        //return val instanceof Multigraph;
        //Just check for busySpinnerLevel function, since that's the part of the
        //multigraph that we use (duck typing).
        return (typeof(val.busySpinnerLevel) == "function");
    });

    this.hasA("x0").which.isA("number");
    this.hasA("y0").which.isA("number");

    this.hasA("filter").which.validatesWith(function(filter) {
        return ((typeof(filter) === 'undefined')
                ||
                ((typeof(filter.reset) === 'function') && (typeof(filter.filter) === 'function')));
    });

    this.isBuiltWith(function () {
        this.window( new Window() );
        this.plotarea( new Plotarea() );
        this.background( new Background() );
    });

    this.respondsTo("postParse", function () {
        var i,
            that = this,
            handleAjaxEvent = function(event) {
                if (event.action === 'start') {
                    if (that.multigraph()) {
                        that.multigraph().busySpinnerLevel(1);
                    }
                } else if (event.action === 'complete') {
                    if (that.multigraph()) {
                        that.multigraph().busySpinnerLevel(-1);
                    }
                }
            };

        for (i=0; i<this.data().size(); ++i) {
            this.data().at(i).addListener("ajaxEvent", handleAjaxEvent);
        }
    });

    /**
     * Initializes the Graph's geometry. Determines the width and height of the Graph's `windowBox`,
     * `paddingBox` and `plotBox`; calls its Axes' and Legend's implementations of
     * `initializeGeometry`.
     *
     * @method initializeGeometry
     * @param {Integer} width Width of the multigraph's div
     * @param {Integer} height Height of the multigraph's div
     * @param {Object} graphicsContext
     * @author jrfrimme
     */
    this.respondsTo("initializeGeometry", function (width, height, graphicsContext) {
        var w              = this.window(),
            windowBorder   = w.border(),
            windowMargin   = w.margin(),
            windowPadding  = w.padding(),
            plotarea       = this.plotarea(),
            plotareaBorder = plotarea.border(),
            plotareaMargin = plotarea.margin(),
            i;

        this.windowBox( new Box(width, height) );
        this.paddingBox( new Box(
            ( width -
              ( windowMargin.left()  + windowBorder + windowPadding.left() ) -
              ( windowMargin.right() + windowBorder + windowPadding.right() )
            ),
            ( height -
              ( windowMargin.top()    + windowBorder + windowPadding.top() ) -
              ( windowMargin.bottom() + windowBorder + windowPadding.bottom() )
            )
        )
                       );
        this.plotBox( new Box(
            (
                this.paddingBox().width() -
                    ( plotareaMargin.left() + plotareaMargin.right() + (2 * plotareaBorder))
            ),
            (
                this.paddingBox().height() -
                    ( plotareaMargin.top() + plotareaMargin.bottom() + (2 * plotareaBorder))
            )
        )
                    );
        for (i = 0; i < this.axes().size(); ++i) {
            this.axes().at(i).initializeGeometry(this, graphicsContext);
        }
        if (this.legend()) {
            this.legend().initializeGeometry(this, graphicsContext);
        }
        if (this.title()) {
            this.title().initializeGeometry(graphicsContext);
        }

        this.x0( windowMargin.left()   + windowBorder + windowPadding.left()   + plotareaMargin.left()   + plotareaBorder );
        this.y0( windowMargin.bottom() + windowBorder + windowPadding.bottom() + plotareaMargin.bottom() + plotareaBorder );
    });

    /**
     * Convience function for registering callback functions on the Graph's `Data` models. Adds
     * `dataReady` event listeners to each of the Graph's `Data` models.
     *
     * @method registerCommonDataCallback
     * @param {Function} callback
     * @author jrfrimme
     */
    this.respondsTo("registerCommonDataCallback", function (callback) {
        var i;
        for (i = 0; i < this.data().size(); ++i) {
            this.data().at(i).addListener("dataReady", callback);
        }
    });

    /**
     * 
     *
     * @method pauseAllData
     * @author jrfrimme
     */
    this.respondsTo("pauseAllData", function () {
        var i;
        // pause all this graph's data sources:
        for (i = 0; i < this.data().size(); ++i) {
            this.data().at(i).pause();
        }
    });

    /**
     * 
     *
     * @method resumeAllData
     * @author jrfrimme
     */
    this.respondsTo("resumeAllData", function () {
        var i;
        // resume all this graph's data sources:
        for (i = 0; i < this.data().size(); ++i) {
            this.data().at(i).resume();
        }
    });

    /**
     * @method findNearestAxis
     * @param {} x
     * @param {} y
     * @param {} orientation
     * @author jrfrimme
     */
    this.respondsTo("findNearestAxis", function (x, y, orientation) {
        var foundAxis = null,
            mindist = 9999,
            axes = this.axes(),
            naxes = this.axes().size(),
            axis,
            i,
            d;
        for (i = 0; i < naxes; ++i) {
            axis = axes.at(i);
            if (!axis.visible()) { continue; }
            if ((orientation === undefined) ||
                (orientation === null) ||
                (axis.orientation() === orientation)) {
                d = axis.distanceToPoint(x, y);
                if (foundAxis === null || d < mindist) {
                    foundAxis = axis;
                    mindist = d;
                }
            }
        }
        return foundAxis;
    });

    this.respondsTo("axisById", function (id) {
        // return a pointer to the axis for this graph that has the given id, if any
        var axes = this.axes(),
            i;
        for (i = 0; i < axes.size(); ++i) {
            if (axes.at(i).id() === id) {
                return axes.at(i);
            }
        }
        return undefined;
    });


    this.respondsTo("dataById", function(id) { // 'id' is a string id of a data object
        // Return a reference to the data object associated with the given graph having the given id
        var datas = this.data(),
            data;
        for (i = 0; i < datas.size(); ++i) {
            data = datas.at(i);
            if (data.id() === id) {
                return data;
            }
        }
        return undefined;
    });

    this.respondsTo("variableById", function (id) {
        // return a pointer to the variable for this graph that has the given id, if any
        var datas,
            re = /^([^\.]+)\.(.+)$/,
            m = id.match(re),
            data_id,
            var_id,
            data,
            columns,
            i, j;

        if (m) {
            data_id = m[1];
            var_id = m[2];
            data = this.dataById(data_id);
            return data.columnIdToDataVariable(var_id);
        } else {
            datas = this.data();
            for (i = 0; i < datas.size(); ++i) {
                columns = datas.at(i).columns();
                for (j = 0; j < columns.size(); ++j) {
                    if (columns.at(j).id() === id) {
                        return columns.at(j);
                    }
                }
            }
            return undefined;
        }
    });

    this.respondsTo("normalize", function () {
        var HORIZONTAL = Axis.HORIZONTAL,
            VERTICAL   = Axis.VERTICAL,
            axes  = this.axes(),
            plots = this.plots(),
            i, j,
            haxisCount = 0,
            vaxisCount = 0,
            axis,
            axisid,
            plot;

        //
        // normalizes the data sections
        //
        for (i = 0; i < this.data().size(); i++) {
            this.data().at(i).normalize();
        }

        //
        // Handles missing horizontalaxis and vertical axis tags
        //
        for (i = 0; i < axes.size(); i++) {
            if (axes.at(i).orientation() === HORIZONTAL) {
                haxisCount++;
            } else if (axes.at(i).orientation() === VERTICAL) {
                vaxisCount++;
            }
        }

        if (haxisCount === 0) {
            axes.add(new Axis(HORIZONTAL));
        }
        if (vaxisCount === 0) {
            axes.add(new Axis(VERTICAL));
        }

        //
        // Handles missing id's for axes
        //
        haxisCount = 0;
        vaxisCount = 0;
        for (i = 0; i < axes.size(); i++) {
            axis = axes.at(i);
            if (axis.orientation() === HORIZONTAL) {
                axisid = "x";
                if (haxisCount > 0) {
                    axisid += haxisCount;
                }
                haxisCount++;
            } else if (axis.orientation() === VERTICAL) {
                axisid = "y";
                if (vaxisCount > 0) {
                    axisid += vaxisCount;
                }
                vaxisCount++;
            }

            if (axis.id() === undefined) {
                axis.id(axisid);
            }
        }

        //
        // normalizes the rest of the axis properties
        //
        for (i = 0; i < axes.size(); i++) {
            axes.at(i).normalize(this);
        }

        //
        // handles missing plot tags
        //
        if (plots.size() === 0) {
            plots.add(new DataPlot());
        }

        //
        // normalizes the plots
        //
        for (i = 0; i < plots.size(); i++) {
            plots.at(i).normalize(this);
        }

        //
        // normalizes the legend
        //
        if (this.legend()) {
            this.legend().normalize(this);
        }

        //
        // execute the setDataRange method for each axis binding, to sync up all axes
        // that participate in the binding (this takes care of setting dataMin/dataMax
        // for any axes that don't have them already but which are bound to axes that
        // do have them)
        // 
        AxisBinding.syncAllBindings();

        //
        // arrange to set missing axis min/max values when data is ready, if necessary
        // 
        for (i = 0; i < axes.size(); i++) {
            // for each axis...
            axis = axes.at(i);
            if (!axis.hasDataMin() || !axis.hasDataMax()) {
                // if this axis is mising either a dataMin() or dataMax() value...
                for (j = 0; j < plots.size(); ++j) {
                    // find a DataPlot that references this axis...
                    plot = plots.at(j);
                    if (plot instanceof DataPlot && (plot.horizontalaxis() === axis || plot.verticalaxis() === axis)) {
                        // ... and then register a dataReady listener for this plot's data section which sets the
                        // missing bound(s) on the axis once the data is ready.  Do this inside a closure so that we
                        // can refer to a pointer to our dynamically-defined listener function from inside itself,
                        // so that we can de-register it once it is called; this is done via the the local variable
                        // axisBoundsSetter.  The closure also serves to capture the current values, via arguments,
                        // of the axis pointer, a pointer to the data object, and a boolean (isHorizontal) that
                        // indicates whether the axis is the plot's horizontal or vertical axis.
                        (function (axis, data, isHorizontal) {
                            var axisBoundsSetter = function (event) {
                                var columnNumber = isHorizontal ? 0 : 1,
                                    bounds = data.getBounds(columnNumber),
                                    min = axis.dataMin(),
                                    max = axis.dataMax();
                                if (!axis.hasDataMin()) {
                                    min = bounds[0];
                                }
                                if (!axis.hasDataMax()) {
                                    max = bounds[1];
                                }
                                if (!axis.hasDataMin() || !axis.hasDataMax()) {
                                    axis.setDataRange(min, max);
                                }
                                data.removeListener('dataReady', axisBoundsSetter);
                            };
                            data.addListener('dataReady', axisBoundsSetter);
                        }(axis,                             // axis
                          plot.data(),                      // data
                          plot.horizontalaxis() === axis    // isHorizontal
                         ));
                        break; // for (j=0; j < this.plots().size(); ++j)...
                    }
                }
            }
        }



    });

    utilityFunctions.insertDefaults(this, defaultValues, attributes);
});

module.exports = Graph;

},{"../../lib/jermaine/src/jermaine.js":9,"../core/axis_binding.js":20,"../core/data_plot.js":30,"../math/box.js":102,"../util/utilityFunctions.js":159,"./axis.js":19,"./background.js":22,"./data.js":27,"./legend.js":47,"./plot.js":55,"./plotarea.js":57,"./title.js":66,"./window.js":71}],43:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var RGBColor = require('../math/rgb_color.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.horizontalaxis.grid);

var Grid = new jermaine.Model("Grid", function () {
    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    });
    this.hasA("visible").which.isA("boolean");

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis.grid, attributes);
});

module.exports = Grid;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/rgb_color.js":107,"../util/utilityFunctions.js":159}],44:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.legend.icon);

var Icon = new jermaine.Model("Icon", function () {
    this.hasA("height").which.isA("integer");
    this.hasA("width").which.isA("integer");
    this.hasA("border").which.isA("integer");

    utilityFunctions.insertDefaults(this, defaultValues.legend.icon, attributes);
});

module.exports = Icon;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":159}],45:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Point = require('../math/point.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.background.img);

var Img = new jermaine.Model("Img", function () {
    this.hasA("src").which.isA("string");
    this.hasA("anchor").which.validatesWith(function (anchor) {
        return anchor instanceof Point;
    });
    this.hasA("base").which.validatesWith(function (base) {
        return base instanceof Point;
    });
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });
    this.hasA("frame").which.validatesWith(function (frame) {
        return frame === Img.PADDING || frame === Img.PLOT;
    });
    this.isBuiltWith("src");

    utilityFunctions.insertDefaults(this, defaultValues.background.img, attributes);
});

Img.PADDING = "padding";
Img.PLOT    = "plot";

module.exports = Img;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/point.js":106,"../util/utilityFunctions.js":159}],46:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataValue = require('./data_value.js'),
    DataFormatter = require('./data_formatter.js'),
    DataMeasure = require('./data_measure.js'),
    Point = require('../math/point.js'),
    RGBColor = require('../math/rgb_color.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.horizontalaxis.labels.label);

var Labeler = new jermaine.Model("Labeler", function () {

    var getValue = function (valueOrFunction) {
        if (typeof(valueOrFunction) === "function") {
            return valueOrFunction();
        } else {
            return valueOrFunction;
        }
    };

    this.hasA("axis").which.validatesWith(function (axis) {
        var Axis = require('./axis.js');
        return axis instanceof Axis;
    });
    this.hasA("formatter").which.validatesWith(DataFormatter.isInstance);
    this.hasA("font").which.isA("string").and.which.defaultsTo("");
    this.hasA("start").which.validatesWith(DataValue.isInstance);
    this.hasA("angle").which.isA("number");
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });
    this.hasA("anchor").which.validatesWith(function (anchor) {
        return anchor instanceof Point;
    });
    this.hasA("spacing").which.validatesWith(DataMeasure.isInstance);
    this.hasA("densityfactor").which.isA("number").and.which.defaultsTo(1.0);

    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    });

    this.hasA("visible").which.isA("boolean").and.which.defaultsTo(true);

    this.isBuiltWith("axis", function () {
        var labelsDefaults = defaultValues.horizontalaxis.labels;
        if (this.axis().type() === DataValue.DATETIME) {
            this.start( getValue(labelsDefaults['start-datetime']) );
        } else {
            this.start( getValue(labelsDefaults['start-number']) );
        }
    });

    this.respondsTo("initializeGeometry", function (graph) {
        var axis    = this.axis(),
            plotBox = graph.plotBox(),
            labelDefaults = defaultValues.horizontalaxis.labels.label,
            Axis = require('./axis.js');

        if (this.position() === undefined) {
            if (axis.orientation() === Axis.HORIZONTAL) {
                if (axis.perpOffset() > plotBox.height()/2) {
                    this.position( getValue(labelDefaults["position-horizontal-top"]) );
                } else {
                    this.position( getValue(labelDefaults["position-horizontal-bottom"]) );
                }
            } else {
                if (axis.perpOffset() > plotBox.width()/2) {
                    this.position( getValue(labelDefaults["position-vertical-right"]) );
                } else {
                    this.position( getValue(labelDefaults["position-vertical-left"]) );
                }
            }
        }

        if (this.anchor() === undefined) {
            if (axis.orientation() === Axis.HORIZONTAL) {
                if (axis.perpOffset() > plotBox.height()/2) {
                    this.anchor( getValue(labelDefaults["anchor-horizontal-top"]) );
                } else {
                    this.anchor( getValue(labelDefaults["anchor-horizontal-bottom"]) );
                }
            } else {
                if (axis.perpOffset() > plotBox.width()/2) {
                    this.anchor( getValue(labelDefaults["anchor-vertical-right"]) );
                } else {
                    this.anchor( getValue(labelDefaults["anchor-vertical-left"]) );
                }
            }
        }
    });

    this.respondsTo("isEqualExceptForSpacing", function (labeler) {
        // return true iff the given labeler and this labeler are equal in every way
        // except for their spacing values
        return ((this.axis()                         ===   labeler.axis()                            ) &&
                (this.formatter().getFormatString()  ===   labeler.formatter().getFormatString()     ) &&
                (this.start()                        .eq(  labeler.start()                         ) ) &&
                (this.angle()                        ===   labeler.angle()                           ) &&
                (this.position()                     .eq(  labeler.position()                      ) ) &&
                (this.anchor()                       .eq(  labeler.anchor()                        ) ) &&
                (this.densityfactor()                ===   labeler.densityfactor()                   )
               );
    });


    this.hasA("iteratorNextValue").which.validatesWith(DataValue.isInstanceOrNull).and.which.defaultsTo(null);
    this.hasA("iteratorMinValue").which.validatesWith(DataValue.isInstance);
    this.hasA("iteratorMaxValue").which.validatesWith(DataValue.isInstance);

    this.respondsTo("prepare", function (minDataValue, maxDataValue) {
        this.iteratorMinValue(minDataValue);
        this.iteratorMaxValue(maxDataValue);
        this.iteratorNextValue( this.spacing().firstSpacingLocationAtOrAfter(minDataValue, this.start()) );
    });

    this.respondsTo("hasNext", function () {
        var value = this.iteratorNextValue();
        if (value === null || value === undefined) {
            return false;
        }
        return value.le(this.iteratorMaxValue());
    });

    this.respondsTo("peekNext", function () {
        var value    = this.iteratorNextValue(),
            maxValue = this.iteratorMaxValue();
        if (value === null || value === undefined) {
            return undefined;
        }
        if (maxValue !== undefined && value.gt(maxValue)) {
            return undefined;
        }
        return value;
    });

    this.respondsTo("next", function () {
        var value = this.iteratorNextValue(),
            maxValue = this.iteratorMaxValue();
        if (value === null || value === undefined) {
            return undefined;
        }
        if (maxValue !== undefined && value.gt(maxValue)) {
            return undefined;
        }
        this.iteratorNextValue( value.add( this.spacing() ) );
        return value;
    });

    this.respondsTo("getLabelDensity", function (graphicsContext) {
        var axis                      = this.axis(),
            pixelSpacing              = this.spacing().getRealValue() * axis.axisToDataRatio(),
            minRealValue              = axis.dataMin().getRealValue(),
            maxRealValue              = axis.dataMax().getRealValue(),
            representativeRealValue   = minRealValue + 0.51234567 * (maxRealValue - minRealValue),
            representativeValue       = DataValue.create(axis.type(), representativeRealValue ),
            representativeValueString = this.formatter().format(representativeValue),
            Axis                      = require('./axis.js');

        // length of the formatted axis representative value, in pixels
        var pixelFormattedValue = (
            (axis.orientation() === Axis.HORIZONTAL) ?
                this.measureStringWidth(graphicsContext, representativeValueString) :
                this.measureStringHeight(graphicsContext, representativeValueString)
        );
        // return the ratio -- the fraction of the spacing taken up by the formatted string
        return pixelFormattedValue / ( pixelSpacing * this.densityfactor() );
    });


    this.respondsTo("measureStringWidth", function (graphicsContext, string) {
        // Graphics drivers should replace this method with an actual implementation; this
        // is just a placeholder.  The implementation should return the width, in pixels,
        // of the given string.  Of course this is dependent on font choice, size, etc,
        // but we gloss over that at the moment.  Just return the width of the string
        // using some reasonable default font for now.  Later on, we'll modify this
        // function to use font information.
        return string.length*30;
    });
    this.respondsTo("measureStringHeight", function (graphicsContext, string) {
        // see comment for measureStringWidth() above
        return string.length*30;
    });
    this.respondsTo("renderLabel", function (graphicsContext, value) {
        // Graphics drivers should replace this method with an actual implementation; this
        // is just a placeholder.  The implementation should draw the string for the given
        // value, formatted by the labeler's DataFormatter, in the location along the axis
        // determined by the value itself, and the labeler's position, anchor, and angle
        // attributes.
    });

    this.respondsTo("normalize", function () {
        var defaultNumberFormat   = "%.1f",
            defaultDatetimeFormat = "%Y-%M-%D %H:%i",
            labelerFormat,
            type = this.axis().type();

        //
        // Determines default values of labeler attributes based on axis type
        //
        if (type === DataValue.DATETIME) {
            labelerFormat = defaultDatetimeFormat;
        } else {
            labelerFormat = defaultNumberFormat;
        }

        //
        // Inserts labeler defaults
        //
        if (this.formatter() === undefined) {
            this.formatter(DataFormatter.create(type, labelerFormat));
        }

    });

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis.labels.label, attributes);
});

module.exports = Labeler;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/point.js":106,"../math/rgb_color.js":107,"../util/utilityFunctions.js":159,"./axis.js":19,"./data_formatter.js":28,"./data_measure.js":29,"./data_value.js":31}],47:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Point = require('../math/point.js'),
    RGBColor = require('../math/rgb_color.js'),
    Icon = require('./icon.js'),
    Plot = require('./plot.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    validationFunctions = require('../util/validationFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.legend);

/**
 * Legend is a Jermaine model that supports the rendering of Multigraph Legends.
 * 
 * The methods for this object take a parameter called `graphicsContext`, which is a
 * driver-specific object that stores whatever state/configuration is needed by the
 * driver.  Each driver is responsible for creating its own graphicsContext object and
 * passing it to these methods, which in turn pass that object on to the driver-specific
 * methods that they call.
 * 
 * @class Legend
 * @for Legend
 * @constructor
 * @requires Point,RGBColor,Plot,Icon
 */
var Legend = new jermaine.Model("Legend", function () {
    /**
     * The value which determines if the legend will be rendered; a value of `true` means the Legend will
     * be drawn while `false` means that it will not.
     *
     * @property visible
     * @type {boolean}
     * @author jrfrimme
     */
    this.hasA("visible").which.validatesWith(function (visible) {
        return typeof visible === "boolean" || visible === null;
    });

    /**
     * The value which gives the location of the base point relative to the Legend's frame.
     *
     * @property base
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("base").which.validatesWith(function (base) {
        return base instanceof Point;
    });

    /**
     * The value which gives the location of the Legend's anchor point to be attached to the base point.
     *
     * @property anchor
     * @type {Point}
     * @author jrfrimme
     */
    this.hasAn("anchor").which.validatesWith(function (anchor) {
        return anchor instanceof Point;
    });

    /**
     * A coordinate pair of pixel offsets for the base point.
     *
     * @property position
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });

    /**
     * The value which determines whether the legend is positioned relative to the plot area or the padding
     * box. A value of `plot` means the Legend will be drawn relative to the plot area while `padding` means
     * that it will the padding box.
     *
     * @property frame
     * @type {String}
     * @author jrfrimme
     */
    this.hasA("frame").which.validatesWith(function (frame) {
        return frame === "plot" || frame === "padding";
    });

    /**
     * The value which determines the background color of the Legend.
     *
     * @property color
     * @type {RGBColor}
     * @author jrfrimme
     */
    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    });

    /**
     * The value which determines the bordercolor of the Legend.
     *
     * @property bordercolor
     * @type {RGBColor}
     * @author jrfrimme
     */
    this.hasA("bordercolor").which.validatesWith(function (bordercolor) {
        return bordercolor instanceof RGBColor;
    });

    /**
     * The value which determines the opacity of the Legend; depending on where the Legend is positioned it
     * may obscure parts of the plot data.
     *
     * @property opacity
     * @type {Float}
     * @author jrfrimme
     */
    this.hasA("opacity").which.validatesWith(function (opacity) {
        return validationFunctions.validateNumberRange(opacity, 0.0, 1.0);
    });

    /**
     * The value which determines the thickness of the border drawn around the Legend; a value of `0` turns
     * the border off.
     *
     * @property border
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("border").which.isA("integer");

    /**
     * The value which determines the number of rows to be used for Plot entries in the Legend. If left
     * unspecified then rows will be inserted to account for each Plot entry.
     *
     * @property rows
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("rows").which.isA("integer").and.isGreaterThan(0);

    /**
     * The value which determines the number of columns to be used for Plot entries in the Legend. If rows
     * is set while columns is left unspecified then columns will be inserted to account for each Plot
     * entry.
     *
     * @property columns
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("columns").which.isA("integer").and.isGreaterThan(0);

    /**
     * The value which determines whether the corners of the legend box are rounded when drawn. A value of
     * `0` means that the corners will be drawn square while values greater than `0` mean that the corners
     * are rounded off with circles whose radius in pixels is this value.
     *
     * @property cornerradius
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("cornerradius").which.isA("integer");

    /**
     * The value which determines the pixel width of the padding between the Legend border and its entries.
     *
     * @property padding
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("padding").which.isA("integer");

    /**
     * A optional sub-model which determines the appearance of the Icons for the Plot entries.
     *
     * @property icon
     * @type {Icon}
     * @author jrfrimme
     */
    this.hasAn("icon").which.validatesWith(function (icon) {
        return icon instanceof Icon;
    });

    this.isBuiltWith(function () {
        this.icon( new Icon() );
    });

    /**
     * Pointers to Plot models that have entries in the Legend.
     *
     * @property plots
     * @type {Plot}
     * @author jrfrimme
     */
    this.hasMany("plots").eachOfWhich.validateWith(function (plot) {
        return plot instanceof Plot;
    });

    /**
     * Internal value which determines the number of pixels between an entries icon and its border.
     *
     * @property iconOffset
     * @type {Integer}
     * @default 5
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("iconOffset").which.isAn("integer").and.defaultsTo(5);

    /**
     * Internal value which determines the number of pixels between an entries label and its icon.
     *
     * @property labelOffset
     * @type {Integer}
     * @default 5
     * @private
     * @final
     * @type {}
     * @author jrfrimme
     */
    this.hasA("labelOffset").which.isAn("integer").and.defaultsTo(5);

    /**
     * Internal value which determines the number of pixels between the right end of an entries label and
     * its border
     *
     * @property labelEnding
     * @type {Integer}
     * @default 15
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("labelEnding").which.isAn("integer").defaultsTo(15);

    /**
     * Computed value of the width of the Legend.
     *
     * @property width
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("width").which.isA("number");

    /**
     * Computed value of the height of the Legend.
     *
     * @property height
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("height").which.isA("number");

    /**
     * Computed `x` value of the Legend's lower left corner relative to its frame.
     *
     * @property x
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("x").which.isA("number");

    /**
     * Computed `y` value of the Legend's lower left corner relative to its frame.
     *
     * @property y
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("y").which.isA("number");

    /**
     * Computed width of an individual plot entry.
     *
     * @property blockWidth
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("blockWidth").which.isA("number");

    /**
     * Computed height of an individual plot entry.
     *
     * @property blockHeight
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("blockHeight").which.isA("number");

    /**
     * Computed width of the longest label of all plot entries.
     *
     * @property maxLabelWidth
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("maxLabelWidth").which.isA("number");

    /**
     * Maximum value of the Icon's height and the computed height of the tallest label of all plot entries.
     *
     * @property maxLabelHeight
     * @type {Float}
     * @private
     * @final
     * @author jrfrimme
     */
    this.hasA("maxLabelHeight").which.isA("number");

    this.respondsTo("determineVisibility", function () {
        switch (this.visible()) {
        case true:
            return true;
        case false:
            return false;
        case null:
            if (this.plots().size() > 1) {
                return true;
            } else {
                return false;
            }
        }
    });

    /**
     * Initializes the Legend's geometry. Determines values for the internal attributes `maxLabelWidth`,
     * `maxLabelHeight`, `blockWidth`, `blockHeight`, `width`, `height`, `x` and `y`; these values
     * determine the size and position of the legend and its various internal components, and need
     * to be recomputed whenever the geometry of the containing graph changes;  this method is
     * called by Graph.initializeGeometry().
     * 
     * @method initializeGeometry
     * @chainable
     * @param {Graph} graph Jermaine Graph model
     * @param {Object} graphicsContext driver-specific graphics context object
     * @author jrfrimme
     * @todo Find out whether or not padding needs to be taken into consideration.
     */
    this.respondsTo("initializeGeometry", function (graph, graphicsContext) {
        var anchor     = this.anchor(),
            base       = this.base(),
            position   = this.position(),
            iconOffset = this.iconOffset(),
            widths  = [],
            heights = [],
            label,
            i;

        if (this.determineVisibility() === false) {
            return this;
        }

        for (i = 0; i < this.plots().size(); i++) {
            label = this.plots().at(i).legend().label();
            if (label !== undefined) {
                label.initializeGeometry(graphicsContext);
                widths.push(label.origWidth());
                heights.push(label.origHeight());
            }
        }

        widths.sort(function (a, b) {
            return b - a;
        });
        heights.sort(function (a, b) {
            return b - a;
        });
        this.maxLabelWidth(widths[0]);
        this.maxLabelHeight(Math.max(heights[0], this.icon().height()));

        this.blockWidth(iconOffset + this.icon().width() + this.labelOffset() + this.maxLabelWidth() + this.labelEnding());
        this.blockHeight(iconOffset + this.maxLabelHeight());

        // TODO: find out whether or not padding needs to be taken into consideration
        this.width((2 * this.border()) + (this.columns() * this.blockWidth()));
        this.height((2 * this.border()) + (this.rows() * this.blockHeight()) + iconOffset);

        if (this.frame() === "padding") {
            this.x(((base.x() + 1) * graph.paddingBox().width()/2)  - ((anchor.x() + 1) * this.width()/2)  + position.x());
            this.y(((base.y() + 1) * graph.paddingBox().height()/2) - ((anchor.y() + 1) * this.height()/2) + position.y());
        } else {
            this.x(((base.x() + 1) * graph.plotBox().width()/2)     - ((anchor.x() + 1) * this.width()/2)  + position.x());
            this.y(((base.y() + 1) * graph.plotBox().height()/2)    - ((anchor.y() + 1) * this.height()/2) + position.y());
        }

        return this;
    });

    /**
     * Renders the legend; calls various driver-specific graphics functions to do the
     * actual drawing of the various parts of the legend (background, borders, icons,
     * text).
     * 
     * @method render
     * @chainable
     * 
     * @param {Object} graphicsContext driver-specific graphics context object
     * 
     * @author jrfrimme
     */
    this.respondsTo("render", function (graphicsContext) {
        var plots = this.plots(),
            icon  = this.icon(),
            blockx, blocky,
            iconx, icony,
            labelx, labely,
            plotCount = 0,
            r, c;

        if (this.determineVisibility() === false) {
            return this;
        }

        // perform any neccesary setup
        this.begin(graphicsContext);

        // Draw the legend box
        this.renderLegend(graphicsContext);

        for (r = 0; r < this.rows(); r++) {
            if (plotCount >= plots.size()) {
                break;
            }
            blocky = this.border() + ((this.rows() - r - 1) * this.blockHeight());
            icony  = blocky + this.iconOffset();
            labely = icony;
            for (c = 0; c < this.columns(); c++) {
                if (plotCount >= plots.size()) {
                    break;
                }
                blockx = this.border() + (c * this.blockWidth());
                iconx  = blockx + this.iconOffset();
                labelx = iconx + icon.width() + this.labelOffset();

                // Draw the icon
                plots.at(plotCount).renderer().renderLegendIcon(graphicsContext, iconx, icony, icon, this.opacity());
                
                // Draw the icon border
                if (icon.border() > 0) {
                    icon.renderBorder(graphicsContext, iconx, icony, this.opacity());
                }
                
                // Write the text
                this.renderLabel(plots.at(plotCount).legend().label(), graphicsContext, labelx, labely);

                plotCount++;
            }
        }

        // preform any neccesary steps at the end of rendering
        this.end(graphicsContext);

        return this;
    });

    this.respondsTo("normalize", function (graph) {
        var legendPlots = this.plots(),
            graphPlots  = graph.plots(),
            columns = this.columns,
            rows    = this.rows,
            i, j,
            flag;

        //
        // stores pointers to plots with legends in the Legend object
        //
        for (i = 0; i < graphPlots.size(); i++) {
            // doesn't add a plot if it doesn't have a visible legend
            if (!graphPlots.at(i).legend() || graphPlots.at(i).legend().visible() !== true) {
                continue;
            }

            // doesn't add a plot if it has already been added
            flag = false;
            for (j = 0; j < legendPlots.size(); j++) {
                if (graphPlots.at(i) === legendPlots.at(j)) {
                    flag = true;
                    break;
                }
            }
            if (flag === true) {
                continue;
            }

            legendPlots.add(graphPlots.at(i));
        }

        //
        // If there are no plots in the legend default to 1 row and column if they aren't specified
        //
        if (legendPlots.size() === 0) {
            if (columns() === undefined) {
                columns(1);
            }
            if (rows() === undefined) {
                rows(1);
            }
        }

        //
        // if neither rows nor cols is specified, default to 1 col
        //
        if (rows() === undefined && columns() === undefined) {
            columns(1);
        }

        //
        // if only one of rows/cols is specified, compute the other
        //
        if (columns() === undefined) {
            columns(parseInt(legendPlots.size() / rows() + ( (legendPlots.size() % rows()) > 0 ? 1 : 0 ), 10));
        } else if (rows() === undefined) {
            rows(parseInt(legendPlots.size() / columns() + ( (legendPlots.size() % columns()) > 0 ? 1 : 0 ), 10));
        }

        return this;
    });

    utilityFunctions.insertDefaults(this, defaultValues.legend, attributes);
});

module.exports = Legend;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/point.js":106,"../math/rgb_color.js":107,"../util/utilityFunctions.js":159,"../util/validationFunctions.js":160,"./icon.js":44,"./plot.js":55}],48:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/**
 * The Mixin model provides a convenient way for Jermaine
 * applications to "mix in" additional functionality to a model,
 * from outside the model's initial definition.
 * 
 * The ability to add features (methods and/or attributes) to a
 * Jermaine model outside its initial definition already exists in
 * Jermaine -- this Mixin model does not actually add new
 * functionality to Jermaine; it just provides a convenient
 * pattern for grouping additional features together and applying
 * them to a model as a group.
 * 
 * The Mixin model maintains an internal list of functions, called
 * mixin functions, and provides an add() method for adding a
 * function to that list.
 * 
 * The apply() method calls all of the mixinfunctions that have been
 * added to the list, passing each one the same arguments
 * that were passed to the apply() function itself.
 * 
 * That's it.  That's all the Mixin class does.  It's up to you to
 * put whatever jermaine-model-extending code you want in the
 * mixin functions you add to the Mixin; the Mixin simply serves
 * as a place to hold them all, and a convenient way to execute
 * them all at once.
 *
 * @class Mixin
 * @for Mixin
 * @author mbp
 */
var Mixin = new jermaine.Model("Mixin", function () {

    /**
     * The internal list of functions to be applied.
     *
     * @property mixinfuncs
     * @private
     * @type {}
     * @author mbp
     */
    this.hasMany("mixinfuncs");

    /**
     * Internal value for tracking whether apply() has been called
     * for this Mixin.
     *
     * @property applied
     * @type {}
     * @private
     * @author mbp
     */
    this.hasA("applied").which.isA("boolean").defaultsTo(false);

    /**
     * Adds a function to this Mixin's mixin list.  Does not check
     * to see if the function is already on the list -- just blindly
     * appends the given function to the list.
     *
     * @method add
     * @param {} func
     * @author mbp
     */
    this.respondsTo("add", function (mixinfunc) {
        this.mixinfuncs().add(mixinfunc);
    });

    /**
     * Call each of this Mixin's mixin functions.  Any
     * arguments passed to apply() will be passed through to each
     * mixin function called.
     * 
     * apply() checks to see whether it has ever been called
     * before for this Mixin, and only executes the mixin
     * functions if this is the first call to apply(); calls to
     * apply() after the first one will have no effect.  (This is
     * true even if additional mixin functions are added after
     * apply() is called; the Mixin maintains a single internal
     * Boolean value that tracks whether apply() has been called.)
     *
     * @method apply
     * @author mbp
     */
    this.respondsTo("apply", function () {
        if (! this.applied()) {
            var i;
            for (i=0; i<this.mixinfuncs().size(); ++i) {
                this.mixinfuncs().at(i).apply(this, arguments);
            }
        }
        this.applied(true);
    });


    /**
     * Just like apply(), but forces the mixin functions to be called
     * regardless of whether apply() was previously called for this
     * Mixin.
     *
     * @method reapply
     * @author mbp
     */
    this.respondsTo("reapply", function () {
        this.applied(false);
        this.apply.apply(this,arguments);
    });


});

module.exports = Mixin;

},{"../../lib/jermaine/src/jermaine.js":9}],49:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
var Multigraph;
module.exports = function($) {
    if (typeof(Multigraph) !== "undefined") { return Multigraph; }

    var jermaine = require('../../lib/jermaine/src/jermaine.js');

    /**
     * The Multigraph Jermaine model is the root class for the js-multigraph project.
     *
     * @class Multigraph
     * @for Multigraph
     * @constructor
     */
    Multigraph = new jermaine.Model("Multigraph", function () {

        /**
         * Jermiane Attr_List of all the graphs in a Multigraph.
         *
         * @property graphs
         * @type {Graph}
         * @author jrfrimme
         */
        this.hasMany("graphs").eachOfWhich.validateWith(function (graph) {
            var Graph = require('./graph.js');
            return graph instanceof Graph;
        });

        /**
         * The div the multigraph is rendered in.
         *
         * @property div
         * @type {HTML Element}
         * @author jrfrimme
         */
        this.hasA("div"); // the actual div element

        /**
         * The url for the mugl file this graph was created from, if any
         *
         * @property mugl
         * @type {string}
         * @author mbp
         */
        this.hasA("mugl");

        /**
         * JavaScript array of ajax throttles; each entry in this array is an
         * object with the following properties:
         *    regex        : regular expression for matching URLs
         *    ajaxthrottle : instance of $.ajaxthrottle
         * 
         * @property ajaxthrottles
         * @type {Array}
         * @author mbp
         */
        this.hasA("ajaxthrottles");

        this.isBuiltWith(function() {
            this.ajaxthrottles([]);
        });

        this.respondsTo("addAjaxThrottle", function (pattern, requests, period, concurrent) {
            this.ajaxthrottles().push({
                regex        : pattern ? new RegExp(pattern) : undefined,
                ajaxthrottle : $.ajaxthrottle({
                    numRequestsPerTimePeriod : parseInt(requests,10),
                    timePeriod               : parseInt(period, 10),
                    maxConcurrent            : parseInt(concurrent, 10)
                })
            });
        });

        this.respondsTo("getAjaxThrottle", function (url) {
            var throttle = undefined;
            $.each(this.ajaxthrottles(), function() {
                if (!this.regex || this.regex.test(url)) {
                    throttle = this.ajaxthrottle;
                    return false;
                }
                return true;
            });
            return throttle;
        });

        /*
         * This function transforms a given URL so that it
         * is relative to the same base as the URL from which the MUGL
         * file was loaded.  If this graph was not created from a MUGL
         * file (either it came from a MUGL string, or was created programmatically),
         * the URL is returned unchanged.
         * 
         * If the URL to be rebased is absolute (contains '://')
         * or root-relative (starts with a '/'), it is returned unchanged.
         * 
         * Otherise, the given URL is relative, and whhat is returned is a
         * new URL obtained by interpreting it relative to the URL
         * from which the MUGL was loaded. 
         */
        this.respondsTo("rebaseUrl", function(url) {
            var baseurl = this.mugl();
            if (! baseurl) {
                return url;
            }
            if (/^\//.test(url)) {
                // url is root-relative (starts with a '/'); return it unmodified
                return url;
            }
            if (/:\/\//.test(url)) {
                // url contains '://', so assume it's a full url, return it unmodified
                return url;
            }
            // convert baseurl to a real base path, by eliminating any url args and
            // everything after the final '/'
            if (!/^\//.test(baseurl)  && !/:\/\//.test(baseurl) && !/^\.\//.test(baseurl)) {
                // first make sure that if baseurl is relative, it starts with './'
                baseurl = './' + baseurl; 
            }
            baseurl = baseurl.replace(/\?.*$/, ''); // remove everything after the first '?'
            baseurl = baseurl.replace(/\/[^\/]*$/, '/'); // remove everything after the last '/'
            return baseurl + url;
        });

        /**
         * The busy spinner
         *
         * @property busySpinner
         * @type {HTML Element}
         * @author mbp
         */
        this.hasA("busySpinner"); // the busy_spinner div

        this.respondsTo("busySpinnerLevel", function (delta) {
            if (this.busySpinner()) {
                $(this.busySpinner()).busy_spinner('level', delta);
            }
        });


        /**
         * Initializes the Multigraph's geometry by calling the `initializeGeometry` function of
         * each of its graph children.
         *
         * @method initializeGeometry
         * @param {Integer} width Width of the multigraph's div.
         * @param {Integer} height Height of the multigraph's div.
         * @param {Object} graphicsContext
         * @author jrfrimme
         */
        this.respondsTo("initializeGeometry", function (width, height, graphicsContext) {
            var i;
            for (i = 0; i < this.graphs().size(); ++i) {
                this.graphs().at(i).initializeGeometry(width, height, graphicsContext);
            }
        });

        /**
         * Convience function for registering callback functions for data becoming ready.
         *
         * @method registerCommonDataCallback
         * @param {Function} callback Callback function to be registered.
         * @author jrfrimme
         */
        this.respondsTo("registerCommonDataCallback", function (callback) {
            var i;
            for (i = 0; i < this.graphs().size(); ++i) {
                this.graphs().at(i).registerCommonDataCallback(callback);
            }
        });

        this.respondsTo("normalize", function () {
            var i;
            for (i = 0; i < this.graphs().size(); ++i) {
                this.graphs().at(i).normalize();
            }
        });


    });

    /**
     * Determines if the browser supports canvas elements.
     *
     * @method browserHasCanvasSupport
     * @private
     * @static
     * @author jrfrimme
     */
    Multigraph.browserHasCanvasSupport = function () {
        // Warning: this function uses the global variables `window` and `document`
        // --- it does not rely on these variables being passed in as is the
        // case with '$' above.
        return (
                (!!window.HTMLCanvasElement) &&
                (!!window.CanvasRenderingContext2D) &&
                (function (elem) {
                    return !!(elem.getContext && elem.getContext('2d'));
                }(document.createElement('canvas')))
            );
    };
    
    Multigraph.browserHasSVGSupport = function () {
        // Warning: this function uses the global variable `document`
        // --- it does not rely on this variable being passed in as is the
        // case with '$' above.
        return !!document.createElementNS &&
            !!document.createElementNS('http://www.w3.org/2000/svg', "svg").createSVGRect;
    };

    /**
     * Creates a Multigraph according to specified options. Returns a
     * jQuery `promise` which interacts with the multigraph through its
     * `done` function.
     *
     * @method createGraph
     * @param {Object} options
     *
     * @param {String|HTML Element|jQuery Object} options.div (REQUIRED)
     *      The DOM element div into which the multigraph should be
     *      placed; this value may be either (a) a string which is taken
     *      to be the id attribute of a div in the page, (b) a reference
     *      to the div DOM element itself, or (c) a jQuery object
     *      corresponding to the div DOM element.
     * 
     * @param {URI} options.mugl (REQUIRED, unless muglString is present)
     *       the URL from which the MUGL
     *       file for the Multigraph can be loaded
     * 
     * @param {String} options.muglString (REQUIRED, unless mugl is present)
     *       a string containing the MUGL XML for the graph
     * 
     * @param {String} options.driver (OPTIONAL) Indicates which
     *       graphics driver to use; should be one of the strings
     *       "canvas", "raphael", or "auto".  The default (which is
     *       used if the 'driver' tag is absent) is "auto", which
     *       causes Multigraph to check the features of the browser
     *       it is running in and choose the most appropriate driver.
     * 
     * @param {Function} options.error (OPTIONAL) A function for
     *       displaying error messages to the user.  Multigraph will
     *       call this function if and when it encounters an error.  The
     *       function should receive a single argument which is an
     *       instance of the JavaScript Error object.  The default is to
     *       use Multigraph's own internal mechanism for displaying user
     *       messages.
     *
     * @param {Function} options.warning (OPTIONAL) A function for
     *       displaying warning messages to the user.  Multigraph will
     *       call this function if and when it needs to display a
     *       warning message. The function should receive a single
     *       argument which is an instance of the JavaScript Error
     *       object.  The default is to use Multigraph's own internal
     *       mechanism for displaying user messages.
     * @return {Promise} jQuery promise which provides interaction with
     *     the graph through its `done` function.
     * @author mbp
     */
    Multigraph.createGraph = function (options) {
        var div = options.div,
            messageHandler,
            defaultMessageHandler;

        // // if driver wasn't specified, choose the best based on browser capability
        // if (!options.driver) {
        //     if (ns.browserHasCanvasSupport()) {
        //         options.driver = "canvas";
        //     } else {
        //         options.driver = "raphael";
        //     }
        // }
        // Force canvas driver from now on:
        options.driver = "canvas";

        // if div is a string, assume it's an id, and convert it to the div element itself
        if (typeof(div) === "string") {
            div = $("#" + div)[0];
        }

        // Force the div to have the specific width or height given in the options, if any.
        // I'm adding this code to resolve a problem with the div size sometimes not being
        // available when src/graphics/canvas/multigraph.js:createCanvasGraphFromString()
        // is used; see the notes in that file.
        if (options.width !== undefined && options.width > 0) {
            $(div).width(options.width);
        }
        if (options.height !== undefined && options.height > 0) {
            $(div).height(options.height);
        }

        //
        // NOTE: each of the Multigraph.create{DRIVER}Graph functions below takes an
        // "options" object argument just like Multigraph.createGraph does.  In general this
        // "options" object is the same as the one passed to this Multigraph.createGraph
        // function, but it differs in one way: Instead of containing separate "error" and
        // "warning" properties which are optional, the "options" object passed to the
        // Multigraph.create{DRIVER}Graph functions requires a single (non-optional!)
        // "messageHandler" property, which in turn contains "error" and "warning" properties
        // which are functions for handling errors and warnings, respectively.  Both the
        // "error" and a "warning" properties must be present in the "messageHandler" object
        // and must point to valid functions.
        // 
        // The rationale behind this is to allow convenience for callers of the more "public"
        // Multigraph.createGraph function, so that they don't have to specify an error or
        // warning handler function unless they want to use custom ones.  The internal
        // Multigraph.create{DRIVER}Graph functions, however, always need access to error and
        // warning functions, and often need to pass both of them on to other functions, so
        // they're encapsulated together into a single messageHandler object to make this
        // easier.
        //
        // Build the messageHandler object:
        messageHandler = {};
        if (typeof(options.error) === "function") {
            messageHandler.error = options.error;
        }
        if (typeof(options.warning) === "function") {
            messageHandler.warning = options.warning;
        }

        if (! messageHandler.error  || ! messageHandler.warning) {
            defaultMessageHandler = Multigraph.createDefaultMessageHandlers(div);
            if (! messageHandler.error) {
                messageHandler.error = defaultMessageHandler.error;
            }
            if (! messageHandler.warning) {
                messageHandler.warning = defaultMessageHandler.warning;
            }
        }
        options.messageHandler = messageHandler;

        if (options.muglString !== undefined) {
            // delegate to the driver-specific create function
            if (options.driver === "canvas") {
                return Multigraph.createCanvasGraphFromString(options);
            } else if (options.driver === "raphael") {
                return Multigraph.createRaphaelGraphFromString(options);
            } else {
                options.messageHanlder.error(new Error("invalid graphic driver '" + options.driver + "' specified to Multigraph.createGraph"));
                return undefined;
            }
        }

        // delegate to the driver-specific create function
        if (options.driver === "canvas") {
            return Multigraph.createCanvasGraph(options);
        } else if (options.driver === "raphael") {
            return Multigraph.createRaphaelGraph(options);
        } else {
            options.messageHanlder.error(new Error("invalid graphic driver '" + options.driver + "' specified to Multigraph.createGraph"));
            return undefined;
        }
    };

    /**
     * `window.multigraph.create` is an alias for `window.multigraph.core.Multigraph.createGraph`.
     *
     * @method window.multigraph.create
     * @param {Object} options
     *
     * @param {String|HTML Element|jQuery Object} options.div (REQUIRED)
     *      The DOM element div into which the multigraph should be
     *      placed; this value may be either (a) a string which is taken
     *      to be the id attribute of a div in the page, (b) a reference
     *      to the div DOM element itself, or (c) a jQuery object
     *      corresponding to the div DOM element.
     * 
     * @param {URI} options.mugl (REQUIRED) the URL from which the MUGL
     *       file for the Multigraph can be loaded
     * 
     * @param {String} options.driver (OPTIONAL) Indicates which
     *       graphics driver to use; should be one of the strings
     *       "canvas", "raphael", or "auto".  The default (which is
     *       used if the 'driver' tag is absent) is "auto", which
     *       causes Multigraph to check the features of the browser
     *       it is running in and choose the most appropriate driver.
     * 
     * @param {Function} options.error (OPTIONAL) A function for
     *       displaying error messages to the user.  Multigraph will
     *       call this function if and when it encounters an error.  The
     *       function should receive a single argument which is an
     *       instance of the JavaScrip Error object.  The default is to
     *       use Multigraph's own internal mechanism for displaying user
     *       messages.
     *
     * @param {Function} options.warning (OPTIONAL) A function for
     *       displaying warning messages to the user.  Multigraph will
     *       call this function if and when it needs to display a
     *       warning message. The function should receive a single
     *       argument which is an instance of the JavaScript Error
     *       object.  The default is to use Multigraph's own internal
     *       mechanism for displaying user messages.
     * @return {Promise} jQuery promise which provides interaction with
     *     the graph through its `done` function.
     * @static
     * @author jrfrimme
     */
    Multigraph.create = Multigraph.createGraph;

    /**
     * Creates default error and warning functions for multigraph.
     *
     * @method createDefaultMessageHandlers
     * @param {HTML Element} div
     * @static
     * @return {Object} Object keyed by `error` and `warning` which respectively point to
     *     the generated default error and warning functions.
     * @author jrfrimme
     */
    Multigraph.createDefaultMessageHandlers = function (div) {

        $(div).css('position', 'relative');
        $(div).errorDisplay({});

        return {
            error : function(e) {
                var stackTrace = (e.stack && typeof(e.stack) === "string") ? e.stack.replace(/\n/g, "</li><li>") : e.message;
                $(div).errorDisplay("displayError", stackTrace, e.message, {
                    fontColor       : '#000000',
                    backgroundColor : '#ff0000',
                    indicatorColor  : '#ff0000'
                });
            },

            warning : function (w) {
                // w can be either a string, or a Warning instance
                var message    = "Warning: " + ((typeof(w) === "string") ? w : w.message),
                    stackTrace = (typeof(w) !== "string" && w.stack && typeof(w.stack) === "string") ? w.stack.replace(/\n/g, "</li><li>") : message;
                $(div).errorDisplay("displayError", stackTrace, message, {
                    fontColor       : '#000000',
                    backgroundColor : '#e06a1b',
                    indicatorColor  : '#e06a1b'
                });
            }
        };
    };

    // define empty object for holding data adpaters
    Multigraph._dataAdapters = {};

    Multigraph.installDataAdapter = function(name, adapter) {
        Multigraph._dataAdapters[name] = adapter;
    };

    Multigraph.getDataAdapter = function(name) {
        return Multigraph._dataAdapters[name];
    };

    // so that data adpaters, or other JS code interacting with Multigraph,
    // may have access to sprintf:
    Multigraph.sprintf = require('sprintf');

    return Multigraph;
};

},{"../../lib/jermaine/src/jermaine.js":9,"./graph.js":42,"sprintf":17}],50:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var sprintf = require('sprintf');

var NumberFormatter = function (format) {
    var testString;
    if (typeof(format) !== "string") {
        throw new Error("format must be a string");
    }
    this.formatString = format;
    testString = sprintf(format, 0);
    this.length = testString.length;
};

NumberFormatter.prototype.format = function (value) {
    return sprintf(this.formatString, value.getRealValue());
};

NumberFormatter.prototype.getMaxLength = function () {
    return this.length;
};

NumberFormatter.prototype.getFormatString = function () {
    return this.formatString;
};

module.exports = NumberFormatter;

},{"../../lib/jermaine/src/jermaine.js":9,"sprintf":17}],51:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

NumberValue = require('./number_value.js');

// Fudge factor for floating point comparisons:
var epsilon = 1E-12;

var NumberMeasure = function (measure) {
    this.measure = measure;
};

NumberMeasure.prototype.getRealValue = function () {
    return this.measure;
};

NumberMeasure.prototype.toString = function () {
    return this.measure.toString();
};

NumberMeasure.prototype.firstSpacingLocationAtOrAfter = function (value, alignment)  {
    var f,
        n,
        m,
        a = alignment.value,
        v = value.value,
        s = Math.abs(this.measure);
    f = (v - a) / s;
    n = Math.floor(f);
    m = n + 1;
    //if ((Math.abs(n - f) < epsilon) || (Math.abs(m - f) < epsilon)) {
    //NOTE: by definition of n=floor(f), we know f >= n, so Math.abs(n - f) is the same as (f - n)
    //Also by definition, floor(f)+1 >= f, so Math.abs(m - f) is the same as (m - f)
    if ((f - n < epsilon) || (m - f < epsilon)) {
        return new NumberValue(v);
    }
    return new NumberValue(a + s * m);
};

// Consider a lattice of values spaced `s` apart, aligned with `a`
//    i.e. all values a + z*s, where z is any integer
// Return the largest value in this lattice that is <= `v`
function lastSpacingLocationAtOrBefore(s, v, a) {
    var n, n, f;
    v = v - a;
    if (v >= 0) {
        f = v / s;
        n = Math.floor(f);
        if (f - n < epsilon) { return v; }
        return a + n*s;
    } else {
        f = -v / s;
        n = Math.ceil(f);
        if (n - f < epsilon) { return v; }
        return a - n*s;
    }
}

/**
 * This function is just like `firstSpacingLocationAtOrAfter` above, but returns the
 * greatest NumberValue in the lattice that is less than or equal to `value`.
 * 
 * return: a NumberValue
 */
NumberMeasure.prototype.lastSpacingLocationAtOrBefore = function (/*NumberValue*/value, /*NumberValue*/alignment)  {
    return new NumberValue(lastSpacingLocationAtOrBefore(this.measure, value.value, alignment.value));
};

//    var f,
//        n,
//        m,
//        a = alignment.value,
//        v = value.value,
//        s = Math.abs(this.measure);
//    f = (v - a) / s;
//    if (f > 0) {
//        n = Math.floor(f);
//    } else {
//        n = Math.ceil(f);
//    }
//    m = n + 1;
//    if ((f - n < epsilon) || (m - f < epsilon)) {
//        console.log('at 1');
//        console.log(f);
//        console.log(f-n);
//        console.log(m-f);
//        console.log(epsilon);
//        return new NumberValue(v);
//    }
//    console.log('at 2');
//    return new NumberValue(a + s * n);
//};

NumberMeasure.parse = function (s) {
    return new NumberMeasure(parseFloat(s));
};

module.exports = NumberMeasure;

},{"../../lib/jermaine/src/jermaine.js":9,"./number_value.js":52}],52:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

DataValue = require('./data_value.js');

var NumberValue = function (value) {
    this.value = value;
};

NumberValue.prototype.getRealValue = function () {
    return this.value;
};

NumberValue.prototype.toString = function () {
    return this.value.toString();
};

NumberValue.prototype.compareTo = function (x) {
    if (this.value < x.value) {
        return -1;
    } else if (this.value > x.value) {
        return 1;
    }
    return 0;
};

NumberValue.prototype.addRealValue = function ( realValueIncr ) {
    return new NumberValue(this.value + realValueIncr);
};

NumberValue.prototype.add = function (/*DataMeasure*/ measure) {
    // NOTE: deliberately accessing the 'measure' property of a NumberMeasure here, rather
    // than calling its getRealValue() method, for convenience and efficiency:
    return new NumberValue(this.value + measure.measure);
};

NumberValue.prototype.type = DataValue.NUMBER;

NumberValue.prototype.clone = function() {
    return new NumberValue(this.value);
};

NumberValue.parse = function (s) {
    return new NumberValue(parseFloat(s));
};

DataValue.mixinComparators(NumberValue.prototype);

module.exports = NumberValue;

},{"../../lib/jermaine/src/jermaine.js":9,"./data_value.js":31}],53:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

DataValue = require('./data_value.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.horizontalaxis.pan);

var Pan = new jermaine.Model("Pan", function () {
    this.hasA("allowed").which.isA("boolean");
    this.hasA("min").which.validatesWith(DataValue.isInstanceOrNull);
    this.hasA("max").which.validatesWith(DataValue.isInstanceOrNull);

    //NOTE: the distinction between DataValue and DataMeasure for the zoom & pan model
    //      attributes might seem confusing, so here's a table to clarify it:
    //
    //              Boolean      DataValue      DataMeasure
    //              -------      ---------      -----------
    //  zoom:       allowed      anchor         min,max
    //   pan:       allowed      min,max

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis.pan, attributes);
});

module.exports = Pan;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":159,"./data_value.js":31}],54:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var ArrayData = require('./array_data.js'),
    DataMeasure = require('./data_measure.js'),
    DataValue = require('./data_value.js');

var PeriodicArrayData = new jermaine.Model(function () {
    var PeriodicArrayData = this,
        emptyIterator = {
            "next"    : function () {},
            "hasNext" : function () { return false; }
        };

    this.isA(ArrayData);
    this.hasA("period").which.validatesWith(DataMeasure.isInstance);
    //this.hasA("column0RelativeRealValues").which.defaultsTo(null);
    this.isBuiltWith("columns", "stringArray", "period", function () {
        this.init();
        this.addListener("listenerAdded", function (event) {
            var data = this.array();
            if (event.targetType === "dataReady") {
                event.listener(data[0][0], data[data.length-1][0]);
            }
        });
    });

    /*
     this.respondsTo("initializeColumn0RelativeRealValues", function() {
     var array = this.array(),
     column0RelativeRealValues = [],
     i;
     for (i=0; i<array.length; ++i) {
     column0RelativeRealValues[i] = array[i][0] - array[0][0];
     }
     this.column0RelativeRealValues(column0RelativeRealValues);
     });
     */

    /**
     * @method getIterator
     * @param {string array} columnIDs
     * @param {DataValue} min
     * @param {DataValue} max
     * @param {Integer} buffer
     * @author jrfrimme
     */
    this.respondsTo("getIterator", function (columnIds, min, max, buffer) {
        return PeriodicArrayData.getArrayDataIterator(this, columnIds, min, max, buffer);
    });

    /**
     * @method getArrayDataIterator
     * @static
     * @param {ArrayData} arrayData
     * @param {string array} columnIDs
     * @param {DataValue} min
     * @param {DataValue} max
     * @param {Integer} buffer
     * @return iter
     * @author jrfrimme
     */
    PeriodicArrayData.getArrayDataIterator = function (periodicArrayData, columnIds, min, max, buffer) {
        var iter = {},
            arraySlice = [],
            curr = 0,
            i, j,
            currentIndex,
            columnIndices,
            array = periodicArrayData.array();

        buffer = buffer || 0;

        // columnIds argument should be an array of strings
        if (Object.prototype.toString.apply(columnIds) !== "[object Array]") {
            throw new Error("ArrayData: getIterator method requires that the first parameter be an array of strings");
        } else {
            for (i = 0; i < columnIds.length; ++i) {
                if (typeof(columnIds[i]) !== "string") {
                    throw new Error("ArrayData: getIterator method requires that the first parameter be an array of strings");
                }
            }
        }

        //min,max arguments should be data values
        if (!DataValue.isInstance(min) || !DataValue.isInstance(max)) {
            throw new Error("ArrayData: getIterator method requires the second and third argument to be number values");
        }

        //buffer argument should be an integer
        if (typeof(buffer) !== "number") {
            throw new Error("ArrayData: getIterator method requires last argument to be an integer");
        }

        // if we have no data, return an empty iterator
        if (array.length === 0) {
            return emptyIterator;
        }

        /*
         // populate the column0RelativeRealValues array if it hasn't yet been populated
         if (this.column0RelativeRealValues() === null) {
         this.initializeColumn0RelativeRealValues();
         }
         */

        // Let `baseValue` be the location of the first data point in the array
        var baseValue = array[0][0];

        // In the regular lattice of spacing `period` aligned with baseValue,
        // find the last point that is less than or equal to `min`.  Call this point `b`.
        var b = periodicArrayData.period().lastSpacingLocationAtOrBefore(min, baseValue);

        // Let `offsetRealValue` be the difference between b and baseValue, as a real value:
        var offsetRealValue = b.getRealValue() - baseValue.getRealValue();

        // Let `baseMin` be `min` shifted 'backward' by offsetRealValue; this is `min`
        // relative to the same period cycle as baseValue:
        var baseMin = DataValue.create(min.type, min.getRealValue() - offsetRealValue);

        // find the index of the first row in the array whose column0 value is >= baseMin;
        // this is the data point we start with
        for (currentIndex = 0; currentIndex < array.length; ++currentIndex) {
            if (array[currentIndex][0].ge(baseMin)) {
                break;
            }
        }
        if (currentIndex === array.length) {
            currentIndex = 0;
        }

        //
        //TODO later: back up 'buffer' steps
        //

        // set the current value to be the column0 value at this first index, shifted
        // 'forward' by offsetRealValue
        var currentValue = DataValue.create(array[currentIndex][0].type, array[currentIndex][0].getRealValue() + offsetRealValue);

        columnIndices = [];
        for (j = 0; j < columnIds.length; ++j) {
            var k = periodicArrayData.columnIdToColumnNumber(columnIds[j]);
            columnIndices.push( k );
        }

        return {
            next : function () {
                var projection = [],
                    i, x;
                if (currentIndex < 0) {
                    return null;
                }
                for (i = 0; i < columnIndices.length; ++i) {
                    if (columnIndices[i] === 0) {
                        projection.push(currentValue);
                    } else {
                        projection.push(array[currentIndex][columnIndices[i]]);
                    }
                }
                ++currentIndex;
                if (currentIndex >= array.length) {
                    currentIndex = 0;
                    b = b.add(periodicArrayData.period());
                    offsetRealValue = b.getRealValue() - baseValue.getRealValue();
                }
                currentValue = DataValue.create(array[currentIndex][0].type, array[currentIndex][0].getRealValue() + offsetRealValue);
                if (currentValue.gt(max)) {
                    //TODO: actually need to figure out how to move forward `buffer` steps, but for
                    // now skip that part.
                    currentIndex = -1;
                }
                return projection;
            },
            hasNext : function () {
                return (currentIndex >= 0);
            }
        };
        
    };

});


module.exports = PeriodicArrayData;

},{"../../lib/jermaine/src/jermaine.js":9,"./array_data.js":18,"./data_measure.js":29,"./data_value.js":31}],55:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var PlotLegend = require('./plot_legend.js'),
    Axis = require('./axis.js'),
    Renderer = require('./renderer.js');

var Plot = new jermaine.Model("Plot", function () {
    this.hasA("legend").which.validatesWith(function (legend) {
        return legend instanceof PlotLegend;
    });
    this.hasA("horizontalaxis").which.validatesWith(function (axis) {
        return axis instanceof Axis;
    });
    this.hasA("verticalaxis").which.validatesWith(function (axis) {
        return axis instanceof Axis;
    });
    this.hasA("renderer").which.validatesWith(function (renderer) {
        return renderer instanceof Renderer;
    });
    this.hasA("visible").which.isA("boolean").and.defaultsTo(true);

    this.respondsTo("normalize", function(graph) {
        var graphAxes = graph.axes(),
            rendererType,
            numberOfVariables,
            findNextVariableAtOrAfter,
            i,
            DataPlot = require('../core/data_plot.js');

        //
        // Handles missing variables
        //
        findNextVariableAtOrAfter = function (plot, data, index) {
            var overlapFlag = false,
                variableInPlotFlag,
                i = index,
                j,
                variable;

            while (true) {
                if (i === index && overlapFlag === true) {
                    throw new Error("Plot Normalizer: There does not exist an unused variable");
                }

                if (i === data.columns().size()) {
                    i = 0;
                    overlapFlag = true;
                }

                variableInPlotFlag = false;
                variable = data.columns().at(i);

                for (j = 0; j < plot.variable().size(); j++) {
                    if (plot.variable().at(j) === variable) {
                        variableInPlotFlag = true;
                        break;
                    }
                }

                if (variableInPlotFlag === false) {
                    return variable;
                }

                i++;
            }
            
        };

        //
        // Handles missing horizontalaxis tags
        //
        if (this.horizontalaxis() === undefined) {
            for (i = 0; i < graphAxes.size(); i++) {
                if (graphAxes.at(i).orientation() === Axis.HORIZONTAL) {
                    this.horizontalaxis(graphAxes.at(i));
                    break;
                }
            }
        }

        //
        // Handles missing verticalaxis tags
        //
        if (this.verticalaxis() === undefined) {
            for (i = 0; i < graphAxes.size(); i++) {
                if (graphAxes.at(i).orientation() === Axis.VERTICAL) {
                    this.verticalaxis(graphAxes.at(i));
                    break;
                }
            }
        }

        //
        // Handles missing renderer tags
        //
        if (this.renderer() === undefined) {
            require('./renderers/all_renderers.js');
            rendererType = Renderer.Type.parse("line");
            this.renderer(Renderer.create(rendererType));
            this.renderer().plot(this);
        }

        numberOfVariables = this.renderer().numberOfVariables();

        if (this instanceof DataPlot) {
            var plotData = this.data,
                plotVariables = this.variable();
            
            if (plotData() === undefined) {
                plotData(graph.data().at(0));
            }

            if (plotVariables.size() === 0) {
                plotVariables.add(findNextVariableAtOrAfter(this, plotData(), 0));
            }

            if (plotVariables.at(0) === null) {
                plotVariables.replace(0, findNextVariableAtOrAfter(this, plotData(), 0));
            }

            while (plotVariables.size() < numberOfVariables) {
                plotVariables.add(findNextVariableAtOrAfter(this, plotData(), 1));
            }

            // 1. get variables from a data section, some will be used, others won't be.
            // 2. check if horizontal axis needs a variable
            //       if it does - find first unused variable, starting at position 0
            //                  - if no unused variables exist - throw error
            //                  - CONTINUE
            //       if it does not - CONTINUE
            // 3. check if vertical axis needs variable(s)
            //       if it does - find first unused variable, starting at the position of
            //                    the x variable
            //                  - if no unused variables exist - throw error
            //                  - check if vertical axis needs another variable
            //                        if it does - Repeat step 3

            if (this.datatips()) {
                this.datatips().normalize(this);
            }
        }

    });

});

module.exports = Plot;

},{"../../lib/jermaine/src/jermaine.js":9,"../core/data_plot.js":30,"./axis.js":19,"./plot_legend.js":56,"./renderer.js":58,"./renderers/all_renderers.js":59}],56:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Text = require('./text.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.legend);

var PlotLegend = new jermaine.Model("PlotLegend", function () {
    this.hasA("visible").which.isA("boolean");
    this.hasA("label").which.validatesWith(function (label) {
        return label instanceof Text;
    });

    utilityFunctions.insertDefaults(this, defaultValues.plot.legend, attributes);
});

module.exports = PlotLegend;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":159,"./text.js":65}],57:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var RGBColor = require('../math/rgb_color.js'),
    Insets = require('../math/insets.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plotarea);

var Plotarea = new jermaine.Model("Plotarea", function () {

    this.hasA("margin").which.validatesWith(function (margin) {
        return margin instanceof Insets;
    });

    this.hasA("border").which.isA("integer");

    this.hasA("color").which.validatesWith(function (color) {
        return color === null || color instanceof RGBColor;
    });

    this.hasA("bordercolor").which.validatesWith(function (bordercolor) {
        return bordercolor instanceof RGBColor;
    });

    utilityFunctions.insertDefaults(this, defaultValues.plotarea, attributes);
});

module.exports = Plotarea;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/insets.js":105,"../math/rgb_color.js":107,"../util/utilityFunctions.js":159}],58:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Warning = require('./warning.js'),
    Enum = require('../math/enum.js'),
    rendererList,
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer),
    Type = new Enum("RendererType"),
    RGBColor = require('../math/rgb_color.js');

var Renderer = new jermaine.Model("Renderer", function () {
    this.hasA("type").which.validatesWith(Type.isInstance);
    this.hasA("plot").which.validatesWith(function (plot) {
        var Plot = require('./plot.js');
        return plot instanceof Plot;
    });
    this.hasA("numberOfVariables").which.isA("number");

    this.hasA("filter").which.validatesWith(function(filter) {
        return ((typeof(filter) === 'undefined')
                ||
                ((typeof(filter.reset) === 'function') && (typeof(filter.filter) === 'function')));
    });

    this.respondsTo("setUpMissing", function () {
        // A call to this method results in the addition (or replacement) of a method called "isMissing()"
        // that can be used to test whether a value meets the "missing" criteria of one of this renderer's
        // plot's data columns.  The point of having this "setUpMissing()" method create the "isMissing()"
        // method, rather than just coding the "isMissing()" method directly here, is so that we can capture
        // a pointer to the plot's data object via a closure, for faster access, rather than coding
        // this.plot().data() in "isMissing()", which adds the overhead of 2 getter calls to each invocation.
        //
        // NOTE: This is awkward.  What we really want is for this stuff to happen automatically when
        // the renderer's "plot" attribute is set.  Can Jermaine be modified to allow us to write
        // a custom setter, so that we can execute this code automatically when the render's "plot"
        // attribute is set ???
        var plot = this.plot(),
            data;
        if (!plot) {
            console.log("Warning: renderer.setUpMissing() called for renderer that has no plot ref");
            // this should really eventually throw an error
            return;
        }

        // for ConstantPlot, create function that always returns false, since it has no data
        var ConstantPlot = require('./constant_plot.js');
        if (plot instanceof ConstantPlot) {
            this.isMissing = function (p) {
                return false;
            };
            return;
        }


        if (!plot.data()) {
            // this should eventually throw an error
            console.log("Warning: renderer.setUpMissing() called for renderer whose plot has no data ref");
            return;
        }
        data = plot.data();
        this.isMissing = function (p) {
            var i;
            for (i = 1; i < p.length; ++i) {
                if (data.isMissing(p[i], i)) {
                    return true;
                }
            }
            return false;
        };
    });

    this.isBuiltWith("type");

    utilityFunctions.insertDefaults(this, defaultValues.plot.renderer, attributes);

    this.respondsTo("transformPoint", function (input) {
        var output = [],
            haxis = this.plot().horizontalaxis(),
            vaxis = this.plot().verticalaxis(),
            i;

        output[0] = haxis.dataValueToAxisValue(input[0]);
        for (i = 1; i < input.length; ++i) {
            output[i] = vaxis.dataValueToAxisValue(input[i]);
        }
        return output;
    });

    var equalOrUndefined = function (a, b) {
        return ((a===b) || ((a===undefined) && (b===undefined)));
    };

    this.respondsTo("setOption", function (name, value, min, max) {
        var rendererOpt,
            rendererOpts,
            i;
        if (!this.optionsMetadata[name]) {
            throw new Error("attempt to set unknown renderer option '"+name+"'");
        }
        rendererOpts = this.options()[name]();
        for (i = 0; i < rendererOpts.size(); ++i) {
            if (equalOrUndefined(rendererOpts.at(i).min(), min) &&
                equalOrUndefined(rendererOpts.at(i).max(), max)) {
                rendererOpts.at(i).value(value);
                return;
            }
        }
        // If we get this far, it means we didn't find an existing option in the list with matching min/max
        // settings, so we create a new one and append it to the end of the list:
        rendererOpt = new (this.optionsMetadata[name].type)();
        rendererOpt.value(value);
        rendererOpt.min(min);
        rendererOpt.max(max);
        rendererOpts.add(rendererOpt);
    });

    this.respondsTo("setOptionFromString", function (name, stringValue, stringMin, stringMax) {
        var plot = this.plot(),
            type = this.type(),
            DataValue = require('./data_value.js');

        //
        // Two blocks of code below provides support for the deprecated "dotsize" and "dotcolor"
        // options, which have been replaced by "pointsize" and "pointcolor".  Delete these blocks
        // when removing support for this.
        // 

        // 
        // First block in support of deprecated dotsize/dotcolor options:
        //
        var warning = undefined;
        if (name === "dotsize") {
            name = "pointsize";
            warning = new Warning('deprecated "dotsize" option used for "' + type + '" renderer; use "pointsize" instead');
        } else if (name === "dotcolor") {
            name = "pointcolor";
            warning = new Warning('deprecated "dotcolor" option used for "' + type + '" renderer; use "pointcolor" instead');
        }
        // 
        // End of first block in support of deprecated dotsize/dotcolor options
        //

        var rendererOpt;
        if (!this.optionsMetadata[name]) {
            // If this renderer has no option named "name", bail out immediately.  This should eventually
            // throw an error, but for now we just quietly ignore it, to eliminate error conditions coming
            // from unimplemented options.
            //console.log("WARNING: renderer has no option named '" + name + "'");
            throw new Warning('"' + type + '"' + ' renderer has no option named "' + name + '"');
        }
        rendererOpt = new (this.optionsMetadata[name].type)();
        rendererOpt.parseValue(stringValue, this);
        if (plot && plot.verticalaxis()) {
            if (stringMin !== undefined) {
                rendererOpt.min( DataValue.parse( plot.verticalaxis().type(), stringMin ));
            }
            if (stringMax !== undefined) {
                rendererOpt.max( DataValue.parse( plot.verticalaxis().type(), stringMax ));
            }
        }
        this.setOption(name, rendererOpt.value(), rendererOpt.min(), rendererOpt.max());

        // 
        // Second block in support of deprecated dotsize/dotcolor options:
        //
        if (warning) {
            throw warning;
        }
        // 
        // End of second block in support of deprecated dotsize/dotcolor options:
        //
    });


    this.respondsTo("getOptionValue", function (optionName, /*optional:*/value) {
        var i,
            options,
            optionList;

        options = this.options();
        if (typeof(options[optionName]) !== "function") {
            throw new Error('unknown option "'+optionName+'"');
        }
        optionList = options[optionName]();
        if (!optionList) {
            throw new Error('unknown option "'+optionName+'"');
        }
        //NOTE: options are stored in reverse order; default one is always in the '0' position.
        //  Search through them starting at the END of the list, going backwards!
        for (i = optionList.size()-1; i >= 0; --i) {
            var option = optionList.at(i);
            if (((option.min()===undefined) || (value===undefined) || option.min().le(value)) &&
                ((option.max()===undefined) || (value===undefined) || option.max().gt(value))) {
                return option.value();
            }
        }
        
    });

    // method must be overridden by subclass:
    this.respondsTo("begin", function () {
    });
    // method must be overridden by subclass:
    this.respondsTo("dataPoint", function (point) {
    });
    // method must be overridden by subclass:
    this.respondsTo("end", function () {
    });

});

/*
 * Private list of known renderers.  This list is populated from within individual
 * renderer submodel implementations by calls to Renderer.addType.
 */
rendererList = [];

/*
 * Add a renderer submodel to the list of known renders.  rendererObj should be
 * an object with two properties:
 *    'type'  : the type of the renderer -- a string, which is the value expected
 *              for the type attribute of the mugl <renderer> tag.
 *    'model' : the renderer submodel
 */
Renderer.addType = function (rendererObj) {
    rendererList.push(rendererObj);
};

/*
 * Factory method: create an instance of a renderer submodel based on its type (a string).
 */
Renderer.create = function (type) {
    var i,
        renderer;
    for (i = 0; i < rendererList.length; ++i) {
        if (rendererList[i].type === type) {
            renderer = new (rendererList[i].model)();
            renderer.type(type);
            return renderer;
        }
    }
    throw new Error("Renderer.create: '" + type + "' is not a known renderer type");
    //        throw new Error('Renderer.create: attempt to create a renderer of unknown type');
};

Renderer.declareOptions = function (renderer, OptionsModelName, options) {
    var i,
        OptionsModel,
        optionsMetadata,
        declareOption = function(optionName, optionType) {
            // NOTE: this call to hasMany() has to be in a function here, rather than just
            // being written inline where it is used below, because we need a closure to
            // capture value of options[i].type as optionType, for use in the validation
            // function.  Otherwise, the validator captures the 'options' array and the
            // local loop variable i instead, and evaluates options[i].type when validation
            // is performed!
            OptionsModel.hasMany(optionName).eachOfWhich.validateWith(function (v) {
                return v instanceof optionType;
            });
        };

    OptionsModel    = new jermaine.Model(OptionsModelName, function () {});
    optionsMetadata = {};
    for (i = 0; i < options.length; ++i) {
        declareOption(options[i].name, options[i].type);
        optionsMetadata[options[i].name] = {
            "type"    : options[i].type,
            "default" : options[i]["default"]
        };
    }
    renderer.hasA("options").isImmutable().defaultsTo(function () { return new OptionsModel(); });
    renderer.prototype.optionsMetadata = optionsMetadata;

    renderer.isBuiltWith(function () {
        // populate options with default values stored in options metadata (which was populated by declareOptions):
        var optionsMetadata = this.optionsMetadata,
            opt, ropt;
        for (opt in optionsMetadata) {
            if (optionsMetadata.hasOwnProperty(opt)) {
                ropt = new (optionsMetadata[opt].type)(optionsMetadata[opt]["default"]);
                this.options()[opt]().add( ropt );
            }
        }
    });

};


Renderer.Option = new jermaine.Model("Renderer.Option", function () {
    var DataValue = require('./data_value.js');
    this.hasA("min").which.validatesWith(DataValue.isInstance);
    this.hasA("max").which.validatesWith(DataValue.isInstance);
});


Renderer.RGBColorOption = new jermaine.Model("Renderer.RGBColorOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.validatesWith(function (v) {
        return v instanceof RGBColor || v === null;
    });
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return this.value().getHexString();
    });
    this.respondsTo("parseValue", function (string) {
        this.value( RGBColor.parse(string) );
    });
    this.respondsTo("valueEq", function (value) {
        return this.value().eq(value);
    });

});

Renderer.NumberOption = new jermaine.Model("Renderer.NumberOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.isA("number");
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return this.value().toString();
    });
    this.respondsTo("parseValue", function (string) {
        this.value( parseFloat(string) );
    });
    this.respondsTo("valueEq", function (value) {
        return (this.value()===value);
    });
});

Renderer.DataValueOption = new jermaine.Model("Renderer.DataValueOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.validatesWith(function (value) {
        var DataValue = require('./data_value.js');
        return DataValue.isInstance(value) || value === null;
    });
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return this.value();
    });
    this.respondsTo("valueEq", function (value) {
        return this.value().eq(value);
    });
});

Renderer.VerticalDataValueOption = new jermaine.Model("Renderer.DataValueOption", function () {
    this.isA(Renderer.DataValueOption);
    this.isBuiltWith("value");
    this.respondsTo("parseValue", function (string, renderer) {
        var DataValue = require('./data_value.js');
        this.value( DataValue.parse(renderer.plot().verticalaxis().type(), string) );
    });
    
});

Renderer.HorizontalDataValueOption = new jermaine.Model("Renderer.DataValueOption", function () {
    this.isA(Renderer.DataValueOption);
    this.isBuiltWith("value");
    this.respondsTo("parseValue", function (string, renderer) {
        var DataValue = require('./data_value.js');
        this.value( DataValue.parse(renderer.plot().horizontalaxis().type(), string) );
    });
    
});

Renderer.DataMeasureOption = new jermaine.Model("Renderer.DataMeasureOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.validatesWith(function (value) {
        var DataMeasure = require('./data_measure.js');
        return DataMeasure.isInstance(value) || value === null;
    });
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return this.value();
    });
    this.respondsTo("valueEq", function (value) {
        return this.value().eq(value);
    });
});

Renderer.VerticalDataMeasureOption = new jermaine.Model("Renderer.DataMeasureOption", function () {
    this.isA(Renderer.DataMeasureOption);
    this.respondsTo("parseValue", function (string, renderer) {
        var DataMeasure = require('./data_measure.js');
        this.value( DataMeasure.parse(renderer.plot().verticalaxis().type(), string) );
    });
    
});

Renderer.HorizontalDataMeasureOption = new jermaine.Model("Renderer.DataMeasureOption", function () {
    this.isA(Renderer.DataMeasureOption);
    this.isBuiltWith("value");
    this.respondsTo("parseValue", function (string, renderer) {
        var DataMeasure = require('./data_measure.js');
        this.value( DataMeasure.parse(renderer.plot().horizontalaxis().type(), string) );
    });
    
});

Renderer.Type = Type;

module.exports = Renderer;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/enum.js":104,"../math/rgb_color.js":107,"../util/utilityFunctions.js":159,"./constant_plot.js":25,"./data_measure.js":29,"./data_value.js":31,"./plot.js":55,"./warning.js":67}],59:[function(require,module,exports){
require('./band_renderer.js');
require('./bar_renderer.js');
require('./fill_renderer.js');
require('./pointline_renderer.js');
require('./rangebar_renderer.js');

},{"./band_renderer.js":60,"./bar_renderer.js":61,"./fill_renderer.js":62,"./pointline_renderer.js":63,"./rangebar_renderer.js":64}],60:[function(require,module,exports){
var jermaine = require('../../../lib/jermaine/src/jermaine.js');

// The Band renderer is a 2-variable renderer which fills the region
// between two data lines with a solid color, and draws a line segment
// between consecutive data points in each line.
// 
// It is very similar to the fill renderer except that the filled region
// extends between the two (vertical axis) data values at each data point, instead
// of between a single (vertical axis) value and a horizontal base line.
// 
// The line segements should occlude the solid fill.
// 
// This renderer accepts the following options:
// 
//     OPTION NAME:          linecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          Color used for line segments.
// 
//     OPTION NAME:          linewidth
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Width, in pixels, of line segments.  A
//                           value of 0 means do not draw line segments.
// 
//     OPTION NAME:          line1color
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        none (linecolor is used)
//     DESCRIPTION:          Color used for line segments connecting the
//                           values of variable 1.   If both linecolor and
//                           line1color are specified, line1color is used.
// 
//     OPTION NAME:          line1width
//     DATA TYPE:            number
//     DEFAULT VALUE:        -1 (linewidth is used)
//     DESCRIPTION:          Width, in pixels, of line segments connecting the
//                           values of variable 1.  A value of 0 means do not
//                           draw line segments.   If both linewidth and
//                           line1width are specified, line1width is used.
// 
//     OPTION NAME:          line2color
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        none (linecolor is used)
//     DESCRIPTION:          Color used for line segments connecting the
//                           values of variable 2.   If both linecolor and
//                           line2color are specified, line2color is used.
// 
//     OPTION NAME:          line2width
//     DATA TYPE:            number
//     DEFAULT VALUE:        -1 (linewidth is used)
//     DESCRIPTION:          Width, in pixels, of line segments connecting the
//                           values of variable 2.  A value of 0 means do not
//                           draw line segments.   If both linewidth and
//                           line2width are specified, line2width is used.
// 
//     OPTION NAME:          fillcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x808080 (dark gray)
//     DESCRIPTION:          Color used for the fill area.
// 
//     OPTION NAME:          fillopacity
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Opacity used for the fill area.
//

var Renderer = require('../renderer.js'),
    RGBColor = require('../../math/rgb_color.js');

var BandRenderer = new jermaine.Model("BandRenderer", function () {
    this.isA(Renderer);
    this.hasA("numberOfVariables").which.defaultsTo(3);
});

BandRenderer.GRAY = parseInt("80", 16) / 255;

Renderer.declareOptions(BandRenderer, "BandRendererOptions", [
    {
        "name"          : "linecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "linewidth",
        "type"          : Renderer.NumberOption,
        "default"       : 1
    },
    {
        "name"          : "line1color",
        "type"          : Renderer.RGBColorOption,
        "default"       : null
    },
    {
        "name"          : "line1width",
        "type"          : Renderer.NumberOption,
        "default"       : -1
    },
    {
        "name"          : "line2color",
        "type"          : Renderer.RGBColorOption,
        "default"       : null
    },
    {
        "name"          : "line2width",
        "type"          : Renderer.NumberOption,
        "default"       : -1
    },
    {
        "name"          : "fillcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(BandRenderer.GRAY,BandRenderer.GRAY,BandRenderer.GRAY)
    },
    {
        "name"          : "fillopacity",
        "type"          : Renderer.NumberOption,
        "default"       : 1.0
    }
]);

Renderer.BAND = new Renderer.Type("band");

Renderer.addType({"type"  : Renderer.Type.parse("band"),
                  "model" : BandRenderer});

module.exports = BandRenderer;

},{"../../../lib/jermaine/src/jermaine.js":9,"../../math/rgb_color.js":107,"../renderer.js":58}],61:[function(require,module,exports){
var jermaine = require('../../../lib/jermaine/src/jermaine.js');

// The Bar renderer is a 1-variable renderer which draws a bar at each
// non-missing data point with an outline around the bar and a solid
// fill between the bar and the horizontal axis.
// 
// This renderer accepts the following options:
// 
//     OPTION NAME:          barwidth
//     DATA TYPE:            DataMeasure
//     DEFAULT VALUE:        ???
//     DESCRIPTION:          Width, in relative terms to the type of the
//                           axis the plot is on, of the bars.
//                           
//     OPTION NAME:          baroffset
//     DATA TYPE:            number
//     DEFAULT VALUE:        0
//     DESCRIPTION:          The offset, in pixels, of the left edge of
//                           each bar from the corresponding data value.
//                           
//     OPTION NAME:          barbase
//     DATA TYPE:            DataValue
//     DEFAULT VALUE:        null
//     DESCRIPTION:          The location, relative to the plot's
//                           vertical axis, of the bottom of the bar; if
//                           no barbase is specified, the bars will
//                           extend down to the bottom of the plot area.
//                           
//     OPTION NAME:          linecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          The color to be used for the outline around
//                           each bar.
// 
//     OPTION NAME:          fillcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          The color to be used for the fill inside
//                           each bar; if barbase is specified, this
//                           color is used only for bars that extend
//                           above the base.
// 
//     OPTION NAME:          fillopacity
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Opacity used for the fill inside each bar.
// 
//     OPTION NAME:          hidelines
//     DATA TYPE:            number
//     DEFAULT VALUE:        2
//     DESCRIPTION:          Bars which are less wide, in pixels, than
//                           this number do not render their outlines.
//                           
var Renderer = require('../renderer.js'),
    RGBColor = require('../../math/rgb_color.js'),
    DataMeasure = require('../data_measure.js'),
    utilityFunctions = require('../../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer);

var BarRenderer = new jermaine.Model("BarRenderer", function () {
    this.isA(Renderer);
    this.hasA("numberOfVariables").which.defaultsTo(2);
});

Renderer.declareOptions(BarRenderer, "BarRendererOptions", [
    {
        "name"          : "barwidth",
        "type"          : Renderer.HorizontalDataMeasureOption,
        "default"       : new DataMeasure.parse("number", 0)
    },
    {
        "name"          : "baroffset",
        "type"          : Renderer.NumberOption,
        "default"       : 0
    },
    {
        "name"          : "barbase",
        "type"          : Renderer.VerticalDataValueOption,
        "default"       : null
    },
    {
        "name"          : "fillcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "fillopacity",
        "type"          : Renderer.NumberOption,
        "default"       : 1.0
    },
    {
        "name"          : "linecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "hidelines",
        "type"          : Renderer.NumberOption,
        "default"       : 2
    }
]);

Renderer.BAR = new Renderer.Type("bar");

Renderer.addType({"type"  : Renderer.Type.parse("bar"),
                  "model" : BarRenderer});

module.exports = BarRenderer;

},{"../../../lib/jermaine/src/jermaine.js":9,"../../math/rgb_color.js":107,"../../util/utilityFunctions.js":159,"../data_measure.js":29,"../renderer.js":58}],62:[function(require,module,exports){
var jermaine = require('../../../lib/jermaine/src/jermaine.js');

// The Fill renderer is a 1-variable renderer which connects consecutive
// non-missing data points with line segments with a solid fill between
// the lines and the horizontal axis.
// 
// The line segements should occlude the solid fill.
// 
// This renderer accepts the following options:
// 
//     OPTION NAME:          linecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          Color used for line segments
// 
//     OPTION NAME:          linewidth
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Width, in pixels, of line segments.  A
//                           value of 0 means do not draw line segments.
// 
//     OPTION NAME:          fillcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x808080 (dark gray)
//     DESCRIPTION:          Color used for the fill area.
// 
//     OPTION NAME:          downfillcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        null
//     DESCRIPTION:          Color used for fill area that is below the
//                           fillbase, if a fillbase is specified. If no
//                           downfillcolor is specifed, fillcolor will
//                           be used for all fill areas.
// 
//     OPTION NAME:          fillopacity
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Opacity used for the fill area.
// 
//     OPTION NAME:          fillbase
//     DATA TYPE:            DataValue
//     DEFAULT VALUE:        null
//     DESCRIPTION:          The location along the plot's vertical axis
//                           of the horizontal line that defines the
//                           bottom (or top) of the filled region; if no
//                           fillbase is specified, the fill will extend
//                           down to the bottom of the plot area.
// 
var Renderer = require('../renderer.js'),
    RGBColor = require('../../math/rgb_color.js'),
    utilityFunctions = require('../../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer);

var FillRenderer = new jermaine.Model("FillRenderer", function () {
    this.isA(Renderer);
    this.hasA("numberOfVariables").which.defaultsTo(2);
});

FillRenderer.GRAY = parseInt("80", 16) / 255;

Renderer.declareOptions(FillRenderer, "FillRendererOptions", [
    {
        "name"          : "linecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "linewidth",
        "type"          : Renderer.NumberOption,
        "default"       : 1
    },
    {
        "name"          : "fillcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(FillRenderer.GRAY,FillRenderer.GRAY,FillRenderer.GRAY)
    },
    {
        "name"          : "downfillcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : null
    },
    {
        "name"          : "fillopacity",
        "type"          : Renderer.NumberOption,
        "default"       : 1.0
    },
    {
        "name"          : "fillbase",
        "type"          : Renderer.VerticalDataValueOption,
        "default"       : null
    }
]);

Renderer.FILL = new Renderer.Type("fill");

Renderer.addType({"type"  : Renderer.Type.parse("fill"),
                  "model" : FillRenderer});

module.exports = FillRenderer;

},{"../../../lib/jermaine/src/jermaine.js":9,"../../math/rgb_color.js":107,"../../util/utilityFunctions.js":159,"../renderer.js":58}],63:[function(require,module,exports){
var jermaine = require('../../../lib/jermaine/src/jermaine.js');

// The Pointline renderer is a 1-variable renderer which draws a shape
// at each non-missing data point, and connects consecutive
// non-missing data points with line segments.  The drawing of both
// the points, and the lines, is optional, so this renderer can be
// used to draw just points, just line segments, or both.
// 
// When both points and line segments are drawn, the points should
// be drawn on "top of" the line segments.
// 
// This renderer accepts the following options:
// 
//     OPTION NAME:          linewidth
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Width, in pixels, of line segments.  A
//                           value of 0 means do not draw line segments.
// 
//     OPTION NAME:          linecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          Color used for line segments
// 
//     OPTION NAME:          pointsize
//     DATA TYPE:            number
//     DEFAULT VALUE:        0
//     DESCRIPTION:          The radius of drawn points.  A value
//                           of 0 means do not draw points.
// 
//     OPTION NAME:          pointcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          Color used for drawing points
// 
//     OPTION NAME:          pointshape
//     DATA TYPE:            One of the constants PointlineRenderer.CIRCLE,
//                           PointlineRenderer.SQUARE, PointlineRenderer.TRIANGLE,
//                           PointlineRenderer.DIAMOND, PointlineRenderer.STAR,
//                           PointlineRenderer.PLUS, or PointlineRenderer.X.  These
//                           correspond to the strings "circle", "square", "triangle",
//                           "diamond", "star", "plus", and "x" in MUGL files.
//     DEFAULT VALUE:        PointlineRenderer.CIRCLE
//     DESCRIPTION:          The shape to use for drawing points.
// 
//     OPTION NAME:          linestroke
//     DATA TYPE:            One of the constants PointlineRenderer.SOLID,
//                           PointlineRenderer.DASHED.  These
//                           correspond to the strings "solid", "dashed" in MUGL files.
//     DEFAULT VALUE:        PointlineRenderer.SOLID
//     DESCRIPTION:          Whether to draw solid or dashed lines
// 
//     OPTION NAME:          pointopacity
//     DATA TYPE:            number
//     DEFAULT VALUE:        1.0
//     DESCRIPTION:          The opactiy of the drawn points, in the range 0-1.
//                           A value of 1 means completely opaque; a value of 0
//                           means completely invisible.
// 
//     OPTION NAME:          pointoutlinewidth
//     DATA TYPE:            number
//     DEFAULT VALUE:        0
//     DESCRIPTION:          The width, in pixels, of the outline to be drawn
//                           around each point.  A value of 0 means draw no
//                           outline.
// 
//     OPTION NAME:          pointoutlinecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          The color to use for the outline around each point.
//
var Renderer = require('../renderer.js'),
    RGBColor = require('../../math/rgb_color.js'),
    utilityFunctions = require('../../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer);

var PointlineRenderer = new jermaine.Model("PointlineRenderer", function () {
    this.isA(Renderer);
    this.hasA("numberOfVariables").which.defaultsTo(2);
    //
    //this.isBuiltWith(...)  NO NO NO!!!
    //
    // DO NOT CALL isBuiltWith for a renderer subclass; Renderer.declareOptions calls isBuiltWith(), and it
    // will break if you also call it here!!!
});


PointlineRenderer.CIRCLE   = "circle";
PointlineRenderer.SQUARE   = "square";
PointlineRenderer.TRIANGLE = "triangle";
PointlineRenderer.DIAMOND  = "diamond";
PointlineRenderer.STAR     = "star";
PointlineRenderer.PLUS     = "plus";
PointlineRenderer.X        = "x";

PointlineRenderer.shapes = [ 
    PointlineRenderer.CIRCLE,
    PointlineRenderer.SQUARE,
    PointlineRenderer.TRIANGLE,
    PointlineRenderer.DIAMOND,
    PointlineRenderer.STAR,
    PointlineRenderer.PLUS,
    PointlineRenderer.X
];

PointlineRenderer.isShape = function (shape) {
    var i;
    for (i=0; i<PointlineRenderer.shapes.length; ++i) {
        if (PointlineRenderer.shapes[i] === shape) { return true; }
    }
    return false;
};

PointlineRenderer.parseShape = function (string) {
    if (string.toLowerCase() === PointlineRenderer.CIRCLE)   { return PointlineRenderer.CIRCLE;   }
    if (string.toLowerCase() === PointlineRenderer.SQUARE)   { return PointlineRenderer.SQUARE;   }
    if (string.toLowerCase() === PointlineRenderer.TRIANGLE) { return PointlineRenderer.TRIANGLE; }
    if (string.toLowerCase() === PointlineRenderer.DIAMOND)  { return PointlineRenderer.DIAMOND;  }
    if (string.toLowerCase() === PointlineRenderer.STAR)     { return PointlineRenderer.STAR;     }
    if (string.toLowerCase() === PointlineRenderer.PLUS)     { return PointlineRenderer.PLUS;     }
    if (string.toLowerCase() === PointlineRenderer.X)        { return PointlineRenderer.X;        }
    throw new Error("unknown point shape: " + string);
};

/*
 * This function converts a "shape" enum object to a string.  In reality, the objects ARE
 * the strings, so we just return the object.
 */
PointlineRenderer.serializeShape = function (shape) {
    return shape;
};

PointlineRenderer.ShapeOption = new jermaine.Model("PointlineRenderer.ShapeOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.validatesWith(PointlineRenderer.isShape);
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return PointlineRenderer.serializeShape(this.value());
    });
    this.respondsTo("parseValue", function (string) {
        this.value( PointlineRenderer.parseShape(string) );
    });
    this.respondsTo("valueEq", function (value) {
        return (this.value()===value);
    });
});

///////////////////////////////////////////////////////////////////////

PointlineRenderer.SOLID   = "solid";
PointlineRenderer.DASHED  = "dashed";

PointlineRenderer.strokes = [ 
    PointlineRenderer.SOLID,
    PointlineRenderer.DASHED
];

PointlineRenderer.isStroke = function (stroke) {
    var i;
    for (i=0; i<PointlineRenderer.strokes.length; ++i) {
        if (PointlineRenderer.strokes[i] === stroke) { return true; }
    }
    return false;
};

PointlineRenderer.parseStroke = function (string) {
    if (string.toLowerCase() === PointlineRenderer.SOLID)   { return PointlineRenderer.SOLID;   }
    if (string.toLowerCase() === PointlineRenderer.DASHED)  { return PointlineRenderer.DASHED;   }
    throw new Error("unknown line stroke: " + string);
};

/*
 * This function converts a "stroke" enum object to a string.  In reality, the objects ARE
 * the strings, so we just return the object.
 */
PointlineRenderer.serializeStroke = function (stroke) {
    return stroke;
};

PointlineRenderer.StrokeOption = new jermaine.Model("PointlineRenderer.StrokeOption", function () {
    this.isA(Renderer.Option);
    this.hasA("value").which.validatesWith(PointlineRenderer.isStroke);
    this.isBuiltWith("value");
    this.respondsTo("serializeValue", function () {
        return PointlineRenderer.serializeStroke(this.value());
    });
    this.respondsTo("parseValue", function (string) {
        this.value( PointlineRenderer.parseStroke(string) );
    });
    this.respondsTo("valueEq", function (value) {
        return (this.value()===value);
    });
});

///////////////////////////////////////////////////////////////////////

Renderer.declareOptions(PointlineRenderer, "PointlineRendererOptions", [
    {
        "name"          : "linecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "linewidth",
        "type"          : Renderer.NumberOption,
        "default"       : 1
    },
    {
        "name"          : "pointshape",
        "type"          : PointlineRenderer.ShapeOption,
        "default"       : PointlineRenderer.CIRCLE
    },
    {
        "name"          : "linestroke",
        "type"          : PointlineRenderer.StrokeOption,
        "default"       : PointlineRenderer.SOLID
    },
    {
        "name"          : "pointsize",
        "type"          : Renderer.NumberOption,
        "default"       : 0
    },
    {
        "name"          : "pointcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "pointopacity",
        "type"          : Renderer.NumberOption,
        "default"       : 1.0
    },
    {
        "name"          : "pointoutlinewidth",
        "type"          : Renderer.NumberOption,
        "default"       : 0
    },
    {
        "name"          : "pointoutlinecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    }
]);

Renderer.POINTLINE = new Renderer.Type("pointline");
Renderer.POINT     = new Renderer.Type("point");
Renderer.LINE      = new Renderer.Type("line");

Renderer.addType({"type"  : Renderer.Type.parse("pointline"),
                  "model" : PointlineRenderer});
Renderer.addType({"type"  : Renderer.Type.parse("line"),
                  "model" : PointlineRenderer});
Renderer.addType({"type"  : Renderer.Type.parse("point"),
                  "model" : PointlineRenderer});

module.exports = PointlineRenderer;


},{"../../../lib/jermaine/src/jermaine.js":9,"../../math/rgb_color.js":107,"../../util/utilityFunctions.js":159,"../renderer.js":58}],64:[function(require,module,exports){
var jermaine = require('../../../lib/jermaine/src/jermaine.js');

// The RangeBar renderer is a 2-variable renderer which draws a
// vertical bar between two data values, and optionally outlines
// around the bars.  It is very similar to the Bar renderer except
// that the bar is drawn between two data values, instead of between a
// single data value and a base line.
// 
// The line segements should occlude the solid fill.
// 
// This renderer accepts the following options:
// 
//     OPTION NAME:          barwidth
//     DATA TYPE:            DataMeasure
//     DEFAULT VALUE:        ???
//     DESCRIPTION:          Width, in relative terms to the type of the
//                           axis the plot is on, of the bars.
//                           
//     OPTION NAME:          baroffset
//     DATA TYPE:            number
//     DEFAULT VALUE:        0
//     DESCRIPTION:          The offset of the left edge of each bar
//                           from the corresponding data value, as a
//                           fraction (0-1) of the barwidth.
// 
//     OPTION NAME:          fillcolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x808080 (dark gray)
//     DESCRIPTION:          Color used for filling the bars.
// 
//     OPTION NAME:          fillopacity
//     DATA TYPE:            number
//     DEFAULT VALUE:        1
//     DESCRIPTION:          Opacity used for the fill area.
// 
//     OPTION NAME:          linecolor
//     DATA TYPE:            RGBColor
//     DEFAULT VALUE:        0x000000 (black)
//     DESCRIPTION:          Color used for outlines around the bars.
// 
//     OPTION NAME:          linewidth
//     DATA TYPE:            number
//     DEFAULT VALUE:        0
//     DESCRIPTION:          Width, in pixels, of outlines around
//                           the bars.  A value of 0 (which is the
//                           default) means don't draw outlines.
// 
//     OPTION NAME:          hidelines
//     DATA TYPE:            number
//     DEFAULT VALUE:        2
//     DESCRIPTION:          Bars which are less wide, in pixels, than
//                           this number do not render their outlines.
// 
var Renderer = require('../renderer.js'),
    RGBColor = require('../../math/rgb_color.js'),
    DataMeasure = require('../data_measure.js'),
    utilityFunctions = require('../../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.plot.renderer);

var RangeBarRenderer = new jermaine.Model("RangeBarRenderer", function () {
    this.isA(Renderer);
    this.hasA("numberOfVariables").which.defaultsTo(3);
});

Renderer.declareOptions(RangeBarRenderer, "RangeBarRendererOptions", [
    {
        "name"          : "barwidth",
        "type"          : Renderer.HorizontalDataMeasureOption,
        "default"       : new DataMeasure.parse("number", 0)
    },
    {
        "name"          : "baroffset",
        "type"          : Renderer.NumberOption,
        "default"       : 0
    },
    {
        "name"          : "fillcolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : RGBColor.parse("0x808080")
    },
    {
        "name"          : "fillopacity",
        "type"          : Renderer.NumberOption,
        "default"       : 1.0
    },
    {
        "name"          : "linecolor",
        "type"          : Renderer.RGBColorOption,
        "default"       : new RGBColor(0,0,0)
    },
    {
        "name"          : "linewidth",
        "type"          : Renderer.NumberOption,
        "default"       : 1
    },
    {
        "name"          : "hidelines",
        "type"          : Renderer.NumberOption,
        "default"       : 2
    }
]);

Renderer.RANGEBAR = new Renderer.Type("rangebar");

Renderer.addType({"type"  : Renderer.Type.parse("rangebar"),
                  "model" : RangeBarRenderer});

module.exports = RangeBarRenderer;

},{"../../../lib/jermaine/src/jermaine.js":9,"../../math/rgb_color.js":107,"../../util/utilityFunctions.js":159,"../data_measure.js":29,"../renderer.js":58}],65:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/**
 * Text is a Jermaine model that supports storing and determining metrics of
 * strings in different graphics contexts.
 *
 * @class Text
 * @for Text
 * @constructor
 * @param string {String} The string stored in the Text model
 */
var Text = new jermaine.Model("Text", function () {
    this.isBuiltWith("string");

    /**
     * The string stored in the Text model
     *
     * @property string
     * @type {String}
     */
    this.hasA("string").which.isA("string");

    /**
     * The unrotated width of the string
     *
     * @property origWidth
     * @type {float}
     * @final
     */
    this.hasA("origWidth").which.isA("number");

    /**
     * The unrotated height of the string
     *
     * @property origHeight
     * @type {float}
     * @final
     */
    this.hasA("origHeight").which.isA("number");

    /**
     * The rotated width of the string
     *
     * @property rotatedWidth
     * @type {float}
     * @final
     */
    this.hasA("rotatedWidth").which.isA("number");

    /**
     * The rotated height of the string
     *
     * @property rotatedHeight
     * @type {float}
     * @final
     */
    this.hasA("rotatedHeight").which.isA("number");

    this.hasA("font").which.isA("string").and.which.defaultsTo("");

    /**
     * Determines unrotated and rotated widths and heights for the stored string. Overridden by
     * implementations in graphics drivers.
     *
     * @method initializeGeometry
     * @chainable
     * @param {Object} graphicsContext
     *   @param {Float} graphicsContext.angle
     */
    this.respondsTo("initializeGeometry", function (graphicsContext) {
        var origWidth,
            origHeight,
            rotatedWidth,
            rotatedHeight;

        origWidth  = this.measureStringWidth(graphicsContext);
        origHeight = this.measureStringHeight(graphicsContext);
        rotatedWidth = origWidth;
        rotatedHeight = origHeight;

        if (graphicsContext && graphicsContext.angle !== undefined) {
            var angle = graphicsContext.angle/180 * Math.PI;
            rotatedWidth = Math.abs(Math.cos(angle)) * origWidth + Math.abs(Math.sin(angle)) * origHeight;
            rotatedHeight = Math.abs(Math.sin(angle)) * origWidth + Math.abs(Math.cos(angle)) * origHeight;
        }

        this.origWidth(origWidth);
        this.origHeight(origHeight);
        this.rotatedWidth(rotatedWidth);
        this.rotatedHeight(rotatedHeight);

        return this;
    });

    /**
     * Determines unrotated width for the stored string. Overridden by implementations in graphics
     * drivers.
     *
     * @method measureStringWidth
     * @private
     * @return {Float} Unrotated width of string.
     * @param {Object} graphicsContext
     */
    this.respondsTo("measureStringWidth", function (graphicsContext) {
        // Graphics drivers should replace this method with an actual implementation; this
        // is just a placeholder.  The implementation should return the width, in pixels,
        // of the given string.  Of course this is dependent on font choice, size, etc,
        // but we gloss over that at the moment.  Just return the width of the string
        // using some reasonable default font for now.  Later on, we'll modify this
        // function to use font information.
        var lines,
            maxLength = 1,
            testLength,
            i;

        if (this.string() === undefined) {
            throw new Error("measureStringWidth requires the string attr to be set.");
        }

        lines = this.string().split(/\n/);
        for (i = 0; i < lines.length; i++) {
            testLength = lines[i].length;
            if (testLength > maxLength) {
                maxLength = testLength;
            }
        }
        
        return maxLength * 15;
    });

    /**
     * Determines unrotated height for the stored string. Overridden by implementations in graphics
     * drivers.
     *
     * @method measureStringHeight
     * @private
     * @return {Float} Unrotated height of string.
     * @param {Object} graphicsContext
     */
    this.respondsTo("measureStringHeight", function (graphicsContext) {
        // Graphics drivers should replace this method with an actual implementation; this
        // is just a placeholder.  The implementation should return the height, in pixels,
        // of the given string.  Of course this is dependent on font choice, size, etc,
        // but we gloss over that at the moment.  Just return the height of the string
        // using some reasonable default font for now.  Later on, we'll modify this
        // function to use font information.
        if (this.string() === undefined) {
            throw new Error("measureStringHeight requires the string attr to be set.");
        }
        var newlineCount = this.string().match(/\n/g);
        return (newlineCount !== null ? (newlineCount.length + 1) : 1) * 12;
    });
});

module.exports = Text;

},{"../../lib/jermaine/src/jermaine.js":9}],66:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Text = require('./text.js'),
    RGBColor = require('../math/rgb_color.js'),
    Point = require('../math/point.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.title);

/**
 * Title is a Jermiane model that controls Graph Titles.
 *
 * @class Title
 * @for Title
 * @constructor
 * @param {Text} text
 * @param {Graph} graph
 * @author jrfrimme
 */
var Title = new jermaine.Model("GraphTitle", function () {
    /**
     * Pointer to the Title's parent Graph Jermaine model.
     *
     * @property graph
     * @type {Graph}
     * @author jrfrimme
     */
    this.hasA("graph").which.validatesWith(function (graph) {
        var Graph = require('./graph.js');
        return graph instanceof Graph;
    });
    /**
     * The text of the title.
     *
     * @property text
     * @type {Text}
     * @author jrfrimme
     */
    this.hasA("text").which.validatesWith(function (text) {
        return text instanceof Text;
    });
    /**
     * Determines if the Title is positioned relative to the Graphs `plot` or `padding`
     * box.
     *
     * @property frame
     * @type {String}
     * @author jrfrimme
     */
    this.hasA("frame").which.isA("string");
    /**
     * The width of the border to be drawn around the title in pixel; use a value of `0`
     * to not draw a border.
     *
     * @property border
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("border").which.isAn("integer");
    /**
     * Background color for the Title's region.
     *
     * @property color
     * @type {RGBColor}
     * @author jrfrimme
     */
    this.hasA("color").which.validatesWith(function (color) {
        return color instanceof RGBColor;
    });
    /**
     * Color for the Title's border.
     *
     * @property bordercolor
     * @type {RGBColor}
     * @author jrfrimme
     */
    this.hasA("bordercolor").which.validatesWith(function (bordercolor) {
        return bordercolor instanceof RGBColor;
    });
    /**
     * Opacity of the Title's region.
     *
     * @property opacity
     * @type {Number}
     * @author jrfrimme
     */
    this.hasA("opacity").which.isA("number");
    /**
     * The width of the padding between the Title's text and its border in pixels; use a
     * value of `0` to not draw the padding.
     *
     * @property padding
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("padding").which.isAn("integer");
    /**
     * Determines whether the corners of the title appear rounded. If cornerradius is 0,
     * which is the default, the corners are drawn square. If cornerradius > 0, then the
     * corners are rounded off using circles whose radius is cornerradius pixels.
     *
     * @property cornerradius
     * @deprecated
     * @type {Integer}
     * @author jrfrimme
     */
    this.hasA("cornerradius").which.isAn("integer");
    /**
     * A coordinate pair which gives the relative location of the Title's anchor point.
     *
     * @property anchor
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("anchor").which.validatesWith(function (anchor) {
        return anchor instanceof Point;
    });
    /**
     * A coordinate pair which gives the location of the Title's base point, relative to
     * its Graph's plot or padding box - determined by the `frame` attribute.
     *
     * @property base
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("base").which.validatesWith(function (base) {
        return base instanceof Point;
    });
    /**
     * A coordinate pair of pixel offsets for the base point.
     *
     * @property position
     * @type {Point}
     * @author jrfrimme
     */
    this.hasA("position").which.validatesWith(function (position) {
        return position instanceof Point;
    });
    /**
     * The font-size of the title. Currently is a constant.
     *
     * @property font-size
     * @type {String}
     * @author jrfrimme
     */
    this.hasA("fontSize").which.isA("string").and.defaultsTo("18px");

    /**
     * Determines the geometry of the Title's text.
     *
     * @method initializeGeometry
     * @chainable
     * @param {Object} graphicsContext
     * @author jrfrimme
     */
    this.respondsTo("initializeGeometry", function (graphicsContext) {
        graphicsContext.fontSize = this.fontSize();
        this.text().initializeGeometry(graphicsContext);
        return this;
    });

    /**
     * Renders the Graph Title. Overridden by implementations in graphics drivers.
     *
     * @method render
     * @private
     * @author jrfrimme
     */
    this.respondsTo("render", function () {});

    this.isBuiltWith("text", "graph");

    utilityFunctions.insertDefaults(this, defaultValues.title, attributes);

});

module.exports = Title;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/point.js":106,"../math/rgb_color.js":107,"../util/utilityFunctions.js":159,"./graph.js":42,"./text.js":65}],67:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Warning = function(message) {
    this.message = message;
};

Warning.prototype = new Error();

module.exports  = Warning;

},{"../../lib/jermaine/src/jermaine.js":9}],68:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
var WebServiceData;
module.exports = function($) {
    if (typeof(WebServiceData) !== "undefined") { return WebServiceData; }

    var jermaine = require('../../lib/jermaine/src/jermaine.js');

    var Data = require('./data.js'),
        DataValue = require('./data_value.js'),
        DataFormatter = require('./data_formatter.js'),
        ArrayData = require('./array_data.js'),
        WebServiceDataCacheNode = require('./web_service_data_cache_node.js'),
        WebServiceDataIterator = require('./web_service_data_iterator.js');

    WebServiceData = new jermaine.Model(function () {
        this.isA(Data);
        this.hasA("serviceaddress").which.isA("string");
        this.hasA("serviceaddresspattern").which.isA("string");
        this.hasA("format").which.isA("string");
        this.hasA("formatter").which.validatesWith(DataFormatter.isInstance);
        this.hasA("messageHandler");
        this.hasA("ajaxthrottle");
        this.isBuiltWith("columns", "serviceaddress", "%messageHandler", "%ajaxthrottle", function () {
            this.init();
            if (this.columns().size() > 0) {
                var column0Type = this.columns().at(0).type();
                if (this.format() === undefined) {
                    this.format(column0Type===DataValue.NUMBER ? "%f" : "%Y%M%D%H%i%s");
                }
                this.formatter(DataFormatter.create(column0Type, this.format()));
            }
            if (this.ajaxthrottle() === undefined) {
                this.ajaxthrottle($);
            }
        });

        this.respondsTo("_displayError", function (e) {
            if (this.messageHandler()) {
                this.messageHandler().error(e);
            } else {
                throw e;
            }
        });

        this.respondsTo("getBounds", function (columnNumber) {
            // TODO: replace this kludge
            return [0, 10];
        });

        this.hasA("arraydata").which.defaultsTo(null).and.validatesWith(function (arraydata) {
            return arraydata instanceof ArrayData || arraydata === null;
        });

        /**
         * A pointer to the head WebServiceDataCacheNode in this WebServieData's cache.
         *
         * @property cacheHead
         * @type {null|WebServiceDataCacheNode}
         * @author jrfrimme
         */
        this.hasA("cacheHead").which.defaultsTo(null).and.validatesWith(function (x) {
            return x === null || x instanceof WebServiceDataCacheNode;
        });

        /**
         * A pointer to the tail WebServiceDataCacheNode in this WebServieData's cache.
         *
         * @property cacheTail
         * @type {null|WebServiceDataCacheNode}
         * @author jrfrimme
         */
        this.hasA("cacheTail").which.defaultsTo(null).and.validatesWith(function (x) {
            return x === null || x instanceof WebServiceDataCacheNode;
        });

        /**
         * Return a pointer to the first WebServiceDataCacheNode in this WebServieData's cache
         * that actually contains data, if any.  If the cache doesn't contain any data, return null.
         *
         * @method dataHead
         * @author jrfrimme
         * @return {null|WebServiceDataCacheNode}
         */
        this.respondsTo("dataHead", function () {
            var head = this.cacheHead();
            if (head === null) { return null; }
            if (head.hasData()) { return head; }
            return head.dataNext();
        });

        /**
         * Return a pointer to the last WebServiceDataCacheNode in this WebServieData's cache
         * that actually contains data, if any.  If the cache doesn't contain any data, return null.
         *
         * @method dataTail
         * @author jrfrimme
         * @return {null|WebServiceDataCacheNode}
         */
        this.respondsTo("dataTail", function () {
            var tail = this.cacheTail();
            if (tail === null) { return null; }
            if (tail.hasData()) { return tail; }
            return tail.dataPrev();
        });

        /**
         * Insert a WebServiceCacheNode into this WebService's cache.
         * If this node's coveredMin is less than the cache head's
         * coveredMin, insert it at the head; otherwise insert it at
         * the tail.  Note that nodes are only inserted either at the
         * head or at the tail of the cache --- not in the middle.
         *
         * @method insertCacheNode
         * @param {WebServiceCacheNode} node
         * @author jrfrimme
         */
        this.respondsTo("insertCacheNode", function (node) {
            var head = this.cacheHead(),
                tail = this.cacheTail();
            if (head === null) {
                this.cacheHead(node);
                this.cacheTail(node);
            } else {
                if (node.coveredMin().lt(head.coveredMin())) {
                    node.next(head);
                    head.prev(node);
                    this.cacheHead(node);
                } else {
                    node.prev(tail);
                    tail.next(node);
                    this.cacheTail(node);
                }
            }
        });

        this.respondsTo("constructRequestURL", function (min, max) {
            var serviceaddress = this.serviceaddress(),
                formatter = this.formatter();

            if (serviceaddress === undefined) {
                throw new Error("WebServiceData.constructRequestURL: undefined service address");
            }
            if (formatter === undefined) {
                throw new Error("WebServiceData.constructRequestURL: undefined formatter for column 0");
            }
            if (this.serviceaddresspattern() === undefined) {
                if ((serviceaddress.indexOf("$min") < 0) &&
                    (serviceaddress.indexOf("$max") < 0)) {
                    this.serviceaddresspattern(serviceaddress + "$min,$max");
                } else {
                    this.serviceaddresspattern(serviceaddress);
                }
            }
            return (this.serviceaddresspattern()
                    .replace("$min", formatter.format(min))
                    .replace("$max", formatter.format(max)));
        });

        this.hasA("coveredMin").which.defaultsTo(null).and.validatesWith(function (x) {
            return x === null || DataValue.isInstance(x);
        });
        this.hasA("coveredMax").which.defaultsTo(null).and.validatesWith(function (x) {
            return x === null || DataValue.isInstance(x);
        });

        /**
         * Initiate requests needed to fetch data between coveredMin and coveredMax, if any.
         *
         * @method insureCoveredRange
         * @author jrfrimme
         */
        this.respondsTo("insureCoveredRange", function () {
            var head = this.cacheHead(),
                tail = this.cacheTail(),
                coveredMin = this.coveredMin(),
                coveredMax = this.coveredMax();

            if (coveredMin === null || coveredMax === null) {
                return;
            }
            if (head === null || tail === null) {
                this.requestSingleRange(coveredMin, coveredMax);
            } else {
                if (coveredMin.lt(head.coveredMin())) {
                    //                     head's min              tail's max
                    //  -----|-------------|-----------------------|----------------
                    //       coveredMin
                    this.requestSingleRange(coveredMin, head.coveredMin());
                }
                if (coveredMax.gt(tail.coveredMax())) {
                    //                     head's min              tail's max
                    //  -------------------|-----------------------|-----------|----
                    //                                                         coveredMax
                    this.requestSingleRange(tail.coveredMax(), coveredMax);
                }
            }
        });

        this.respondsTo("requestSingleRange", function (min, max) {
            var node,
                requestURL,
                that = this,
                JQueryXMLParser = require('../parser/xml/jquery_xml_parser.js')($);

            // create the cache node that will hold the data in this range
            node = new WebServiceDataCacheNode(min, max);

            // insert it into the cache linked list
            this.insertCacheNode(node);

            // construct the URL for fetching the data in this range
            requestURL = this.constructRequestURL(min, max);

            // initiate the fetch request
            this.emit({type : 'ajaxEvent', action : 'start'});
            this.ajaxthrottle().ajax({
                url      : requestURL,
                dataType : "text",
                success  : function (data, textStatus, jqXHR) {
                    // if data contains a <values> tag, extract its text string value
                    if (data.indexOf("<values>") > 0) {
                        data = JQueryXMLParser.stringToJQueryXMLObj(data).find("values").text();
                    }
                    node.parseData(that.getColumns(), data);

                    that.emit({type : 'ajaxEvent', action : 'success'});
                    that.emit({type : 'dataReady'});
                },

                error : function (jqXHR, textStatus, errorThrown) {
                    var message = errorThrown;
                    if (jqXHR.statusCode().status === 404) {
                        message = "URL not found: '" + requestURL + '"';
                    } else {
                        if (textStatus) {
                            message = textStatus + ": " + message;
                        }
                    }
                    that._displayError(new Error(message));
                },

                // 'complete' callback gets called after either 'success' or 'error', whichever:
                complete : function (jqXHR, textStatus) {
                    that.emit({type : 'ajaxEvent', action : 'complete'});
                }

            });
        });

        this.respondsTo("getIterator", function (columnIds, min, max, buffer) {
            var initialNode,
                initialIndex,
                n, b, i, tmp,
                finalNode,
                finalIndex,
                columnIndices;

            // if min > max, swap them
            if (min.gt(max)) {
                tmp = min;
                min = max;
                max = tmp;
            }

            if (this.coveredMin() === null || min.lt(this.coveredMin())) {
                this.coveredMin(min.clone());
            }
            if (this.coveredMax() === null || max.gt(this.coveredMax())) {
                this.coveredMax(max.clone());
            }

            if (!this.paused()) {
                this.insureCoveredRange();
            }

            if (this.dataHead() === null) {
                // cache is empty, return empty iterator:
                return {
                    "next"    : function () {},
                    "hasNext" : function () { return false; }
                };
            }
            // convert columnIds to columnIndices
            columnIndices = [];
            for (i = 0; i < columnIds.length; ++i) {
                columnIndices.push( this.columnIdToColumnNumber(columnIds[i]) );
            }

            // find the data node containing the 'min' value
            initialNode = this.dataHead();
            while ((initialNode !== null) &&
                   (initialNode.dataNext() !== null) &&
                   (min.gt(initialNode.dataMax()))) {
                initialNode = initialNode.dataNext();
            }
            
            if (initialNode === null || !initialNode.hasData()) {
                initialIndex = -1;
            } else {
                initialIndex = 0;
                // find the index within the initial node corresponding to the 'min' value
                while ((initialIndex < initialNode.data().length-1) &&
                       (initialNode.data()[initialIndex][columnIndices[0]].lt(min))) {
                    ++initialIndex;
                }
                
                // back up 'buffer' steps, being careful not to go further back than the first element of the head node
                n = 0;
                while (n<buffer) {
                    --initialIndex;
                    if (initialIndex<0) {
                        b = initialNode.dataPrev();
                        if (b !== null) {
                            initialNode = b;
                            initialIndex = initialNode.data().length-1;
                        } else {
                            initialIndex = 0;
                            break;
                        }
                    }
                    ++n;
                }
                
                // find the data node containing the 'max' value
                finalNode = initialNode;
                while ( (max.gt(finalNode.dataMax())) &&
                        (finalNode.dataNext() !== null) ) {
                    finalNode = finalNode.dataNext();
                }
                
                // find the index within the final node corresponding to the 'max' value
                finalIndex = 0;
                if (finalNode === initialNode) {
                    finalIndex = initialIndex;
                }
                while ((finalIndex < finalNode.data().length-1) &&
                       (finalNode.data()[finalIndex][columnIndices[0]].lt(max))) {
                    ++finalIndex;
                }
                
                // go forward 'buffer' more steps, being careful not to go further than the last element of the tail
                n = 0;
                //while (n<buffer && !(finalNode===_tail && finalIndex<finalNode.data.length)) {
                while (n < buffer) {
                    ++finalIndex;
                    if (finalIndex >= finalNode.data().length) {
                        b = finalNode.dataNext();
                        if (b !== null) {
                            finalNode = b;
                            finalIndex = 0;
                        } else {
                            finalIndex = finalNode.data().length-1;
                            break;
                        }
                    }
                    ++n;
                }
                
            }
            
            return new WebServiceDataIterator(columnIndices, initialNode, initialIndex, finalNode, finalIndex);
        });

        this.hasA("paused").which.isA("boolean").and.defaultsTo(false);
        this.respondsTo("pause", function() {
            this.paused(true);
        });
        this.respondsTo("resume", function() {
            this.paused(false);
            this.emit({type : 'dataReady',
                       min : this.coveredMin(),
                       max : this.coveredMax()});
        });

    });

    return WebServiceData;
};

},{"../../lib/jermaine/src/jermaine.js":9,"../parser/xml/jquery_xml_parser.js":146,"./array_data.js":18,"./data.js":27,"./data_formatter.js":28,"./data_value.js":31,"./web_service_data_cache_node.js":69,"./web_service_data_iterator.js":70}],69:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/**
 * A WebServiceDataCacheNode represents a single node in the
 * doubly-linked list holding the data for a WebServiceDataCache.
 * The WebServiceDataCacheNode has an array of data (which may
 * actually be null, if the node's data has not yet been loaded),
 * next and prev pointers to the next and previous nodes in the
 * linked list, and coveredMin and coveredMax values that indicate
 * the min and max values of the "covered" range of data for this
 * node.
 * 
 * The "covered" range is the interval of the data number line for
 * which this node is responsible for storing data; Multigraph
 * uses range this to avoid requesting the same data twice --- it
 * never requests data for a range already covered by an existing
 * cache node.
 * 
 * Initially, when the WebServiceDataCacheNode is created, the
 * limits of the covered range are specified in the constructor.
 * Later on, when the node's data is actually populated, the
 * limits are potentially adjusted outward, if the range of data
 * received is larger than the initially specified covered range.
 * So in all cases, the covered range indicates the range for
 * which no more data is needed, because it's covered by this
 * node.
 * 
 * Note that the covered range is never adjusted to be smaller.
 * 
 * The WebServiceDataCacheNode does not actually fetch any data
 * --- it is simply a storage container for fetched data; it's up
 * to other code outside of this object to fetch and populate the
 * data.
 *
 * @class WebServiceDataCacheNode
 * @for WebServiceDataCacheNode
 * @constructor
 * @param {DataValue} coveredMin
 * @param {DataValue} coveredMax
 */
var DataValue = require('./data_value.js'),
    ArrayData = require('./array_data.js');

var WebServiceDataCacheNode = new jermaine.Model(function () {

    /**
     * The actual data for this node.
     *
     * @property data
     * @type {Array|null}
     * @author jrfrimme
     */
    this.hasA("data").which.defaultsTo(null).and.validatesWith(function (data) {
        var validationFunctions = require('../util/validationFunctions.js');
        // accept null
        if (data === null) { return true; }
        // only accept arrays
        if (validationFunctions.typeOf(data) !== "array") {
            this.message = "WebServiceDataCacheNode's data attribute is not an Array";
            return false;
        }
        // if the array contains anything, do a cursory check that it looks
        // like an array of DataValue arrays (just check the first row)
        if (data.length > 0) {
            var firstRow = data[0],
                i;
            if (validationFunctions.typeOf(firstRow) !== "array") {
                this.message = "WebServiceDataCacheNode's data attribute is not an Array of Arrays";
                return false;
            }
            for (i = 0; i < firstRow.length; ++i) {
                if (!DataValue.isInstance(firstRow[i])) {
                    this.message = "WebServiceDataCacheNode's data attribute is not an Array of Arrays of DataValues (bad value in position " + i + " of first row";
                    return false;
                }
            }
        }
        return true;
    });

    /**
     * The next node in the cache's linked list
     *
     * @property next
     * @type {WebServiceDataCacheNode|null}
     * @author jrfrimme
     */
    this.hasA("next").which.defaultsTo(null).and.validatesWith(function (x) {
        return x === null || x instanceof WebServiceDataCacheNode;
    });

    /**
     * The previous node in the cache's linked list
     *
     * @property prev
     * @type {WebServiceDataCacheNode|null}
     * @author jrfrimme
     */
    this.hasA("prev").which.defaultsTo(null).and.validatesWith(function (x) {
        return x === null || x instanceof WebServiceDataCacheNode;
    });

    /**
     * The min of the covered value range
     *
     * @property coveredMin
     * @type {DataValue}
     * @author jrfrimme
     */
    this.hasA("coveredMin").which.validatesWith(DataValue.isInstance);

    /**
     * The max of the covered value range
     *
     * @property coveredMax
     * @type {DataValue}
     * @author jrfrimme
     */
    this.hasA("coveredMax").which.validatesWith(DataValue.isInstance);

    /**
     * Return the next node in the cache that actually has data,
     * or null if none exists.
     *
     * @method dataNext
     * @author jrfrimme
     * @return {WebServiceDataCacheNode|null}
     */
    this.respondsTo("dataNext", function () {
        var node = this.next();
        while (node !== null && !node.hasData()) {
            node = node.next();
        }
        return node;
    });

    /**
     * Return the previous node in the cache that actually has data,
     * or null if none exists.
     *
     * @method dataPrev
     * @author jrfrimme
     * @return {WebServiceDataCacheNode|null}
     */
    this.respondsTo("dataPrev", function () {
        var node = this.prev();
        while (node !== null && !node.hasData()) {
            node = node.prev();
        }
        return node;
    });

    /**
     * Return the minimum (column 0) data value for this node.  Returns null
     * if the node has no data yet.
     *
     * @method dataMin
     * @author jrfrimme
     * @return {DataValue|null}
     */
    this.respondsTo("dataMin", function () {
        var data = this.data();
        if (data === null) { return null; }
        if (data.length === 0) { return null; }
        if (data[0] === null) { return null; }
        if (data[0].length === 0) { return null; }
        return data[0][0];
    });

    /**
     * Return the maximum (column 0) data value for this node.    Returns null
     * if the node has no data yet.
     *
     * @method dataMax
     * @author jrfrimme
     * @return {DataValue|null}
     */
    this.respondsTo("dataMax", function() {
        var data = this.data();
        if (data === null) { return null; }
        if (data.length === 0) { return null; }
        if (data[data.length-1] === null) { return null; }
        if (data[data.length-1].length === 0) { return null; }
        return data[data.length-1][0];
    });

    /**
     * Return true if this node has data; false if not.
     *
     * @method hasData
     * @author jrfrimme
     * @return Boolean
     */
    this.respondsTo("hasData", function() {
        return this.data() !== null;
    });

    this.isBuiltWith("coveredMin", "coveredMax");

    /**
     * Populate this node's data array by parsing the values
     * contained in the 'dataText' string, which should be a
     * string of comma-separated values of the same sort expected
     * by ArrayData and CSVData.  The first argument, `columns`,
     * should be a plain javascript array of DataVariable instances,
     * of the sort returned by `Data.getColumns()`.
     * 
     * This method examines other nodes in the cache in order
     * insure that values included in this node's data array
     * are (a) strictly greater than the maximum value present in the
     * cache prior to this node, and (b) strictly less than the
     * minimum value present in the cache after this node.
     * This guarantees that there is no overlap between the
     * data in this node and other nodes in the cache.
     *
     * @method parseData
     * @param {DataVariable Attr_List} columns
     * @param {String} dataText
     * @author jrfrimme
     */
    this.respondsTo("parseData", function (columns, dataText) {
        var i, b,
            maxPrevValue = null,
            minNextValue = null,
            arrayDataArray,
            data,
            row;

        // set maxPrevValue to the max value in column0 in the cache prior to this block, if any:
        b = this.dataPrev();
        if (b !== null) {
            maxPrevValue = b.dataMax();
        }

        // set minNextValue to the min value in column0 in the cache after this block, if any:
        b = this.dataNext();
        if (b !== null) {
            minNextValue = b.dataMin();
        }

        // convert the csv dataText string to an array
        arrayDataArray = ArrayData.textToDataValuesArray(columns, dataText);

        // populate the data array by copying values from the converted array, skipping any
        // values that are already within the range covered by the rest of the cache
        data = [];
        for (i = 0; i < arrayDataArray.length; ++i) {
            row = arrayDataArray[i];
            if ((maxPrevValue === null || row[0].gt(maxPrevValue)) &&
                (minNextValue === null || row[0].lt(minNextValue))) {
                data.push( row );
            }
        }

        // if we didn't get any new values, we're done
        if (data.length === 0) {
            return;
        }
        
        // lower the coveredMin value if the actual data received is lower than the current coveredMin value
        if (data[0][0].lt(this.coveredMin())) {
            this.coveredMin(data[0][0]);
        }

        // raise the coveredMax value if the actual data received is higher than the current coveredMax value
        if (data[data.length-1][0].gt(this.coveredMax())) {
            this.coveredMax(data[data.length-1][0]);
        }

        // load the data
        this.data( data );
    });
});

module.exports = WebServiceDataCacheNode;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/validationFunctions.js":160,"./array_data.js":18,"./data_value.js":31}],70:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

/**
 * An iterator for stepping through data values stored in a linked list of
 * WebServiceDataCacheNodes.  The constructor takes 5 arguments:
 * 
 * @class WebServiceDataIterator
 * @for WebServiceDataIterator
 * @constructor
 *
 * @param {Array} columnIndices
 *     JavaScript array of the indices of the columns
 *     of data to return
 * @param {WebServiceDataCacheNode} initialNode
 *     Pointer to the WebServiceDataCacheNode containing the first
 *     value to iterate over
 * @param {integer} initialIndex
 *     Index, within initialNode, of the first value to iterate over
 * @param {WebServiceDataCacheNode} finalNode
 *     Pointer to the WebServiceDataCacheNode containing the last
 *     value to iterate over
 * @param {integer} finalIndex
 *     Index, within finalNode, of the last value to iterate over
 */
var WebServiceDataCacheNode = require('./web_service_data_cache_node.js'),
    ValidationFunctions = require('../util/validationFunctions.js');

var WebServiceDataIterator = new jermaine.Model(function () {
    var WebServiceDataIterator = this;

    this.hasA("currentNode").which.validatesWith(function(x) {
        return x instanceof WebServiceDataCacheNode;
    });
    this.hasA("currentIndex").which.isA("integer");
    this.hasA("columnIndices").which.validatesWith(function(x) {
        return ValidationFunctions.typeOf(x) === "array";
    });
    
    this.hasA("initialNode").which.validatesWith(function(x) {
        return x instanceof WebServiceDataCacheNode;
    });
    this.hasA("finalNode").which.validatesWith(function(x) {
        return x instanceof WebServiceDataCacheNode;
    });
    this.hasA("initialIndex").which.isA("integer");
    this.hasA("finalIndex").which.isA("integer");

    this.isBuiltWith("columnIndices", "initialNode", "initialIndex", "finalNode", "finalIndex", function() {
        this.currentNode(this.initialNode());
        this.currentIndex(this.initialIndex());
    });

    this.respondsTo("hasNext", function() {
        if (this.currentNode() === null || this.currentIndex() < 0) { return false; }
        if (this.currentNode() !== this.finalNode()) {
            return true;
        }
        return this.currentIndex() <= this.finalIndex();
    });

    this.respondsTo("next", function() {
        var vals = [],
            columnIndices = this.columnIndices(),
            currentIndex = this.currentIndex(),
            finalIndex = this.finalIndex(),
            currentNode = this.currentNode(),
            i;

        if (currentNode === this.finalNode()) {
            if (currentIndex > finalIndex) { return null; }
            for (i=0; i<columnIndices.length; ++i) {
                vals.push(currentNode.data()[currentIndex][columnIndices[i]]);
            }
            this.currentIndex(++currentIndex);
            return vals;
        } else {
            for (i=0; i<columnIndices.length; ++i) {
                vals.push(currentNode.data()[currentIndex][columnIndices[i]]);
            }
            this.currentIndex(++currentIndex);
            if (currentIndex >= currentNode.data().length) {
                this.currentNode(currentNode.dataNext());
                this.currentIndex(0);
            }
            return vals;
        }
    });

});

module.exports = WebServiceDataIterator;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/validationFunctions.js":160,"./web_service_data_cache_node.js":69}],71:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Insets = require('../math/insets.js'),
    RGBColor = require('../math/rgb_color.js'),
    utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.window);

var Window = new jermaine.Model("Window", function () {

    this.hasA("width").which.isA("integer");

    this.hasA("height").which.isA("integer");

    this.hasA("border").which.isA("integer");

    this.hasA("margin").which.validatesWith(function (margin) {
        return margin instanceof Insets;
    });

    this.hasA("padding").which.validatesWith(function (padding) {
        return padding instanceof Insets;
    });

    this.hasA("bordercolor").which.validatesWith(function (bordercolor) {
        return bordercolor instanceof RGBColor;
    });

    utilityFunctions.insertDefaults(this, defaultValues.window, attributes);
});

module.exports = Window;

},{"../../lib/jermaine/src/jermaine.js":9,"../math/insets.js":105,"../math/rgb_color.js":107,"../util/utilityFunctions.js":159}],72:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var DataMeasure = require('./data_measure.js'),
    DataValue = require('./data_value.js');

var utilityFunctions = require('../util/utilityFunctions.js'),
    defaultValues = utilityFunctions.getDefaultValuesFromXSD(),
    attributes = utilityFunctions.getKeys(defaultValues.horizontalaxis.zoom);

var Zoom = new jermaine.Model("Zoom", function () {

    this.hasA("allowed").which.isA("boolean");
    this.hasA("min").which.validatesWith(function (min) {
        return DataMeasure.isInstance(min);
    });
    this.hasA("max").which.validatesWith(function (max) {
        return DataMeasure.isInstance(max);
    });
    this.hasA("anchor").which.validatesWith(function (anchor) {
        return DataValue.isInstance(anchor) || anchor === null;
    });

    utilityFunctions.insertDefaults(this, defaultValues.horizontalaxis.zoom, attributes);
});

module.exports = Zoom;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/utilityFunctions.js":159,"./data_measure.js":29,"./data_value.js":31}],73:[function(require,module,exports){
var _INCLUDED = false;

module.exports = function($, window, errorHandler) {
    if (!_INCLUDED) {
        require('./draggable/graph.js')($, window, errorHandler);
        require('./touch/graph.js')($, window, errorHandler);
        require('./touch/multigraph.js')($, window, errorHandler);
        require('./mouse/graph.js')($, window, errorHandler);
        require('./mouse/multigraph.js')($, window, errorHandler);
        require('./multigraph.js')($, window, errorHandler);
        require('./resize/multigraph.js')($, window, errorHandler);
        _INCLUDED = true;
    }
};

},{"./draggable/graph.js":74,"./mouse/graph.js":75,"./mouse/multigraph.js":76,"./multigraph.js":77,"./resize/multigraph.js":78,"./touch/graph.js":79,"./touch/multigraph.js":80}],74:[function(require,module,exports){
module.exports = function($, window, errorHandler) {
    var Graph = require('../../core/graph.js'),
        Axis = require('../../core/axis.js');

    if (typeof(Graph.dragStarted)==="function") { return Graph; }

    Graph.hasA("dragStarted").which.isA("boolean");
    Graph.hasA("dragOrientation").which.validatesWith(Axis.Orientation.isInstance);
    Graph.hasA("dragAxis").which.validatesWith(function (a) {
        return a instanceof Axis;
    });

    Graph.respondsTo("doDragReset", function () {
        this.dragStarted(false);
        this.pauseAllData();
    });

    Graph.respondsTo("doDragDone", function () {
        this.resumeAllData();
    });

    Graph.respondsTo("doDrag", function (multigraph, bx, by, dx, dy, shiftKey) {
        var dragAxis        = this.dragAxis,
            dragOrientation = this.dragOrientation,
            HORIZONTAL = Axis.HORIZONTAL,
            VERTICAL   = Axis.VERTICAL;
        // TODO: this try...catch is just to remind myself how to apply, make sure this is correct later
        try {
            if (!this.dragStarted()) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    dragOrientation(HORIZONTAL);
                } else {
                    dragOrientation(VERTICAL);
                }
                dragAxis(this.findNearestAxis(bx, by, dragOrientation()));
                if (dragAxis() === null) {
                    dragOrientation( (dragOrientation() === HORIZONTAL) ? VERTICAL : HORIZONTAL );
                    dragAxis( this.findNearestAxis(bx, by, dragOrientation()) );
                }
                this.dragStarted(true);
            }

            // do the action
            if (shiftKey) {
                if (dragOrientation() === HORIZONTAL) {
                    dragAxis().doZoom(bx, dx);
                } else {
                    dragAxis().doZoom(by, dy);
                }
            } else {
                if (dragOrientation() === HORIZONTAL) {
                    dragAxis().doPan(bx, dx);
                } else {
                    dragAxis().doPan(by, dy);
                }
            }

            // draw everything
            multigraph.redraw();
        } catch (e) {
            errorHandler(e);
        }
    });

    return Graph;
};

},{"../../core/axis.js":19,"../../core/graph.js":42}],75:[function(require,module,exports){
module.exports = function($, window, errorHandler) {
    var Graph = require('../../core/graph.js'),
        ConstantPlot = require('../../core/constant_plot.js'),
        Axis = require('../../core/axis.js');

    if (typeof(Graph.mouseWheelTimer)==="function") { return Graph; }

    Graph.hasA("mouseWheelTimer").which.defaultsTo(null);

    Graph.respondsTo("doWheelZoom", function (multigraph, x, y, delta) {
        var that = this;
        try {
            this.pauseAllData();
            var axis = this.findNearestAxis(x, y);
            if (axis.orientation() === Axis.HORIZONTAL) {
                axis.doZoom(x, 4*delta);
            } else {
                axis.doZoom(y, 4*delta);
            }
            multigraph.redraw();

            // resume data fetching after .5 seconds of no mouse wheel motion:
            var mouseWheelTimer = this.mouseWheelTimer;
            if (mouseWheelTimer() !== null) {
                window.clearTimeout(mouseWheelTimer());
                mouseWheelTimer(null);
            }
            mouseWheelTimer(window.setTimeout(function () {
                that.resumeAllData();
            }, 500)); 
        } catch (e) {
            errorHandler(e);
        }
    });


    Graph.hasA("existingDatatips").which.defaultsTo(function () { return []; });
    Graph.respondsTo("handleDatatips", function (loc, width, height, $target, div) {
        var existingDatatips = this.existingDatatips(),
            plots            = this.plots(),
            plot,
            datatipsData,
            datatipIndex,
            i;

        var temp = $("<span></span>")
                .css({
                    "display"          : "hidden",
                    "margin"           : "0px",
                    "padding-left"     : "5px",
                    "padding-right"    : "5px",
                    "padding-top"      : "1px",
                    "padding-bottom"   : "1px"
                })
                .appendTo(div);

        // find first available bit of data
        for (i = 0; i < plots.size(); i++) {
            plot = plots.at(i);
            if (plot instanceof ConstantPlot) {
                continue;
            }
            datatipsData = plot.getDatatipsData(loc, width, height, this, temp);
            if (datatipsData !== undefined) {
                datatipIndex = i;
                break;
            }
        }

        temp.remove();

        // don't do anything if there is no data
        if (datatipsData === undefined) {
            this.removeDatatips();
            return;
        }

        // flag all datatips for removal
        for (i = 0; i < existingDatatips.length; i++) {
            existingDatatips[i].flag = true;
        }

        // remove flags from datatips that don't need to be redrawn
        checkDatatipExistence(datatipsData, existingDatatips);

        this.removeFlaggedDatatips();

        // don't do anything if datatip already exists
        if (datatipsData.flag === false) {
            return;
        }

        var arrowLength = 10;
        datatipsData.arrow = arrowLength;

        var datatip = plots.at(datatipIndex).createDatatip(datatipsData);

        datatip.appendTo(div);

        datatip.mousedown(function (event) {
            $target.trigger("mousedown", event);
        });

        datatipsData.elem = datatip;
        existingDatatips.push(datatipsData);
    });

    var checkDatatipExistence = function (datatipData, existingData) {
        var i, l;
        for (i = 0, l = existingData.length; i < l; i++) {
            if (
                datatipData.content   === existingData[i].content   &&
                    datatipData.type      === existingData[i].type      &&
                    datatipData.pixelp[0] === existingData[i].pixelp[0] &&
                    datatipData.pixelp[1] === existingData[i].pixelp[1]
            ) {
                existingData[i].flag = false;
                datatipData.flag = false; // do not redraw
                return;
            }
        }
        datatipData.flag = true; // needs to be drawn
    };

    Graph.respondsTo("removeDatatips", function () {
        var existingDatatips = this.existingDatatips(),
            i;
        if (existingDatatips.length > 0) {
            for (i = 0; i < existingDatatips.length; i++) {
                existingDatatips[i].elem.remove();
            }
            existingDatatips = [];
        }
    });

    Graph.respondsTo("removeFlaggedDatatips", function () {
        var existingDatatips = this.existingDatatips(),
            i;
        if (existingDatatips.length > 0) {
            for (i = 0; i < existingDatatips.length; i++) {
                if (existingDatatips[i].flag === true) {
                    existingDatatips[i].elem.remove();
                    existingDatatips.splice(i, 1);
                }
            }
        }
    });


    return Graph;
};

},{"../../core/axis.js":19,"../../core/constant_plot.js":25,"../../core/graph.js":42}],76:[function(require,module,exports){
module.exports = function($, window, errorHandler) {

    var Multigraph = require('../../core/multigraph.js')($),
        Point = require('../../math/point.js');

    if (typeof(Multigraph.registerMouseEvents)==="function") { return Multigraph; }

    Multigraph.respondsTo("registerMouseEvents", function (target) {
        var base,
            mouseLast,
            mouseIsDown = false,
            dragStarted = false,
            multigraph = this,
            $target = $(target);

        var eventLocationToGraphCoords = function (event) {
            return new Point((event.pageX - $target.offset().left) - multigraph.graphs().at(0).x0(),
                             $target.height() - (event.pageY - $target.offset().top) - multigraph.graphs().at(0).y0());
        };

        $target.mousedown(function (event, datatipsEvent) {
            if (datatipsEvent) {
                // if the datatips mousedown handler is triggered through the datatips handler
                // then the default event does not contain pageX or pageY. So the datatips handler
                // passes its event, which does contain pageX and pageY.
                event = datatipsEvent;
            }
            event.preventDefault();
            var i;
            for (i = 0; i < multigraph.graphs().size(); i++) {
                multigraph.graphs().at(i).removeDatatips();
            }

            mouseLast = base = eventLocationToGraphCoords(event);
            mouseIsDown = true;
            dragStarted = false;
        });

        $target.mouseup(function (event) {
            mouseIsDown = false;
            multigraph.graphs().at(0).doDragDone();
        });

        $target.mousemove(function (event) {
            var eventLoc = eventLocationToGraphCoords(event),
                graphs   = multigraph.graphs();
            if (mouseIsDown) {
                var dx = eventLoc.x() - mouseLast.x(),
                    dy = eventLoc.y() - mouseLast.y();
                if (multigraph.graphs().size() > 0) {
                    if (!dragStarted ) {
                        graphs.at(0).doDragReset();
                    }
                    graphs.at(0).doDrag(multigraph, base.x(), base.y(), dx, dy, event.shiftKey);
                }
                dragStarted = true;
            } else { // datatips handling
                var i;
                for (i = 0; i < graphs.size(); i++) {
                    graphs.at(i).handleDatatips(eventLoc, multigraph.width(), multigraph.height(), $target, multigraph.div());
                }
            }
            mouseLast = eventLoc;
        });

        $target.mousewheel(function (event, delta) {
            var eventLoc = eventLocationToGraphCoords(event);
            if (multigraph.graphs().size() > 0) {
                multigraph.graphs().at(0).doWheelZoom(multigraph, eventLoc.x(), eventLoc.y(), delta);
            }
            event.preventDefault();
        });


        $target.mouseleave(function (event) {
            mouseIsDown = false;
            multigraph.graphs().at(0).doDragDone();
        });

        $(multigraph.div()).mouseleave(function (event) {
            var graphs = multigraph.graphs(),
                i;
            for (i = 0; i < graphs.size(); i++) {
                graphs.at(i).removeDatatips();
            }
        });

    });

    return Multigraph;
};

},{"../../core/multigraph.js":49,"../../math/point.js":106}],77:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
var _INCLUDED = false;
module.exports = function($, window, errorHandler) {

    if (_INCLUDED) { return; } else { _INCLUDED = true; }
    
    var Multigraph = require('../core/multigraph.js')($);

    var methods = {
        multigraph : function () {
            return this.data('multigraph').multigraph;
        },

        done : function (func) {
            return this.each(function () {
                return $(this).data('multigraph').multigraph.done(func);
            });
        },

        init : function (options) {
            return this.each(function () {
                var $this = $(this),
                    data = $this.data('multigraph');
                if (!("mugl" in options) && !("muglString" in options)) {
                    // if options contains neigther "mugl" nor "muglString",
                    // assume it's a JSON mugl object, so pass it on as
                    // the value of "muglString":
                    options = {
                        muglString: options
                    };
                }
                options.div = this;
                if ( ! data ) {
                    $this.data('multigraph', {
                        multigraph : Multigraph.createGraph(options)
                    });
                }
                return this;
            });
        }
    };

    $.fn.multigraph = function (method) {
        if ( methods[method] ) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.multigraph' );
            return null;
        }    
    };

    /*
     * Inclusion of this file allows markup like the following to be
     * used in HTML:
     * 
     *     <div class="multigraph"
     *        data-src="MUGL_FILE"
     *        data-width="WIDTH"
     *        data-height="HEIGHT"
     *        data-driver="DRIVER">
     *     </div>
     * 
     * The data-driver tag is optional; if not specified, it currently
     * defaults to "canvas", but that will be changed in the future to
     * make a smart choice based on browser capabilities.
     * 
     * The data-width and data-height tags are also optional; if they
     * are not specified, Multigraph will use the div size as determined
     * by the browser (which may be set by css rules, for example).  If
     * data-width or data-height is present, it will override any css
     * width or height.
     * 
     */
    $(document).ready(function () {

        $("div.multigraph").each(function () {

            var width  = $(this).attr("data-width"),
                height = $(this).attr("data-height"),
                src    = $(this).attr("data-src"),
                driver = $(this).attr("data-driver"),
                options;

            if (width !== undefined) {
                $(this).css('width', width + 'px');
            }
            if (height !== undefined) {
                $(this).css('height', height + 'px');
            }

            /*
             // don't default to canvas here any more; Multigraph.createGraph now does
             // browser detection and will default to canvas if possible, otherwise
             // to raphael
             if (driver === undefined) {
             driver = "canvas";
             }
             */

            options = {
                'div'    : this,
                'mugl'   : src,
                'driver' : driver
            };

            $(this).multigraph(options);
            $(this).lightbox({
                scale : true,
                postopen : function () {
                    var lightboxData = this.data("lightbox");
                    lightboxData.originalDiv = this;
                    this.data("multigraph").multigraph.done(function (m) {
                        m.div(lightboxData.contents);
                        m.initializeSurface();
                        m.resizeSurface(lightboxData.contentWidth, lightboxData.contentHeight);
                        m.width(lightboxData.contentWidth)
                            .height(lightboxData.contentHeight);
                        m.busySpinner().remove();
                        m.busySpinner($('<div style="position: absolute; left:5px; top:5px;"></div>')
                                      .appendTo($(m.div()))
                                      .busy_spinner());
                        m.render();
                    });
                    var timeout= window.setTimeout(function () {
                        lightboxData.contents.lightbox("resize");
                        window.clearTimeout(timeout);
                    }, 50);
                },
                postclose : function () {
                    var lightboxData = this.data("lightbox");
                    this.data("multigraph").multigraph.done(function (m) {
                        m.div(lightboxData.originalDiv)
                            .width($(m.div()).width())
                            .height($(m.div()).height())
                            .busySpinner($('<div style="position: absolute; left:5px; top:5px;"></div>')
                                         .appendTo($(m.div()))
                                         .busy_spinner()
                                        );

                        m.initializeSurface();
                        m.render();
                    });
                },
                postresize : function () {
                    var lightboxData = this.data("lightbox");
                    this.data("multigraph").multigraph.done(function (m) {
                        m.resizeSurface(lightboxData.contentWidth, lightboxData.contentHeight);
                        m.width(lightboxData.contentWidth)
                            .height(lightboxData.contentHeight);
                        m.render();
                    });
                }
            });

        });

    });

};

},{"../core/multigraph.js":49}],78:[function(require,module,exports){
module.exports = function($, window, errorHandler) {
    var Multigraph = require('../../core/multigraph.js')($),
        Point = require('../../math/point.js');

    if (typeof(Multigraph.registerResizeEvents)==="function") { return Multigraph; }

    Multigraph.respondsTo("registerResizeEvents", function (target) {
        var multigraph = this;
        var container = $(this.div());
        var c = $(target); // select canvas in multigraph div
        $(window).resize(respondGraph);

        function respondGraph()
        {
            c.attr("width", container.width() * window.devicePixelRatio);
            c.attr("height", container.height() * window.devicePixelRatio);
            c.css("width", container.width());
            c.css("height", container.height());
            multigraph.init();
        }
    });

    return Multigraph;
};

},{"../../core/multigraph.js":49,"../../math/point.js":106}],79:[function(require,module,exports){
module.exports = function($, window, errorHandler) {
    var Graph = require('../../core/graph.js'),
        Axis = require('../../core/axis.js');

    if (typeof(Graph.doFirstPinchZoom)==="function") { return Graph; }

    Graph.respondsTo("doFirstPinchZoom", function (multigraph, bx, by, dx, dy, totalx, totaly) {
        var dragAxis = this.dragAxis,
            dragOrientation = this.dragOrientation,
            HORIZONTAL = Axis.HORIZONTAL,
            VERTICAL   = Axis.VERTICAL;

        // TODO: this try...catch is just to remind myself how to apply, make sure this is correct later
        try {
            if (!this.dragStarted()) {
                if (totalx > totaly) {
                    dragOrientation(HORIZONTAL);
                } else {
                    dragOrientation(VERTICAL);
                }
                dragAxis(this.findNearestAxis(bx, by, dragOrientation()));
                if (dragAxis() === null) {
                    dragOrientation( (dragOrientation() === HORIZONTAL) ? VERTICAL : HORIZONTAL );
                    dragAxis( this.findNearestAxis(bx, by, dragOrientation()) );
                }
                this.dragStarted(true);
            }

            // do the action
            if (dragOrientation() === HORIZONTAL) {
                dragAxis().doZoom(bx, dx);
            } else {
                dragAxis().doZoom(by, dy);
            }

            // draw everything
            multigraph.redraw();
        } catch (e) {
            errorHandler(e);
        }
    });

    return Graph;
};

},{"../../core/axis.js":19,"../../core/graph.js":42}],80:[function(require,module,exports){
module.exports = function($, window, errorHandler) {
    var Multigraph = require('../../core/multigraph.js')($),
        Point = require('../../math/point.js');

    if (typeof(Multigraph.registerTouchEvents)==="function") { return Multigraph; }

    Multigraph.respondsTo("registerTouchEvents", function (target) {
        var touchStarted           = false,
            dragStarted            = false,
            pinchZoomStarted       = false,
            pinchZoomDetermined    = false,
            pinchZoomInitialDeltas = {},
            pinchZoomDeterminedTimeout,
            previoustoucha, previoustouchb,
            base,
            multigraph = this,
            $target = $(target);

        var touchLocationToGraphCoords = function (touch) {
            return new Point((touch.pageX - $target.offset().left) - multigraph.graphs().at(0).x0(),
                             $target.height() - (touch.pageY - $target.offset().top) - multigraph.graphs().at(0).y0());
        };

        var handleTouchStart = function (jqueryEvent) {
            var e = jqueryEvent.originalEvent;
            e.preventDefault();

            if (e.touches.length === 1) {
                base = touchLocationToGraphCoords(e.touches[0]);
            }
            previoustoucha = touchLocationToGraphCoords(e.touches[0]);

            // one finger drag
            if (e.touches.length === 1) {
                dragStarted = true;
            } else {
                dragStarted = false;
            }

            // pinch zoom
            if (e.touches.length === 2) {
                pinchZoomStarted = true;
                pinchZoomDetermined = false;
                previoustouchb = touchLocationToGraphCoords(e.touches[1]);
            } else {
                pinchZoomStarted = false;
                pinchZoomDetermined = false;
            }

            touchStarted = false;
            multigraph.graphs().at(0).doDragDone();
        };

        var handleTouchMove = function (jqueryEvent) {
            var e = jqueryEvent.originalEvent;
            e.preventDefault();

            // one finger drag
            if (e.touches.length === 1 && dragStarted === true) {
                handleDrag(e);
            }
            // pinch zoom
            if (e.touches.length === 2 && pinchZoomStarted === true) {
                handlePinchZoom(e);
            }
        };

        var handleTouchEnd = function (jqueryEvent) {
            var e = jqueryEvent.originalEvent;
            e.preventDefault();
            
            // one finger drag
            if (e.touches.length === 1) {
                dragStarted = true;
            } else {
                dragStarted = false;
            }
            
            // pinch zoom
            if (e.touches.length === 2) {
                pinchZoomStarted = true;
                pinchZoomDetermined = false;
            } else {
                pinchZoomStarted = false;
                pinchZoomDetermined = false;
            }

            touchStarted = false;
            multigraph.graphs().at(0).doDragDone();
        };

        var handleTouchLeave = function (jqueryEvent) {
            jqueryEvent.originalEvent.preventDefault();

            dragStarted = false;
            pinchZoomStarted = false;
            pinchZoomDetermined = false;
            touchStarted = false;

            multigraph.graphs().at(0).doDragDone();
        };

        var handleDrag = function (e) {
            var touchLoc = touchLocationToGraphCoords(e.touches[0]),
                dx = touchLoc.x() - previoustoucha.x(),
                dy = touchLoc.y() - previoustoucha.y();
            if (multigraph.graphs().size() > 0) {
                if (!touchStarted) {
                    multigraph.graphs().at(0).doDragReset();
                }
                multigraph.graphs().at(0).doDrag(multigraph, base.x(), base.y(), dx, dy, false);
            }
            touchStarted = true;
            previoustoucha = touchLoc;
        };

        var handlePinchZoom = function (e) {
            var a = touchLocationToGraphCoords(e.touches[0]),
                b = touchLocationToGraphCoords(e.touches[1]),
                basex = (a.x() + b.x()) / 2,
                basey = (a.y() + b.y()) / 2,
                dx = calculateAbsoluteDistance(a.x(), b.x()) - calculateAbsoluteDistance(previoustoucha.x(), previoustouchb.x()),
                dy = calculateAbsoluteDistance(a.y(), b.y()) - calculateAbsoluteDistance(previoustoucha.y(), previoustouchb.y());

            if (multigraph.graphs().size() > 0) {
                if (!touchStarted) {
                    multigraph.graphs().at(0).doDragReset();
                }
                if (pinchZoomDetermined === true) {
                    multigraph.graphs().at(0).doDrag(multigraph, basex, basey, dx, dy, true);
                }
            }
            touchStarted = true;

            // two finger scroll
            var cx = ((a.x() - previoustoucha.x()) + (b.x() - previoustouchb.x())) / 2,
                cy = ((a.y() - previoustoucha.y()) + (b.y() - previoustouchb.y())) / 2;
            if (pinchZoomDetermined === true) {
                multigraph.graphs().at(0).doDrag(multigraph, basex, basey, cx, cy, false);
            }

            if (pinchZoomDetermined === false) {
                if (pinchZoomInitialDeltas.base === undefined) {
                    pinchZoomInitialDeltas.base = {};
                    pinchZoomInitialDeltas.base.x = basex;
                    pinchZoomInitialDeltas.base.y = basey;
                } 
                if (pinchZoomInitialDeltas.zoomDeltas === undefined) {
                    pinchZoomInitialDeltas.zoomDeltas = {
                        "dx"     : 0,
                        "dy"     : 0,
                        "totalx" : 0,
                        "totaly" : 0
                    };
                }
                if (pinchZoomInitialDeltas.panDeltas === undefined) {
                    pinchZoomInitialDeltas.panDeltas = {
                        "dx" : 0,
                        "dy" : 0
                    };
                }

                pinchZoomInitialDeltas.zoomDeltas.dx += dx;
                pinchZoomInitialDeltas.zoomDeltas.dy += dy;
                pinchZoomInitialDeltas.panDeltas.dx += cx;
                pinchZoomInitialDeltas.panDeltas.dy += cy;

                pinchZoomInitialDeltas.zoomDeltas.totalx += Math.abs(dx);
                pinchZoomInitialDeltas.zoomDeltas.totaly += Math.abs(dy);

                if (pinchZoomDeterminedTimeout === undefined) {
                    pinchZoomDeterminedTimeout = setTimeout(function () {
                        var basex = pinchZoomInitialDeltas.base.x,
                            basey = pinchZoomInitialDeltas.base.y,
                            dx = pinchZoomInitialDeltas.zoomDeltas.dx,
                            dy = pinchZoomInitialDeltas.zoomDeltas.dy,
                            cx = pinchZoomInitialDeltas.panDeltas.dx,
                            cy = pinchZoomInitialDeltas.panDeltas.dy;

                        multigraph.graphs().at(0).doDragReset();

                        multigraph.graphs().at(0).doFirstPinchZoom(multigraph, basex, basey, dx, dy, pinchZoomInitialDeltas.zoomDeltas.totalx, pinchZoomInitialDeltas.zoomDeltas.totaly);
                        multigraph.graphs().at(0).doDrag(multigraph, basex, basey, cx, cy, false);

                        pinchZoomInitialDeltas = {};
                        pinchZoomDetermined = true;
                        clearTimeout(pinchZoomDeterminedTimeout);
                        pinchZoomDeterminedTimeout = undefined;
                    }, 60);
                }
            }

            previoustoucha = a;
            previoustouchb = b;

        };

        var calculateAbsoluteDistance = function (a, b) {
            return Math.abs(a - b);
        };

        $target.on("touchstart", handleTouchStart);
        $target.on("touchmove", handleTouchMove);
        $target.on("touchend", handleTouchEnd);
        $target.on("touchleave", handleTouchLeave);

    });

    return Multigraph;
};

},{"../../core/multigraph.js":49,"../../math/point.js":106}],81:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function($, window) {
    if (_INCLUDED) { return; }
    _INCLUDED = true;

    require('./multigraph.js')($, window);

    require('./axis.js')();
    require('./axis_title.js')();
    require('./background.js')();
    require('./graph.js')();
    require('./graph_title.js')();
    require('./icon.js')();
    require('./img.js')();
    require('./labeler.js')();
    require('./legend.js')();
    require('./plotarea.js')();
    require('./renderers/band_renderer.js')();
    require('./renderers/bar_renderer.js')();
    require('./renderers/fill_renderer.js')();
    require('./renderers/pointline_renderer.js')();
    require('./renderers/rangebar_renderer.js')();
    require('./text.js')();
    require('./window.js')();
};

},{"./axis.js":82,"./axis_title.js":83,"./background.js":84,"./graph.js":85,"./graph_title.js":86,"./icon.js":87,"./img.js":88,"./labeler.js":89,"./legend.js":90,"./multigraph.js":91,"./plotarea.js":92,"./renderers/band_renderer.js":93,"./renderers/bar_renderer.js":94,"./renderers/fill_renderer.js":95,"./renderers/pointline_renderer.js":96,"./renderers/rangebar_renderer.js":97,"./text.js":98,"./window.js":99}],82:[function(require,module,exports){
module.exports = function() {
    var Axis = require('../../core/axis.js');

    if (typeof(Axis.renderGrid)==="function") { return Axis; }

    Axis.respondsTo("renderGrid", function (graph, context) {
        if (!this.visible()) { return; }
        this.prepareRender(context);

        // draw the grid lines
        if (this.hasDataMin() && this.hasDataMax()) { // skip if we don't yet have data values
            if (this.grid().visible()) { // skip if grid lines aren't turned on
                if (this.labelers().size() > 0 && this.currentLabelDensity() <= 1.5) {
                    var currentLabeler = this.currentLabeler(),
                        perpOffset     = this.perpOffset(),
                        plotBox        = graph.plotBox();
                    currentLabeler.prepare(this.dataMin(), this.dataMax());
                    context.beginPath();
                    while (currentLabeler.hasNext()) {
                        var v = currentLabeler.next(),
                            a = this.dataValueToAxisValue(v);
                        if (this.orientation() === Axis.HORIZONTAL) {
                            context.moveTo(a, perpOffset);
                            context.lineTo(a, plotBox.height() - perpOffset);
                        } else {
                            context.moveTo(perpOffset, a);
                            context.lineTo(plotBox.width() - perpOffset, a);
                        }
                    }
                    context.strokeStyle = this.grid().color().getHexString("#");
                    context.stroke();
                }
            }
        }
    });

    Axis.respondsTo("render", function (graph, context) {
        if (!this.visible()) { return; }
        var parallelOffset = this.parallelOffset(),
            perpOffset     = this.perpOffset(),
            pixelLength    = this.pixelLength(),
            currentLabeler = this.currentLabeler(),
            axisIsHorizontal = (this.orientation() === Axis.HORIZONTAL);
        //NOTE: axes are drawn relative to the graph's plot area (plotBox); the coordinates
        //      below are relative to the coordinate system of that box.

        //
        // Render the axis line itself, unless its linewidth() property is 0.
        // TODO: modify this so that it correctly draws a line with the given
        // linewidth().  At the moment, it only makes a distinction between
        // lines of width 0, which aren't drawn at all, and lines with width > 0,
        // which are drawn with width 1.
        if (this.linewidth() > 0) {
            context.beginPath();
            if (axisIsHorizontal) {
                context.moveTo(parallelOffset, perpOffset);
                context.lineTo(parallelOffset + pixelLength, perpOffset);
            } else {
                context.moveTo(perpOffset, parallelOffset);
                context.lineTo(perpOffset, parallelOffset + pixelLength);
            }

            context.strokeStyle = this.color().getHexString("#");
            context.stroke();
        }

        //
        // Render the tick marks and labels
        //
        if (this.hasDataMin() && this.hasDataMax()) { // but skip if we don't yet have data values
            if (currentLabeler && currentLabeler.visible()) { // also skip if we have no current labeler, or
                var tickwidth = this.tickwidth(),             //   if we do but its `visible` property is false
                    tickmin   = this.tickmin(),
                    tickmax   = this.tickmax(),
                    tickcolor = this.tickcolor();
                context.beginPath();
                context.fillStyle = '#000000';
                currentLabeler.prepare(this.dataMin(), this.dataMax());
                while (currentLabeler.hasNext()) {
                    var v = currentLabeler.next(),
                        a = this.dataValueToAxisValue(v);
                    if (tickwidth > 0) {
                        if (tickcolor !== undefined && tickcolor !== null) {
                            context.strokeStyle = tickcolor.getHexString('#');
                        }
                        if (axisIsHorizontal) {
                            context.moveTo(a, perpOffset+tickmax);
                            context.lineTo(a, perpOffset+tickmin);
                        } else {
                            context.moveTo(perpOffset+tickmin, a);
                            context.lineTo(perpOffset+tickmax, a);
                        }
                        if (tickcolor !== undefined && tickcolor !== null) {
                            context.restore();
                        }
                    }
                    currentLabeler.renderLabel(context, v);
                }
                context.stroke();
            }
        }

        //
        // Render the title
        //
        if (this.title()) {
            this.title().render(context);
        }

    });

    return Axis;
};

},{"../../core/axis.js":19}],83:[function(require,module,exports){
module.exports = function() {
    var AxisTitle = require('../../core/axis_title.js'),
        Axis = require('../../core/axis.js'),
        Point = require('../../math/point.js');

    if (typeof(AxisTitle.render)==="function") { return AxisTitle; }

    AxisTitle.respondsTo("render", function (context) {
        var axis        = this.axis(),
            title       = this.content(),
            anchor      = this.anchor(),
            perpOffset  = axis.perpOffset(),
            h           = title.origHeight(),
            w           = title.origWidth(),
            pixelAnchor = new Point(
                0.5 * w * (anchor.x() + 1),
                0.5 * h * (anchor.y() + 1)
            ),
            storedBase  = (this.base() + 1) * (axis.pixelLength() / 2) + axis.minoffset() + axis.parallelOffset(),
            pixelBase;

        if (axis.orientation() === Axis.HORIZONTAL) {
            pixelBase = new Point(storedBase, perpOffset);
        } else {
            pixelBase = new Point(perpOffset, storedBase);
        }

        context.save();
        context.fillStyle = "rgba(0, 0, 0, 1)";
        title.font(this.font());
        title.drawText(context, pixelAnchor, pixelBase, this.position(), this.angle());
        context.restore();
    });

    return AxisTitle;
};

},{"../../core/axis.js":19,"../../core/axis_title.js":21,"../../math/point.js":106}],84:[function(require,module,exports){
module.exports = function() {
    var Background = require('../../core/background.js');

    if (typeof(Background.render)==="function") { return Background; }

    Background.respondsTo("render", function (graph, context, width, height) {
        var mb = graph.window().margin().left() + graph.window().border(),
            img = this.img();

        context.save();
        context.fillStyle = this.color().getHexString("#");
        context.fillRect(mb, mb, width - 2*mb, height - 2*mb);
        context.restore();
        
        if (img && img.src() !== undefined) {
            img.render(graph, context, width, height);
        }
    });

    return Background;
};

},{"../../core/background.js":22}],85:[function(require,module,exports){
module.exports = function() {
    var Graph = require('../../core/graph.js');

    if (typeof(Graph.render)==="function") { return Graph; }

    Graph.respondsTo("render", function (context, width, height) {
        var i;

        this.window().render(context, width, height);

        this.background().render(this, context, width, height);

        context.transform(1,0,0,1,this.x0(),this.y0());

        this.plotarea().render(this, context);

        for (i = 0; i < this.axes().size(); ++i) {
            this.axes().at(i).renderGrid(this, context);
        }


        context.save();
        context.rect(0, 0, this.plotBox().width(), this.plotBox().height());
        context.clip();


        for (i = 0; i < this.plots().size(); ++i) {
            this.plots().at(i).render(this, context);
        }

        context.restore();

        for (i = 0; i < this.axes().size(); ++i) {
            this.axes().at(i).render(this, context);
        }

        this.legend().render(context);

        if (this.title()) {
            this.title().render(context);
        }
    });

    return Graph;
};

},{"../../core/graph.js":42}],86:[function(require,module,exports){
module.exports = function() {
    var Title = require('../../core/title.js'),
        Point = require('../../math/point.js');

    if (typeof(Title.render)==="function") { return Title; }

    Title.respondsTo("render", function (context) {
        var graph           = this.graph(),
            border          = this.border(),
            padding         = this.padding(),
            storedAnchor    = this.anchor(),
            storedBase      = this.base(),
            position        = this.position(),
            title           = this.text(),
            backgroundColor = this.color().toRGBA(this.opacity()),
            paddingBox      = graph.paddingBox(),
            plotBox         = graph.plotBox(),
            plotareaMargin  = graph.plotarea().margin(),
            h = title.origHeight(),
            w = title.origWidth(),
            pixelAnchor = new Point(
                (0.5 * w + padding + border) * (storedAnchor.x() + 1),
                (0.5 * h + padding + border) * (storedAnchor.y() + 1)
            ),
            pixelBase;

        if (this.frame() === "padding") {
            pixelBase = new Point(
                (storedBase.x() + 1) * (paddingBox.width() / 2)  - plotareaMargin.left(),
                (storedBase.y() + 1) * (paddingBox.height() / 2) - plotareaMargin.bottom()
            );
        } else {
            pixelBase = new Point(
                (storedBase.x() + 1) * (plotBox.width() / 2),
                (storedBase.y() + 1) * (plotBox.height() / 2)
            );
        }

        context.save();
        title.setTransform(context, pixelAnchor, pixelBase, position, 0);
        context.transform(1, 0, 0, -1, 0, 0);

        // border
        if (border > 0) {
            context.strokeStyle = this.bordercolor().toRGBA();
            context.lineWidth = border;
            context.strokeRect(
                border / 2,
                border / 2,
                w + (2 * padding) + border,
                h + (2 * padding) + border
            );
        }

        // background
        context.fillStyle = backgroundColor;
        context.fillRect(
            border,
            border,
            w + (2 * padding),
            h + (2 * padding)
        );
        context.restore();

        // text
        context.save();
        var textPosition = new Point(
            position.x() + border + padding,
            position.y() + border + padding
        );
        context.font = this.fontSize() + " sans-serif";
        context.fillStyle = "rgba(0, 0, 0, 1)";
        title.drawText(context, pixelAnchor, pixelBase, textPosition, 0);
        context.restore();
    });

    return Title;
};

},{"../../core/title.js":66,"../../math/point.js":106}],87:[function(require,module,exports){
module.exports = function() {
    var Icon = require('../../core/icon.js'),
        Point = require('../../math/point.js');

    if (typeof(Icon.renderBorder)==="function") { return Icon; }

    Icon.respondsTo("renderBorder", function (context, x, y) {
        context.save();
        context.strokeStyle = "rgba(0, 0, 0, 1)";
        context.strokeRect(x, y, this.width(), this.height());
        context.restore();
    });
    return Icon;
};

},{"../../core/icon.js":44,"../../math/point.js":106}],88:[function(require,module,exports){
module.exports = function() {
    var Img = require('../../core/img.js'),
        Util = require('../../math/util.js');

    if (typeof(Img.render)==="function") { return Img; }

    Img.hasA("image").which.defaultsTo(function () {return new Image();});
    Img.hasA("fetched").which.defaultsTo(false);

    Img.respondsTo("render", function (graph, context, width, height) {
        if (this.fetched()) {
            var interp      = Util.interp,
                image       = this.image(),
                graphWindow = graph.window(),
                plotarea    = graph.plotarea(),
                base = this.base(),
                ax = interp(this.anchor().x(), -1, 1, 0, image.width),
                ay = interp(this.anchor().y(), 1, -1, 0, image.height),
                paddingLeft = graphWindow.margin().left() + graphWindow.border(),
                paddingTop  = graphWindow.margin().top() + graphWindow.border(),
                plotLeft = paddingLeft + graphWindow.padding().left() + plotarea.margin().left() + plotarea.border(),
                plotTop  = paddingTop + graphWindow.padding().top() + plotarea.margin().top() + plotarea.border(),
                bx, by,
                x, y;
            if (this.frame() === Img.PLOT) {
                bx = plotLeft + interp(base.x(), -1, 1, 0, graph.plotBox().width());
                by = plotTop + interp(base.y(), 1, -1, 0, graph.plotBox().height());
            } else {
                bx = paddingLeft + interp(base.x(), -1, 1, 0, graph.paddingBox().width());
                by = paddingTop + interp(base.y(), 1, -1, 0, graph.paddingBox().height());
            }
            x = bx + this.position().x() - ax;
            y = by + this.position().y() - ay;
            context.save();
            context.transform(1, 0, 0, -1, 0, height);
            context.drawImage(image, x, y, image.width, image.height);
            context.restore();
        } else {
            var that = this;
            this.image().onload = function () {
                that.fetched(true);
                context.save();
                context.setTransform(1, 0, 0, -1, 0, height);
                graph.render(context, width, height);
                context.restore();
            };
            this.image().src = this.src();
        }
    });

    return Img;
};

},{"../../core/img.js":45,"../../math/util.js":108}],89:[function(require,module,exports){
module.exports = function() {
    var Labeler = require('../../core/labeler.js'),
        Text = require('../../core/text.js'),
        Axis = require('../../core/axis.js'),
        Point = require('../../math/point.js');

    if (typeof(Labeler.renderLabel)==="function") { return Labeler; }

    Labeler.respondsTo("measureStringWidth", function (context, string) {
        var t = new Text(string);
        t.font(this.font());
        return t.initializeGeometry({
            "context" : context,
            "angle"   : this.angle()
        }).rotatedWidth();
    });

    Labeler.respondsTo("measureStringHeight", function (context, string) {
        var t = new Text(string);
        t.font(this.font());
        return t.initializeGeometry({
            "context" : context,
            "angle"   : this.angle()
        }).rotatedHeight();
    });

    Labeler.respondsTo("renderLabel", function (context, value) {
        var axis            = this.axis(),
            storedAnchor    = this.anchor(),
            angle           = this.angle(),
            perpOffset      = axis.perpOffset(),
            a               = axis.dataValueToAxisValue(value),
            formattedString = new Text(this.formatter().format(value)),
            pixelAnchor,
            base;

        formattedString.font(this.font());
        formattedString.initializeGeometry({
            "context" : context,
            "angle"   : angle
        });

        pixelAnchor = new Point(
            0.5 * formattedString.origWidth() * (storedAnchor.x() + 1),
            0.5 * formattedString.origHeight() * (storedAnchor.y() + 1)
        );

        if (axis.orientation() === Axis.HORIZONTAL) {
            base = new Point(a, perpOffset);
        } else {
            base = new Point(perpOffset, a);
        }


        context.save();
        context.fillStyle = this.color().getHexString("#");
        formattedString.drawText(context, pixelAnchor, base, this.position(), angle);
        context.restore();
    });

    return Labeler;
};

},{"../../core/axis.js":19,"../../core/labeler.js":46,"../../core/text.js":65,"../../math/point.js":106}],90:[function(require,module,exports){
module.exports = function() {
    var Legend = require('../../core/legend.js'),
        Point = require('../../math/point.js');

    if (typeof(Legend.renderLegend)==="function") { return Legend; }

    Legend.respondsTo("begin", function (context) {
        context.save();
        context.transform(1, 0, 0, 1, this.x(), this.y());
    });

    Legend.respondsTo("end", function (context) {
        context.restore();
    });

    Legend.respondsTo("renderLegend", function (context) {
        var border = this.border();
        context.save();
        if (border > 0) {
            context.strokeStyle = this.bordercolor().toRGBA();
            context.strokeRect(border/2, border/2, this.width() - border/2, this.height() - border/2);
        }

        context.fillStyle = this.color().toRGBA(this.opacity());
        context.fillRect(border, border, this.width() - (2 * border), this.height() - (2 * border));
        context.restore();
    });

    Legend.respondsTo("renderLabel", function (label, context, x, y) {
        context.save();
        context.fillStyle = "rgba(0, 0, 0, 1)";
        context.transform(1, 0, 0, -1, 0, y + this.maxLabelHeight()/2 - label.origHeight()/2);
        context.fillText(label.string(), x, 0);
        context.restore();
    });

    return Legend;
};

},{"../../core/legend.js":47,"../../math/point.js":106}],91:[function(require,module,exports){
module.exports = function($, window) {
    var Multigraph = require('../../core/multigraph.js')($),
        Point = require('../../math/point.js'),
        vF = require('../../util/validationFunctions.js');

    if (typeof(Multigraph.render)==="function") { return Multigraph; }

    Multigraph.hasA("canvas");  // canvas object itself (the '<canvas>' tag itself)
    Multigraph.hasA("context"); // canvas context object
    Multigraph.hasA("width").which.isA("number");
    Multigraph.hasA("height").which.isA("number");

    Multigraph.respondsTo("redraw", function () {
        var that = this;
        window.requestAnimationFrame(function () {
            that.render();
        });
    });

    Multigraph.respondsTo("init", function () {
        var $div = $(this.div());
        this.width($div.width());
        this.height($div.height());
        if (this.width() > 0 && this.height() > 0) {
            // create the canvas
            $("<canvas width=\""+this.width()*window.devicePixelRatio+"\" height=\""+this.height()*window.devicePixelRatio+"\" style=\"width:"+this.width()+"px; height:"+this.height()+"px;\"/>")
                .appendTo($div);

            this.initializeSurface();

            this.busySpinner($('<div style="position:absolute;top:50%;left:50%;margin-top:-16px;margin-left:-16px"></div>') .
                             appendTo($div) .
                             busy_spinner());
        }
        this.render();
    });

    Multigraph.respondsTo("render", function () {
        var context = this.context(),
            width   = this.width(),
            height  = this.height(),
            i;

        context.setTransform(1, 0, 0, 1, 0, 0);
        context.scale(window.devicePixelRatio, window.devicePixelRatio);
        context.transform(1, 0, 0, -1, 0, height);
        context.clearRect(0, 0, width, height);
        this.initializeGeometry(width, height, {"context" : context});
        for (i = 0; i < this.graphs().size(); ++i) {
            this.graphs().at(i).render(context, width, height);
        }
    });

    Multigraph.respondsTo("registerEvents", function () {
        var canvas = this.canvas();
        this.registerMouseEvents(canvas);
        this.registerTouchEvents(canvas);
        this.registerResizeEvents(canvas);
    });

    Multigraph.respondsTo("resizeSurface", function (width, height) {
        var canvas = this.context().canvas;
        canvas.width  = width;
        canvas.height = height;
    });

    Multigraph.respondsTo("initializeSurface", function () {
        this.canvas($(this.div()).children("canvas")[0]);
        this.context(this.canvas().getContext("2d"));
    });

    //    var applyMixins = function (options) {
    //        var errorHandler = options.messageHandler.error;
    //        window.multigraph.parser.mixin.apply(window.multigraph, "parseXML");
    //        ns.mixin.apply(window.multigraph.core);
    //        window.multigraph.events.draggable.mixin.apply(window.multigraph, errorHandler);
    //        window.multigraph.events.mouse.mixin.apply(window.multigraph, errorHandler);
    //        window.multigraph.events.touch.mixin.apply(window.multigraph, errorHandler);
    //        window.multigraph.normalizer.mixin.apply(window.multigraph.core);
    //    };

    // Return true iff the string `s` looks like a json object.
    // This simply checks to see if the first non-whitespace char is a '{' or '['.
    function looks_like_json(s) {
        return /^\s*[{\[]/.test(s);
    }

    var generateInitialGraph = function (mugl, options) {
        var JQueryXMLParser = require('../../parser/xml/jquery_xml_parser.js')($);
        require('../../parser/json/json_parser.js')($);
        var multigraph;
        if (vF.typeOf(mugl) === 'string') {
            if (looks_like_json(mugl)) {
                //http://stackoverflow.com/questions/4935632/parse-json-in-javascript
                var obj = JSON && JSON.parse(mugl) || $.parseJSON(mugl);
                multigraph = Multigraph.parseJSON( obj, options.mugl, options.messageHandler );
            } else {
                var xmlObj = JQueryXMLParser.stringToJQueryXMLObj(mugl);
                multigraph = Multigraph.parseXML( xmlObj, options.mugl, options.messageHandler );
            }
        } else {
            multigraph = Multigraph.parseJSON( mugl, options.mugl, options.messageHandler );
        }


        multigraph.normalize();
        multigraph.div(options.div);
        $(options.div).css("cursor" , "pointer");
        multigraph.init();
        multigraph.registerEvents();
        multigraph.registerCommonDataCallback(function (event) {
            multigraph.redraw();
        });
        return multigraph;
    };

    Multigraph.createCanvasGraph = function (options) {
        var muglPromise,
            deferred;

        try {
            //applyMixins(options);
            require('../../events/all.js')($, window, options.messageHandler.error);
            muglPromise = $.ajax({
                "url"      : options.mugl,
                "dataType" : "text"
            });

            deferred = $.Deferred();
        } catch (e) {
//console.log('at c 1');
throw e;
//            options.messageHandler.error(e);
        }

        muglPromise.done(function (data) {
            try {
                // TODO: div size IS available here; see below.  What's going on???!!!
                var multigraph = generateInitialGraph(data, options);
                deferred.resolve(multigraph);
            } catch (e) {
//console.log('at c 2');
throw e;
//                options.messageHandler.error(e);
            }
        });

        return deferred.promise();
    };

    Multigraph.createCanvasGraphFromString = function (options) {
        var deferred;

        try {
            //applyMixins(options);
            require('../../events/all.js')($, window, options.messageHandler.error);
            deferred = $.Deferred();
            // TODO: figure this out!  div size is not available here?  Apparently, at this point in
            // code execution, the browser hasn't laid things out enough for the div to have been
            // assigned a size, at least sometimes???  But it IS available at the corresponding place in
            // createCanvasGraph above?  This is worked around by the code in
            // src/core/multigraph.js:createGraph() that forces the div to have the size specified in
            // the options --- so we can work around the problem by passing an explicit size in the
            // options.  But we need to really figure out what's going on and resolve it.
            var multigraph = generateInitialGraph(options.muglString, options);
            deferred.resolve(multigraph);
        } catch (e) {
//console.log('at c 3');
throw e;
//            options.messageHandler.error(e);
        }

        return deferred.promise();
    };

    return Multigraph;
};

},{"../../core/multigraph.js":49,"../../events/all.js":73,"../../math/point.js":106,"../../parser/json/json_parser.js":121,"../../parser/xml/jquery_xml_parser.js":146,"../../util/validationFunctions.js":160}],92:[function(require,module,exports){
module.exports = function() {
    var Plotarea = require('../../core/plotarea.js');

    if (typeof(Plotarea.render)==="function") { return Plotarea; }

    Plotarea.respondsTo("render", function (graph, context) {
        var plotBox = graph.plotBox(),
            border = this.border();

        if (this.color() !== null) {
            context.save();
            context.fillStyle = this.color().getHexString("#");
            context.fillRect(0, 0, plotBox.width(), plotBox.height());
            context.restore();
        }

        if (border > 0) {
            context.save();
            context.lineWidth = border;
            context.strokeStyle = this.bordercolor().getHexString("#");
            context.strokeRect(-border/2, -border/2, plotBox.width() + border, plotBox.height() + border);
            context.restore();
        }
    });

    return Plotarea;
};

},{"../../core/plotarea.js":57}],93:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function() {
    var BandRenderer = require('../../../core/renderers/band_renderer.js');

    if (_INCLUDED) { return BandRenderer; }
    _INCLUDED = true;

    // cached state object, for quick access during rendering, populated in begin() method:
    BandRenderer.hasA("state");

    BandRenderer.respondsTo("begin", function (context) {
        var state = {
            "context"            : context,
            "run"                : [],
            "linecolor"          : this.getOptionValue("linecolor"),
            "line1color"         : this.getOptionValue("line1color"),
            "line2color"         : this.getOptionValue("line2color"),
            "linewidth"          : this.getOptionValue("linewidth"),
            "line1width"         : this.getOptionValue("line1width"),
            "line2width"         : this.getOptionValue("line2width"),
            "fillcolor"          : this.getOptionValue("fillcolor"),
            "fillopacity"        : this.getOptionValue("fillopacity")
        };
        this.state(state);
    });

    // This renderer's dataPoint() method works by accumulating
    // and drawing one "run" of data points at a time.  A "run" of
    // points consists of a consecutive sequence of non-missing
    // data points which have the same fill color.  (The fill
    // color can change if the data line crosses the fill base
    // line, if the downfillcolor is different from the
    // fillcolor.)
    BandRenderer.respondsTo("dataPoint", function (datap) {
        var state = this.state();

        if (this.isMissing(datap)) {
            // if this is a missing point, render and reset the current run, if any
            if (state.run.length > 0) {
                this.renderRun();
                state.run = [];
            }
        } else {
            // otherwise, transform point to pixel coords
            var p = this.transformPoint(datap);
            // and add it to the current run
            state.run.push(p);
        }
    });

    BandRenderer.respondsTo("end", function () {
        var state = this.state();
        // render the current run, if any
        if (state.run.length > 0) {
            this.renderRun();
        }
    });

    /*
     * Private utility function to stroke line segments connecting the points of a run
     */
    var strokeRunLine = function(context, run, whichLine, color, defaultColor, width, defaultWidth) {
        var i;

        width = (width >= 0) ? width : defaultWidth;
        if (width > 0) {
            color = (color !== null) ? color : defaultColor;
            context.save();
            context.strokeStyle = color.getHexString("#");
            context.lineWidth = width;
            context.beginPath();
            context.moveTo(run[0][0], run[0][whichLine]);
            for (i = 1; i < run.length; ++i) {
                context.lineTo(run[i][0], run[i][whichLine]);
            }
            context.stroke();
            context.restore();
        }
    };

    // Render the current run of data points.  This consists of drawing the fill region
    // in the band between the two data lines, and connecting the points of each data line
    // with lines of the appropriate color.
    BandRenderer.respondsTo("renderRun", function () {
        var state   = this.state(),
            context = state.context,
            run     = state.run,
            i;

        // fill the run
        context.save();
        context.globalAlpha = state.fillopacity;
        context.fillStyle = state.fillcolor.getHexString("#");
        context.beginPath();
        // trace to the right along line 1
        context.moveTo(run[0][0], run[0][1]);
        for (i = 1; i < run.length; ++i) {
            context.lineTo(run[i][0], run[i][1]);
        }
        // trace back to the left along line 2
        context.lineTo(run[run.length-1][0], run[run.length-1][2]);
        for (i = run.length-1; i >= 0; --i) {
            context.lineTo(run[i][0], run[i][2]);
        }
        context.fill();
        context.restore();

        // stroke line1
        strokeRunLine(context, run, 1, state.line1color, state.linecolor, state.line1width, state.linewidth);

        // stroke line2
        strokeRunLine(context, run, 2, state.line2color, state.linecolor, state.line2width, state.linewidth);
    });

    BandRenderer.respondsTo("renderLegendIcon", function (context, x, y, icon) {
        var state = this.state(),
            iconWidth  = icon.width(),
            iconHeight = icon.height();

        context.save();
        context.transform(1, 0, 0, 1, x, y);

        context.save();
        // Draw icon background (with opacity)
        if (iconWidth < 10 || iconHeight < 10) {
            context.fillStyle = state.fillcolor.toRGBA();
        } else {
            context.fillStyle = "#FFFFFF";
        }
        context.fillRect(0, 0, iconWidth, iconHeight);
        context.restore();

        // Draw icon graphics
        context.strokeStyle = (state.line2color !== null) ? state.line2color : state.linecolor;
        context.lineWidth   = (state.line2width >= 0) ? state.line2width : state.linewidth;
        context.fillStyle   = state.fillcolor.toRGBA(state.fillopacity);

        context.beginPath();

        context.moveTo(0,         2*iconHeight/8);
        context.lineTo(0,         6*iconHeight/8);
        context.lineTo(iconWidth, 7*iconHeight/8);
        context.lineTo(iconWidth, 3*iconHeight/8);
        context.lineTo(0,         2*iconHeight/8);
        
        context.fill();
        context.stroke();

        context.restore();
    });

    return BandRenderer;
};

},{"../../../core/renderers/band_renderer.js":60}],94:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function() {
    var BarRenderer = require('../../../core/renderers/bar_renderer.js');

    if (_INCLUDED) { return BarRenderer; }
    _INCLUDED = true;

    // cached settings object, for quick access during rendering, populated in begin() method:
    BarRenderer.hasA("settings");

    BarRenderer.respondsTo("begin", function (context) {
        var settings = {
            "context"            : context,
            "barpixelwidth"      : this.getOptionValue("barwidth").getRealValue() * this.plot().horizontalaxis().axisToDataRatio(),
            "baroffset"          : this.getOptionValue("baroffset"),
            "barpixelbase"       : (this.getOptionValue("barbase") !== null)?this.plot().verticalaxis().dataValueToAxisValue(this.getOptionValue("barbase")):0,
            "fillcolor"          : this.getOptionValue("fillcolor"),
            "linecolor"          : this.getOptionValue("linecolor"),
            "hidelines"          : this.getOptionValue("hidelines"),
            "barGroups"          : [],
            "currentBarGroup"    : null,
            "prevCorner"         : null,
            "pixelEdgeTolerance" : 1
        };

        this.settings(settings);
    });

    // This bar renderer uses a somewhat sophisticated technique when drawing
    // the outlines around the bars, in order to make sure that it only draws
    // one vertical line between two bars that share an edge.  If a complete
    // outline were drawn around each bar separately, the common edge between
    // adjacent bars would get drawn twice, once for each bar, possibly in
    // slightly different locations on the screen due to roundoff error,
    // thereby making some of the outline lines appear thicker than others.
    // 
    // In order to avoid this roundoff artifact, this render only draws the
    // bars (the filled region of the bar, that is) in its dataPoint() method,
    // and keeps a record of the bar locations and heights so that it can draw all
    // of the bar outlines at once, in its end() method.  The bar locations and
    // heights are stored in an array called _barGroups, which is an array of
    // "bar group" objects.  Each "bar group" corresponds to a sequence of adjacent
    // bars --- two bars are considered to be adjacent if the right edge of the left
    // bar is within _pixelEdgeTolerance pixels of the left edge of the right bar.
    // A "bar group" is represented by an array of points representing the pixel
    // coordinates of the upper left corners of all the bars in the group, followed by
    // the pixel coordinates of the upper right corner of the right-most bar in the group.
    // (The last, right-most, bar is the only one whose upper right corner is included
    // in the list).  So, for example, the following bar group
    // 
    //        *--*
    //        |  |--*
    //     *--*  |  |
    //     |  |  |  |
    //     |  |  |  |
    //   ---------------
    //     1  2  3  4
    // 
    // would be represented by the array
    //
    //    [ [1,2], [2,3], [3,3], [4,3] ]
    //
    
    BarRenderer.respondsTo("dataPoint", function (datap) {
        if (this.isMissing(datap)) {
            return;
        }

        var settings = this.settings(),
            context  = settings.context,
            p  = this.transformPoint(datap),
            x0 = p[0] + settings.baroffset,
            x1 = p[0] + settings.baroffset + settings.barpixelwidth;

        context.save();
        context.fillStyle = this.getOptionValue("fillcolor", datap[1]).getHexString("#");
        context.fillRect(x0, settings.barpixelbase, settings.barpixelwidth, p[1] - settings.barpixelbase);
        context.restore();

        if (settings.barpixelwidth > settings.hidelines) {
            if (settings.prevCorner === null) {
                settings.currentBarGroup = [ [x0,p[1]] ];
            } else {
                if (Math.abs(x0 - settings.prevCorner[0]) <= settings.pixelEdgeTolerance) {
                    settings.currentBarGroup.push( [x0,p[1]] );
                } else {
                    settings.currentBarGroup.push( settings.prevCorner );
                    settings.barGroups.push( settings.currentBarGroup );
                    settings.currentBarGroup = [ [x0,p[1]] ];
                }
            }
            settings.prevCorner = [x1,p[1]];
        }
    });
    
    BarRenderer.respondsTo("end", function () {
        var settings     = this.settings(),
            context      = settings.context,
            barpixelbase = settings.barpixelbase,
            max = Math.max,
            min = Math.min,
            p,
            barGroup,
            i, j, n;

        if (settings.prevCorner !== null && settings.currentBarGroup !== null) {
            settings.currentBarGroup.push( settings.prevCorner );
            settings.barGroups.push( settings.currentBarGroup );
        }        

        context.save();
        context.strokeStyle = settings.linecolor.getHexString("#");
        context.beginPath();
        for (i = 0; i < settings.barGroups.length; i++) {
            barGroup = settings.barGroups[i];
            n = barGroup.length;
            if (n < 2) { return; } // this should never happen
            
            // For the first point, draw 3 lines:
            //
            //       y |------
            //         |
            //         |
            //    base |------
            //         ^     ^
            //         x     x(next)
            //
            
            //   horizontal line @ y from x(next) to x
            context.moveTo(barGroup[1][0], barGroup[0][1]);
            context.lineTo(barGroup[0][0], barGroup[0][1]);
            //   vertical line @ x from y to base
            context.lineTo(barGroup[0][0], barpixelbase);
            //   horizontal line @ base from x to x(next)
            context.lineTo(barGroup[1][0], barpixelbase);
            
            for (j = 1; j < n - 1; ++j) {
                // For intermediate points, draw 3 lines:
                //
                //       y |
                //         |
                //         |
                //         |------ y(next)
                //         |
                //         |
                //         |------ base
                //         ^     ^
                //         x     x(next)
                //
                //   vertical line @ x from min to max of (y, y(next), base)
                context.moveTo(barGroup[j][0], min(barGroup[j-1][1], barGroup[j][1], barpixelbase));
                context.lineTo(barGroup[j][0], max(barGroup[j-1][1], barGroup[j][1], barpixelbase));
                //   horizontal line @ y(next) from x to x(next)
                context.moveTo(barGroup[j][0],   barGroup[j][1]);
                context.lineTo(barGroup[j+1][0], barGroup[j][1]);
                //   horizontal line @ base from x to x(next)
                context.moveTo(barGroup[j][0],   barpixelbase);
                context.lineTo(barGroup[j+1][0], barpixelbase);
            }
            // For last point, draw one line:
            //
            //       y |
            //         |
            //         |
            //    base |
            //         ^     ^
            //         x     x(next)
            //
            //   vertical line @ x from base to y
            context.moveTo(barGroup[n-1][0], barGroup[n-1][1]);
            context.lineTo(barGroup[n-1][0], barpixelbase);
        }
        context.stroke();
        context.restore();
    });

    BarRenderer.respondsTo("renderLegendIcon", function (context, x, y, icon) {
        var settings          = this.settings(),
            rendererFillColor = this.getOptionValue("fillcolor", 0).toRGBA(this.getOptionValue("fillopacity", 0));

        context.save();
        context.transform(1, 0, 0, 1, x, y);

        // Draw icon background (with opacity)
        context.fillStyle = "rgba(255, 255, 255, 1)";
        context.fillRect(0, 0, icon.width(), icon.height());

        context.lineWidth = 1;
        context.fillStyle = rendererFillColor;

        if (settings.barpixelwidth < settings.hidelines) {
            context.strokeStyle = rendererFillColor;
        } else {
            context.strokeStyle = this.getOptionValue("linecolor", 0).toRGBA();
        }

        // Adjust the width of the icons bars based upon the width and height of the icon Ranges: {20, 10, 0}
        var iconWidth = icon.width(),
            iconHeight = icon.height(),
            barwidth;
        if (iconWidth > 20 || iconHeight > 20) {
            barwidth = iconWidth / 6;
        } else if (iconWidth > 10 || iconHeight > 10) {
            barwidth = iconWidth / 4;
        } else {
            barwidth = iconWidth / 4;
        }

        // If the icon is large enough draw extra bars
        if (iconWidth > 20 && iconHeight > 20) {
            context.fillRect(   (iconWidth / 4) - (barwidth / 2),             0, barwidth, iconHeight / 2);
            context.strokeRect( (iconWidth / 4) - (barwidth / 2),             0, barwidth, iconHeight / 2);

            context.fillRect(   iconWidth - (iconWidth / 4) - (barwidth / 2), 0, barwidth, iconHeight / 3);
            context.strokeRect( iconWidth - (iconWidth / 4) - (barwidth / 2), 0, barwidth, iconHeight / 3);
        }

        context.fillRect(       (iconWidth / 2) - (barwidth / 2),             0, barwidth, iconHeight - (iconHeight / 4));
        context.strokeRect(     (iconWidth / 2) - (barwidth / 2),             0, barwidth, iconHeight - (iconHeight / 4));

        context.restore();
    });
    
    return BarRenderer;
};


},{"../../../core/renderers/bar_renderer.js":61}],95:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function() {
    var FillRenderer = require('../../../core/renderers/fill_renderer.js'),
        mathUtil = require('../../../math/util.js');

    if (_INCLUDED) { return FillRenderer; }
    _INCLUDED = true;

    // cached state object, for quick access during rendering, populated in begin() method:
    FillRenderer.hasA("state");

    FillRenderer.respondsTo("begin", function (context) {
        var state = {
            "context"            : context,
            "run"                : [],
            "previouspoint"      : null,
            "linecolor"          : this.getOptionValue("linecolor"),
            "linewidth"          : this.getOptionValue("linewidth"),
            "fillcolor"          : this.getOptionValue("fillcolor"),
            "downfillcolor"      : this.getOptionValue("downfillcolor"),
            "fillopacity"        : this.getOptionValue("fillopacity"),
            "fillbase"           : this.getOptionValue("fillbase"),
            "currentfillcolor"   : null
        };
        if (state.downfillcolor === null) {
            state.downfillcolor = state.fillcolor;
        }
        if (state.fillbase !== null) {
            state.fillpixelbase = this.plot().verticalaxis().dataValueToAxisValue(state.fillbase);
        } else {
            state.fillpixelbase = 0;
        }

        this.state(state);

        context.save();
        context.fillStyle = state.fillcolor.getHexString("#");
    });

    // This renderer's dataPoint() method works by accumulating
    // and drawing one "run" of data points at a time.  A "run" of
    // points consists of a consecutive sequence of non-missing
    // data points which have the same fill color.  (The fill
    // color can change if the data line crosses the fill base
    // line, if the downfillcolor is different from the
    // fillcolor.)
    FillRenderer.respondsTo("dataPoint", function (datap) {
        var state = this.state(),
            fillpixelbase = state.fillpixelbase,
            fillcolor,
            linecolor,
            p;

        // if this is a missing point, and if it's not the first point, end the current run and render it
        if (this.isMissing(datap)) {
            if (state.previouspoint !== null) {
                state.run.push( [state.previouspoint[0], fillpixelbase] );
                this.renderRun();
                state.run = [];
                state.previouspoint = null;
            }
            return;
        }

        // transform point to pixel coords
        p = this.transformPoint(datap);

        // set the fillcolor and linecolor for this data point, based on whether it's above
        // or below the base line
        if (p[1] >= fillpixelbase) {
            fillcolor = state.fillcolor;
        } else {
            fillcolor = state.downfillcolor;
        }

        // if we're starting a new run, start with this data point's base line projection
        if (state.run.length === 0) {
            state.run.push( [p[0], fillpixelbase] );
        } else {
            // if we're not starting a new run, but the fill color
            // has changed, interpolate to find the exact base
            // line crossing point, end the current run with that
            // point, render it, and start a new run with the
            // crossing point.
            if (!fillcolor.eq(state.currentfillcolor)) {
                var x = mathUtil.safe_interp(fillpixelbase, state.previouspoint[1], p[1], state.previouspoint[0], p[0]);
                // base line crossing point is [x, state.fillpixelbase]
                // These points are pushed twice so the outline of the fill will be drawn properly,
                // otherwise the outline would not be drawn around the segments that cross the baseline.
                state.run.push( [x, fillpixelbase] );
                state.run.push( [x, fillpixelbase] );
                this.renderRun();
                state.run = [];
                state.run.push( [x, fillpixelbase] );
                state.run.push( [x, fillpixelbase] );
            }
        }

        // add this point to the current run, and remember it and the current colors for next time
        state.run.push(p);
        state.previouspoint = p;
        state.currentfillcolor = fillcolor;
    });

    FillRenderer.respondsTo("end", function () {
        var state = this.state(),
            context = state.context;
        if (state.run.length > 0) {
            state.run.push( [state.run[state.run.length-1][0], state.fillpixelbase] );
            this.renderRun();
        }
        context.restore();
    });

    // Render the current run of data points.  This consists of drawing the fill region
    // under the points, and the lines connecting the points.  The first and last points
    // in the run array are always on the base line; the points in between these two
    // are the actual data points.
    FillRenderer.respondsTo("renderRun", function () {
        var state = this.state(),
            context = state.context,
            i;

        // fill the run
        context.save();
        context.globalAlpha = state.fillopacity;
        context.fillStyle = state.currentfillcolor.getHexString("#");
        context.beginPath();
        context.moveTo(state.run[0][0], state.run[0][1]);
        for (i = 1; i < state.run.length; ++i) {
            context.lineTo(state.run[i][0], state.run[i][1]);
        }
        context.fill();
        context.restore();

        // stroke the run
        context.save();
        context.strokeStyle = state.linecolor.getHexString("#");
        context.lineWidth = state.linewidth;
        context.beginPath();
        context.moveTo(state.run[1][0], state.run[1][1]);
        for (i = 2; i < state.run.length-1; ++i) {
            context.lineTo(state.run[i][0], state.run[i][1]);
        }
        context.stroke();
        context.restore();
    });

    FillRenderer.respondsTo("renderLegendIcon", function (context, x, y, icon) {
        var state = this.state(),
            iconWidth = icon.width(),
            iconHeight = icon.height();
        
        context.save();
        context.transform(1, 0, 0, 1, x, y);

        context.save();
        // Draw icon background (with opacity)
        if (iconWidth < 10 || iconHeight < 10) {
            context.fillStyle = state.fillcolor.toRGBA();
        } else {
            context.fillStyle = "rgba(255, 255, 255, 1)";
        }
        context.fillRect(0, 0, iconWidth, iconHeight);
        context.restore();

        context.strokeStyle = state.linecolor.toRGBA();
        context.lineWidth   = state.linewidth;
        context.fillStyle   = state.fillcolor.toRGBA(state.fillopacity);

        context.beginPath();
        context.moveTo(0, 0);
        // Draw the middle range icon or the large range icon if the width and height allow it
        if (iconWidth > 10 || iconHeight > 10) {
            // Draw a more complex icon if the icons width and height are large enough
            if (iconWidth > 20 || iconHeight > 20) {
                context.lineTo(iconWidth / 6, iconHeight / 2);
                context.lineTo(iconWidth / 3, iconHeight / 4);
            }
            context.lineTo(iconWidth / 2, iconHeight - iconHeight / 4);

            if (iconWidth > 20 || iconHeight > 20) {
                context.lineTo(iconWidth - iconWidth / 3, iconHeight / 4);
                context.lineTo(iconWidth - iconWidth / 6, iconHeight / 2);
            }
        }
        context.lineTo(iconWidth, 0);
        context.stroke();
        context.fill();

        context.restore();
    });

    return FillRenderer;
};

},{"../../../core/renderers/fill_renderer.js":62,"../../../math/util.js":108}],96:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function() {
    var PointlineRenderer = require('../../../core/renderers/pointline_renderer.js'),
        Renderer = require('../../../core/renderer.js');

    if (_INCLUDED) { return PointlineRenderer; }
    _INCLUDED = true;

    // cached settings object, for quick access during rendering, populated in begin() method:
    PointlineRenderer.hasA("settings");

    PointlineRenderer.respondsTo("begin", function (context) {
        var settings = {
            "context"            : context,
            "points"             : [],
            "first"              : true,
            "pointshape"         : this.getOptionValue("pointshape"),
            "pointcolor"         : this.getOptionValue("pointcolor"),
            "pointopacity"       : this.getOptionValue("pointopacity"),
            "pointsize"          : this.getOptionValue("pointsize"),
            "pointoutlinewidth"  : this.getOptionValue("pointoutlinewidth"),
            "pointoutlinecolor"  : this.getOptionValue("pointoutlinecolor"),
            "linestroke"         : this.getOptionValue("linestroke"),
            "linecolor"          : this.getOptionValue("linecolor"),
            "linewidth"          : this.getOptionValue("linewidth")
        };

        // turns off points for line renderers
        if (this.type() === Renderer.LINE) {
            settings.pointsize = 0;
        }
        // turns off lines for point renderers
        if (this.type() === Renderer.POINT) {
            settings.linewidth = 0;
        }
        this.settings(settings);

        if (settings.linewidth > 0) {
            context.save();
            context.beginPath();
            if (settings.linestroke === PointlineRenderer.DASHED) {
                context.setLineDash([5,5]);
            }
            context.lineWidth = settings.linewidth;
            context.strokeStyle = settings.linecolor.getHexString("#");
        }

        if (this.filter()) {
            this.filter().reset();
        }
    });
    PointlineRenderer.respondsTo("dataPoint", function (datap) {
        var settings = this.settings(),
            context  = settings.context,
            p;
        if (this.isMissing(datap)) {
            settings.first = true;
            return;
        }
        p = this.transformPoint(datap);
        if (this.filter()) {
            if (this.filter().filter(datap, p)) {
                return;
            }
        }
        if (settings.linewidth > 0) {
            if (settings.first) {
                context.moveTo(p[0], p[1]);
                settings.first = false;
            } else {
                context.lineTo(p[0], p[1]);
            }
        }
        if (settings.pointsize > 0) {
            settings.points.push(p);
        }
    });

    PointlineRenderer.respondsTo("end", function () {
        var settings = this.settings(),
            context  = settings.context;
        if (settings.linewidth > 0) {
            context.stroke();
            context.restore();
        }
        if (settings.pointsize > 0) {
            this.drawPoints();
        }
    });


    PointlineRenderer.respondsTo("drawPoints", function (p) {
        var settings   = this.settings(),
            context    = settings.context,
            points     = settings.points,
            pointshape = settings.pointshape,
            i;

        context.save();
        context.beginPath();
        if ((pointshape === PointlineRenderer.PLUS) || (pointshape === PointlineRenderer.X)) {
            context.strokeStyle = settings.pointcolor.getHexString("#");
            context.lineWidth = settings.pointoutlinewidth;
        } else {
            context.fillStyle = settings.pointcolor.toRGBA(settings.pointopacity);
            context.strokeStyle = settings.pointoutlinecolor.getHexString("#");
            context.lineWidth = settings.pointoutlinewidth;
        }

        for (i=0; i<points.length; ++i) {
            this.drawPoint(context, settings, points[i]);
        }

        if (!((pointshape === PointlineRenderer.PLUS) || (pointshape === PointlineRenderer.X))) {
            context.fill();
        }
        context.stroke();
        context.restore();
    });

    PointlineRenderer.respondsTo("drawPoint", function (context, settings, p) {
        var pointsize = settings.pointsize,
            p0 = p[0],
            p1 = p[1],
            a,b,d;

        switch (settings.pointshape) {
        case PointlineRenderer.PLUS:
            context.moveTo(p0,             p1 - pointsize);
            context.lineTo(p0,             p1 + pointsize);
            context.moveTo(p0 - pointsize, p1);
            context.lineTo(p0 + pointsize, p1);
            return;
        case PointlineRenderer.X:
            d = 0.70710 * pointsize;
            context.moveTo(p0-d, p1-d);
            context.lineTo(p0+d, p1+d);
            context.moveTo(p0-d, p1+d);
            context.lineTo(p0+d, p1-d);
            return;
        case PointlineRenderer.SQUARE:
            context.moveTo(p0 - pointsize, p1 - pointsize);
            context.lineTo(p0 + pointsize, p1 - pointsize);
            context.lineTo(p0 + pointsize, p1 + pointsize);
            context.lineTo(p0 - pointsize, p1 + pointsize);
            return;
        case PointlineRenderer.TRIANGLE:
            d = 1.5 * pointsize;
            a = 0.866025 * d;
            b = 0.5 * d;
            context.moveTo(p0,     p1 + d);
            context.lineTo(p0 + a, p1 - b);
            context.lineTo(p0 - a, p1 - b);
            return;
        case PointlineRenderer.DIAMOND:
            d = 1.5 * pointsize;
            context.moveTo(p0 - pointsize, p1);
            context.lineTo(p0,             p1 + d);
            context.lineTo(p0 + pointsize, p1);
            context.lineTo(p0,             p1 - d);
            return;
        case PointlineRenderer.STAR:
            d = 1.5 * pointsize;
            context.moveTo(p0 - d*0.0000, p1 + d*1.0000);
            context.lineTo(p0 + d*0.3536, p1 + d*0.3536);
            context.lineTo(p0 + d*0.9511, p1 + d*0.3090);
            context.lineTo(p0 + d*0.4455, p1 - d*0.2270);
            context.lineTo(p0 + d*0.5878, p1 - d*0.8090);
            context.lineTo(p0 - d*0.0782, p1 - d*0.4938);
            context.lineTo(p0 - d*0.5878, p1 - d*0.8090);
            context.lineTo(p0 - d*0.4938, p1 - d*0.0782);
            context.lineTo(p0 - d*0.9511, p1 + d*0.3090);
            context.lineTo(p0 - d*0.2270, p1 + d*0.4455);
            return;
        case PointlineRenderer.CIRCLE:
            context.moveTo(p0 + pointsize, p1);
            context.arc(p0, p1, pointsize, 0, 2*Math.PI, false);
            return;
        }
    });

    PointlineRenderer.respondsTo("renderLegendIcon", function (context, x, y, icon) {
        var settings   = this.settings(),
            pointshape = settings.pointshape,
            iconWidth  = icon.width(),
            iconHeight = icon.height();

        context.save();
        // Draw icon background (with opacity)
        context.fillStyle = "rgba(255, 255, 255, 1)";
        context.fillRect(x, y, iconWidth, iconHeight);

        if (settings.linewidth > 0) {
            context.strokeStyle = settings.linecolor.toRGBA();
            context.lineWidth   = settings.linewidth;
            context.beginPath();
            context.moveTo(x, y + iconHeight/2);
            context.lineTo(x + iconWidth, y + iconHeight/2);
            context.stroke();
        }
        if (settings.pointsize > 0) {
            context.beginPath();
            if ((pointshape === PointlineRenderer.PLUS) || (pointshape === PointlineRenderer.X)) {
                context.strokeStyle = settings.pointcolor.toRGBA();
                context.lineWidth   = settings.pointoutlinewidth;
            } else {
                context.fillStyle   = settings.pointcolor.toRGBA(settings.pointopacity);
                context.strokeStyle = settings.pointoutlinecolor.toRGBA();
                context.lineWidth   = settings.pointoutlinewidth;
            }

            this.drawPoint(context, settings, [(x + iconWidth/2), (y + iconHeight/2)]);

            if (!((pointshape === PointlineRenderer.PLUS) || (pointshape === PointlineRenderer.X))) {
                context.fill();
            }
            context.stroke();
        }
        context.restore();
    });

    return PointlineRenderer;
};

},{"../../../core/renderer.js":58,"../../../core/renderers/pointline_renderer.js":63}],97:[function(require,module,exports){
var _INCLUDED = false;
module.exports = function() {
    var RangeBarRenderer = require('../../../core/renderers/rangebar_renderer.js');

    if (_INCLUDED) { return RangeBarRenderer; }
    _INCLUDED = true;

    // cached state object, for quick access during rendering, populated in begin() method:
    RangeBarRenderer.hasA("state");

    RangeBarRenderer.respondsTo("begin", function (context) {
        var state = {
            "context"            : context,
            "run"                : [],
            "barpixelwidth"      : this.getOptionValue("barwidth").getRealValue() * this.plot().horizontalaxis().axisToDataRatio(),
            "barpixeloffset"     : 0,
            "baroffset"          : this.getOptionValue("baroffset"),
            "fillcolor"          : this.getOptionValue("fillcolor"),
            "fillopacity"        : this.getOptionValue("fillopacity"),
            "linecolor"          : this.getOptionValue("linecolor"),
            "linewidth"          : this.getOptionValue("linewidth"),
            "hidelines"          : this.getOptionValue("hidelines")
        };
        state.barpixeloffset = state.barpixelwidth * state.baroffset;
        this.state(state);
        context.save();
        context.beginPath();
    });

    RangeBarRenderer.respondsTo("dataPoint", function (datap) {
        if (this.isMissing(datap)) {
            return;
        }

        var state = this.state(),
            context = state.context,
            p = this.transformPoint(datap),
            x0 = p[0] - state.barpixeloffset,
            x1 = x0 + state.barpixelwidth;

        context.moveTo(x0, p[1]);
        context.lineTo(x0, p[2]);
        context.lineTo(x1, p[2]);
        context.lineTo(x1, p[1]);
        context.lineTo(x0, p[1]);
    });

    RangeBarRenderer.respondsTo("end", function () {
        var state = this.state(),
            context = state.context;

        context.globalAlpha = state.fillopacity;
        context.fillStyle = state.fillcolor.getHexString("#");
        context.fill();
        if (state.linewidth > 0 && state.barpixelwidth > state.hidelines) {
            context.strokeStyle = state.linecolor.getHexString("#");
            context.lineWidth = state.linewidth;
            context.stroke();
        }
        context.restore();
    });

    RangeBarRenderer.respondsTo("renderLegendIcon", function (context, x, y, icon) {
        var state = this.state(),
            iconWidth  = icon.width(),
            iconHeight = icon.height(),
            barwidth;

        context.save();
        context.transform(1, 0, 0, 1, x, y);

        // Draw icon background (with opacity)
        context.save();
        context.strokeStyle = "#FFFFFF";
        context.fillStyle = "#FFFFFF";
        context.fillRect(0, 0, iconWidth, iconHeight);
        context.restore();

        // Draw icon graphics
        context.fillStyle = state.fillcolor.toRGBA(state.fillopacity);
        context.lineWidth = state.linewidth;
        if (state.barpixelwidth < 10) {
            context.strokeStyle = state.fillcolor.toRGBA(state.fillopacity);
        } else {
            context.strokeStyle = state.linecolor.getHexString("#");
        }

        // Adjust the width of the icons bars based upon the width and height of the icon Ranges: {20, 10, 0}
        if (iconWidth > 20 || iconHeight > 20) {
            barwidth = iconWidth / 6;
        } else if(iconWidth > 10 || iconHeight > 10) {
            barwidth = iconWidth / 4;
        } else {
            barwidth = iconWidth / 4;
        }

        // If the icon is large enough draw extra bars
        if (iconWidth > 20 && iconHeight > 20) {
            context.fillRect(  iconWidth/4 - barwidth/2,             iconHeight/8, barwidth, iconHeight/2);
            context.strokeRect(iconWidth/4 - barwidth/2,             iconHeight/8, barwidth, iconHeight/2);

            context.fillRect(  iconWidth - iconWidth/4 - barwidth/2, iconHeight/4, barwidth, iconHeight/3);
            context.strokeRect(iconWidth - iconWidth/4 - barwidth/2, iconHeight/4, barwidth, iconHeight/3);
        }

        context.fillRect(  iconWidth/2 - barwidth/2, 0, barwidth, iconHeight-iconHeight/4);
        context.strokeRect(iconWidth/2 - barwidth/2, 0, barwidth, iconHeight-iconHeight/4);

        context.restore();
    });

    return RangeBarRenderer;
};

},{"../../../core/renderers/rangebar_renderer.js":64}],98:[function(require,module,exports){
module.exports = function() {
    var Text = require('../../core/text.js');

    if (typeof(Text.drawText)==="function") { return Text; }

    Text.respondsTo("initializeGeometry", function (graphicsContext) {
        var origWidth,
            origHeight,
            rotatedWidth,
            rotatedHeight;

        graphicsContext.context.save();
        if (this.font() !== "") {
            // the new way: use the "font" property
            graphicsContext.context.font = this.font();
        } else if (graphicsContext.fontSize !== undefined) {
            // the old way, for backward compatibility ("fontSize" property of graphics context object):
            graphicsContext.context.font = graphicsContext.fontSize + " sans-serif";
        }

        origWidth  = this.measureStringWidth(graphicsContext.context);
        origHeight = this.measureStringHeight(graphicsContext.context);

        graphicsContext.context.restore();

        if (graphicsContext.angle !== undefined) {
            var angle = graphicsContext.angle/180 * Math.PI;
            rotatedWidth = Math.abs(Math.cos(angle)) * origWidth + Math.abs(Math.sin(angle)) * origHeight;
            rotatedHeight = Math.abs(Math.sin(angle)) * origWidth + Math.abs(Math.cos(angle)) * origHeight;
        } else {
            rotatedWidth = origWidth;
            rotatedHeight = origHeight;
        }

        this.origWidth(origWidth);
        this.origHeight(origHeight);
        this.rotatedWidth(rotatedWidth);
        this.rotatedHeight(rotatedHeight);

        return this;
    });

    /**
     * Determines unrotated width for the stored string in the canvas environment.
     *
     * @method measureStringWidth
     * @for Text
     * @private
     * @return {Float} Unrotated width of string.
     * @param {Context} context
     */
    Text.respondsTo("measureStringWidth", function (context) {
        if (this.string() === undefined) {
            throw new Error("measureStringWidth requires the string attr to be set.");
        }

        var metrics = context.measureText(this.string());
        return metrics.width;
    });

    /**
     * Determines unrotated height for the stored string in the canvas environment.
     *
     * @method measureStringHeight
     * @for Text
     * @private
     * @return {Float} Unrotated height of string.
     * @param {Context} context
     */
    Text.respondsTo("measureStringHeight", function (context) {
        if (this.string() === undefined) {
            throw new Error("measureStringHeight requires the string attr to be set.");
        }

        //NOTE: kludge: canvas cannot exactly measure text height, so we just return a value
        //      estimated by using the width of an "M" as a substitute.  Maybe improve this
        //      later by using a better workaround.
        var metrics = context.measureText("M"),
            newlineCount = this.string().match(/\n/g);
        return (newlineCount !== null ? (newlineCount.length + 1) : 1) * metrics.width;
    });

    Text.respondsTo("setTransform", function (context, anchor, base, position, angle) {
        context.transform(1, 0, 0, -1, 0, 2 * base.y());
        context.transform(1, 0, 0, 1, base.x(), base.y());
        context.transform(1, 0, 0, 1, position.x(), -position.y());
        context.rotate(-angle * Math.PI/180.0);
        context.transform(1, 0, 0, 1, -anchor.x(), anchor.y());
    });

    Text.respondsTo("drawText", function (context, anchor, base, position, angle) {
        context.save();
        this.setTransform(context, anchor, base, position, angle);
        if (this.font() !== "") {
            context.font = this.font();
        }
        context.fillText(this.string(), 0, 0);
        context.restore();
    });

    return Text;
};

},{"../../core/text.js":65}],99:[function(require,module,exports){
module.exports = function() {
    var Window = require('../../core/window.js');

    if (typeof(Window.render)==="function") { return Window; }

    Window.respondsTo("render", function (context, width, height) {
        var m = this.margin().left();

        context.save();
        context.fillStyle = this.bordercolor().getHexString("#");
        context.fillRect(m, m, width - 2*m, height - 2*m);
        context.restore();
    });

    return Window;
};

},{"../../core/window.js":71}],100:[function(require,module,exports){
require('../lib/jquery/jquery.min.js');
require('./main.js');

},{"../lib/jquery/jquery.min.js":13,"./main.js":101}],101:[function(require,module,exports){
require('../lib/ajaxthrottle/src/ajaxthrottle.js');
require('../lib/lightbox/lightbox.js');
require('../lib/jquery/jquery.mousewheel.js');
require('../lib/busy-spinner/busy_spinner.js');
require('../lib/error-display/build/errorDisplay.js');
require('../lib/requestanimationframe/requestanimationframe.js');

require('./parser/xml/jquery_xml_parser.js')($);
require('./parser/json/json_parser.js')($);
require('./graphics/canvas/all.js')($, window);

// This forces ./events/multigraph.js to load, which is where the 'main' program
// really lives --- i.e. installation of the Multigraph jQuery plugin, and the
// $(document).ready(...) stuff that springs into action once the page has loaded.
// Note that the 3rd arg to require('./events/multigraph.js') is unused.
require('./events/multigraph.js')($, window, undefined);

// For JS applications that want to use the bundled multigraph file, instead of
// referencing Multigraph through npm-style require statements, and for backward
// compatibility with pre-npm versions of Multigraph, create the globael
// window.multigraph object which exposes a bunch of objects/functions from the
// Multigraph code.
var Multigraph = require('./core/multigraph.js')($);
var utilityFunctions = require('./util/utilityFunctions.js');
var parsingFunctions = require('./util/parsingFunctions.js');
var validationFunctions = require('./util/validationFunctions.js');

window.multigraph = {
    'core' : {
        'Multigraph':                	Multigraph,
        'CSVData':                		require('./core/csv_data.js')($),
        'WebServiceData':             	require('./core/web_service_data.js')($),

        'ArrayData':                    require('./core/array_data.js'),
        'Axis':                         require('./core/axis.js'),
        'AxisBinding':                  require('./core/axis_binding.js'),
        'AxisTitle':                    require('./core/axis_title.js'),
        'Background':                   require('./core/background.js'),
        'ConstantPlot':                 require('./core/constant_plot.js'),
        'Data':                         require('./core/data.js'),
        'DataFormatter':                require('./core/data_formatter.js'),
        'DataMeasure':                  require('./core/data_measure.js'),
        'DataPlot':                     require('./core/data_plot.js'),
        'DataValue':                    require('./core/data_value.js'),
        'DataVariable':                 require('./core/data_variable.js'),
        'Datatips':                     require('./core/datatips.js'),
        'DatatipsVariable':             require('./core/datatips_variable.js'),
        'DatetimeFormatter':            require('./core/datetime_formatter.js'),
        'DatetimeMeasure':              require('./core/datetime_measure.js'),
        'DatetimeValue':                require('./core/datetime_value.js'),
        'EventEmitter':                 require('./core/event_emitter.js'),
        'FilterOption':                 require('./core/filter_option.js'),
        'Filter':                       require('./core/filter.js'),
        'Graph':                        require('./core/graph.js'),
        'Grid':                         require('./core/grid.js'),
        'Icon':                         require('./core/icon.js'),
        'Img':                          require('./core/img.js'),
        'Labeler':                      require('./core/labeler.js'),
        'Legend':                       require('./core/legend.js'),
        'Mixin':                        require('./core/mixin.js'),
        'NumberFormatter':              require('./core/number_formatter.js'),
        'NumberMeasure':                require('./core/number_measure.js'),
        'NumberValue':                  require('./core/number_value.js'),
        'Pan':                          require('./core/pan.js'),
        'PeriodicArrayData':            require('./core/periodic_array_data.js'),
        'Plot':                         require('./core/plot.js'),
        'PlotLegend':                   require('./core/plot_legend.js'),
        'Plotarea':                     require('./core/plotarea.js'),
        'Renderer':                     require('./core/renderer.js'),
        'BandRenderer':                 require('./core/renderers/band_renderer.js'),
        'BarRenderer':                  require('./core/renderers/bar_renderer.js'),
        'FillRenderer':                 require('./core/renderers/fill_renderer.js'),
        'PointlineRenderer':            require('./core/renderers/pointline_renderer.js'),
        'RangeBarRenderer':             require('./core/renderers/rangebar_renderer.js'),
        'Text':                         require('./core/text.js'),
        'Title':                        require('./core/title.js'),
        'Warning':                      require('./core/warning.js'),
        'WebServiceDataCacheNode':      require('./core/web_service_data_cache_node.js'),
        'WebServiceDataIterator':       require('./core/web_service_data_iterator.js'),
        'Window':                       require('./core/window.js'),
        'Zoom':                         require('./core/zoom.js'),

        'browserHasCanvasSupport' : Multigraph.browserHasCanvasSupport,
        'browserHasSVGSupport'    : Multigraph.browserHasSVGSupport
    },

    'create': Multigraph.create,

    'math': {
        'Box': 				require('./math/box.js'),
        'Displacement': 	require('./math/displacement.js'),
        'Enum': 			require('./math/enum.js'),
        'Insets': 			require('./math/insets.js'),
        'Point': 			require('./math/point.js'),
        'RGBColor': 		require('./math/rgb_color.js'),
        'util': 			require('./math/util.js')
    },
    'parser' : {
        'jquery' : {
            'stringToJQueryXMLObj' : (require('./parser/xml/jquery_xml_parser.js')($)).stringToJQueryXMLObj
        }
    },

    'utilityFunctions' : {
        'getKeys' 					: utilityFunctions.getKeys,
        'insertDefaults' 			: utilityFunctions.insertDefaults,
        'getDefaultValuesFromXSD' 	: utilityFunctions.getDefaultValuesFromXSD,
        
        'parseAttribute' 			: parsingFunctions.parseAttribute,
        'parseInteger' 				: parsingFunctions.parseInteger,
        'parseBoolean' 				: parsingFunctions.parseBoolean,
        'getXMLAttr' 				: parsingFunctions.getXMLAttr,
        
        'validateNumberRange' 		: validationFunctions.validateNumberRange,
        'typeOf' 					: validationFunctions.typeOf
    },

    'jermaine': require('../lib/jermaine/src/jermaine.js'),

    'jQuery' : $
};
window.sprintf = require('sprintf');

},{"../lib/ajaxthrottle/src/ajaxthrottle.js":1,"../lib/busy-spinner/busy_spinner.js":2,"../lib/error-display/build/errorDisplay.js":3,"../lib/jermaine/src/jermaine.js":9,"../lib/jquery/jquery.mousewheel.js":14,"../lib/lightbox/lightbox.js":15,"../lib/requestanimationframe/requestanimationframe.js":16,"./core/array_data.js":18,"./core/axis.js":19,"./core/axis_binding.js":20,"./core/axis_title.js":21,"./core/background.js":22,"./core/constant_plot.js":25,"./core/csv_data.js":26,"./core/data.js":27,"./core/data_formatter.js":28,"./core/data_measure.js":29,"./core/data_plot.js":30,"./core/data_value.js":31,"./core/data_variable.js":32,"./core/datatips.js":33,"./core/datatips_variable.js":34,"./core/datetime_formatter.js":35,"./core/datetime_measure.js":36,"./core/datetime_value.js":38,"./core/event_emitter.js":39,"./core/filter.js":40,"./core/filter_option.js":41,"./core/graph.js":42,"./core/grid.js":43,"./core/icon.js":44,"./core/img.js":45,"./core/labeler.js":46,"./core/legend.js":47,"./core/mixin.js":48,"./core/multigraph.js":49,"./core/number_formatter.js":50,"./core/number_measure.js":51,"./core/number_value.js":52,"./core/pan.js":53,"./core/periodic_array_data.js":54,"./core/plot.js":55,"./core/plot_legend.js":56,"./core/plotarea.js":57,"./core/renderer.js":58,"./core/renderers/band_renderer.js":60,"./core/renderers/bar_renderer.js":61,"./core/renderers/fill_renderer.js":62,"./core/renderers/pointline_renderer.js":63,"./core/renderers/rangebar_renderer.js":64,"./core/text.js":65,"./core/title.js":66,"./core/warning.js":67,"./core/web_service_data.js":68,"./core/web_service_data_cache_node.js":69,"./core/web_service_data_iterator.js":70,"./core/window.js":71,"./core/zoom.js":72,"./events/multigraph.js":77,"./graphics/canvas/all.js":81,"./math/box.js":102,"./math/displacement.js":103,"./math/enum.js":104,"./math/insets.js":105,"./math/point.js":106,"./math/rgb_color.js":107,"./math/util.js":108,"./parser/json/json_parser.js":121,"./parser/xml/jquery_xml_parser.js":146,"./util/parsingFunctions.js":158,"./util/utilityFunctions.js":159,"./util/validationFunctions.js":160,"sprintf":17}],102:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Box = new jermaine.Model("Box", function () {
    this.hasA("width").which.isA("number");
    this.hasA("height").which.isA("number");
    this.isBuiltWith("width", "height");
});
    
module.exports = Box;

},{"../../lib/jermaine/src/jermaine.js":9}],103:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js'),
    validationFunctions = require('../util/validationFunctions.js');

var Displacement = {};
/**
 * A Displacement represents a geometric position along a line
 * segment, expressed in terms of two quantities: a relative
 * position called `a`, and an absolute offset called `b`.  The
 * length of the line segment is not known in advance --- the idea
 * is that the Displacement object encapsulates a rule for
 * determining a location along ANY line segment.  The Displacement
 * has methods which take the line segment length as an argument
 * and return the computed final position.
 *
 * There are two different position-calcuating methods,
 * corresponding to two different interpretations of the relative
 * value `a`:
 *
 * **relative length**:
 *     `a` is a number between 0 and 1, representing a fraction of
 *       the total length of the line segment; the relative
 *       position determined by `a` is the fraction `a` of the
 *       total length of the segment.
 *     In this case, the position-calculating method
 *       `calculateLength(L)` returns the number `a * L + b`, which
 *       corresponds to moving `a` of the way along the length L,
 *       then adding `b`:
 *
 *             [--------------------------------X------------]
 *             |<---- a * L --->|<---- b ------>|
 *             |<------------------  L  -------------------->|
 *
 * **relative coordinate**:
 *     `a` is a number between -1 and 1, representing a coordinate
 *       value in a [-1,1] coordinate system along the line
 *       segment.
 *     In this case, the position-calculating method
 *       `calculateCoordinate(L)` returns the number `(a+1) * L/2 +
 *       b`.  which corresponds to moving to the position
 *       determined by the `a` coordinate, then adding `b`:
 *
 *             [------------------------------------X--------]
 *             |<--- (a+1) * L/2 --->|<---- b ----->|
 *             |<------------------  L  -------------------->|
 *
 * @class Displacement
 * @for Displacement
 * @constructor
 * @param {Number} a
 * @param {Integer} b (OPTIONAL)
 */
Displacement = new jermaine.Model("Displacement", function () {
    
    this.hasA("a").which.validatesWith(function (a) {
        return validationFunctions.validateNumberRange(a, -1.0, 1.0);
    });
    this.hasA("b").which.isA("integer").and.defaultsTo(0);
    this.isBuiltWith("a", "%b");

    this.respondsTo("calculateLength", function (totalLength) {
        return this.a() * totalLength + this.b();
    });

    this.respondsTo("calculateCoordinate", function (totalLength) {
        return (this.a() + 1) * totalLength/2.0 + this.b();
    });

});

Displacement.regExp = /^([\+\-]?[0-9\.]+)([+\-])([0-9\.+\-]+)$/;

/**
 * Parses a string into a Displacement.  The string should be of one of the following forms:
 *
 *     "A+B"  ==>  a=A  b=B
 *     "A-B"  ==>  a=A  b=-B
 *     "A"    ==>  a=A  b=0
 *     "+A"   ==>  a=A  b=0
 *     "-A"   ==>  a=-A b=0
 * 
 * If the input argument is not a string, it is coerced into one.
 */
Displacement.parse = function (string) {
    if (typeof(string) !== "string") {
        string = String(string);
    }
    var ar = Displacement.regExp.exec(string),
        d,
        a,
        b,
        sign;
    if (string === undefined) {
        d = new Displacement(1);
    } else if (ar !== null) {
        a = parseFloat(ar[1]);
        b = parseFloat(ar[3]);
        switch (ar[2]) {
        case "+":
            sign = 1;
            break;
        case "-":
            sign = -1;
            break;
        default:
            sign = 0;
            break;
        }
        /*
         if (isNaN(a) || sign == 0 || isNaN(b)) {
         throw new ParseError('parse error');
         }
         */
        d = new Displacement(a, sign * b);
    } else {
        a = parseFloat(string);
        /*n
         if (isNaN(a)) {
         throw new ParseError('parse error');
         }
         */
        d = new Displacement(a);
    }
    return d;
};

module.exports = Displacement;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/validationFunctions.js":160}],104:[function(require,module,exports){
// Use Enum to create objects that act like enumerations in other languages (such as Java).
// 
// Usage is like this:
// 
//   var Suit = Enum("Suit");
//   var clubs = new Suit("clubs");
//   var diamonds = new Suit("diamonds");
//   var spades = new Suit("spades");
//   var hearts = new Suit("hearts");
// 
//   var c = Suit.parse("clubs");  # c is guaranteed to equal the clubs variable from above
// 
var Enum = function (name) {

    var instances = {};

    var Enum = function (key) {
        if (instances[key] !== undefined) {
            throw new Error("attempt to redefine "+name+" Enum with key '"+key+"'");
        }
        this.enumType = name;
        this.key = key;
        instances[key] = this;
    };

    Enum.parse = function (key) {
        return instances[key];
    };

    Enum.prototype.toString = function () {
        return this.key;
    };

    Enum.isInstance = function (obj) {
        return (obj !== undefined && obj !== null && obj.enumType === name);
    };

    return Enum;
};

module.exports = Enum;

},{}],105:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Insets = new jermaine.Model("Insets", function () {
    this.hasA("top").which.isA("number");
    this.hasA("left").which.isA("number");
    this.hasA("bottom").which.isA("number");
    this.hasA("right").which.isA("number");
    this.respondsTo("set", function (top, left, bottom, right) {
        this.top(top);
        this.left(left);
        this.bottom(bottom);
        this.right(right);
    });
    this.isBuiltWith("top", "left", "bottom", "right");
});

module.exports = Insets;

},{"../../lib/jermaine/src/jermaine.js":9}],106:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var Point = new jermaine.Model("Point", function () {
    this.hasA("x").which.isA("number");
    this.hasA("y").which.isA("number");
    this.isBuiltWith("x", "y");
    this.respondsTo("eq", function (p) {
        return ((this.x()===p.x()) && (this.y()===p.y()));
    });
});

var regExp = /^\s*([0-9\-\+\.eE]+)(,|\s+|\s*,\s+|\s+,\s*)([0-9\-\+\.eE]+)\s*$/;

Point.parse = function (string) {
    var ar = regExp.exec(string),
        p;
    // ar[1] is x value
    // ar[2] is separator between x and y
    // ar[3] is y value
    
    if (!ar || (ar.length !== 4)) {
        throw new Error("cannot parse string '"+string+"' as a Point");
    }
    return new Point(parseFloat(ar[1]), parseFloat(ar[3]));
};

module.exports = Point;


},{"../../lib/jermaine/src/jermaine.js":9}],107:[function(require,module,exports){
var jermaine = require('../../lib/jermaine/src/jermaine.js');

var validationFunctions = require('../util/validationFunctions.js');

var RGBColor = new jermaine.Model("RGBColor", function () {
    
    this.hasA("r").which.validatesWith(function (r) {
        return validationFunctions.validateNumberRange(r, 0, 1.0);
    });
    this.hasA("g").which.validatesWith(function (g) {
        return validationFunctions.validateNumberRange(g, 0, 1.0);
    });
    this.hasA("b").which.validatesWith(function (b) {
        return validationFunctions.validateNumberRange(b, 0, 1.0);
    });
    
    var numberToHex = function (number) {
        number = parseInt(number * 255, 10).toString(16);
        if (number.length === 1) {
            number = "0" + number;
        }
        return number;
    };
    
    this.respondsTo("getHexString", function (prefix) {
        if (!prefix) {
            prefix = "0x";
        }
        return prefix + numberToHex(this.r()) + numberToHex(this.g()) + numberToHex(this.b());
    });
    
    this.respondsTo("toRGBA", function (alpha) {
        if (alpha === undefined) {
            alpha = 1.0;
        }
        if (typeof(alpha) !== "number") {
            throw new Error("RGBColor.toRGBA: The argument, if present, must be a number");
        }
        return "rgba(" + (255*this.r()) + ", " + (255*this.g()) + ", " + (255*this.b()) + ", " + alpha + ")";
    });
    
    this.respondsTo("eq", function (color) {
        return ((this.r()===color.r()) && (this.g()===color.g()) && (this.b()===color.b()));
    });
    
    this.isBuiltWith("r", "g", "b");
    
});


/*
 * To remove support for deprecated color names, remove the following function,
 * and find all references to it elsewhere in the source code, and remove them,
 * along with accompanying code that generates warning message.  Also remove
 * support for these 9 color names from RGBColor.parse below.
 */
RGBColor.colorNameIsDeprecated = function (colorName) {
    switch (colorName) {
    case "grey": return "0xeeeeee";
    case "skyblue": return "0x87ceeb";
    case "khaki": return "0xf0e68c";
    case "orange": return "0xffa500";
    case "salmon": return "0xfa8072";
    case "olive": return "0x9acd32";
    case "sienna": return "0xa0522d";
    case "pink": return "0xffb5c5";
    case "violet": return "0xee82ee";
    }
    return false;
};

RGBColor.parse = function (input) {
    var red,
        green,
        blue,
        grey,
        parsedInput,
        colorObj;
    
    if (input === undefined) {
        return undefined;
    } else if (typeof(input) === "string") {
        parsedInput = input.toLowerCase();
        
        switch (parsedInput) {
        case "black":
            red = 0;
            green = 0;
            blue = 0;
            break;
        case "red":
            red = 1;
            green = 0;
            blue = 0;
            break;
        case "green":
            red = 0;
            green = 1;
            blue = 0;
            break;
        case "blue":
            red = 0;
            green = 0;
            blue = 1;
            break;
        case "yellow":
            red = 1;
            green = 1;
            blue = 0;
            break;
        case "magenta":
            red = 1;
            green = 0;
            blue = 1;
            break;
        case "cyan":
            red = 0;
            green = 1;
            blue = 1;
            break;
        case "white":
            red = 1;
            green = 1;
            blue = 1;
            break;
        case "grey":
            grey = parseInt("ee", 16) / 255;
            red = grey;
            green = grey;
            blue = grey;
            break;
        case "skyblue":
            red = parseInt("87", 16) / 255;
            green = parseInt("ce", 16) / 255;
            blue = parseInt("eb", 16) / 255;
            break;
        case "khaki":
            red = parseInt("f0", 16) / 255;
            green = parseInt("e6", 16) / 255;
            blue = parseInt("8c", 16) / 255;
            break;
        case "orange":
            red = parseInt("ff", 16) / 255;
            green = parseInt("a5", 16) / 255;
            blue = parseInt("00", 16) / 255;
            break;
        case "salmon":
            red = parseInt("fa", 16) / 255;
            green = parseInt("80", 16) / 255;
            blue = parseInt("72", 16) / 255;
            break;
        case "olive":
            red = parseInt("9a", 16) / 255;
            green = parseInt("cd", 16) / 255;
            blue = parseInt("32", 16) / 255;
            break;
        case "sienna":
            red = parseInt("a0", 16) / 255;
            green = parseInt("52", 16) / 255;
            blue = parseInt("2d", 16) / 255;
            break;
        case "pink":
            red = parseInt("ff", 16) / 255;
            green = parseInt("b5", 16) / 255;
            blue = parseInt("c5", 16) / 255;
            break;
        case "violet":
            red = parseInt("ee", 16) / 255;
            green = parseInt("82", 16) / 255;
            blue = parseInt("ee", 16) / 255;
            break;
        default:
            parsedInput = parsedInput.replace(/(0(x|X)|#)/, "");
            if (parsedInput.search(new RegExp(/([^0-9a-f])/)) !== -1) {
                throw new Error("'" + input + "' is not a valid color");
            }
            
            if (parsedInput.length === 6) {
                red = parseInt(parsedInput.substring(0,2), 16) / 255;
                green = parseInt(parsedInput.substring(2,4), 16) / 255;
                blue = parseInt(parsedInput.substring(4,6), 16) / 255;
            } else if (parsedInput.length === 3) {
                red = parseInt(parsedInput.charAt(0), 16) / 15;
                green = parseInt(parsedInput.charAt(1), 16) / 15;
                blue = parseInt(parsedInput.charAt(2), 16) / 15;
            } else {
                throw new Error("'" + input + "' is not a valid color");
            }
            break;
        }
        colorObj = new RGBColor(red, green, blue);
        return colorObj;
    }
    throw new Error("'" + input + "' is not a valid color");
};

module.exports = RGBColor;

},{"../../lib/jermaine/src/jermaine.js":9,"../util/validationFunctions.js":160}],108:[function(require,module,exports){
Util = {};

Util.interp = function (x, x0, x1, y0, y1) {
    // return the 'y' coordinate of the point on the line segment
    // connecting the two points (x0,y0) and (x1,y1) whose 'x'
    // coordinate is x
    return y0 + ((y1 - y0) * (x - x0)) / (x1 - x0);
};

Util.safe_interp = function (x, x0, x1, y0, y1) {
    // same as "interp", but if the line is vertical (x0 === x1), return
    // the average of the two y values, rather than NaN
    if (x0 === x1) { return (y0 + y1) / 2; }
    return Util.interp(x, x0, x1, y0, y1);
};

Util.l2dist = function (x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx*dx + dy*dy);
};

module.exports = Util;

},{}],109:[function(require,module,exports){

//  "horizontalaxis" : {
//    "id" : STRING, "type" : DATATYPE(number), "length" : RELLEN(1.0), "base" : POINT(-1,1), "anchor" : DOUBLE(-1), "position" : POINT(0,0),
//    "min" : DATAVALUEORAUTO(auto), "max" : DATAVALUEORAUTO(auto), "minposition" : RELPOS(-1.0), "maxposition" : RELPOS(1.0), "color" : COLOR(black), "linewidth" : INTEGER(1),
//    "tickmin" : INTEGER(-3), "tickmax" : INTEGER(3), "tickcolor" : COLOR(black),
//    "labels" : {
//       "format" : STRING, "start" : DATAVALUE(0), "angle" : DOUBLE(0), "position" : POINT,
//       "anchor" : POINT, "color" : COLOR(black), "spacing" : STRING, "densityfactor" : DOUBLE(1.0),
//       "label" : [
//           { "format" : STRING, "start" : STRING, "angle" : DOUBLE, "position" : POINT, "anchor" : POINT, "spacing" : STRING, "densityfactor" : DOUBLE },
//           { "format" : STRING, "start" : STRING, "angle" : DOUBLE, "position" : POINT, "anchor" : POINT, "spacing" : STRING, "densityfactor" : DOUBLE },
//           ...
//        ]
//    }
//    "title" : { "base" : DOUBLE(0), "anchor" : POINT, "position" : POINT, "angle" : DOUBLE(0), "text" : "TITLETEXT", "font": STRING },
//    "grid" : { "color" : COLOR(0xeeeeee), "visible" : BOOLEAN(false) },
//    "pan" : { "allowed" : BOOLEAN(yes), "min" : DATAVALUE, "max" : DATAVALUE },
//    "zoom" : { "allowed" : BOOLEAN(yes), "min" : DATAMEASURE, "max" : DATAMEASURE, "anchor" : DATAVALUE },
//    "binding" : { "id" : STRING!, "min" : DATAVALUE!, "max" : DATAVALUE! }
//    "visible" : BOOLEAN(true)
//  }


// these are needed so that their .parseJSON methods will be defined when called below:
require('./labeler.js');
require('./axis_title.js');
require('./grid.js');
require('./pan.js');
require('./zoom.js');

var Axis = require('../../core/axis.js'),
    pF = require('../../util/parsingFunctions.js'),
    vF = require('../../util/validationFunctions.js'),
    uF = require('../../util/utilityFunctions.js');

var parseLabels = function (json, axis) {
    var spacings,
        labelers  = axis.labelers(),
        Labeler = require('../../core/labeler.js'),
        DataValue = require('../../core/data_value.js'),
        i;

    spacings = [];
    if (json !== undefined) {
        if (json.spacing !== undefined) {
            spacings = vF.typeOf(json.spacing) === 'array' ? json.spacing : [ json.spacing ];
        }
    }
    if (spacings.length > 0) {
        // If there was a spacing attr on the <labels> tag, create a new labeler for
        // each spacing present in it, using the other values from the <labels> tag
        for (i = 0; i < spacings.length; ++i) {
            labelers.add(Labeler.parseJSON(json, axis, undefined, spacings[i]));
        }
    } else if (json !== undefined && json.label !== undefined && json.label.length > 0) {
        // If there are <label> tags, parse the <labels> tag to get default values
        var defaults = Labeler.parseJSON(json, axis, undefined, null);
        // And loop over each <label> tag, creating labelers for each, splitting multiple
        // spacings on the same <label> tag into multiple labelers:
        json.label.forEach(function(e) {
            var spacing = [];
            if (e.spacing !== undefined) {
                spacing = vF.typeOf(e.spacing) === 'array' ? e.spacing : [ e.spacing ];
            }
            spacing.forEach(function(s) {
                labelers.add( Labeler.parseJSON(e, axis, defaults, s) );
            });
        });
    } else {
        // Otherwise create labelers using the default spacing, with the other values
        // from the <labels> tag
        var defaultValues = (uF.getDefaultValuesFromXSD()).horizontalaxis.labels;
        var defaultSpacings = axis.type() === DataValue.NUMBER ?
                defaultValues.defaultNumberSpacing :
                defaultValues.defaultDatetimeSpacing;
        for (i = 0; i < defaultSpacings.length; ++i) {
            labelers.add(Labeler.parseJSON(json, axis, undefined, defaultSpacings[i]));
        }
    }
};


Axis.parseJSON = function (json, orientation, messageHandler, multigraph) {

    var DataValue = require('../../core/data_value.js'),
        Point = require('../../math/point.js'),
        RGBColor = require('../../math/rgb_color.js'),
        Displacement = require('../../math/displacement.js'),
        AxisTitle = require('../../core/axis_title.js'),
        Grid = require('../../core/grid.js'),
        Pan = require('../../core/pan.js'),
        Zoom = require('../../core/zoom.js'),
        AxisBinding = require('../../core/axis_binding.js'),

        axis              = new Axis(orientation),
        parseAttribute    = pF.parseAttribute,
        parseDisplacement = Displacement.parse,
        parseJSONPoint    = function(p) { return new Point(p[0], p[1]); },
        parseRGBColor     = RGBColor.parse,
        attr, child,
        value;

    if (json) {

        parseAttribute(json.id,     axis.id);
        parseAttribute(json.type,   axis.type,   DataValue.parseType);
        parseAttribute(json.length, axis.length, parseDisplacement);

        //
        // The following provides support for the deprecated "positionbase" axis attribute;
        // MUGL files should use the "base" attribute instead.  When we're ready to remove
        // support for the deprecated attribute, delete this block of code:
        //
        (function () {
            var positionbase = json.positionbase;
            if (positionbase) {
                messageHandler.warning('Use of deprecated axis attribute "positionbase"; use "base" attribute instead');
                if ((positionbase === "left") || (positionbase === "bottom")) {
                    axis.base(new Point(-1, -1));
                } else if (positionbase === "right") {
                    axis.base(new Point(1, -1));
                } else if (positionbase === "top") {
                    axis.base(new Point(-1, 1));
                }
            }
        }());
        //
        // End of code to delete when removing support for deprecated "positionbase"
        // attribute.
        //

        attr = json.position;
        if (attr !== undefined) {
            if (vF.typeOf(attr) === 'array') {
                axis.position(parseJSONPoint(attr));
            } else {
                // If position is not an array, and if it can be interpreted
                // as a number, construct the position point by interpreting that
                // number as an offset from the 0 location along the perpendicular
                // direction.
                if (vF.isNumberNotNaN(attr)) {
                    if (orientation === Axis.HORIZONTAL) {
                        axis.position(new Point(0, attr));
                    } else {
                        axis.position(new Point(attr, 0));
                    }
                } else {
                    throw new Error("axis position '"+attr+"' is of the wrong type; it should be a number or a point");
                }
            }
        }

        // Note: we coerce the min and max values to strings here, because the "min" and "max" attrs
        // of the Axis object require strings.  See the comments about these properties in src/core/axis.js
        // for a discussion of why this is the case.
        if ("min" in json) {
            axis.min(uF.coerceToString(json.min));
        }
        if (axis.min() !== "auto") {
            axis.dataMin(DataValue.parse(axis.type(), axis.min()));
        }
        if ("max" in json) {
            axis.max(uF.coerceToString(json.max));
        }
        if (axis.max() !== "auto") {
            axis.dataMax(DataValue.parse(axis.type(), axis.max()));
        }

        parseAttribute(json.pregap,         axis.pregap);
        parseAttribute(json.postgap,        axis.postgap);
        parseAttribute(json.anchor,         axis.anchor);
        parseAttribute(json.base,           axis.base,           parseJSONPoint);
        parseAttribute(json.minposition,    axis.minposition,    parseDisplacement);
        parseAttribute(json.maxposition,    axis.maxposition,    parseDisplacement);
        parseAttribute(json.minoffset,      axis.minoffset);
        parseAttribute(json.maxoffset,      axis.maxoffset);
        parseAttribute(json.color,          axis.color,          parseRGBColor);
        parseAttribute(json.tickcolor,      axis.tickcolor,      parseRGBColor);
        parseAttribute(json.tickwidth,      axis.tickwidth);
        parseAttribute(json.tickmin,        axis.tickmin);
        parseAttribute(json.tickmax,        axis.tickmax);
        parseAttribute(json.highlightstyle, axis.highlightstyle);
        parseAttribute(json.linewidth,      axis.linewidth);
        
        if ("title" in json) {
            if (typeof(json.title) === 'boolean') {
                if (json.title) {
                    axis.title(new AxisTitle(axis));
                    } else {
                        axis.title(AxisTitle.parseJSON({}, axis));
                    }
            } else {
                axis.title(AxisTitle.parseJSON(json.title, axis));
            }
        } else {
            axis.title(new AxisTitle(axis));
        }

        if (json.grid) {
            axis.grid(Grid.parseJSON(json.grid));
        }

        if (json.visible !== undefined) {
            axis.visible(json.visible);
        }

        if ("pan" in json) {
            axis.pan(Pan.parseJSON(json.pan, axis.type()));
        }

        if ("zoom" in json) {
            axis.zoom(Zoom.parseJSON(json.zoom, axis.type()));
        }

        if (json.labels) {
            parseLabels(json.labels, axis);
        }

        if (json.binding) {
            var bindingMinDataValue = DataValue.parse(axis.type(), json.binding.min),
                bindingMaxDataValue = DataValue.parse(axis.type(), json.binding.max);
            if (typeof(json.binding.id) !== "string") {
                throw new Error("invalid axis binding id: '" + json.binding.id + "'");
            }
            if (! DataValue.isInstance(bindingMinDataValue)) {
                throw new Error("invalid axis binding min: '" + json.binding.min + "'");
            }
            if (! DataValue.isInstance(bindingMaxDataValue)) {
                throw new Error("invalid axis binding max: '" + json.binding.max + "'");
            }
            AxisBinding.findByIdOrCreateNew(json.binding.id).addAxis(axis, bindingMinDataValue, bindingMaxDataValue, multigraph);
        }

    }
    return axis;
};

module.exports = Axis;

},{"../../core/axis.js":19,"../../core/axis_binding.js":20,"../../core/axis_title.js":21,"../../core/data_value.js":31,"../../core/grid.js":43,"../../core/labeler.js":46,"../../core/pan.js":53,"../../core/zoom.js":72,"../../math/displacement.js":103,"../../math/point.js":106,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158,"../../util/utilityFunctions.js":159,"../../util/validationFunctions.js":160,"./axis_title.js":110,"./grid.js":118,"./labeler.js":122,"./pan.js":125,"./zoom.js":132}],110:[function(require,module,exports){
var AxisTitle = require('../../core/axis_title.js');

// "title" { "base": 23.2, "anchor": [12, 4], "position": [3, 7], "angle": 45, "text" : "temperature", "font" : "Roboto" }
// empty title:
//   "title" {}
//   "title" {"text" : "" }
AxisTitle.parseJSON = function (json, axis) {
    var title = new AxisTitle(axis),
        Text = require('../../core/text.js'),
        Point = require('../../math/point.js'),
        parseAttribute = require('../../util/parsingFunctions.js').parseAttribute,
        nonEmptyTitle = false,
        parseJSONPoint = function(p) { return new Point(p[0], p[1]); },
        text;

    if (json) {
        text = json.text;
        if (text !== "" && text !== undefined) {
            title.content(new Text(text));
            nonEmptyTitle = true;
        }
        parseAttribute(json.anchor,   title.anchor,   parseJSONPoint);
        parseAttribute(json.base,     title.base);
        parseAttribute(json.position, title.position, parseJSONPoint);
        parseAttribute(json.angle,    title.angle);
        parseAttribute(json.font,    title.font);
    }

    if (nonEmptyTitle === true) { 
        return title;
    }
    return undefined;
};

module.exports = AxisTitle;

},{"../../core/axis_title.js":21,"../../core/text.js":65,"../../math/point.js":106,"../../util/parsingFunctions.js":158}],111:[function(require,module,exports){
var Background = require('../../core/background.js');

// "background" : {
//   "color": "#ffff00",
//   "img" : { "src": "foo.png", "anchor": [-1, 5], "base": [3, 12], "position": [-2, 3], "frame": "padding" }
// }
Background.parseJSON = function (json, multigraph) {
    var background       = new Background(),
        parseAttribute   = require('../../util/parsingFunctions.js').parseAttribute,
        RGBColor         = require('../../math/rgb_color.js'),
        Img              = require('../../core/img.js'),
        child;

    if (json) {
        parseAttribute(json.color, background.color, RGBColor.parse);
        if (json.img) {
            background.img(Img.parseJSON(json.img, multigraph));
        }
    }
    return background;
};

module.exports = Background;

},{"../../core/background.js":22,"../../core/img.js":45,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],112:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Data = require('../../core/data.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Data.parseJSON)==="function") { return Data; };

    // "data" : {
    //   "adapter"      : STRING,
    //   "missingvalue" : "DATAVALUE",
    //   "missingop"    : "COMPARATOR">,
    //   "variables" : [
    //         { "id" : STRING!, "column" : INTEGER, "type" : DATATYPE(number), "missingvalue" : STRING, "missingop" : COMPARATOR }
    //         { "id" : STRING!, "column" : INTEGER, "type" : DATATYPE(number), "missingvalue" : STRING, "missingop" : COMPARATOR }
    //         ...
    //   ],
    //   "repeat" : { "period" : STRING },
    //   "repeat" : STRING,
    //   "values" : [
    //      [ 3.2, 1.4, ...],
    //      [ 5.1, 7.8, ...],
    //      ...
    //   ],
    //   "csv" : STRING,
    //   "csv" : { "location" : STRING },
    //   "service" : STRING,
    //   "service" : {
    //       "location" : STRING!
    //       "format"   : STRING
    //   }
    // }
    Data.parseJSON = function (json, multigraph, messageHandler) {
        var ArrayData = require('../../core/array_data.js'),
            DataVariable = require('../../core/data_variable.js'),
            DataMeasure = require('../../core/data_measure.js'),
            PeriodicArrayData = require('../../core/periodic_array_data.js'),
            CSVData = require('../../core/csv_data.js')($),
            WebServiceData = require('../../core/web_service_data.js')($),
            Multigraph = require('../../core/multigraph.js')($),
            pF = require('../../util/parsingFunctions.js'),
            vF = require('../../util/validationFunctions.js'),
            uF = require('../../util/utilityFunctions.js'),
            defaultMissingvalueString,
            defaultMissingopString,
            dataVariables = [],
            data,
            adap, adapter = ArrayData;

        require('./data_variable.js'); // so that DataVariable.parseJSON method is defined when needed below

        if (json) {

            adap = json.adapter;
            if (adap !== undefined && adap !== "") {
                adapter = Multigraph.getDataAdapter(adap);
                if (adapter === undefined) {
                    throw new Error("Missing data adapater: " + adap);
                }
            }

            // be sure to leave defaultMissingvalueString undefined if
            // json.missingvalue is undefined, otherwise the String cast
            // here will result in the string "undefined", which wreaks havoc!
            if (json.missingvalue) {
                defaultMissingvalueString = uF.coerceToString(json.missingvalue);
            }
            defaultMissingopString    = json.missingop;

            if (json.variables) {
                json.variables.forEach(function(variable) {
                    dataVariables.push(DataVariable.parseJSON(variable));
                });
            }

            // check to see if we have a <repeat> section, and if so, grab the period from it
            var haveRepeat = false,
                period;
            if ("repeat" in json) {
                var periodProp = (vF.typeOf(json.repeat) === 'object') ? json.repeat.period : json.repeat;
                if (periodProp === undefined || periodProp === "") {
                    messageHandler.warning("repeat requires a period; data treated as non-repeating");
                } else {
                    period = DataMeasure.parse(dataVariables[0].type(), periodProp);
                    haveRepeat = true;
                }
            }

            // if we have a <values> section, parse it and return an ArrayData instance:
            if (json.values) {
                // Note this does not use the data adapter -- not supported for inline json data
                var stringValues = json.values;
                if (haveRepeat) {
                    data = new PeriodicArrayData(dataVariables, stringValues, period);
                } else {
                    data = new ArrayData(dataVariables, stringValues);
                }
            }

            // if we have a <csv> section, parse it and return a CSVData instance:
            if (json.csv) {
                var filename = (vF.typeOf(json.csv) === 'object') ? json.csv.location : json.csv;
                data = new CSVData(dataVariables,
                                   multigraph ? multigraph.rebaseUrl(filename) : filename,
                                   messageHandler,
                                   multigraph ? multigraph.getAjaxThrottle(filename) : undefined);
            }

            // if we have a <service> section, parse it and return a WebServiceData instance:
            if (json.service) {
                var location = (vF.typeOf(json.service) === 'object') ? json.service.location : json.service;
                data = new WebServiceData(dataVariables,
                                          multigraph ? multigraph.rebaseUrl(location) : location,
                                          messageHandler,
                                          multigraph ? multigraph.getAjaxThrottle(location) : undefined);
                if (vF.typeOf(json.service) === 'object' && ("format" in json.service)) {
                    data.format(json.service.format);
                }
            }

            // if the json contains an "id" property, pass it on to our data object:
            if ("id" in json) {
                data.id(json.id);
            }
        }

        if (data) {
            if (defaultMissingvalueString !== undefined) {
                data.defaultMissingvalue(defaultMissingvalueString);
            }
            if (defaultMissingopString !== undefined) {
                data.defaultMissingop(defaultMissingopString);
            }
            data.adapter(adapter);
        }
        
        return data;
    };

    return Data;
};



},{"../../core/array_data.js":18,"../../core/csv_data.js":26,"../../core/data.js":27,"../../core/data_measure.js":29,"../../core/data_variable.js":32,"../../core/multigraph.js":49,"../../core/periodic_array_data.js":54,"../../core/web_service_data.js":68,"../../util/parsingFunctions.js":158,"../../util/utilityFunctions.js":159,"../../util/validationFunctions.js":160,"./data_variable.js":113}],113:[function(require,module,exports){
var DataVariable = require('../../core/data_variable.js');

//  "variable" : {
//      "id"           : STRING!,
//      "column"       : INTEGER,
//      "type"         : DATATYPE(number),
//      "missingvalue" : STRING,
//      "missingop"    : COMPARATOR,
//  }
DataVariable.parseJSON = function (json, data) {
    var variable,
        pF             = require('../../util/parsingFunctions.js'),
        parseAttribute = pF.parseAttribute,
        DataValue      = require('../../core/data_value.js'),
        attr;

    if (json && json.id) {
        variable = new DataVariable(json.id);
        parseAttribute(json.column,       variable.column);
        parseAttribute(json.type,         variable.type,         DataValue.parseType);
        parseAttribute(json.missingvalue, variable.missingvalue, function(v) { return DataValue.parse(variable.type(), v); });
        parseAttribute(json.missingop,    variable.missingop,    DataValue.parseComparator);
    }
    return variable;
};

module.exports = DataVariable;

},{"../../core/data_value.js":31,"../../core/data_variable.js":32,"../../util/parsingFunctions.js":158}],114:[function(require,module,exports){
var Datatips = require('../../core/datatips.js');

// "datatips" : {
//   "format"           : "STRING!",
//   "bgcolor"          : "COLOR",
//   "bgalpha"          : "DOUBLE",
//   "border"           : "INTEGER",
//   "bordercolor"      : "COLOR",
//   "pad"              : "INTEGER",
//   "variable-formats" : [ "STRING!", ... ]
// }
Datatips.parseJSON = function (json) {
    var datatips         = new Datatips(),
        RGBColor         = require('../../math/rgb_color.js'),
        DatatipsVariable = require('../../core/datatips_variable.js'),
        pF               = require('../../util/parsingFunctions.js'),
        uF               = require('../../util/utilityFunctions.js'),
        parseRGBColor    = RGBColor.parse,
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger,
        child;
    if (json) {
        if (json["variable-formats"]) {
            json["variable-formats"].forEach(function(fmt) {
                var dtv = new DatatipsVariable();
                dtv.formatString(fmt);
                datatips.variables().add(dtv);
            });
        }
        
        parseAttribute(json.format,      datatips.formatString);
        parseAttribute(json.bgcolor,     datatips.bgcolor,     parseRGBColor);
        parseAttribute(json.bgalpha,     datatips.bgalpha);
        parseAttribute(json.border,      datatips.border);
        parseAttribute(json.bordercolor, datatips.bordercolor, parseRGBColor);
        parseAttribute(json.pad,         datatips.pad);
    }
    return datatips;
};

module.exports = Datatips;

},{"../../core/datatips.js":33,"../../core/datatips_variable.js":34,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158,"../../util/utilityFunctions.js":159}],115:[function(require,module,exports){
var Filter = require('../../core/filter.js');

// "filter" : {
//   "type": "STRING"
//   "options" : [
//     { "name" : "STRING!", "value" : "STRING!" },
//     { "name" : "STRING!", "value" : "STRING!" }
//     ...
//   }
// }
Filter.parseJSON = function (json) {
    var filter = new Filter(),
        FilterOption = require('../../core/filter_option.js'),
        pF = require('../../util/parsingFunctions.js'),
        uF = require('../../util/utilityFunctions.js'),
        o;

    require('./filter_option.js'); // so that FilterOption.parseJSON will exist below

    if (json) {
        if (json.options) {
            for (opt in json.options) {
                if (json.options.hasOwnProperty(opt)) {
                    o = new FilterOption();
                    o.name(opt);
                    o.value(uF.coerceToString(json.options[opt]));
                    filter.options().add( o );
                }
            }
        }

        pF.parseAttribute(json.type, filter.type);
        return filter;
    };

    return Filter;
};

module.exports = Filter;

},{"../../core/filter.js":40,"../../core/filter_option.js":41,"../../util/parsingFunctions.js":158,"../../util/utilityFunctions.js":159,"./filter_option.js":116}],116:[function(require,module,exports){
var FilterOption = require('../../core/filter_option.js');

// "option" : { "name" : "STRING!",  "value" : "STRING!" }
FilterOption.parseJSON = function (json) {
    var pF     = require('../../util/parsingFunctions.js'),
        uF     = require('../../util/utilityFunctions.js'),
        option = new FilterOption();
    if (json) {
        option.name(json.name);
        if ("value" in json && json.value !== "") {
            // coerce to string since "value" attr of filter_option is of type string
            option.value(uF.coerceToString(json.value));
        }
    }
    return option;
};

module.exports = FilterOption;

},{"../../core/filter_option.js":41,"../../util/parsingFunctions.js":158,"../../util/utilityFunctions.js":159}],117:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Graph = require('../../core/graph.js'),
        pF = require('../../util/parsingFunctions.js');

    // if parseJSON method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Graph.parseJSON)==="function") { return Graph; };

    Graph.parseJSON = function (json, multigraph, messageHandler) {
        var graph = new Graph(),
            Axis  = require('../../core/axis.js'),
            Window = require('../../core/window.js'),
            Legend = require('../../core/legend.js'),
            Background = require('../../core/background.js'),
            Plotarea = require('../../core/plotarea.js'),
            ConsecutiveDistanceFilter = require('../../core/consecutive_distance_filter.js'),
            Title = require('../../core/title.js'),
            Data = require('../../core/data.js'),
            Plot = require('../../core/plot.js'),
            uF = require('../../util/utilityFunctions.js'),
            vF = require('../../util/validationFunctions.js'),
            defaults = uF.getDefaultValuesFromXSD(),
            child;

        // so that these objects' .parseJSON methods will exist when needed below:
        require('./window.js');
        require('./legend.js');
        require('./background.js');
        require('./plotarea.js');
        require('./title.js');
        require('./axis.js');
        require('./data.js')($);
        require('./plot.js');

        graph.multigraph(multigraph);
        if (json) {

            if (json.window) {
                graph.window( Window.parseJSON(json.window) );
            }

            if ("legend" in json) {
                graph.legend( Legend.parseJSON(json.legend) );
            } else {
                graph.legend( Legend.parseJSON() );
            }

            if (json.background) {
                graph.background( Background.parseJSON(json.background, graph.multigraph()) );
            }

            if (json.plotarea) {
                graph.plotarea( Plotarea.parseJSON(json.plotarea) );
            }

            if (json.title) {
                graph.title( Title.parseJSON(json.title, graph) );
            }

            if ("filter" in json) {
                    if (vF.typeOf(json.filter) === 'object') {
                        if ((typeof(json.filter.type) !== 'undefined') && (json.filter.type !== 'consecutivedistance')) {
                            throw new Error('unknown filter type: ' + json.filter.type);
                        }
                        graph.filter(new ConsecutiveDistanceFilter(json.filter));
                    } else {
                        if (vF.typeOf(json.filter) !== 'boolean') {
                            throw new Error('invalid filter property: ' + json.filter);
                        } else if (json.filter) {
                            graph.filter(new ConsecutiveDistanceFilter({}));
                        }
                    }
            }

            var haxes = json.horizontalaxis ? json.horizontalaxis : json.horizontalaxes;
            if (json.horizontalaxis && json.horizontalaxes) {
                throw new Error("graph may not have both 'horizontalaxis' and 'horizontalaxes'");
            }
            if (haxes) {
                if (vF.typeOf(haxes) === 'array') {
                    haxes.forEach(function(axis) {
                        graph.axes().add( Axis.parseJSON(axis, Axis.HORIZONTAL, messageHandler, graph.multigraph()) );
                    });
                } else {
                    graph.axes().add( Axis.parseJSON(haxes, Axis.HORIZONTAL, messageHandler, graph.multigraph()) );
                }
            }

            var vaxes = json.verticalaxis ? json.verticalaxis : json.verticalaxes;
            if (json.verticalaxis && json.verticalaxes) {
                throw new Error("graph may not have both 'verticalaxis' and 'verticalaxes'");
            }
            if (vaxes) {
                if (vF.typeOf(vaxes) === 'array') {
                    vaxes.forEach(function(axis) {
                        graph.axes().add( Axis.parseJSON(axis, Axis.VERTICAL, messageHandler, graph.multigraph()) );
                    });
                } else {
                    graph.axes().add( Axis.parseJSON(vaxes, Axis.VERTICAL, messageHandler, graph.multigraph()) );
                }
            }


            function addAjaxThrottle(t) {
                var pattern    = t.pattern    ? t.pattern    : defaults.throttle.pattern,
                    requests   = t.requests   ? t.requests   : defaults.throttle.requests,
                    period     = t.period     ? t.period     : defaults.throttle.period,
                    concurrent = t.concurrent ? t.concurrent : defaults.throttle.concurrent;
                multigraph.addAjaxThrottle(pattern, requests, period, concurrent);
            }
            var throttles = json.throttle ? json.throttle : json.throttles;
            if (json.throttle && json.throttles) {
                throw new Error("graph may not have both 'throttle' and 'throttles'");
            }
            if (throttles) {
                if (vF.typeOf(throttles) === 'array') {
                    throttles.forEach(addAjaxThrottle);
                } else {
                    addAjaxThrottle(throttles);
                }
            }

            if (json.data) {
                if (vF.typeOf(json.data) === 'array') {
                    json.data.forEach(function(data) {
                        graph.data().add( Data.parseJSON(data, graph.multigraph(), messageHandler) );
                    });
                } else {
                    graph.data().add( Data.parseJSON(json.data, graph.multigraph(), messageHandler) );
                }
            }

            var plots = json.plot ? json.plot : json.plots;
            if (json.plot && json.plots) {
                throw new Error("graph may not have both 'plot' and 'plots'");
            }
            if (plots) {
                if (vF.typeOf(plots) === 'array') {
                    plots.forEach(function(plot) {
                        graph.plots().add( Plot.parseJSON(plot, graph, messageHandler) );
                    });
                } else {
                    graph.plots().add( Plot.parseJSON(plots, graph, messageHandler) );
                }
            }

            graph.postParse();
        }
        return graph;
    };

    return Graph;
};

},{"../../core/axis.js":19,"../../core/background.js":22,"../../core/consecutive_distance_filter.js":24,"../../core/data.js":27,"../../core/graph.js":42,"../../core/legend.js":47,"../../core/plot.js":55,"../../core/plotarea.js":57,"../../core/title.js":66,"../../core/window.js":71,"../../util/parsingFunctions.js":158,"../../util/utilityFunctions.js":159,"../../util/validationFunctions.js":160,"./axis.js":109,"./background.js":111,"./data.js":112,"./legend.js":123,"./plot.js":126,"./plotarea.js":128,"./title.js":130,"./window.js":131}],118:[function(require,module,exports){
var Grid = require('../../core/grid.js');

// "grid": { "color": "#ff00ff", visible: true }
Grid.parseJSON = function (json) {
    var grid             = new Grid(),
        RGBColor         = require('../../math/rgb_color.js'),
        parseAttribute   = require('../../util/parsingFunctions.js').parseAttribute,
        attr;
    if (json) {
        parseAttribute(json.color, grid.color, RGBColor.parse);
        //NOTE: visible attribute should default to true when parsing, so that
        //      the presence of a "grid" property at all will turn on a grid.  In
        //      the Grid object itself, though, the default for the visible
        //      attribute is false, so that when we create a default grid object
        //      in code (as opposed to parsing), it defaults to not visible.
        attr = json.visible;
        if (attr !== undefined) {
            grid.visible(attr);
        } else {
            grid.visible(true);
        }
    }
    return grid;
};

module.exports = Grid;

},{"../../core/grid.js":43,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],119:[function(require,module,exports){
var Icon = require('../../core/icon.js');

// "icon" : { "border": 2, "width": 30, "height": 20 }
Icon.parseJSON = function (json) {
    var icon = new Icon(),
        parseAttribute = require('../../util/parsingFunctions.js').parseAttribute;
    if (json) {
        parseAttribute(json.height, icon.height);
        parseAttribute(json.width,  icon.width);
        parseAttribute(json.border, icon.border);
    }
    return icon;
};

module.exports = Icon;

},{"../../core/icon.js":44,"../../util/parsingFunctions.js":158}],120:[function(require,module,exports){
var Img = require('../../core/img.js');

// "img" : { "src": "foo.png", "anchor": [-1, 5], "base": [3, 12], "position": [-2, 3], "frame": "padding" }
Img.parseJSON = function (json, multigraph) {
    var img,
        parseAttribute = require('../../util/parsingFunctions.js').parseAttribute,
        Point          = require('../../math/point.js'),
        parseJSONPoint = function(p) { return new Point(p[0], p[1]); };
    if (json && json.src !== undefined) {
        var src = json.src;
        if (!src) {
            throw new Error('img requires a "src" property');
        }
        if (multigraph) {
            src = multigraph.rebaseUrl(src);
        }
        img = new Img(src);
        parseAttribute(json.anchor,   img.anchor,   parseJSONPoint);
        parseAttribute(json.base,     img.base,     parseJSONPoint);
        parseAttribute(json.position, img.position, parseJSONPoint);
        parseAttribute(json.frame,    img.frame,    function (value) { return value.toLowerCase(); });
    }
    return img;
};

module.exports = Img;

},{"../../core/img.js":45,"../../math/point.js":106,"../../util/parsingFunctions.js":158}],121:[function(require,module,exports){
// usage:
// 
//   A valid jQuery object must be passed to the function returned by requiring this file.
//
//      require('.../src/parser/json/json_parser.js')($);
//      var Multigraph = require('.../src/core/multigraph.js')($);
//      var m = Multigraph.parseJSON( {...} };
// 
//   where {...} is the JSON object to be parsed.
//
var included = false;
module.exports = function($) {
    if (included) { return; }
    included = true;

    require('./data.js')($);
    require('./graph.js')($);
    require('./multigraph.js')($);

    require('./axis.js');
    require('./axis_title.js');
    require('./background.js');
    require('./datatips.js');
    require('./data_variable.js');
    require('./filter.js');
    require('./filter_option.js');
    require('./grid.js');
    require('./icon.js');
    require('./img.js');
    require('./json_parser.js');
    require('./labeler.js');
    require('./legend.js');
    require('./pan.js');
    require('./plotarea.js');
    require('./plot.js');
    require('./plot_legend.js');
    require('./renderer.js');
    require('./title.js');
    require('./window.js');
    require('./zoom.js');
};

},{"./axis.js":109,"./axis_title.js":110,"./background.js":111,"./data.js":112,"./data_variable.js":113,"./datatips.js":114,"./filter.js":115,"./filter_option.js":116,"./graph.js":117,"./grid.js":118,"./icon.js":119,"./img.js":120,"./json_parser.js":121,"./labeler.js":122,"./legend.js":123,"./multigraph.js":124,"./pan.js":125,"./plot.js":126,"./plot_legend.js":127,"./plotarea.js":128,"./renderer.js":129,"./title.js":130,"./window.js":131,"./zoom.js":132}],122:[function(require,module,exports){
var Labeler = require('../../core/labeler.js');

// "labels" : {
//   "format: STRING,
//   "start" : DATAVALUE(0),
//   "angle" : DOUBLE(0),
//   "position" : POINT,
//   "anchor" : POINT,
//   "color" : COLOR(black),
//   "spacing" : STRING,
//   "font": STRING,
//   "densityfactor" : DOUBLE(1.0),
//   "label" : [
//     { "format": "%Y", "start": STRING, "angle": 45, "position": [2,3],
//       "anchor": [1,1], "spacing": "1Y", "densityfactor": 0.2 },
//     { "format": "%M", "start": STRING, "angle": 45, "position": [2,3],
//       "anchor": [1,1], "spacing": ["1M", "1D"], "densityfactor": 9.0 }
//   ]
// }
//
// Feature added 2015-12-16:
//   The "format" attribute (for an axis of type number only) can be an
//   array of strings to be displayed for the values 0..L-1 where L is the
//   number of strings in the array.  For example:
//        "format": ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov"]
//   would cause "Jan" to be rendered as the label for value 0, "Feb" for value 1,
//   and so on.  There is currently no way to customize the association between numerical
//   values and strings -- it's hardcoded to be the integers starting with 0.

Labeler.parseJSON = function (json, axis, defaults, spacing) {
    // This parser takes an optional final argument, spacing, which is a string representing
    // the spacing to be parsed for the labeler.  If that argument is not present, the spacing
    // value is taken from the json object.  If a spacing argument is present, it is parsed
    // and used to set the spacing attribute of the Labeler object, and in this case, any
    // spacing value present in the json is ignored.
    //
    // If the spacing argument has the value null, the resulting labeler will have no spacing
    // attribute set at all.
    var labeler,
        Point = require('../../math/point.js'),
        RGBColor = require('../../math/rgb_color.js'),
        DataMeasure = require('../../core/data_measure.js'),
        DataValue = require('../../core/data_value.js'),
        DataFormatter = require('../../core/data_formatter.js'),
        CategoryFormatter = require('../../core/category_formatter.js'),
        pF = require('../../util/parsingFunctions.js'),
        vF = require('../../util/validationFunctions.js'),
        parseJSONPoint = function(p) { return new Point(p[0], p[1]); };

    // `parseAttribute` returns true or false depending on whether or not it set the attribute.
    // If it did not and if the `defaults` object exists then the attribute is set to the
    // appropriate default value.
    var parseLabelerAttribute = function (value, attribute, preprocessor, defaultName) {
        if (!pF.parseAttribute(value, attribute, preprocessor) && defaults !== undefined) {
            attribute(defaults[defaultName]());
        }
    };
    var parseDataFormatter = function (type) {
        return function (value) {
            return DataFormatter.create(type, value);
        };
    };
    var parseDataValue = function (type) {
        return function (value) {
            return DataValue.parse(type, value);
        };
    };

    if (json) {
        labeler = new Labeler(axis);
        if (spacing !== null) {
            if (spacing === undefined) {
                spacing = json.spacing;
            }
            //NOTE: spacing might still === undefined at this point
            parseLabelerAttribute(spacing, labeler.spacing,
                                  function(v) { return DataMeasure.parse(axis.type(), v); }, //pF.parseDataMeasure(),
                                  "spacing");
        }

        if (vF.typeOf(json.format) === "array") {
            parseLabelerAttribute(json.format,    labeler.formatter,     function(format) {
                return new CategoryFormatter(json.format);
            }, undefined);
        } else {
            parseLabelerAttribute(json.format,        labeler.formatter,     parseDataFormatter(axis.type()),          "formatter");
        }

        parseLabelerAttribute(json.start,         labeler.start,         parseDataValue(axis.type()),                  "start");
        parseLabelerAttribute(json.angle,         labeler.angle,         undefined,                                    "angle");
        parseLabelerAttribute(json.position,      labeler.position,      parseJSONPoint,                               "position");
        parseLabelerAttribute(json.anchor,        labeler.anchor,        parseJSONPoint,                               "anchor");
        parseLabelerAttribute(json.densityfactor, labeler.densityfactor, undefined,                                    "densityfactor");
        parseLabelerAttribute(json.color,         labeler.color,         RGBColor.parse,                               "color");
        parseLabelerAttribute(json.font,          labeler.font,          undefined,                                    "font");
        parseLabelerAttribute(json.visible,       labeler.visible,       pF.parseBoolean,                              "visible");

    }
    return labeler;
};

module.exports = Labeler;

},{"../../core/category_formatter.js":23,"../../core/data_formatter.js":28,"../../core/data_measure.js":29,"../../core/data_value.js":31,"../../core/labeler.js":46,"../../math/point.js":106,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158,"../../util/validationFunctions.js":160}],123:[function(require,module,exports){
var Legend = require('../../core/legend.js');

// "legend" : {
//     "visible"      : "BOOLEAN",
//     "base"         : "POINT(1,1)",
//     "anchor"       : "POINT(1,1)",
//     "position"     : "POINT(0,0)",
//     "frame"        : "FRAME(padding)",
//     "color"        : "COLOR(white)",
//     "opacity"      : "DOUBLE(1.0)",
//     "border"       : "INTEGER(1)",
//     "bordercolor"  : "COLOR(black)",
//     "rows"         : "INTEGER",
//     "columns"      : "INTEGER",
//     "cornerradius" : "INTEGER(0)",
//     "padding"      : "INTEGER(0)",
//     "icon" : {
//       "width"  : "INTEGER(40)",
//       "height" : "INTEGER(30)",
//       "border" : "INTEGER(1)"
//     }
// }
Legend.parseJSON = function (json) {
    var legend           = new Legend(),
        pF               = require('../../util/parsingFunctions.js'),
        Point            = require('../../math/point.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        Point            = require('../../math/point.js'),
        Icon             = require('../../core/icon.js'),
        parseAttribute   = pF.parseAttribute,
        parseJSONPoint   = function(p) { return new Point(p[0], p[1]); };

    require('./icon.js'); // for Icon.parseJSON below

    if (typeof(json) === "boolean") {
        parseAttribute(json, legend.visible);
    } else if (json) {
        parseAttribute(json.visible,      legend.visible,      pF.parseBoolean);
        parseAttribute(json.base,         legend.base,         parseJSONPoint);
        parseAttribute(json.anchor,       legend.anchor,       parseJSONPoint);
        parseAttribute(json.position,     legend.position,     parseJSONPoint);
        parseAttribute(json.frame,        legend.frame);
        parseAttribute(json.color,        legend.color,        RGBColor.parse);
        parseAttribute(json.bordercolor,  legend.bordercolor,  RGBColor.parse);
        parseAttribute(json.opacity,      legend.opacity);
        parseAttribute(json.border,       legend.border);
        parseAttribute(json.rows,         legend.rows);
        parseAttribute(json.columns,      legend.columns);
        parseAttribute(json.cornerradius, legend.cornerradius);
        parseAttribute(json.padding,      legend.padding);

        if (json.icon) {
            legend.icon(Icon.parseJSON(json.icon));
        }
    }
    return legend;
};

module.exports = Legend;

},{"../../core/icon.js":44,"../../core/legend.js":47,"../../math/point.js":106,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158,"./icon.js":119}],124:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Multigraph = require('../../core/multigraph.js')($);

    // if parseJSON method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Multigraph.parseJSON)==="function") { return Multigraph; };

    Multigraph.parseJSON = function (json, mugl, messageHandler) {
        var multigraph = new Multigraph(),
            graphs     = multigraph.graphs(),
            Graph      = require('../../core/graph.js'),
            vF         = require('../../util/validationFunctions.js');

        require('./graph.js')($); // for Graph.parseJSON below

        multigraph.mugl(mugl); // set the mugl url
        if (json) {
            if (vF.typeOf(json) === 'array') {
                json.forEach(function(graph) {
                    graphs.add( Graph.parseJSON(graph, multigraph, messageHandler) );
                });
            } else {
                graphs.add( Graph.parseJSON(json, multigraph, messageHandler) );
            }
        }
        return multigraph;
    };

    return Multigraph;
};

},{"../../core/graph.js":42,"../../core/multigraph.js":49,"../../util/validationFunctions.js":160,"./graph.js":117}],125:[function(require,module,exports){
var Pan = require('../../core/pan.js');

Pan.parseJSON = function (json, type) {
    var pan            = new Pan(),
        pF             = require('../../util/parsingFunctions.js'),
        vF             = require('../../util/validationFunctions.js'),
        parseAttribute = pF.parseAttribute,
        parseBoolean   = pF.parseBoolean,
        DataValue      = require('../../core/data_value.js'),
        parseDataValue = function(v) { return DataValue.parse(type, v); };
    if (vF.typeOf(json) === 'boolean') {
        parseAttribute(json,         pan.allowed, parseBoolean);
    } else if (json) {
        parseAttribute(json.allowed, pan.allowed, parseBoolean);
        parseAttribute(json.min,     pan.min,     parseDataValue);
        parseAttribute(json.max,     pan.max,     parseDataValue);
    }
    return pan;
};

module.exports = Pan;

},{"../../core/data_value.js":31,"../../core/pan.js":53,"../../util/parsingFunctions.js":158,"../../util/validationFunctions.js":160}],126:[function(require,module,exports){
var Plot = require('../../core/plot.js');

// "plot" : {
//   "legend" : { "visible": "BOOLEAN", "label": "STRING" }, 
//   "legend" : BOOLEAN,
//                 //NO:  "horizontalaxis" : {
//                 //NO:    "ref" : STRING!,
//                 //NO:    "variables" [ STRING, ... ]
//                 //NO:  },
//                 //NO:  "verticalaxis" : {
//                 //NO:    "ref" : STRING!,
//                 //NO:    "variables" [ STRING, ... ],
//                 //NO:    "constant" : DATAVALUE
//                 //NO:  },
// 
//   "horizontalaxis" : AXIS-ID(string)
//   "horizontalaxis" : [ VARIABLE-ID(string), ... ]
//   "horizontalaxis" : { AXIS-ID(string): [ VARIABLE-ID(string), ... ] }
// 
//   "verticalaxis" : [ VARIABLE-ID(string), ... ]
//   "verticalaxis" : { AXIS-ID(string): DATA-VALUE(number or string) }     <-- ConstantPlot
//   "verticalaxis" : { AXIS-ID(string): VARIABLE-ID(string) }
//   "verticalaxis" : { AXIS-ID(string): [ VARIABLE-ID(string), ... ] }
//   "verticalaxis" : DATA-VALUE(number or string)                          <-- ConstantPlot
//   "verticalaxis" : AXIS-ID(string)
//   "visible" : BOOLEAN(true)
//   "renderer" : {
//     "type" : RENDERERTYPE(line),
//     "options" : {
//         "option1": value1,
//         "option2": value2,
//         "option3": [ { "value": value3, "min": DATAVALUE, "max" : DATAVALUE }, .. ]
//         ...
//     },
//   },
//   "datatips" : {
//     "format"           : STRING!,
//     "bgcolor"          : COLOR,
//     "bgalpha"          : DOUBLE,
//     "border"           : INTEGER,
//     "bordercolor"      : COLOR,
//     "pad"              : INTEGER,
//     "variable-formats" : [ STRING!, ... ]
//   }
// }
//
// Alternately, instead of the "renderer" section, the "plot" section may instead contain
// the following (at the top level of the "plot" object):
// 
//   "style" : RENDERERTYPE(line),
//   "options" : {
//       "option1": value1,
//       "option2": value2,
//       "option3": [ { "value": value3, "min": DATAVALUE, "max" : DATAVALUE }, .. ]
//       ...
//   },
// 
Plot.parseJSON = function (json, graph, messageHandler) {
    var DataPlot                  = require('../../core/data_plot.js'),
        PlotLegend                = require('../../core/plot_legend.js'),
        ConstantPlot              = require('../../core/constant_plot.js'),
        DataValue                 = require('../../core/data_value.js'),
        DateTimeValue             = require('../../core/datetime_value.js'),
        Renderer                  = require('../../core/renderer.js'),
        Filter                    = require('../../core/filter.js'),
        ConsecutiveDistanceFilter = require('../../core/consecutive_distance_filter.js'),
        Datatips                  = require('../../core/datatips.js'),
        pF                        = require('../../util/parsingFunctions.js'),
        vF                        = require('../../util/validationFunctions.js'),
        plot,
        haxis,
        vaxis,
        variable,
        attr;

    // so that PlotLegend,Renderer,Filter,Datatips will have .parseJSON when called below:
    require('./plot_legend.js');
    require('./renderer.js');
    require('./filter.js');
    require('./datatips.js');

    // return the (first) key of an object; intended for convenient fetching of the
    // key name of an object (verticalaxis or horizontalaxis) that contains only one key
    function key(obj) {
        return (Object.keys(obj))[0];
    }

    // return the number of keys in an object
    function keyCount(obj) {
        return Object.keys(obj).length;
    }

    // Return true iff the value v looks like a data_value -- i.e. it's either a number,
    // or a string that looks like it could be parsed into either a number or a datetime value.
    function looks_like_data_value(v) {
        if (vF.typeOf(v) === 'number') {
            return true;
        } else if (vF.typeOf(v) === 'string') {
            // !isNaN is the recommended way to test whether a string represents a valid number
            // http://stackoverflow.com/questions/175739/is-there-a-built-in-way-in-javascript-to-check-if-a-string-is-a-valid-number
            if (!isNaN(v)) {  
                return true;
            } else {
                // if the string isn't a valid number, try to parse it as a DatetimeValue
                try { DatetimeValue.parse(v); }
                catch (e) { return false; }
                return true;
            }
        } else {
            return false;
        }
    }

    if (json) {
        var vars = {
            "horizontal" : [],
            "vertical"   : []
        };
        var axisid = {
            "horizontal" : undefined,
            "vertical"   : undefined
        };

//   "verticalaxis" : [ VARIABLE-ID(string), ... ]
//   "verticalaxis" : { AXIS-ID(string): DATA-VALUE(number or string) }     <-- ConstantPlot
//   "verticalaxis" : { AXIS-ID(string): VARIABLE-ID(string) }
//   "verticalaxis" : { AXIS-ID(string): [ VARIABLE-ID(string), ... ] }
//   "verticalaxis" : DATA-VALUE(number or string)                          <-- ConstantPlot
//   "verticalaxis" : AXIS-ID(string)

        // deal with vertical axis first, because it determines whether we have
        // a ConstantPlot or a DataPlot
        var constant_value = undefined;
        if (json.verticalaxis) {
            if (vF.typeOf(json.verticalaxis) === 'array') {
                // if it's an array, it's a list of variable ids for the plot,
                // and the axisid is unspecified
                vars.vertical = json.verticalaxis;
            } else if (vF.typeOf(json.verticalaxis) === 'number') {
                // in theory we'd like to validate here that the vertical axis type is NUMBER, but
                // we can't do that because we don't actually have the axis yet -- its id is implied
                // so it will be determined later.  So we set a numeric constant value and hope
                // for the best.
                constant_value = DataValue.parse(DataValue.NUMBER, json.verticalaxis);
            } else if (vF.typeOf(json.verticalaxis) === 'string') {
                // It's a string that is either an axis id, or a DatetimeValue constant (we
                // know it's not a number constant, because that would have been caught by
                // the 'number' case above).
                if (looks_like_data_value(json.verticalaxis)) {
                    // Again, in theory, we'd like to validate that the axis type is DateTime,
                    // but we can't because we don't have the axis yet.
                    constant_value = DataValue.parse(DataValue.DATETIME, json.verticalaxis);
                } else {
                    axisid.vertical = json.verticalaxis;
                    vaxis = graph.axisById(axisid.vertical);
                    if (typeof(vaxis) === 'undefined') {
                        throw new Error("plot refers to unknown vertical axis id: " + axisid.vertical);
                    }
                }
            } else if (vF.typeOf(json.verticalaxis) === 'object') {
                // if it's an object, the key is the axis id, and the value
                // is either:
                //    case 1: an array of variable ids, or
                //    case 2: a single value that is either an axis id, or
                //            a constant value for a constant plot
                if (keyCount(json.verticalaxis) !== 1) {
                    throw new Error("plot.verticalaxis object must contain exactly one key/value pair");
                }
                axisid.vertical = key(json.verticalaxis);
                vaxis = graph.axisById(axisid.vertical);
                if (typeof(vaxis) === 'undefined') {
                    throw new Error("plot refers to unknown vertical axis id: " + axisid.vertical);
                }
                if (vF.typeOf(json.verticalaxis[axisid.vertical]) !== "undefined") {
                    if (vF.typeOf(json.verticalaxis[axisid.vertical]) === 'array') {
                        // case 1: array of variable ids.
                        vars.vertical = json.verticalaxis[axisid.vertical];
                    } else {
                        // case 2: single value, either axis id, or constant value.
                        //   if it's a number, it must be a constant value
                        if (vF.typeOf(json.verticalaxis[axisid.vertical]) === 'number') {
                            if (vaxis.type() !== DataValue.NUMBER) {
                                throw new Error("constant value of '" + json.verticalaxis[axisid.vertical]
                                                + "' not appropriate for axis of type '" + vaxis.type() + "'");
                            }
                            constant_value = DataValue.parse(DataValue.NUMBER, json.verticalaxis[axisid.vertical]);
                        } else {
                            // it's not a number, so it must be a string that is either
                            // a constant DatetimeValue, or an axis id.
                            if (vF.typeOf(json.verticalaxis[axisid.vertical]) !== 'string') {
                                throw new Error("value for key '" + axisid.vertical + "' for verticalaxis is of wrong type");
                            }
                            if (looks_like_data_value(json.verticalaxis[axisid.vertical])) {
                                constant_value = DataValue.parse(vaxis.type(), json.verticalaxis[axisid.vertical]);
                            } else {
                                vars.vertical = [ json.verticalaxis[axisid.vertical] ];
                            }
                        }
                    }
                }
            }
        }

        if (constant_value !== undefined) {
            plot = new ConstantPlot(constant_value);
        } else {
            plot = new DataPlot();
        }

        plot.verticalaxis(vaxis);

        //   "horizontalaxis" : AXIS-ID(string)
        //   "horizontalaxis" : [ VARIABLE-ID(string), ... ]
        //   "horizontalaxis" : { AXIS-ID(string): [ VARIABLE-ID(string), ... ] }
        if (json.horizontalaxis) {
            if (vF.typeOf(json.horizontalaxis) === 'array') {
                // if it's an array, it's a list of variable ids for the plot,
                // and the axisid is unspecified
                vars.horizontal = json.horizontalaxis;
            } else if (vF.typeOf(json.horizontalaxis) === 'string') {
                axisid.horizontal = json.horizontalaxis;
                haxis = graph.axisById(axisid.horizontal);
                if (haxis !== undefined) {
                    plot.horizontalaxis(haxis);
                } else {
                    throw new Error("Plot Horizontal Axis Error: The graph does not contain an axis with an id of '" + axisid.horizontal + "'");
                }
            } else if (vF.typeOf(json.horizontalaxis) === 'object') {
                // if it's an object, the key is the axis id, and the value
                // is either:
                //    case 1: an array of variable ids, or
                //    case 2: an axis id
                if (keyCount(json.horizontalaxis) !== 1) {
                    throw new Error("plot.horizontalaxis object must contain exactly one key/value pair");
                }
                axisid.horizontal = key(json.horizontalaxis);
                haxis = graph.axisById(axisid.horizontal);
                if (haxis !== undefined) {
                    plot.horizontalaxis(haxis);
                } else {
                    throw new Error("Plot Horizontal Axis Error: The graph does not contain an axis with an id of '" + axisid.horizontal + "'");
                }
                if (vF.typeOf(json.horizontalaxis[axisid.horizontal]) !== "undefined") {
                    if (vF.typeOf(json.horizontalaxis[axisid.horizontal]) === 'array') {
                        // case 1: array of variable ids.
                        vars.horizontal = json.horizontalaxis[axisid.horizontal];
                    } else {
                        // case 2: an axis id
                            // must be a string that is an axis id.
                            if (vF.typeOf(json.horizontalaxis[axisid.horizontal]) !== 'string') {
                                throw new Error("value for key '" + axisid.horizontal + "' for horizontalaxis is of wrong type");
                            }
                        vars.horizontal = [ json.horizontalaxis[axisid.horizontal] ];
                    }
                }
            }
        }

        // if this is a DataPlot, parse variables
        if (plot instanceof DataPlot) {

            // provide default horizontalaxis variable if none present
            if (vars.horizontal.length == 0) {
                plot.variable().add(null);
            }

            //TODO: defer population of variables until normalizer has executed
            // populate axis variables
            if (graph) {
                var allvars = [].concat(vars.horizontal, vars.vertical);
                allvars.forEach(function(vid) {
                    variable = graph.variableById(vid);
                    if (variable !== undefined) {
                        plot.data( variable.data() );
                        plot.variable().add(variable);
                    } else {
                        throw new Error("Plot Variable Error: No Data tag contains a variable with an id of '" + vid + "'");
                    }
                });
            }
        }





//xxx        // populate verticalaxis
//xxx        if (json.verticalaxis) {
//xxx            if (vF.typeOf(json.verticalaxis) === 'string') {
//xxx                axisid.vertical = json.verticalaxis;
//xxx            } else {
//xxx                if (keyCount(json.verticalaxis) !== 1) {
//xxx                    throw new Error("plot.verticalaxis must contain exactly one key/value pair");
//xxx                }
//xxx                axisid.vertical = key(json.verticalaxis);
//xxx                if (vF.typeOf(json.verticalaxis[axisid.vertical]) !== "undefined") {
//xxx                    if (vF.typeOf(json.verticalaxis[axisid.vertical]) === 'array') {
//xxx                        vars.vertical = json.verticalaxis[axisid.vertical];
//xxx                    } else {
//xxx                        vars.vertical = [ json.verticalaxis[axisid.vertical] ];
//xxx                    }
//xxx                }
//xxx            }
//xxx            vaxis = graph.axisById(axisid.vertical);
//xxx            if (vaxis === undefined) {
//xxx                throw new Error("Plot Vertical Axis Error: The graph does not contain an axis with an id of '" + axisid.vertical + "'");
//xxx            }
//xxx        }
//xxx
//xxx
//xxx//        // populate verticalaxis
//xxx//        if (json.verticalaxis && json.verticalaxis.ref) {
//xxx//            vaxis = graph.axisById(json.verticalaxis.ref);
//xxx//            if (vaxis === undefined) {
//xxx//                throw new Error("Plot Vertical Axis Error: The graph does not contain an axis with an id of '" + json.verticalaxis.ref + "'");
//xxx//            }
//xxx//        }
//xxx
//xxx        // If there is a verticalaxis object, and if the value it contains looks like a
//xxx        // number or datetime value, assume it's a Constant Plot.  Otherwise assume the
//xxx        // value is either a variable id, or a list of variable ids, so we have a Data Plot.
//xxx        if ((vF.typeOf(json.verticalaxis) === 'object') && looks_like_data_value(json.verticalaxis[axisid.vertical])) {
//xxx            plot = new ConstantPlot(DataValue.parse(vaxis.type(), json.verticalaxis[axisid.vertical]));
//xxx        } else {
//xxx            plot = new DataPlot();
//xxx        }
//xxx
//xxx//        if (json.verticalaxis && json.verticalaxis.constant) {
//xxx//            plot = new ConstantPlot(DataValue.parse(vaxis.type(), json.verticalaxis.constant));
//xxx//        } else {
//xxx//            plot = new DataPlot();
//xxx//        }
//xxx
//xxx        plot.verticalaxis(vaxis);
//xxx
//xxx        // populate horizontalaxis
//xxx        if (json.horizontalaxis) {
//xxx            if (vF.typeOf(json.horizontalaxis) === 'string') {
//xxx                axisid.horizontal = json.horizontalaxis;
//xxx            } else {
//xxx                if (keyCount(json.horizontalaxis) !== 1) {
//xxx                    throw new Error("plot.horizontalaxis must contain exactly one key/value pair");
//xxx                }
//xxx                axisid.horizontal = key(json.horizontalaxis);
//xxx                if (vF.typeOf(json.horizontalaxis[axisid.horizontal]) !== "undefined") {
//xxx                    if (vF.typeOf(json.horizontalaxis[axisid.horizontal]) === 'array') {
//xxx                        vars.horizontal = json.horizontalaxis[axisid.horizontal];
//xxx                    } else {
//xxx                        vars.horizontal = [ json.horizontalaxis[axisid.horizontal] ];
//xxx                    }
//xxx                }
//xxx                haxis = graph.axisById(axisid.horizontal);
//xxx                if (haxis !== undefined) {
//xxx                    plot.horizontalaxis(haxis);
//xxx                } else {
//xxx                    throw new Error("Plot Horizontal Axis Error: The graph does not contain an axis with an id of '" + axisid.horizontal + "'");
//xxx                }
//xxx            }
//xxx        }
//xxx
//xxx//        if (json.horizontalaxis && json.horizontalaxis.ref) {
//xxx//            haxis = graph.axisById(json.horizontalaxis.ref);
//xxx//            if (haxis !== undefined) {
//xxx//                plot.horizontalaxis(haxis);
//xxx//            } else {
//xxx//                throw new Error("Plot Horizontal Axis Error: The graph does not contain an axis with an id of '" + json.horizontalaxis.ref + "'");
//xxx//            }
//xxx//        }
//xxx
//xxx        // if this is a DataPlot, parse variables
//xxx        if (plot instanceof DataPlot) {
//xxx
//xxx            // provide default horizontalaxis variable if none present
//xxx            if (vars.horizontal.length == 0) {
//xxx                plot.variable().add(null);
//xxx            }
//xxx
//xxx            //TODO: defer population of variables until normalizer has executed
//xxx            // populate axis variables
//xxx            if (graph) {
//xxx                var allvars = [].concat(vars.horizontal, vars.vertical);
//xxx                allvars.forEach(function(vid) {
//xxx                    variable = graph.variableById(vid);
//xxx                    if (variable !== undefined) {
//xxx                        plot.data( variable.data() );
//xxx                        plot.variable().add(variable);
//xxx                    } else {
//xxx                        throw new Error("Plot Variable Error: No Data tag contains a variable with an id of '" + vid + "'");
//xxx                    }
//xxx                });
//xxx            }
//xxx        }



//        // if this is a DataPlot, parse variables
//        if (plot instanceof DataPlot) {
//            // provide default horizontalaxis variable if not present
//            if (!json.horizontalaxis || !json.horizontalaxis.variables || json.horizontalaxis.variables.length === 0) {
//                plot.variable().add(null);
//            }
//
//            //TODO: defer population of variables until normalizer has executed
//            // populate axis variables
//            var vars = [];
//            if (graph) {
//                if (json.horizontalaxis && json.horizontalaxis.variables) {
//                    vars = vars.concat(json.horizontalaxis.variables);
//                }
//                if (json.verticalaxis && json.verticalaxis.variables) {
//                    vars = vars.concat(json.verticalaxis.variables);
//                }
//                vars.forEach(function(vid) {
//                    variable = graph.variableById(vid);
//                    if (variable !== undefined) {
//                        plot.data( variable.data() );
//                        plot.variable().add(variable);
//                    } else {
//                        throw new Error("Plot Variable Error: No Data tag contains a variable with an id of '" + vid + "'");
//                    }
//                });
//            }
//        }

        if ("legend" in json) {
            plot.legend(PlotLegend.parseJSON(json.legend, plot));
        } else {
            plot.legend(PlotLegend.parseJSON(undefined, plot));
        }

        if (("renderer" in json) && (("style" in json) || ("options" in json))) {
            throw new Error("plot may not contain both 'renderer' and 'style', or 'renderer' and 'options'");
        }

        if (json.visible !== undefined) {
            plot.visible(json.visible);
        }

        if ("renderer" in json) {
            plot.renderer(Renderer.parseJSON(json.renderer, plot, messageHandler));
        } else if ("style" in json) {
            // json.options may or may not be present here
            plot.renderer(Renderer.parseJSON(
                { "type" : json.style, "options" : json.options },
                plot, messageHandler));
        } else if ("options" in json) {
            // json.options is present, but json.style is not here
            // json.options may or may not be present here
            plot.renderer(Renderer.parseJSON(
                { "type" : "line", "options" : json.options },
                plot, messageHandler));
        }

        if ("filter" in json) {
            if (vF.typeOf(json.filter) === 'object') {
                if ((typeof(json.filter.type) !== 'undefined') && (json.filter.type !== 'consecutivedistance')) {
                    throw new Error('unknown filter type: ' + json.filter.type);
                }
                plot.renderer().filter(new ConsecutiveDistanceFilter(json.filter));
            } else if (vF.typeOf(json.filter) === 'boolean') {
                if (json.filter) {
                    if (graph && graph.filter()) {
                        plot.renderer().filter(graph.filter());
                    } else {
                        plot.renderer().filter(new ConsecutiveDistanceFilter({}));
                    }
                }
            } else {
                throw new Error('invalid filter property: ' + json.filter);
            }
        } else if (graph && graph.filter()) {
            plot.renderer().filter(graph.filter());
        }

        if ("datatips" in json) {
            plot.datatips(Datatips.parseJSON(json.datatips));
        }

    }
    return plot;
};

module.exports = Plot;

},{"../../core/consecutive_distance_filter.js":24,"../../core/constant_plot.js":25,"../../core/data_plot.js":30,"../../core/data_value.js":31,"../../core/datatips.js":33,"../../core/datetime_value.js":38,"../../core/filter.js":40,"../../core/plot.js":55,"../../core/plot_legend.js":56,"../../core/renderer.js":58,"../../util/parsingFunctions.js":158,"../../util/validationFunctions.js":160,"./datatips.js":114,"./filter.js":115,"./plot_legend.js":127,"./renderer.js":129}],127:[function(require,module,exports){
var PlotLegend = require('../../core/plot_legend.js');

// "legend" : { "visible" : BOOLEAN,  "label" : "STRING" }
// BOOLEAN
PlotLegend.parseJSON = function (json, plot) {
    var legend           = new PlotLegend(),
        pF               = require('../../util/parsingFunctions.js'),
        Text             = require('../../core/text.js'),
        parseAttribute   = pF.parseAttribute,
        child;
    if (typeof(json) === "boolean") {
        legend.visible(json);
    } else {
        if (json) {
            parseAttribute(json.visible, legend.visible, pF.parseBoolean);
            parseAttribute(json.label,   legend.label,   function (value) { return new Text(value); });
        }
    }
    if (legend.label() === undefined) {
        // TODO: remove this ugly patch with something that works properly
        if (typeof(plot.variable)==="function" && plot.variable().size() >= 2) { 
            legend.label(new Text(plot.variable().at(1).id()));
        } else {
            legend.label(new Text("plot"));
        }
    }

    return legend;
};

module.exports = PlotLegend;

},{"../../core/plot_legend.js":56,"../../core/text.js":65,"../../util/parsingFunctions.js":158}],128:[function(require,module,exports){
var Plotarea = require('../../core/plotarea.js');

//  "plotarea" : {
//     "marginbottom": INTEGER(35),
//     "marginleft": INTEGER(38),
//     "margintop": INTEGER(10),
//     "marginright": INTEGER(35),
//     "border": INTEGER(0),
//     "bordercolor": COLOR(0xeeeeee),
//     "color": COLOR,
//  }
Plotarea.parseJSON = function (json) {
    var plotarea = new Plotarea(),
        margin = plotarea.margin(),
        pF               = require('../../util/parsingFunctions.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        parseRGBColor    = RGBColor.parse,
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger;
    if (json) {
        parseAttribute(json.marginbottom, margin.bottom);
        parseAttribute(json.marginleft,   margin.left);
        parseAttribute(json.margintop,    margin.top);
        parseAttribute(json.marginright,  margin.right);
        parseAttribute(json.border,       plotarea.border);
        parseAttribute(json.color,        plotarea.color,       parseRGBColor);
        parseAttribute(json.bordercolor,  plotarea.bordercolor, parseRGBColor);
    }
    return plotarea;
};

module.exports = Plotarea;

},{"../../core/plotarea.js":57,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],129:[function(require,module,exports){
var Renderer = require('../../core/renderer.js');

// "renderer" : {
//     "type" : RENDERERTYPE(line)
//     "options" : [
//       { "name" : "STRING!", "value" : "STRING!", "min" : "DATAVALUE", "max" : "DATAVALUE" },
//       { "name" : "STRING!", "value" : "STRING!", "min" : "DATAVALUE", "max" : "DATAVALUE" },
//       ...
//     ]
//   }
Renderer.parseJSON = function (json, plot, messageHandler) {
    var DataValue   = require('../../core/data_value.js'),
        NumberValue = require('../../core/number_value.js'),
        Warning     = require('../../core/warning.js'),
        pF          = require('../../util/parsingFunctions.js'),
        vF          = require('../../util/validationFunctions.js'),
        rendererType,
        renderer,
        opt;

    require('../../core/renderers/all_renderers.js');

    function setOption(name, value, min, max) {
        try {
            renderer.setOptionFromString(name, value, min, max);
        } catch (e) {
            if (e instanceof Warning) {
                messageHandler.warning(e);
            } else {
                throw e;
            }
        }
    }

    if (json && json.type !== undefined) {
        rendererType = Renderer.Type.parse(json.type);
        if (!Renderer.Type.isInstance(rendererType)) {
            throw new Error("unknown renderer type '" + json.type + "'");
        }
        renderer = Renderer.create(rendererType);
        renderer.plot(plot);

        if (json.options) {
            for (opt in json.options) {
                if (json.options.hasOwnProperty(opt)) {
                    if (vF.typeOf(json.options[opt]) === 'array') {
                        json.options[opt].forEach(function(subopt) {
                            setOption(opt, subopt.value, subopt.min, subopt.max);
                        });
                    } else {
                        setOption(opt, json.options[opt]);
                    }
                }
            }
        }

    }
    return renderer;
};

module.exports = Renderer;

},{"../../core/data_value.js":31,"../../core/number_value.js":52,"../../core/renderer.js":58,"../../core/renderers/all_renderers.js":59,"../../core/warning.js":67,"../../util/parsingFunctions.js":158,"../../util/validationFunctions.js":160}],130:[function(require,module,exports){
var Title = require('../../core/title.js');

//  "title" : {
//      "base" : POINT(0,1),
//      "anchor" : POINT(0,1),
//      "position" : POINT(0,0),
//      "frame" : FRAME(padding),
//      "color" : COLOR(white),
//      "opacity" : DOUBLE(1.0),
//      "border" : INTEGER(0),
//      "bordercolor" : COLOR(black),
//      "padding" : INTEGER(0),
//      "cornerradius" : INTEGER(15),
//      "fontsize" : INTEGER,
//      "text" : STRING
//  }
Title.parseJSON = function (json, graph) {
    var Point            = require('../../math/point.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        Text             = require('../../core/text.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parseJSONPoint   = function(p) { return new Point(p[0], p[1]); },
        parseRGBColor    = RGBColor.parse,
        parseAttribute   = pF.parseAttribute,
        title;

    if (json) {
        var text = json.text;
        if (text !== "") {
            title = new Title(new Text(text), graph);
        } else {
            return undefined;
        }                
        parseAttribute(json.frame,        title.frame,        function (value) { return value.toLowerCase(); });
        parseAttribute(json.border,       title.border);
        parseAttribute(json.color,        title.color,        parseRGBColor);
        parseAttribute(json.bordercolor,  title.bordercolor,  parseRGBColor);
        parseAttribute(json.opacity,      title.opacity);
        parseAttribute(json.padding,      title.padding);
        parseAttribute(json.cornerradius, title.cornerradius);
        parseAttribute(json.anchor,       title.anchor,       parseJSONPoint);
        parseAttribute(json.base,         title.base,         parseJSONPoint);
        parseAttribute(json.position,     title.position,     parseJSONPoint);
    }
    return title;
};

module.exports = Title;

},{"../../core/text.js":65,"../../core/title.js":66,"../../math/point.js":106,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],131:[function(require,module,exports){
var Window = require('../../core/window.js');

// "window" {
//       "width": INTEGER,
//       "height": INTEGER,
//       "border": INTEGER(2),
//       "bordercolor": COLOR(black),
//       "margin": INTEGER(2),
//       "padding": INTEGER(5),
// }
Window.parseJSON = function (json) {
    var w = new Window(),
        RGBColor         = require('../../math/rgb_color.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger,
        attr;
    if (json) {
        parseAttribute(json.width,  w.width);
        parseAttribute(json.height, w.height);
        parseAttribute(json.border, w.border);

        attr = json.margin;
        if (attr !== undefined) {
            w.margin().set(attr,attr,attr,attr);
        }

        attr = json.padding;
        if (attr !== undefined) {
                w.padding().set(attr,attr,attr,attr);
        }
        parseAttribute(json.bordercolor, w.bordercolor, RGBColor.parse);
    }
    return w;
};

module.exports = Window;

},{"../../core/window.js":71,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],132:[function(require,module,exports){
var Zoom = require('../../core/zoom.js');

Zoom.parseJSON = function (json, type) {
    var zoom             = new Zoom(),
        DataValue        = require('../../core/data_value.js'),
        DataMeasure      = require('../../core/data_measure.js'),
        pF               = require('../../util/parsingFunctions.js'),
        vF               = require('../../util/validationFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        parseBoolean     = pF.parseBoolean,
        parseDataMeasure = function(v) { return DataMeasure.parse(type, v); }, //pF.parseDataMeasure
        attr;
    if (vF.typeOf(json) === 'boolean') {
        parseAttribute(json,         zoom.allowed, parseBoolean);
    } else if (json) {
        parseAttribute(json.allowed, zoom.allowed, parseBoolean);
        parseAttribute(json.min,     zoom.min,     parseDataMeasure);
        parseAttribute(json.max,     zoom.max,     parseDataMeasure);
        attr = json.anchor;
        if (attr !== undefined) {
            if (typeof(attr) === "string" && attr.toLowerCase() === "none") {
                zoom.anchor(null);
            } else {
                zoom.anchor( DataValue.parse(type, attr) );
            }
        }
    }
    return zoom;
};

module.exports = Zoom;

},{"../../core/data_measure.js":29,"../../core/data_value.js":31,"../../core/zoom.js":72,"../../util/parsingFunctions.js":158,"../../util/validationFunctions.js":160}],133:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.

//  <horizontalaxis id="STRING" type="DATATYPE(number)" length="RELLEN(1.0)" base="POINT(-1,1)" anchor="DOUBLE(-1)" position="POINT(0,0)"
//      min="DATAVALUEORAUTO(auto)" max="DATAVALUEORAUTO(auto)" minposition="RELPOS(-1.0)" maxposition="RELPOS(1.0)" color="COLOR(black)" linewidth="INTEGER(1)"
//      tickmin="INTEGER(-3)" tickmax="INTEGER(3)" tickcolor="COLOR(black)">
//    <labels format="STRING" start="DATAVALUE(0)" angle="DOUBLE(0)" position="POINT" anchor="POINT" color="COLOR(black)" spacing="STRING" densityfactor="DOUBLE(1.0)">
//        <label format="STRING" start="STRING" angle="DOUBLE" position="POINT" anchor="POINT" spacing="STRING" densityfactor="DOUBLE">
//        <label format="STRING" start="STRING" angle="DOUBLE" position="POINT" anchor="POINT" spacing="STRING" densityfactor="DOUBLE">
//      </label>
//    </labels>
//    <title base="DOUBLE(0)" anchor="POINT" position="POINT" angle="DOUBLE(0)">TITLETEXT</title>
//    <grid color="COLOR(0xeeeeee)" visible="BOOLEAN(false)" />
//    <pan allowed="BOOLEAN(yes)" min="DATAVALUE" max="DATAVALUE" />
//    <zoom allowed="BOOLEAN(yes)" min="DATAMEASURE" max="DATAMEASURE" anchor="DATAVALUE" />
//    <binding id="STRING!" min="DATAVALUE!" max="DATAVALUE!" />
//  </horizontalaxis>

module.exports = function($) {
    var Axis = require('../../core/axis.js'),
        pF = require('../../util/parsingFunctions.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Axis.parseXML)==="function") { return Axis; };

    var parseLabels = function (xml, axis) {
        var spacingStrings = [],
            spacingString,
            labelsTag = xml.find("labels"),
            labelTags = xml.find("label"),
            labelers  = axis.labelers(),
            Labeler = require('../../core/labeler.js'),
            DataValue = require('../../core/data_value.js'),
            utilityFunctions = require('../../util/utilityFunctions.js'),
            i;
        spacingString = $.trim(pF.getXMLAttr(labelsTag,"spacing"));
        if (spacingString !== "") {
            spacingStrings = spacingString.split(/\s+/);
        }
        if (spacingStrings.length > 0) {
            // If there was a spacing attr on the <labels> tag, create a new labeler for
            // each spacing present in it, using the other values from the <labels> tag
            for (i = 0; i < spacingStrings.length; ++i) {
                labelers.add(Labeler.parseXML(labelsTag, axis, undefined, spacingStrings[i]));
            }
        } else if (labelTags.length > 0) {
            // If there are <label> tags, parse the <labels> tag to get default values
            var defaults = Labeler.parseXML(labelsTag, axis, undefined, null);
            // And loop over each <label> tag, creating labelers for each, splitting multiple
            // spacings on the same <label> tag into multiple labelers:
            $.each(labelTags, function (j, e) {
                spacingString = $.trim(pF.getXMLAttr($(e), "spacing"));
                spacingStrings = [];
                if (spacingString !== "") {
                    spacingStrings = spacingString.split(/\s+/);
                }
                for (i = 0; i < spacingStrings.length; ++i) {
                    labelers.add( Labeler.parseXML($(e), axis, defaults, spacingStrings[i]) );
                }
            });
        } else {
            // Otherwise create labelers using the default spacing, with the other values
            // from the <labels> tag
            var defaultValues = (utilityFunctions.getDefaultValuesFromXSD()).horizontalaxis.labels;
            var defaultSpacings = axis.type() === DataValue.NUMBER ?
                    defaultValues.defaultNumberSpacing :
                    defaultValues.defaultDatetimeSpacing;
            for (i = 0; i < defaultSpacings.length; ++i) {
                labelers.add(Labeler.parseXML(labelsTag, axis, undefined, defaultSpacings[i]));
            }
        }
    };

    
    Axis.parseXML = function (xml, orientation, messageHandler, multigraph) {

        var DataValue = require('../../core/data_value.js'),
            Point = require('../../math/point.js'),
            RGBColor = require('../../math/rgb_color.js'),
            Displacement = require('../../math/displacement.js'),
            AxisTitle = require('../../core/axis_title.js'),
            Grid = require('../../core/grid.js'),
            Pan = require('../../core/pan.js'),
            Zoom = require('../../core/zoom.js'),
            AxisBinding = require('../../core/axis_binding.js'),

            axis              = new Axis(orientation),
            parseAttribute    = pF.parseAttribute,
            parseInteger      = pF.parseInteger,
            parseDisplacement = Displacement.parse,
            parsePoint        = Point.parse,
            parseRGBColor     = RGBColor.parse,
            attr, child,
            value;

        if (xml) {

            parseAttribute(pF.getXMLAttr(xml, "id"),     axis.id);
            parseAttribute(pF.getXMLAttr(xml, "type"),   axis.type,   DataValue.parseType);
            parseAttribute(pF.getXMLAttr(xml, "length"), axis.length, parseDisplacement);

            //
            // The following provides support for the deprecated "positionbase" axis attribute;
            // MUGL files should use the "base" attribute instead.  When we're ready to remove
            // support for the deprecated attribute, delete this block of code:
            //
            (function () {
                var positionbase = pF.getXMLAttr(xml, "positionbase");
                if (positionbase) {
                    messageHandler.warning('Use of deprecated axis attribute "positionbase"; use "base" attribute instead');
                    if ((positionbase === "left") || (positionbase === "bottom")) {
                        axis.base(parsePoint("-1 -1"));
                    } else if (positionbase === "right") {
                        axis.base(parsePoint("1 -1"));
                    } else if (positionbase === "top") {
                        axis.base(parsePoint("-1 1"));
                    }
                }
            }());
            //
            // End of code to delete when removing support for deprecated "positionbase"
            // attribute.
            //

            attr = pF.getXMLAttr(xml, "position");
            if (attr !== undefined) {
                try {
                    axis.position(parsePoint(attr));
                } catch (e) {
                    // If position did not parse as a Point, and if it can be interpreted
                    // as a number, construct the position point by interpreting that
                    // number as an offset from the 0 location along the perpendicular
                    // direction.
                    value = parseInt(attr, 10);
                    if (value !== value) { // test for isNaN
                        throw e;
                    }
                    if (orientation === Axis.HORIZONTAL) {
                        axis.position(new Point(0, value));
                    } else {
                        axis.position(new Point(value, 0));
                    }
                }
            }

            axis.min(pF.getXMLAttr(xml, "min"));
            if (axis.min() !== "auto") {
                axis.dataMin(DataValue.parse(axis.type(), axis.min()));
            }
            axis.max(pF.getXMLAttr(xml, "max"));
            if (axis.max() !== "auto") {
                axis.dataMax(DataValue.parse(axis.type(), axis.max()));
            }

            parseAttribute(pF.getXMLAttr(xml, "pregap"),         axis.pregap,         parseFloat);
            parseAttribute(pF.getXMLAttr(xml, "postgap"),        axis.postgap,        parseFloat);
            parseAttribute(pF.getXMLAttr(xml, "anchor"),         axis.anchor,         parseFloat);
            parseAttribute(pF.getXMLAttr(xml, "base"),           axis.base,           parsePoint);
            parseAttribute(pF.getXMLAttr(xml, "minposition"),    axis.minposition,    parseDisplacement);
            parseAttribute(pF.getXMLAttr(xml, "maxposition"),    axis.maxposition,    parseDisplacement);
            parseAttribute(pF.getXMLAttr(xml, "minoffset"),      axis.minoffset,      parseFloat);
            parseAttribute(pF.getXMLAttr(xml, "maxoffset"),      axis.maxoffset,      parseFloat);
            parseAttribute(pF.getXMLAttr(xml, "color"),          axis.color,          parseRGBColor);
            parseAttribute(pF.getXMLAttr(xml, "tickcolor"),      axis.tickcolor,      parseRGBColor);
            parseAttribute(pF.getXMLAttr(xml, "tickwidth"),      axis.tickwidth,      parseInteger);
            parseAttribute(pF.getXMLAttr(xml, "tickmin"),        axis.tickmin,        parseInteger);
            parseAttribute(pF.getXMLAttr(xml, "tickmax"),        axis.tickmax,        parseInteger);
            parseAttribute(pF.getXMLAttr(xml, "highlightstyle"), axis.highlightstyle);
            parseAttribute(pF.getXMLAttr(xml, "linewidth"),      axis.linewidth,      parseInteger);
            
            child = xml.find("title");
            if (child.length > 0)                    { axis.title(AxisTitle.parseXML(child, axis));     }
            else                                     { axis.title(new AxisTitle(axis));               }
            child = xml.find("grid");
            if (child.length > 0)                    { axis.grid(Grid.parseXML(child));                 }
            child = xml.find("pan");
            if (child.length > 0)                    { axis.pan(Pan.parseXML(child, axis.type()));      }
            child = xml.find("zoom");
            if (child.length > 0)                    { axis.zoom(Zoom.parseXML(child, axis.type()));    }
            if (xml.find("labels").length > 0)       { parseLabels(xml, axis);                             }

            child = xml.find("binding");
            if (child.length > 0) {
                var bindingIdAttr  = pF.getXMLAttr(child,"id"),
                    bindingMinAttr = pF.getXMLAttr(child,"min"),
                    bindingMaxAttr = pF.getXMLAttr(child,"max"),
                    bindingMinDataValue = DataValue.parse(axis.type(), bindingMinAttr),
                    bindingMaxDataValue = DataValue.parse(axis.type(), bindingMaxAttr);
                if (typeof(bindingIdAttr) !== "string" || bindingIdAttr.length <= 0) {
                    throw new Error("invalid axis binding id: '" + bindingIdAttr + "'");
                }
                if (! DataValue.isInstance(bindingMinDataValue)) {
                    throw new Error("invalid axis binding min: '" + bindingMinAttr + "'");
                }
                if (! DataValue.isInstance(bindingMaxDataValue)) {
                    throw new Error("invalid axis binding max: '" + bindingMaxAttr + "'");
                }
                AxisBinding.findByIdOrCreateNew(bindingIdAttr).addAxis(axis, bindingMinDataValue, bindingMaxDataValue, multigraph);
            }

        }
        return axis;
    };

    return Axis;
};

},{"../../core/axis.js":19,"../../core/axis_binding.js":20,"../../core/axis_title.js":21,"../../core/data_value.js":31,"../../core/grid.js":43,"../../core/labeler.js":46,"../../core/pan.js":53,"../../core/zoom.js":72,"../../math/displacement.js":103,"../../math/point.js":106,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158,"../../util/utilityFunctions.js":159}],134:[function(require,module,exports){
var AxisTitle = require('../../core/axis_title.js');

// <title base="23.2" anchor="12 4" position="3 7" angle="45">temperature</title>
// empty title:
//   <title/>
AxisTitle.parseXML = function (xml, axis) {
    var title = new AxisTitle(axis),
        Text = require('../../core/text.js'),
        Point = require('../../math/point.js'),
        pF = require('../../util/parsingFunctions.js'),
        nonEmptyTitle = false,
        parsePoint = Point.parse,
        text,
        parseTitleAttribute = function (value, attribute, preprocessor) {
            if (pF.parseAttribute(value, attribute, preprocessor)) {
                // No.  Don't count the title as nonEmpty just because of attributes.
                // If a <title> tag has only attributes, and no content, this
                // function should return `undefined` so that the normalizer won't
                // come along later and populate the title content with the axis id.
                // Empty <title> content means don't draw a title at all, in which
                // case it's OK to just forget about any attributes that were set.
                //nonEmptyTitle = true;
            }
        };

    if (xml) {
        text = xml.text();
        if (text !== "") {
            title.content(new Text(text));
            nonEmptyTitle = true;
        }
        parseTitleAttribute(pF.getXMLAttr(xml,"anchor"),   title.anchor,   parsePoint);
        parseTitleAttribute(pF.getXMLAttr(xml,"base"),     title.base,     parseFloat);
        parseTitleAttribute(pF.getXMLAttr(xml,"position"), title.position, parsePoint);
        parseTitleAttribute(pF.getXMLAttr(xml,"angle"),    title.angle,    parseFloat);
    }

    if (nonEmptyTitle === true) { 
        return title;
    }
    return undefined;
};

module.exports = AxisTitle;

},{"../../core/axis_title.js":21,"../../core/text.js":65,"../../math/point.js":106,"../../util/parsingFunctions.js":158}],135:[function(require,module,exports){
var Background = require('../../core/background.js');

// <background color="#ffff00">
//   <img src="foo.png" anchor="-1 5" base="3 12" position="-2 3" frame="padding"/>
// </background>
Background.parseXML = function (xml, multigraph) {
    var background       = new Background(),
        pF               = require('../../util/parsingFunctions.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        Img              = require('../../core/img.js'),
        child;

    if (xml) {
        pF.parseAttribute(pF.getXMLAttr(xml,"color"), background.color, RGBColor.parse);
        child = xml.find("img");
        if (child.length > 0) {
            background.img(Img.parseXML(child, multigraph));
        }
    }
    return background;
};

module.exports = Background;

},{"../../core/background.js":22,"../../core/img.js":45,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],136:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Data = require('../../core/data.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Data.parseXML)==="function") { return Data; };

    // <data>
    //   <variables
    //       missingvalue="DATAVALUE"
    //       missingop="COMPARATOR">
    //     <variable
    //         id="STRING!"
    //         column="INTEGER"
    //         type="DATATYPE(number)"
    //         missingvalue="STRING"
    //         missingop="COMPARATOR">
    //     </variable>
    //   </variables>
    //   <repeat period="STRING"/>
    //   <values>
    //   </values>
    //   <csv
    //       location="STRING!">
    //   </csv>
    //   <service
    //       location="STRING!"
    //       format="STRING">
    //   </service>
    // </data>
    Data.parseXML = function (xml, multigraph, messageHandler) {
        var ArrayData = require('../../core/array_data.js'),
            DataVariable = require('../../core/data_variable.js'),
            DataMeasure = require('../../core/data_measure.js'),
            PeriodicArrayData = require('../../core/periodic_array_data.js'),
            CSVData = require('../../core/csv_data.js')($),
            WebServiceData = require('../../core/web_service_data.js')($),
            Multigraph = require('../../core/multigraph.js')($),
            pF = require('../../util/parsingFunctions.js'),
            variables_xml,
            defaultMissingvalueString,
            defaultMissingopString,
            dataVariables = [],
            data,
            adap, adapter = ArrayData;

        if (xml) {

            adap = pF.getXMLAttr($(xml),"adapter");
            if (adap !== undefined && adap !== "") {
                adapter = Multigraph.getDataAdapter(adap);
                if (adapter === undefined) {
                    throw new Error("Missing data adapater: " + adap);
                }
            }

            // parse the <variables> section
            variables_xml = xml.find("variables");
            defaultMissingvalueString = pF.getXMLAttr(variables_xml,"missingvalue");
            defaultMissingopString    = pF.getXMLAttr(variables_xml,"missingop");

            var variables = variables_xml.find(">variable");
            if (variables.length > 0) {
                $.each(variables, function (i, e) {
                    dataVariables.push( DataVariable.parseXML($(e)) );
                });
            }

            // check to see if we have a <repeat> section, and if so, grab the period from it
            var haveRepeat = false,
                period,
                repeat_xml = $(xml.find(">repeat"));
            if (repeat_xml.length > 0) {
                var periodString = pF.getXMLAttr($(repeat_xml),"period");
                if (periodString === undefined || periodString === "") {
                    messageHandler.warning("<repeat> tag requires a 'period' attribute; data treated as non-repeating");
                } else {
                    period = DataMeasure.parse(dataVariables[0].type(),
                                               periodString);
                    haveRepeat = true;
                }
            }

            // if we have a <values> section, parse it and return an ArrayData instance:
            var values_xml = $(xml.find(">values"));
            if (values_xml.length > 0) {
                values_xml = values_xml[0];
                var stringValues = adapter.textToStringArray(dataVariables, $(values_xml).text());
                if (haveRepeat) {
                    data = new PeriodicArrayData(dataVariables, stringValues, period);
                } else {
                    data = new ArrayData(dataVariables, stringValues);
                }
            }

            // if we have a <csv> section, parse it and return a CSVData instance:
            var csv_xml = $(xml.find(">csv"));
            if (csv_xml.length > 0) {
                csv_xml = csv_xml[0];
                var filename = pF.getXMLAttr($(csv_xml),"location");
                data = new CSVData(dataVariables,
                                   multigraph ? multigraph.rebaseUrl(filename) : filename,
                                   messageHandler,
                                   multigraph ? multigraph.getAjaxThrottle(filename) : undefined);
            }

            // if we have a <service> section, parse it and return a WebServiceData instance:
            var service_xml = $(xml.find(">service"));
            if (service_xml.length > 0) {
                service_xml = $(service_xml[0]);
                var location = pF.getXMLAttr(service_xml,"location");
                data = new WebServiceData(dataVariables,
                                          multigraph ? multigraph.rebaseUrl(location) : location,
                                          messageHandler,
                                          multigraph ? multigraph.getAjaxThrottle(location) : undefined);
                var format = pF.getXMLAttr(service_xml,"format");
                if (format) {
                    data.format(format);
                }
            }
        }

        if (data) {
            if (defaultMissingvalueString !== undefined) {
                data.defaultMissingvalue(defaultMissingvalueString);
            }
            if (defaultMissingopString !== undefined) {
                data.defaultMissingop(defaultMissingopString);
            }
            data.adapter(adapter);
        }

        return data;
    };

    return Data;
};


},{"../../core/array_data.js":18,"../../core/csv_data.js":26,"../../core/data.js":27,"../../core/data_measure.js":29,"../../core/data_variable.js":32,"../../core/multigraph.js":49,"../../core/periodic_array_data.js":54,"../../core/web_service_data.js":68,"../../util/parsingFunctions.js":158}],137:[function(require,module,exports){
var DataVariable = require('../../core/data_variable.js');

//  <variable
//      id="STRING!"
//      column="INTEGER"
//      type="DATATYPE(number)"
//      missingvalue="STRING"
//      missingop="COMPARATOR">
//  </variable>
DataVariable.parseXML = function (xml, data) {
    var variable,
        pF = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        DataValue        = require('../../core/data_value.js'),
        attr;

    if (xml && pF.getXMLAttr(xml,"id")) {
        variable = new DataVariable(pF.getXMLAttr(xml,"id"));
        parseAttribute(pF.getXMLAttr(xml,"column"),       variable.column,       pF.parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"type"),         variable.type,         DataValue.parseType);
        //parseAttribute(pF.getXMLAttr(xml,"missingvalue"), variable.missingvalue, pF.parseDataValue(variable.type()));
        parseAttribute(pF.getXMLAttr(xml,"missingvalue"), variable.missingvalue, function(v) { return DataValue.parse(variable.type(), v); });
        parseAttribute(pF.getXMLAttr(xml,"missingop"),    variable.missingop,    DataValue.parseComparator);
    }
    return variable;
};

module.exports = DataVariable;

},{"../../core/data_value.js":31,"../../core/data_variable.js":32,"../../util/parsingFunctions.js":158}],138:[function(require,module,exports){

// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Datatips = require('../../core/datatips.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Datatips.parseXML)==="function") { return Datatips; };

    // <datatips
    //   format="STRING!"
    //   bgcolor="COLOR"
    //   bgalpha="DOUBLE"
    //   border="INTEGER"
    //   bordercolor="COLOR"
    //   pad="INTEGER">
    //   <variable
    //     format="STRING!">
    //   </variable>
    // </datatips>
    Datatips.parseXML = function (xml) {
        var datatips         = new Datatips(),
            RGBColor         = require('../../math/rgb_color.js'),
            DatatipsVariable = require('../../core/datatips_variable.js'),
            pF = require('../../util/parsingFunctions.js'),
            parseRGBColor    = RGBColor.parse,
            parseAttribute   = pF.parseAttribute,
            parseInteger     = pF.parseInteger,
            child;
        if (xml) {
            child = xml.find("variable");
            if (child.length > 0) {
                $.each(child, function (i, e) {
                    datatips.variables().add( DatatipsVariable.parseXML($(e)) );
                });
            }
            
            parseAttribute(pF.getXMLAttr(xml,"format"),      datatips.formatString);
            parseAttribute(pF.getXMLAttr(xml,"bgcolor"),     datatips.bgcolor,     parseRGBColor);
            parseAttribute(pF.getXMLAttr(xml,"bgalpha"),     datatips.bgalpha,     parseFloat);
            parseAttribute(pF.getXMLAttr(xml,"border"),      datatips.border,      parseInteger);
            parseAttribute(pF.getXMLAttr(xml,"bordercolor"), datatips.bordercolor, parseRGBColor);
            parseAttribute(pF.getXMLAttr(xml,"pad"),         datatips.pad,         parseInteger);
        }
        return datatips;
    };

    return Datatips;
};

},{"../../core/datatips.js":33,"../../core/datatips_variable.js":34,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],139:[function(require,module,exports){
var DatatipsVariable = require('../../core/datatips_variable.js');

DatatipsVariable.parseXML = function (xml) {
    var variable = new DatatipsVariable(),
        pF = require('../../util/parsingFunctions.js');

    if (xml) {
        pF.parseAttribute(pF.getXMLAttr(xml,"format"), variable.formatString);
    }
    return variable;
};

module.exports = DatatipsVariable;

},{"../../core/datatips_variable.js":34,"../../util/parsingFunctions.js":158}],140:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Filter = require('../../core/filter.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Filter.parseXML)==="function") { return Filter; };

    // <filter type="STRING">
    //    <option name="STRING!" value="STRING!"/>
    //    <option name="STRING!" value="STRING!"/>
    //    ...
    // </filter>
    Filter.parseXML = function (xml) {
        var filter = new Filter(),
            FilterOption = require('../../core/filter_option.js'),
            pF = require('../../util/parsingFunctions.js'),
            child;
        if (xml) {
            child = xml.find("option");
            if (child.length > 0) {
                $.each(child, function (i, e) {
                    filter.options().add( FilterOption.parseXML($(e)) );
                });
            }
            pF.parseAttribute(pF.getXMLAttr(xml,"type"), filter.type);
        }
        return filter;
    };

    return Filter;
};


},{"../../core/filter.js":40,"../../core/filter_option.js":41,"../../util/parsingFunctions.js":158}],141:[function(require,module,exports){
var FilterOption = require('../../core/filter_option.js');

// <option name="STRING!" value="STRING!"/>
FilterOption.parseXML = function (xml) {
    var pF     = require('../../util/parsingFunctions.js'),
        option = new FilterOption();
    if (xml) {
        option.name(pF.getXMLAttr(xml,"name"));
        option.value(pF.getXMLAttr(xml,"value") === "" ? undefined : pF.getXMLAttr(xml,"value"));
    }
    return option;
};

module.exports = FilterOption;

},{"../../core/filter_option.js":41,"../../util/parsingFunctions.js":158}],142:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Graph = require('../../core/graph.js'),
        pF = require('../../util/parsingFunctions.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Graph.parseXML)==="function") { return Graph; };

    /*
     * This function traverses an XML document looking for attributes values involving deprecated
     * color names and issues a warning about each one found.  Remove this function when removing
     * support for these names.  See src/math/rgb_color.js for a list of the deprecated colors.
     */
    var checkDeprecatedColorNames = function (xml, messageHandler) {
        var RGBColor   = require('../../math/rgb_color.js'),
            $xml       = $(xml),
            attributes = $xml[0].attributes,
            children   = $xml.children(),
            colorNameIsDeprecated = RGBColor.colorNameIsDeprecated,
            dep;
        if (xml.nodeName === "option") {
            if (/color/.test(pF.getXMLAttr($xml,'name'))) {
                dep = colorNameIsDeprecated(pF.getXMLAttr($xml,'value'));
                if (dep) {
                    messageHandler.warning('Warning: color string "' + pF.getXMLAttr($xml,'value') + '" is deprecated; use "' + dep + '" instead');
                }
            }
        }
        if (attributes) {
            $.each(attributes, function () {
                if (/color/.test(this.name)) {
                    dep = colorNameIsDeprecated(this.value);
                    if (dep) {
                        messageHandler.warning('Warning: color string "' + this.value + '" is deprecated; use "' + dep + '" instead');
                    }
                }
            });

        }
        if (children) {
            children.each(function () {
                checkDeprecatedColorNames(this, messageHandler);
            });
        }
    };


    Graph.parseXML = function (xml, multigraph, messageHandler) {
        var graph = new Graph(),
            Axis  = require('../../core/axis.js'),
            Window = require('../../core/window.js'),
            Legend = require('../../core/legend.js'),
            Background = require('../../core/background.js'),
            Plotarea = require('../../core/plotarea.js'),
            Title = require('../../core/title.js'),
            Data = require('../../core/data.js'),
            Plot = require('../../core/plot.js'),
            utilityFunctions = require('../../util/utilityFunctions.js'),
            defaults = utilityFunctions.getDefaultValuesFromXSD(),
            child;

        graph.multigraph(multigraph);
        if (xml) {

            //
            // Delete this try/catch block when removing support for deprecated color names.
            //
            try {
                checkDeprecatedColorNames(xml, messageHandler);
            } catch (e) {
                // just ignore any errors here; the worst that will happen is that the user just
                // won't see the warnings
            }
            //
            // end of block to delete when removing support for deprecated color names
            //

            // NOTE: 'OBJ.find(">TAG")' returns a list of JQuery objects corresponding to the immediate
            // (1st generation) child nodes of OBJ corresponding to xml tag TAG
            child = xml.find(">window");
            if (child.length > 0) {
                graph.window( Window.parseXML(child) );
            }

            child = xml.find(">legend");
            if (child.length > 0) {
                graph.legend( Legend.parseXML(child) );
            } else {
                graph.legend( Legend.parseXML() );
            }
            child = xml.find(">background");
            if (child.length > 0) {
                graph.background( Background.parseXML(child, graph.multigraph()) );
            }
            child = xml.find(">plotarea");
            if (child.length > 0) {
                graph.plotarea( Plotarea.parseXML(child) );
            }
            child = xml.find(">title");
            if (child.length > 0) {
                graph.title( Title.parseXML(child, graph) );
            }
            $.each(xml.find(">horizontalaxis"), function (i, e) {
                graph.axes().add( Axis.parseXML($(e), Axis.HORIZONTAL, messageHandler, graph.multigraph()) );
            });
            $.each(xml.find(">verticalaxis"), function (i, e) {
                graph.axes().add( Axis.parseXML($(e), Axis.VERTICAL, messageHandler, graph.multigraph()) );
            });
            /*
             if (xml.find(">data").length === 0) {
             // On second throught, let's not throw an error if no <data> tag
             // is specified, because conceivably there could be graphs in
             // which all the plots are constant plots, so no data is needed.
             // In particular, in our spec/mugl/constant-plot.xml test!
             // I'm not sure what should be done here --- maybe issue a warning,
             // or maybe don't do anything.
             //    mbp Mon Nov 12 16:05:21 2012
             //throw new Error("Graph Data Error: No data tags specified");
             }
             */
            $.each(xml.find(">throttle"), function (i, e) {
                var pattern    = pF.getXMLAttr($(e),'pattern')    ? pF.getXMLAttr($(e),'pattern')    : defaults.throttle.pattern,
                    requests   = pF.getXMLAttr($(e),'requests')   ? pF.getXMLAttr($(e),'requests')   : defaults.throttle.requests,
                    period     = pF.getXMLAttr($(e),'period')     ? pF.getXMLAttr($(e),'period')     : defaults.throttle.period,
                    concurrent = pF.getXMLAttr($(e),'concurrent') ? pF.getXMLAttr($(e),'concurrent') : defaults.throttle.concurrent;
                multigraph.addAjaxThrottle(pattern, requests, period, concurrent);
            });
            $.each(xml.find(">data"), function (i, e) {
                graph.data().add( Data.parseXML($(e), graph.multigraph(), messageHandler) );
            });
            $.each(xml.find(">plot"), function (i, e) {
                graph.plots().add( Plot.parseXML($(e), graph, messageHandler) );
            });
            graph.postParse();
        }
        return graph;
    };

    return Graph;
};

},{"../../core/axis.js":19,"../../core/background.js":22,"../../core/data.js":27,"../../core/graph.js":42,"../../core/legend.js":47,"../../core/plot.js":55,"../../core/plotarea.js":57,"../../core/title.js":66,"../../core/window.js":71,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158,"../../util/utilityFunctions.js":159}],143:[function(require,module,exports){
var Grid = require('../../core/grid.js');

// <grid color="#ff00ff" visible="true"/>
Grid.parseXML = function (xml) {
    var grid             = new Grid(),
        RGBColor         = require('../../math/rgb_color.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        attr;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"color"), grid.color, RGBColor.parse);
        //NOTE: visible attribute should default to true when parsing, so that
        //      the presence of a <grid> tag at all will turn on a grid.  In
        //      the Grid object itself, though, the default for the visible
        //      attribute is false, so that when we create a default grid object
        //      in code (as opposed to parsing), it defaults to not visible.
        attr = pF.getXMLAttr(xml,"visible");
        if (attr !== undefined) {
            grid.visible(pF.parseBoolean(attr));
        } else {
            grid.visible(true);
        }
    }
    return grid;
};

module.exports = Grid;

},{"../../core/grid.js":43,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],144:[function(require,module,exports){
var Icon = require('../../core/icon.js');

// <icon border="2" width="30" height="20"/>
Icon.parseXML = function (xml) {

    var icon = new Icon(),
        pF = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"height"), icon.height, parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"width"),  icon.width,  parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"border"), icon.border, parseInteger);
    }
    return icon;
};

module.exports = Icon;

},{"../../core/icon.js":44,"../../util/parsingFunctions.js":158}],145:[function(require,module,exports){
var Img = require('../../core/img.js');

//   <img src="foo.png" anchor="-1 5" base="3 12" position="-2 3" frame="padding"/>
Img.parseXML = function (xml, multigraph) {
    var img,
        pF = require('../../util/parsingFunctions.js'),
        Point            = require('../../math/point.js'),
        parseAttribute   = pF.parseAttribute,
        parsePoint       = Point.parse;
    if (xml && pF.getXMLAttr(xml,"src") !== undefined) {
        var src = pF.getXMLAttr(xml,"src");
        if (!src) {
            throw new Error('img elment requires a "src" attribute value');
        }
        if (multigraph) {
            src = multigraph.rebaseUrl(src);
        }
        img = new Img(src);
        parseAttribute(pF.getXMLAttr(xml,"anchor"),   img.anchor,   parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"base"),     img.base,     parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"position"), img.position, parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"frame"),    img.frame,    function (value) { return value.toLowerCase(); });
    }
    return img;
};

module.exports = Img;

},{"../../core/img.js":45,"../../math/point.js":106,"../../util/parsingFunctions.js":158}],146:[function(require,module,exports){
// usage:
// 
//   A valid jQuery object must be passed to the function returned by requiring this file.
//   That function returns a ParseXML object that can be used as follows:
//
//      var ParseXML = require('parse_xml.js')($);
//      ParseXML.stringToJQueryXMLObj(...);
//
var JQueryXMLParser;
module.exports = function($) {
    if (typeof(JQueryXMLParser)!="undefined") { return JQueryXMLParser; };

    JQueryXMLParser = {};

    require('./axis.js')($);
    require('./data.js')($);
    require('./datatips.js')($);
    require('./filter.js')($);
    require('./graph.js')($);
    require('./multigraph.js')($);
    require('./plot.js')($);
    require('./renderer.js')($);

    require('./axis_title.js');
    require('./background.js');
    require('./datatips_variable.js');
    require('./data_variable.js');
    require('./filter_option.js');
    require('./grid.js');
    require('./icon.js');
    require('./img.js');
    require('./labeler.js');
    require('./legend.js');
    require('./pan.js');
    require('./plotarea.js');
    require('./plot_legend.js');
    require('./title.js');
    require('./window.js');
    require('./zoom.js');

    JQueryXMLParser.stringToJQueryXMLObj = function (thingy) {
        if (typeof(thingy) !== "string") {
            return $(thingy);
        }
        var xml = $.parseXML(thingy);
        return $($(xml).children()[0]);
    };

    return JQueryXMLParser;
};

},{"./axis.js":133,"./axis_title.js":134,"./background.js":135,"./data.js":136,"./data_variable.js":137,"./datatips.js":138,"./datatips_variable.js":139,"./filter.js":140,"./filter_option.js":141,"./graph.js":142,"./grid.js":143,"./icon.js":144,"./img.js":145,"./labeler.js":147,"./legend.js":148,"./multigraph.js":149,"./pan.js":150,"./plot.js":151,"./plot_legend.js":152,"./plotarea.js":153,"./renderer.js":154,"./title.js":155,"./window.js":156,"./zoom.js":157}],147:[function(require,module,exports){
var Labeler = require('../../core/labeler.js');

// <labels
//   format="STRING"
//   start="DATAVALUE(0)"
//   angle="DOUBLE(0)"
//   position="POINT"
//   anchor="POINT"
//   color="COLOR(black)"
//   spacing="STRING"
//   densityfactor="DOUBLE(1.0)">
//     <label format="STRING" start="STRING" angle="DOUBLE" position="POINT" anchor="POINT" spacing="STRING" densityfactor="DOUBLE">
//     <label format="STRING" start="STRING" angle="DOUBLE" position="POINT" anchor="POINT" spacing="STRING" densityfactor="DOUBLE">
// </label>
Labeler.parseXML = function (xml, axis, defaults, spacing) {
    // This parser takes an optional final argument, spacing, which is a string representing
    // the spacing to be parsed for the labeler.  If that argument is not present, the spacing
    // value is taken from the xml object.  If a spacing argument is present, it is parsed
    // and used to set the spacing attribute of the Labeler object, and in this case, any
    // spacing value present in the xml is ignored.
    //
    // If the spacing argument has the value null, the resulting labeler will have no spacing
    // attribute set at all.
    var labeler,
        Point = require('../../math/point.js'),
        RGBColor = require('../../math/rgb_color.js'),
        DataMeasure = require('../../core/data_measure.js'),
        DataValue = require('../../core/data_value.js'),
        DataFormatter = require('../../core/data_formatter.js'),
        pF = require('../../util/parsingFunctions.js'),
        parsePoint = Point.parse;

    // `parseAttribute` returns true or false depending on whether or not it set the attribute.
    // If it did not and if the `defaults` object exists then the attribute is set to the
    // appropriate default value.
    var parseLabelerAttribute = function (value, attribute, preprocessor, defaultName) {
        if (!pF.parseAttribute(value, attribute, preprocessor) && defaults !== undefined) {
            attribute(defaults[defaultName]());
        }
    };
    var parseDataFormatter = function (type) {
        return function (value) {
            return DataFormatter.create(type, value);
        };
    };
    var parseDataValue = function (type) {
        return function (value) {
            return DataValue.parse(type, value);
        };
    };

    if (xml) {
        labeler = new Labeler(axis);
        if (spacing !== null) {
            if (spacing === undefined) {
                spacing = pF.getXMLAttr(xml,"spacing");
            }
            //NOTE: spacing might still === undefined at this point
            parseLabelerAttribute(spacing, labeler.spacing,
                                  function(v) { return DataMeasure.parse(axis.type(), v); }, //pF.parseDataMeasure(),
                                  "spacing");
        }
        parseLabelerAttribute(pF.getXMLAttr(xml,"format"),        labeler.formatter,     parseDataFormatter(axis.type()),              "formatter");
        parseLabelerAttribute(pF.getXMLAttr(xml,"start"),         labeler.start,         parseDataValue(axis.type()),                  "start");
        parseLabelerAttribute(pF.getXMLAttr(xml,"angle"),         labeler.angle,         parseFloat,                                   "angle");
        parseLabelerAttribute(pF.getXMLAttr(xml,"position"),      labeler.position,      parsePoint,                                   "position");
        parseLabelerAttribute(pF.getXMLAttr(xml,"anchor"),        labeler.anchor,        parsePoint,                                   "anchor");
        parseLabelerAttribute(pF.getXMLAttr(xml,"densityfactor"), labeler.densityfactor, parseFloat,                                   "densityfactor");
        parseLabelerAttribute(pF.getXMLAttr(xml,"color"),         labeler.color,         RGBColor.parse,                               "color");
        parseLabelerAttribute(pF.getXMLAttr(xml,"visible"),       labeler.visible,       pF.parseBoolean,                "visible");

    }
    return labeler;
};

module.exports = Labeler;

},{"../../core/data_formatter.js":28,"../../core/data_measure.js":29,"../../core/data_value.js":31,"../../core/labeler.js":46,"../../math/point.js":106,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],148:[function(require,module,exports){
var Legend = require('../../core/legend.js');

// <legend
//     visible="BOOLEAN"
//     base="POINT(1,1)"
//     anchor="POINT(1,1)"
//     position="POINT(0,0)"
//     frame="FRAME(padding)"
//     color="COLOR(white)"
//     opacity="DOUBLE(1.0)"
//     border="INTEGER(1)"
//     bordercolor="COLOR(black)"
//     rows="INTEGER"
//     columns="INTEGER"
//     cornerradius="INTEGER(0)"
//     padding="INTEGER(0)">
//   <icon
//       width="INTEGER(40)"
//       height="INTEGER(30)"
//       border="INTEGER(1)">
//   </icon>
// </legend>
Legend.parseXML = function (xml) {
    var legend           = new Legend(),
        pF               = require('../../util/parsingFunctions.js'),
        Point            = require('../../math/point.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        Icon             = require('../../core/icon.js'),
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger,
        parsePoint       = Point.parse,
        parseRGBColor    = RGBColor.parse,
        child;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"visible"),      legend.visible,      pF.parseBoolean);
        parseAttribute(pF.getXMLAttr(xml,"base"),         legend.base,         parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"anchor"),       legend.anchor,       parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"position"),     legend.position,     parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"frame"),        legend.frame);
        parseAttribute(pF.getXMLAttr(xml,"color"),        legend.color,        parseRGBColor);
        parseAttribute(pF.getXMLAttr(xml,"bordercolor"),  legend.bordercolor,  parseRGBColor);
        parseAttribute(pF.getXMLAttr(xml,"opacity"),      legend.opacity,      parseFloat);
        parseAttribute(pF.getXMLAttr(xml,"border"),       legend.border,       parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"rows"),         legend.rows,         parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"columns"),      legend.columns,      parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"cornerradius"), legend.cornerradius, parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"padding"),      legend.padding,      parseInteger);

        child = xml.find("icon");
        if (child.length > 0) {
            legend.icon(Icon.parseXML(child));
        }
    }
    return legend;
};

module.exports = Legend;

},{"../../core/icon.js":44,"../../core/legend.js":47,"../../math/point.js":106,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],149:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Multigraph = require('../../core/multigraph.js')($);

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Multigraph.parseXML)==="function") { return Multigraph; };

    Multigraph.parseXML = function (xml, mugl, messageHandler) {
        var multigraph = new Multigraph(),
            graphs     = multigraph.graphs(),
            Graph      = require('../../core/graph.js'),
            child;
        multigraph.mugl(mugl); // set the mugl url
        if (xml) {
            child = xml.find(">graph");
            if (child.length > 0) {
                $.each(child, function (i, e) {
                    graphs.add( Graph.parseXML($(e), multigraph, messageHandler) );
                });
            } else if (child.length === 0 && xml.children().length > 0) {
                graphs.add( Graph.parseXML(xml, multigraph, messageHandler) );
            }
        }
        return multigraph;
    };

    return Multigraph;
};

},{"../../core/graph.js":42,"../../core/multigraph.js":49}],150:[function(require,module,exports){
var Pan = require('../../core/pan.js');

// <pan allowed="true" min="-100" max="100"/>
Pan.parseXML = function (xml, type) {
    var pan            = new Pan(),
        pF             = require('../../util/parsingFunctions.js'),
        DataValue      = require('../../core/data_value.js'),
        parseAttribute = pF.parseAttribute,
        parseDataValue = function(v) { return DataValue.parse(type, v); };
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"allowed"), pan.allowed, pF.parseBoolean);
        parseAttribute(pF.getXMLAttr(xml,"min"),     pan.min,     parseDataValue);
        parseAttribute(pF.getXMLAttr(xml,"max"),     pan.max,     parseDataValue);
    }
    return pan;
};

module.exports = Pan;

},{"../../core/data_value.js":31,"../../core/pan.js":53,"../../util/parsingFunctions.js":158}],151:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Plot = require('../../core/plot.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Plot.parseXML)==="function") { return Plot; };

    // <plot>
    //   <legend
    //       visible="BOOLEAN"
    //       label="STRING">
    //   </legend>
    //   <horizontalaxis ref="STRING!">
    //     <variable ref="STRING!" />
    //   </horizontalaxis>
    //   <verticalaxis ref="STRING!">
    //     <variable ref="STRING" />
    //     <constant value="DATAVALUE"/>
    //   </verticalaxis>
    //   <renderer type="RENDERERTYPE(line)">
    //     <option name="STRING!" value="STRING!" min="DATAVALUE" max="DATAVALUE"/>
    //     <option name="STRING!" value="STRING!" min="DATAVALUE" max="DATAVALUE"/>
    //     ...
    //   </renderer>
    //   <datatips format="STRING!" bgcolor="COLOR" bgalpha="DOUBLE" border="INTEGER" bordercolor="COLOR" pad="INTEGER">
    //     <variable format="STRING!" />
    //     <variable format="STRING!" />
    //     ...
    //   </datatips>
    // </plot>
    Plot.parseXML = function (xml, graph, messageHandler) {
        var DataPlot     = require('../../core/data_plot.js'),
            PlotLegend   = require('../../core/plot_legend.js'),
            ConstantPlot = require('../../core/constant_plot.js'),
            DataValue    = require('../../core/data_value.js'),
            Renderer     = require('../../core/renderer.js'),
            Filter       = require('../../core/filter.js'),
            Datatips     = require('../../core/datatips.js'),
            pF           = require('../../util/parsingFunctions.js'),
            plot,
            haxis,
            vaxis,
            variable,
            attr, child;
        if (xml) {

            // populate verticalaxis from xml
            child = xml.find(">verticalaxis");
            if (child.length === 1 && pF.getXMLAttr(child,"ref") !== undefined) {
                if (graph) {
                    vaxis = graph.axisById(pF.getXMLAttr(child,"ref"));
                    if (vaxis === undefined) {
                        throw new Error("Plot Vertical Axis Error: The graph does not contain an axis with an id of '" + pF.getXMLAttr(child,"ref") + "'");
                    }
                }
            }

            child = xml.find("verticalaxis constant");
            if (child.length > 0) {
                var constantValueString = pF.getXMLAttr(child,"value");
                if (constantValueString === undefined) {
                    throw new Error("Constant Plot Error: A 'value' attribute is needed to define a Constant Plot");
                }
                plot = new ConstantPlot(DataValue.parse(vaxis.type(), constantValueString));
            } else {
                plot = new DataPlot();
            }

            plot.verticalaxis(vaxis);

            // populate horizontalaxis from xml
            child = xml.find(">horizontalaxis");
            if (child.length === 1 && pF.getXMLAttr(child,"ref") !== undefined) {
                if (graph) {
                    haxis = graph.axisById(pF.getXMLAttr(child,"ref"));
                    if (haxis !== undefined) {
                        plot.horizontalaxis(haxis);
                    } else {
                        throw new Error("Plot Horizontal Axis Error: The graph does not contain an axis with an id of '" + pF.getXMLAttr(child,"ref") + "'");
                    }
                }
            }

            // if this is a DataPlot, parse variables
            if (plot instanceof DataPlot) {

                // provide default horizontalaxis variable if not present in xml
                if (xml.find("horizontalaxis variable").length === 0) {
                    plot.variable().add(null);
                }
                //TODO: defer population of variables until normalizer has executed
                // populate axis variables from xml
                child = xml.find("horizontalaxis variable, verticalaxis variable");
                if (child.length > 0) {
                    if (graph) {
                        $.each(child, function (i, e) {
                            attr = pF.getXMLAttr($(e),"ref");
                            variable = graph.variableById( attr );
                            if (variable !== undefined) {
                                plot.data( variable.data() );
                                plot.variable().add(variable);
                            } else {
                                throw new Error("Plot Variable Error: No Data tag contains a variable with an id of '" + attr + "'");
                            }
                        });
                    }
                }
                }

            // populate legend from xml
            child = xml.find("legend");
            if (child.length > 0) {
                plot.legend(PlotLegend.parseXML(child, plot));
            } else {
                plot.legend(PlotLegend.parseXML(undefined, plot));
            }

            // populate renderer from xml
            child = xml.find("renderer");
            if (child.length > 0) {
                plot.renderer(Renderer.parseXML(child, plot, messageHandler));
            }

            // populate filter from xml
            child = xml.find("filter");
            if (child.length > 0) {
                plot.filter(Filter.parseXML(child));
            }

            // populate datatips from xml
            child = xml.find("datatips");
            if (child.length > 0) {
                plot.datatips(Datatips.parseXML(child));
            }

        }
        return plot;
    };

    return Plot;
};

},{"../../core/constant_plot.js":25,"../../core/data_plot.js":30,"../../core/data_value.js":31,"../../core/datatips.js":33,"../../core/filter.js":40,"../../core/plot.js":55,"../../core/plot_legend.js":56,"../../core/renderer.js":58,"../../util/parsingFunctions.js":158}],152:[function(require,module,exports){
var PlotLegend = require('../../core/plot_legend.js');

// <legend visible="BOOLEAN" label="STRING" />
PlotLegend.parseXML = function (xml, plot) {
    var legend           = new PlotLegend(),
        pF               = require('../../util/parsingFunctions.js'),
        Text             = require('../../core/text.js'),
        parseAttribute   = pF.parseAttribute,
        child;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"visible"), legend.visible, pF.parseBoolean);
        parseAttribute(pF.getXMLAttr(xml,"label"),   legend.label,   function (value) { return new Text(value); });
    }

    if (legend.label() === undefined) {
        // TODO: remove this ugly patch with something that works properly
        if (typeof(plot.variable)==="function" && plot.variable().size() >= 2) { 
            legend.label(new Text(plot.variable().at(1).id()));
        } else {
            legend.label(new Text("plot"));
        }
    }
    return legend;
};

module.exports = PlotLegend;

},{"../../core/plot_legend.js":56,"../../core/text.js":65,"../../util/parsingFunctions.js":158}],153:[function(require,module,exports){
var Plotarea = require('../../core/plotarea.js');

//  <plotarea
//     marginbottom="INTEGER(35)"
//     marginleft="INTEGER(38)"
//     margintop="INTEGER(10)"
//     marginright="INTEGER(35)"
//     border="INTEGER(0)"
//     bordercolor="COLOR(0xeeeeee)"
//     color="COLOR">
//  </plotarea>
Plotarea.parseXML = function (xml) {
    var plotarea = new Plotarea(),
        margin = plotarea.margin(),
        pF               = require('../../util/parsingFunctions.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        parseRGBColor    = RGBColor.parse,
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"marginbottom"), margin.bottom,        parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"marginleft"),   margin.left,          parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"margintop"),    margin.top,           parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"marginright"),  margin.right,         parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"border"),       plotarea.border,      parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"color"),        plotarea.color,       parseRGBColor);
        parseAttribute(pF.getXMLAttr(xml,"bordercolor"),  plotarea.bordercolor, parseRGBColor);
    }
    return plotarea;
};

module.exports = Plotarea;

},{"../../core/plotarea.js":57,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],154:[function(require,module,exports){
// This file uses jQuery.  A valid jQuery object must be passed to the
// function returned by requiring this file.
module.exports = function($) {
    var Renderer = require('../../core/renderer.js');

    // if parseXML method already has been defined, which would be the case if this
    // function was previously called, just return immediately
    if (typeof(Renderer.parseXML)==="function") { return Renderer; };

    // <renderer
    //     type="RENDERERTYPE(line)">
    //   <option
    //       name="STRING!"
    //       value="STRING!"
    //       min="DATAVALUE"
    //       max="DATAVALUE">
    //   </option>
    //   ...
    // </renderer>
    Renderer.parseXML = function (xml, plot, messageHandler) {
        var DataValue   = require('../../core/data_value.js'),
            NumberValue = require('../../core/number_value.js'),
            Warning     = require('../../core/warning.js'),
            pF          = require('../../util/parsingFunctions.js'),
            rendererType,
            renderer,
            opt;

        require('../../core/renderers/all_renderers.js');

        if (xml && pF.getXMLAttr(xml,"type") !== undefined) {
            rendererType = Renderer.Type.parse(pF.getXMLAttr(xml,"type"));
            if (!Renderer.Type.isInstance(rendererType)) {
                throw new Error("unknown renderer type '" + pF.getXMLAttr(xml,"type") + "'");
            }
            renderer = Renderer.create(rendererType);
            renderer.plot(plot);
            if (xml.find("option").length > 0) {

                //
                // The following provides support for deprecatd the "missingvalue" and
                // "missingop" renderer options.  Those options are not officially supported
                // any more; MUGL files should use the  missingvalue/missingop attributes
                // of <data><variable> or <data><variables> instead.  When we're ready to
                // remove this support, delete the block of code:
                //
                (function (renderer, xml, plot, messageHandler) {
                    var i,
                        missingValueOption = xml.find("option[name=missingvalue]"),
                        missingOpOption    = xml.find("option[name=missingop]");
                    if (missingValueOption.length > 0 || missingOpOption.length > 0) {
                        var columns = plot.data().columns(),
                            column;
                        for (i = 0; i < columns.size();  ++i) {
                            column = columns.at(i);
                            if (column.type() === DataValue.NUMBER) {
                                if (missingValueOption.length > 0 && (column.missingvalue() === undefined)) {
                                    column.missingvalue(NumberValue.parse(pF.getXMLAttr(missingValueOption,"value")));
                                }
                                if (missingOpOption.length > 0 && (column.missingop() === undefined)) {
                                    column.missingop(DataValue.parseComparator(pF.getXMLAttr(missingOpOption,"value")));
                                }
                            }
                        }
                    }
                    if (missingValueOption.length > 0) {
                        messageHandler.warning("Renderer option 'missingvalue' is deprecated; " +
                                               "use 'missingvalue' attribute of 'data'/'variable'; instead");
                        // remove the element from the xml so that the option-processing code below doesn't see it
                        missingValueOption.remove();
                    }
                    if (missingOpOption.length > 0) {
                        messageHandler.warning("Renderer option 'missingop' is deprecated; " +
                                               "use 'missingvalue' attribute of 'data'/'variable'; instead");
                        // remove the element from the xml so that the option-processing code below doesn't see it
                        missingOpOption.remove();
                    }
                }(renderer, xml, plot, messageHandler));
                //
                // End of code to delete when removing support for deprecated
                // missingvalue/missingop renderer options.
                //

                $.each(xml.find(">option"), function (i, e) {
                    try {
                        renderer.setOptionFromString(pF.getXMLAttr($(e),"name"),
                                                     pF.getXMLAttr($(e),"value"),
                                                     pF.getXMLAttr($(e),"min"),
                                                     pF.getXMLAttr($(e),"max"));
                    } catch (e) {
                        if (e instanceof Warning) {
                            messageHandler.warning(e);
                        } else {
                            throw e;
                        }
                    }
                });
            }
        }
        return renderer;
    };

    return Renderer;
};

},{"../../core/data_value.js":31,"../../core/number_value.js":52,"../../core/renderer.js":58,"../../core/renderers/all_renderers.js":59,"../../core/warning.js":67,"../../util/parsingFunctions.js":158}],155:[function(require,module,exports){
var Title = require('../../core/title.js');

//  <title
//      base="POINT(0,1)"
//      anchor="POINT(0,1)"
//      position="POINT(0,0)"
//      frame="FRAME(padding)"
//      color="COLOR(white)"
//      opacity="DOUBLE(1.0)"
//      border="INTEGER(0)"
//      bordercolor="COLOR(black)"
//      padding="INTEGER(0)"
//      cornerradius="INTEGER(15)"
//      fontsize="INTEGER">
//  </title>
Title.parseXML = function (xml, graph) {
    var Point            = require('../../math/point.js'),
        RGBColor         = require('../../math/rgb_color.js'),
        Text             = require('../../core/text.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parsePoint       = Point.parse,
        parseRGBColor    = RGBColor.parse,
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger,
        title;

    if (xml) {
        var text = xml.text();
        if (text !== "") {
            title = new Title(new Text(text), graph);
        } else {
            return undefined;
        }                
        parseAttribute(pF.getXMLAttr(xml,"frame"),        title.frame,        function (value) { return value.toLowerCase(); });
        parseAttribute(pF.getXMLAttr(xml,"border"),       title.border,       parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"color"),        title.color,        parseRGBColor);
        parseAttribute(pF.getXMLAttr(xml,"bordercolor"),  title.bordercolor,  parseRGBColor);
        parseAttribute(pF.getXMLAttr(xml,"opacity"),      title.opacity,      parseFloat);
        parseAttribute(pF.getXMLAttr(xml,"padding"),      title.padding,      parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"cornerradius"), title.cornerradius, parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"anchor"),       title.anchor,       parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"base"),         title.base,         parsePoint);
        parseAttribute(pF.getXMLAttr(xml,"position"),     title.position,     parsePoint);
    }
    return title;
};

module.exports = Title;

},{"../../core/text.js":65,"../../core/title.js":66,"../../math/point.js":106,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],156:[function(require,module,exports){
var Window = require('../../core/window.js');

// <window
//       width="INTEGER"
//       height="INTEGER"
//       border="INTEGER(2)"
//       bordercolor="COLOR(black)"
//       margin="INTEGER(2)"
//       padding="INTEGER(5)">
//   </window>
Window.parseXML = function (xml) {
    var w = new Window(),
        RGBColor         = require('../../math/rgb_color.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        parseInteger     = pF.parseInteger,
        attr;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"width"),  w.width,  parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"height"), w.height, parseInteger);
        parseAttribute(pF.getXMLAttr(xml,"border"), w.border, parseInteger);

        attr = pF.getXMLAttr(xml,"margin");
        if (attr !== undefined) {
            (function (m) {
                w.margin().set(m,m,m,m);
            }(parseInt(attr, 10)));
        }

        attr = pF.getXMLAttr(xml,"padding");
        if (attr !== undefined) {
            (function (m) {
                w.padding().set(m,m,m,m);
            }(parseInt(attr, 10)));
        }

        // removed deprecated color name check from commit #17665e2
        //    jrfrimme Tues Apr 2 11:47 2013
        parseAttribute(pF.getXMLAttr(xml,"bordercolor"), w.bordercolor, RGBColor.parse);
    }
    return w;
};

module.exports = Window;

},{"../../core/window.js":71,"../../math/rgb_color.js":107,"../../util/parsingFunctions.js":158}],157:[function(require,module,exports){
var Zoom = require('../../core/zoom.js');

// <zoom allowed="true" min="10" max="100" anchor="0"/>
Zoom.parseXML = function (xml, type) {
    var zoom             = new Zoom(),
        DataValue        = require('../../core/data_value.js'),
        DataMeasure      = require('../../core/data_measure.js'),
        pF               = require('../../util/parsingFunctions.js'),
        parseAttribute   = pF.parseAttribute,
        parseDataMeasure = function(v) { return DataMeasure.parse(type, v); }, //pF.parseDataMeasure
        attr;
    if (xml) {
        parseAttribute(pF.getXMLAttr(xml,"allowed"), zoom.allowed, pF.parseBoolean);
        parseAttribute(pF.getXMLAttr(xml,"min"),     zoom.min,     parseDataMeasure);
        parseAttribute(pF.getXMLAttr(xml,"max"),     zoom.max,     parseDataMeasure);
        attr = pF.getXMLAttr(xml,"anchor");
        if (attr !== undefined) {
            if (attr.toLowerCase() === "none") {
                zoom.anchor(null);
            } else {
                zoom.anchor( DataValue.parse(type, attr) );
            }
        }
    }
    return zoom;
};

module.exports = Zoom;

},{"../../core/data_measure.js":29,"../../core/data_value.js":31,"../../core/zoom.js":72,"../../util/parsingFunctions.js":158}],158:[function(require,module,exports){
var ParsingFunctions = {};

/**
 * The Utility Functions module provides utility functions which correspond to general concepts.
 *
 * @module multigraph
 * @submodule utilityfunctions
 * @main utilityfunctions
 */

/**
 * Functions which provide abstractions for the parser.
 *
 * @class ParsingFunctions
 * @for ParsingFunctions
 * @static
 */

/**
 * Abstract function for parsing and setting jermaine attributes which do not require
 * extremely complicated logic to determine their values. Any attributes which require
 * complex logic to determine their proper values should be explicitly set in the parser.
 *
 * @method parseAttribute
 * @param {String} value
 * @param {Function} attribute
 * @param {Function} preprocessor
 * @static
 * @return {Boolean}
 */
ParsingFunctions.parseAttribute = function (value, attribute, preprocessor) {
    if (value !== undefined) {
        attribute((preprocessor !== undefined) ? preprocessor(value) : value);
        return true;
    }
    return false;
};

/**
 * Parses a string argument with a radix of 10 and returns an integer.
 *
 * @method parseInteger
 * @param {String} value
 * @static
 * @return {Integer}
 */
ParsingFunctions.parseInteger = function (value) {
    return parseInt(value, 10);
};

//mbp
///**
// * Returns a curried function that parses a value into a DataValue of the specified type.
// *
// * @method parseDataValue
// * @param {String} type
// * @static
// * @return {Function}
// */
//ParsingFunctions.parseDataValue = function (type) {
//    return function (value) {
//        return window.multigraph.core.DataValue.parse(type, value);
//    };
//};

//mbp
///**
// * Returns a curried function that parses a value into a DataMeasure of the specified type.
// *
// * @method parseDataMeasure
// * @param {String} type
// * @static
// * @return {Function}
// */
//ParsingFunctions.parseDataMeasure = function (type) {
//    return function (value) {
//        return window.multigraph.core.DataMeasure.parse(type, value);
//    };
//};

/**
 * Parses the allowed Boolean Strings and returns the appropriate value. If the parameter
 * is not one of the allowed values then the parameter is returned as an error might not
 * need to be thrown immediately.
 *
 * @method parseBoolean
 * @param {String} param
 * @static
 * @return {Boolean}
 */
ParsingFunctions.parseBoolean = function (param) {
    if (typeof(param) === "string") {
        switch (param.toLowerCase()) {
        case "true":
        case "yes":
            return true;
        case "false":
        case "no":
            return false;
        default:
            return param;
        }
    } else {
        return param;
    }
};

/*
 * The ParsingFunctions.getXMLAttr() function returns the value of an attribute for
 * an XML document node.
 * 
 * The `node` argument should be a node in an XML document as returned by the jQuery
 * parseXML function.
 * 
 * The `attrname` argument should be a string which is the name of an attribute.
 * 
 * This function ensures to return "undefined" if the node does not have the attribute.
 * 
 * This function itself does not depend on jQuery, which is why it is located in this
 * file -- so that code needing to use this function don't have to require jQuery just
 * for this function.  (The use of this function does require jQuery at some point in
 * the program, because this `node` object must be a jQuery object representing an XML
 * document.)
 * 
 * The reason we have this function for extracting attribute values, rather than
 * just calling node.attr(attrname) directly, is that in some cases node.attr()
 * returns the empty string for attributes which have not been set.  This function
 * uses the hasAttribute() method to check to see whether the attribute value
 * is present, and always returns `undefined` if it is not.
 */
ParsingFunctions.getXMLAttr = function(node, attrname) {
    if (node.length >= 1 && node[0].hasAttribute(attrname)) {
        return node.attr(attrname);
    }
    return undefined;
};

module.exports = ParsingFunctions;

},{}],159:[function(require,module,exports){
utilityFunctions = {};

// Why not use Object.getKeys() ??  mbp Fri Mar 13 00:21:57 2015
utilityFunctions.getKeys = function (obj) {
    var keys = [],
        key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            keys.push(key);
        }
    }
    return keys;
};

// coerce a value to a string, but not if it is the undefined value
utilityFunctions.coerceToString = function(s) {
    if (typeof(s) !== 'undefined') {
        return String(s);
    } else {
        return s;
    }
};

utilityFunctions.insertDefaults = function (elem, defaults, attributes) {
    var i;
    for (i = 0; i < attributes.length; i++) {
        if (defaults[attributes[i]] !== undefined && (typeof(defaults[attributes[i]]) !== "object" || defaults[attributes[i]] === null)) {
            if (elem.attributes().indexOf(attributes[i]) > -1) {
                elem.attribute(attributes[i]).defaultsTo(defaults[attributes[i]]);
            }
        }
    }
    return elem;
};


// This should be renamed; the name 'getDefaultValuesFromXSD' is a holdover from when we
// had an XSD that contained default values, and this function consulted it.  Or maybe
// we never actually had that, but intended to implement it?  In any case, it seems clear
// we won't be using an XSD here, so this should be renamed.  mbp Fri Mar 13 00:23:42 2015
utilityFunctions.getDefaultValuesFromXSD = function () {
    
    var DatetimeValue = require('../core/datetime_value.js'),
        NumberValue = require('../core/number_value.js'),
        Displacement = require('../math/displacement.js'),
        Insets = require('../math/insets.js'),
        Point = require('../math/point.js'),
        RGBColor = require('../math/rgb_color.js');

    return {
        "window": {
            //              "width": undefined,
            //              "height": undefined,
            "border": 2,
            "margin" : function () { return new Insets(/*top*/2, /*left*/2, /*bottom*/2, /*right*/2); },
            "padding": function () { return new Insets(/*top*/5, /*left*/5, /*bottom*/5, /*right*/5); },
            "bordercolor": function () { return new RGBColor.parse("0x000000"); }
        },
        "legend": {
            "icon" : {
                "height": 30,
                "width": 40,
                "border": 1
            },
            "visible": null,
            "base": function () { return new Point(1,1); },
            "anchor": function () { return new Point(1,1); },
            "position": function () { return new Point(0,0); },
            "frame": "plot",
            "color": function () { return new RGBColor.parse("0xffffff"); },
            "bordercolor": function () { return new RGBColor.parse("0x000000"); },
            "opacity": 1.0,
            "border": 1,
            "rows": undefined,
            "columns": undefined,
            "cornerradius": 0,
            "padding": 0
        },
        "background": {
            "img": {
                "src": undefined,
                "anchor": function () { return new Point(-1,-1); },
                "base": function () { return new Point(-1,-1); },
                "position": function () { return new Point(0,0); },
                "frame": "padding"
            },
            "color": "0xffffff"
        },
        "plotarea": {
            "margin" : function () { return new Insets(/*top*/10 , /*left*/38, /*bottom*/35, /*right*/35); },
            "border": 0,
            "color" : null,
            "bordercolor": function () { return new RGBColor.parse("0xeeeeee"); }
        },
        "title": {
            "text"         : undefined,
            "frame"        : "padding",
            "border"       : 0,
            "color"        : function () { return new RGBColor.parse("0xffffff"); },
            "bordercolor"  : function () { return new RGBColor.parse("0x000000"); },
            "opacity"      : 1.0,
            "padding"      : 0,
            "cornerradius" : 15,
            "anchor"       : function () { return new Point(0,1); },
            "base"         : function () { return new Point(0,1); },
            "position"     : function () { return new Point(0,0); }
        },
        "horizontalaxis": {
            "title": {
                "content": undefined,
                //                    "fontname": "default",
                //                    "fontsize": "12",
                //                    "fontcolor": "0x000000",
                "anchor": undefined,
                "base" : 0,
                "position": undefined,

                "position-horizontal-top"    : function () { return new Point(0, 15); },
                "position-horizontal-bottom" : function () { return new Point(0, -18); },
                "position-vertical-right"    : function () { return new Point(33, 0); },
                "position-vertical-left"     : function () { return new Point(-25, 0); },

                "anchor-horizontal-top"      : function () { return new Point(0, -1); },
                "anchor-horizontal-bottom"   : function () { return new Point(0, 1); },
                "anchor-vertical-right"      : function () { return new Point(-1, 0); },
                "anchor-vertical-left"       : function () { return new Point(1, 0); },

                "angle": 0
            },
            "labels": {
                "label": {
                    "format": undefined,
                    // NOTE: the Labeler object's default values for position and anchor should be undefined.
                    //       If those attributes are not specified in the MUGL, the Labeler's
                    //       initializeGeometry() method sets them to one of the context-dependent values
                    //       below.
                    "position": undefined,
                    "anchor": undefined,

                    "position-horizontal-top"    : function () { return new Point(0, 5); },
                    "position-horizontal-bottom" : function () { return new Point(0, -5); },
                    "position-vertical-right"    : function () { return new Point(5, 0); },
                    "position-vertical-left"     : function () { return new Point(-8, 0); },

                    "anchor-horizontal-top"      : function () { return new Point(0, -1); },
                    "anchor-horizontal-bottom"   : function () { return new Point(0, 1); },
                    "anchor-vertical-right"      : function () { return new Point(-1, 0); },
                    "anchor-vertical-left"       : function () { return new Point(1, 0); },

                    "angle": 0.0,
                    "spacing": undefined,
                    "densityfactor": 1.0,
                    "color" : function () { return new RGBColor.parse("0x000000"); },
                    "visible" : true
                    //                        "fontname": undefined,
                    //                        "fontsize": undefined,
                    //                        "fontcolor": undefined
                },
                //                    "fontname": "default",
                //                    "fontsize": "12",
                //                    "fontcolor": "0x000000",
                //                    "format": "%1d",
                //                    "visible": "true",
                "start-number": function () { return new NumberValue(0); },
                "start-datetime": function () { return new DatetimeValue(0); },
                "angle": 0.0,
                "position": function () { return new Point(0,0); },
                "anchor": function () { return new Point(0,0); },
                "color" : function () { return new RGBColor.parse("0x000000"); },
                "visible" : true,
                //"defaultNumberSpacing": "10000 5000 2000 1000 500 200 100 50 20 10 5 2 1 0.1 0.01 0.001",
                //"defaultDatetimeSpacing": "1000Y 500Y 200Y 100Y 50Y 20Y 10Y 5Y 2Y 1Y 6M 3M 2M 1M 7D 3D 2D 1D 12H 6H 3H 2H 1H",
                "defaultNumberSpacing": [10000, 5000, 2000, 1000, 500, 200, 100, 50, 20, 10, 5, 2, 1, 0.1, 0.01, 0.001],
                "defaultDatetimeSpacing": ["1000Y", "500Y", "200Y", "100Y", "50Y", "20Y", "10Y", "5Y", "2Y", "1Y", "6M",
                                           "3M", "2M", "1M", "7D", "3D", "2D", "1D", "12H", "6H", "3H", "2H", "1H"],
                "function": undefined,
                "densityfactor": undefined
            },
            "grid": {
                "color": function () { return new RGBColor.parse("0xeeeeee"); },
                "visible": false
            },
            "pan": {
                "allowed": true,
                "min": null,
                "max": null
            },
            "zoom": {
                "allowed": true,
                "min": undefined,
                "max": undefined,
                "anchor": null
            },
            "binding": {
                "id": undefined,
                "min": undefined,
                "max": undefined
            },
            "id": undefined,
            "type": "number",
            //                "length": 1.0,
            "length" : function () { return new Displacement(1,0); },
            "position": function () { return new Point(0,0); },
            "pregap": 0,
            "postgap": 0,
            "anchor": -1,
            "base": function () { return new Point(-1,-1); },
            "min": "auto",
            "minoffset": 0,
            //"minposition": -1,
            "minposition": function () { return new Displacement(-1,0); },
            "max": "auto",
            "maxoffset": 0,
            //"maxposition": 1,
            "maxposition": function () { return new Displacement(1,0); },
            "positionbase": undefined,
            //                "color": "0x000000",
            "color": function () { return new RGBColor(0,0,0); },
            "tickmin": -3,
            "tickmax": 3,
            "tickcolor": null,
            "highlightstyle": "axis",
            "linewidth": 1,
            "orientation": undefined
        },
        "verticalaxis": {
            "title": {
                "content": undefined,
                //                    "fontname": "default",
                //                    "fontsize": "12",
                //                    "fontcolor": "0x000000",
                "anchor": function () { return new Point(0,-20); },
                "position": function () { return new Point(0,1); },
                "angle": "0"
            },
            "labels": {
                "label": {
                    "format": undefined,
                    "start": undefined,
                    "angle": undefined,
                    "position": undefined,
                    "anchor": undefined,
                    "spacing": undefined,
                    "densityfactor": undefined
                    //                        "fontname": undefined,
                    //                        "fontsize": undefined,
                    //                        "fontcolor": undefined
                },
                //                    "fontname": "default",
                //                    "fontsize": "12",
                //                    "fontcolor": "0x000000",
                "format": "%1d",
                "visible": "true",
                "start": "0",
                "angle": "0.0",
                "position": "0 0",
                "anchor": "0 0",
                //                    "spacing": "10000 5000 2000 1000 500 200 100 50 20 10 5 2 1 0.1 0.01 0.001",
                //                    "defaultDatetimeSpacing": "1000Y 500Y 200Y 100Y 50Y 20Y 10Y 5Y 2Y 1Y 6M 3M 2M 1M 7D 3D 2D 1D 12H 6H 3H 2H 1H",
                "function": undefined,
                "densityfactor": undefined
            },
            "grid": {
                //                    "color": "0xeeeeee",
                "visible": "false"
            },
            "pan": {
                "allowed": "yes",
                "min": undefined,
                "max": undefined
            },
            "zoom": {
                "allowed": "yes",
                "min": undefined,
                "max": undefined,
                "anchor": "none"
            },
            "binding": {
                "id": undefined,
                "min": undefined,
                "max": undefined
            },
            "id": undefined,
            "type": "number",
            //                "length": "1.0",
            "position": "0 0",
            "pregap": "0",
            "postgap": "0",
            "anchor": "-1",
            "base": "-1 1",
            "min": "auto",
            "minoffset": "0",
            "minposition": "-1",
            "max": "auto",
            "maxoffset": "0",
            "maxposition": "1",
            "positionbase": undefined,
            //                "color": "0x000000",
            "tickmin": "-3",
            "tickmax": "3",
            "highlightstyle": "axis",
            "linewidth": "1",
            "orientation": undefined
        },
        "plot": {
            "legend": {
                "visible": true,
                "label": undefined
            },
            "horizontalaxis": {
                "variable": {
                    "ref": undefined,
                    "factor": undefined
                },
                "constant": {
                    "value": undefined
                },
                "ref": undefined
            },
            "verticalaxis": {
                "variable": {
                    "ref": undefined,
                    "factor": undefined
                },
                "constant": {
                    "value": undefined
                },
                "ref": undefined
            },
            "filter": {
                "option": {
                    "name": undefined,
                    "value": undefined
                },
                "type": undefined
            },
            "renderer":{
                "option": {
                    "name": undefined,
                    "value": undefined,
                    "min": undefined,
                    "max": undefined
                },
                "type": function () {
                    var Renderer = require('../core/renderer.js');
                    return Renderer.Type.parse("line");
                }
            },
            "datatips":{
                "variable": {
                    "formatString-number" : "%.2f",
                    "formatString-datetime" : "%d %n %Y"
                },
                //                    "visible": "false",
                "formatString": "{0}: {1}",
                "bgcolor": function () { return RGBColor.parse("0xeeeeee"); },
                "bgalpha": 1.0,
                "border": 1,
                "bordercolor": function () { return RGBColor.parse("0x000000"); },
                "pad": 2
            },
        },
        "throttle": {
            "pattern"    : "",
            "requests"   : 0,
            "period"     : 0,
            "concurrent" : 0
        },
        "data": {
            "variables": {
                "variable": {
                    "id": undefined,
                    "column": undefined,
                    "type": "number",
                    "missingvalue": undefined,
                    "missingop": undefined
                },
                "missingvalue": "-9000",
                "missingop": "eq"
            },
            "values": {
                "content": undefined
            },
            "csv": {
                "location": undefined
            },
            "service": {
                "location": undefined
            }
        }
    };
    
};

module.exports = utilityFunctions;


},{"../core/datetime_value.js":38,"../core/number_value.js":52,"../core/renderer.js":58,"../math/displacement.js":103,"../math/insets.js":105,"../math/point.js":106,"../math/rgb_color.js":107}],160:[function(require,module,exports){
var ValidationFunctions = {};

ValidationFunctions.validateNumberRange = function (number, lowerBound, upperBound) {
    return typeof(number) === "number" && number >= lowerBound && number <= upperBound;
};

// This function, from http://javascript.crockford.com/remedial.html, should correctly
// return 'array' for any Array object, including [].
// Returns 'object' for any JS object.
ValidationFunctions.typeOf = function(value) {
    var s = typeof value;
    if (s === 'object') {
        if (value) {
            //NOTE: Crockford used "=="   ?????!!!!!  mbp Fri Sep 28 08:44:34 2012
            //if (Object.prototype.toString.call(value) == '[object Array]') {
            if (Object.prototype.toString.call(value) === '[object Array]') {
                s = 'array';
            }
        } else {
            s = 'null';
        }
    }
    return s;
};

ValidationFunctions.isNumberNotNaN = function(x) {
    return (typeof(x) === "number") && (x === x);
};

module.exports = ValidationFunctions;

},{}]},{},[100])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImxpYi9hamF4dGhyb3R0bGUvc3JjL2FqYXh0aHJvdHRsZS5qcyIsImxpYi9idXN5LXNwaW5uZXIvYnVzeV9zcGlubmVyLmpzIiwibGliL2Vycm9yLWRpc3BsYXkvYnVpbGQvZXJyb3JEaXNwbGF5LmpzIiwibGliL2plcm1haW5lL3NyYy9jb3JlL2F0dHIuanMiLCJsaWIvamVybWFpbmUvc3JjL2NvcmUvYXR0cl9saXN0LmpzIiwibGliL2plcm1haW5lL3NyYy9jb3JlL21ldGhvZC5qcyIsImxpYi9qZXJtYWluZS9zcmMvY29yZS9tb2RlbC5qcyIsImxpYi9qZXJtYWluZS9zcmMvY29yZS92YWxpZGF0b3IuanMiLCJsaWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzIiwibGliL2plcm1haW5lL3NyYy91dGlsL2V2ZW50X2VtaXR0ZXIuanMiLCJsaWIvamVybWFpbmUvc3JjL3V0aWwvaW5kZXhfb2YuanMiLCJsaWIvamVybWFpbmUvc3JjL3V0aWwvbmFtZXNwYWNlLmpzIiwibGliL2pxdWVyeS9qcXVlcnkubWluLmpzIiwibGliL2pxdWVyeS9qcXVlcnkubW91c2V3aGVlbC5qcyIsImxpYi9saWdodGJveC9saWdodGJveC5qcyIsImxpYi9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL3NwcmludGYvbGliL3NwcmludGYuanMiLCJzcmMvY29yZS9hcnJheV9kYXRhLmpzIiwic3JjL2NvcmUvYXhpcy5qcyIsInNyYy9jb3JlL2F4aXNfYmluZGluZy5qcyIsInNyYy9jb3JlL2F4aXNfdGl0bGUuanMiLCJzcmMvY29yZS9iYWNrZ3JvdW5kLmpzIiwic3JjL2NvcmUvY2F0ZWdvcnlfZm9ybWF0dGVyLmpzIiwic3JjL2NvcmUvY29uc2VjdXRpdmVfZGlzdGFuY2VfZmlsdGVyLmpzIiwic3JjL2NvcmUvY29uc3RhbnRfcGxvdC5qcyIsInNyYy9jb3JlL2Nzdl9kYXRhLmpzIiwic3JjL2NvcmUvZGF0YS5qcyIsInNyYy9jb3JlL2RhdGFfZm9ybWF0dGVyLmpzIiwic3JjL2NvcmUvZGF0YV9tZWFzdXJlLmpzIiwic3JjL2NvcmUvZGF0YV9wbG90LmpzIiwic3JjL2NvcmUvZGF0YV92YWx1ZS5qcyIsInNyYy9jb3JlL2RhdGFfdmFyaWFibGUuanMiLCJzcmMvY29yZS9kYXRhdGlwcy5qcyIsInNyYy9jb3JlL2RhdGF0aXBzX3ZhcmlhYmxlLmpzIiwic3JjL2NvcmUvZGF0ZXRpbWVfZm9ybWF0dGVyLmpzIiwic3JjL2NvcmUvZGF0ZXRpbWVfbWVhc3VyZS5qcyIsInNyYy9jb3JlL2RhdGV0aW1lX3VuaXQuanMiLCJzcmMvY29yZS9kYXRldGltZV92YWx1ZS5qcyIsInNyYy9jb3JlL2V2ZW50X2VtaXR0ZXIuanMiLCJzcmMvY29yZS9maWx0ZXIuanMiLCJzcmMvY29yZS9maWx0ZXJfb3B0aW9uLmpzIiwic3JjL2NvcmUvZ3JhcGguanMiLCJzcmMvY29yZS9ncmlkLmpzIiwic3JjL2NvcmUvaWNvbi5qcyIsInNyYy9jb3JlL2ltZy5qcyIsInNyYy9jb3JlL2xhYmVsZXIuanMiLCJzcmMvY29yZS9sZWdlbmQuanMiLCJzcmMvY29yZS9taXhpbi5qcyIsInNyYy9jb3JlL211bHRpZ3JhcGguanMiLCJzcmMvY29yZS9udW1iZXJfZm9ybWF0dGVyLmpzIiwic3JjL2NvcmUvbnVtYmVyX21lYXN1cmUuanMiLCJzcmMvY29yZS9udW1iZXJfdmFsdWUuanMiLCJzcmMvY29yZS9wYW4uanMiLCJzcmMvY29yZS9wZXJpb2RpY19hcnJheV9kYXRhLmpzIiwic3JjL2NvcmUvcGxvdC5qcyIsInNyYy9jb3JlL3Bsb3RfbGVnZW5kLmpzIiwic3JjL2NvcmUvcGxvdGFyZWEuanMiLCJzcmMvY29yZS9yZW5kZXJlci5qcyIsInNyYy9jb3JlL3JlbmRlcmVycy9hbGxfcmVuZGVyZXJzLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL2JhbmRfcmVuZGVyZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvYmFyX3JlbmRlcmVyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL2ZpbGxfcmVuZGVyZXIuanMiLCJzcmMvY29yZS9yZW5kZXJlcnMvcG9pbnRsaW5lX3JlbmRlcmVyLmpzIiwic3JjL2NvcmUvcmVuZGVyZXJzL3JhbmdlYmFyX3JlbmRlcmVyLmpzIiwic3JjL2NvcmUvdGV4dC5qcyIsInNyYy9jb3JlL3RpdGxlLmpzIiwic3JjL2NvcmUvd2FybmluZy5qcyIsInNyYy9jb3JlL3dlYl9zZXJ2aWNlX2RhdGEuanMiLCJzcmMvY29yZS93ZWJfc2VydmljZV9kYXRhX2NhY2hlX25vZGUuanMiLCJzcmMvY29yZS93ZWJfc2VydmljZV9kYXRhX2l0ZXJhdG9yLmpzIiwic3JjL2NvcmUvd2luZG93LmpzIiwic3JjL2NvcmUvem9vbS5qcyIsInNyYy9ldmVudHMvYWxsLmpzIiwic3JjL2V2ZW50cy9kcmFnZ2FibGUvZ3JhcGguanMiLCJzcmMvZXZlbnRzL21vdXNlL2dyYXBoLmpzIiwic3JjL2V2ZW50cy9tb3VzZS9tdWx0aWdyYXBoLmpzIiwic3JjL2V2ZW50cy9tdWx0aWdyYXBoLmpzIiwic3JjL2V2ZW50cy9yZXNpemUvbXVsdGlncmFwaC5qcyIsInNyYy9ldmVudHMvdG91Y2gvZ3JhcGguanMiLCJzcmMvZXZlbnRzL3RvdWNoL211bHRpZ3JhcGguanMiLCJzcmMvZ3JhcGhpY3MvY2FudmFzL2FsbC5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvYXhpcy5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvYXhpc190aXRsZS5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvYmFja2dyb3VuZC5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvZ3JhcGguanMiLCJzcmMvZ3JhcGhpY3MvY2FudmFzL2dyYXBoX3RpdGxlLmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy9pY29uLmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy9pbWcuanMiLCJzcmMvZ3JhcGhpY3MvY2FudmFzL2xhYmVsZXIuanMiLCJzcmMvZ3JhcGhpY3MvY2FudmFzL2xlZ2VuZC5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvbXVsdGlncmFwaC5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvcGxvdGFyZWEuanMiLCJzcmMvZ3JhcGhpY3MvY2FudmFzL3JlbmRlcmVycy9iYW5kX3JlbmRlcmVyLmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy9yZW5kZXJlcnMvYmFyX3JlbmRlcmVyLmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy9yZW5kZXJlcnMvZmlsbF9yZW5kZXJlci5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvcmVuZGVyZXJzL3BvaW50bGluZV9yZW5kZXJlci5qcyIsInNyYy9ncmFwaGljcy9jYW52YXMvcmVuZGVyZXJzL3JhbmdlYmFyX3JlbmRlcmVyLmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy90ZXh0LmpzIiwic3JjL2dyYXBoaWNzL2NhbnZhcy93aW5kb3cuanMiLCJzcmMvbWFpbi13aXRoLWpxdWVyeS5qcyIsInNyYy9tYWluLmpzIiwic3JjL21hdGgvYm94LmpzIiwic3JjL21hdGgvZGlzcGxhY2VtZW50LmpzIiwic3JjL21hdGgvZW51bS5qcyIsInNyYy9tYXRoL2luc2V0cy5qcyIsInNyYy9tYXRoL3BvaW50LmpzIiwic3JjL21hdGgvcmdiX2NvbG9yLmpzIiwic3JjL21hdGgvdXRpbC5qcyIsInNyYy9wYXJzZXIvanNvbi9heGlzLmpzIiwic3JjL3BhcnNlci9qc29uL2F4aXNfdGl0bGUuanMiLCJzcmMvcGFyc2VyL2pzb24vYmFja2dyb3VuZC5qcyIsInNyYy9wYXJzZXIvanNvbi9kYXRhLmpzIiwic3JjL3BhcnNlci9qc29uL2RhdGFfdmFyaWFibGUuanMiLCJzcmMvcGFyc2VyL2pzb24vZGF0YXRpcHMuanMiLCJzcmMvcGFyc2VyL2pzb24vZmlsdGVyLmpzIiwic3JjL3BhcnNlci9qc29uL2ZpbHRlcl9vcHRpb24uanMiLCJzcmMvcGFyc2VyL2pzb24vZ3JhcGguanMiLCJzcmMvcGFyc2VyL2pzb24vZ3JpZC5qcyIsInNyYy9wYXJzZXIvanNvbi9pY29uLmpzIiwic3JjL3BhcnNlci9qc29uL2ltZy5qcyIsInNyYy9wYXJzZXIvanNvbi9qc29uX3BhcnNlci5qcyIsInNyYy9wYXJzZXIvanNvbi9sYWJlbGVyLmpzIiwic3JjL3BhcnNlci9qc29uL2xlZ2VuZC5qcyIsInNyYy9wYXJzZXIvanNvbi9tdWx0aWdyYXBoLmpzIiwic3JjL3BhcnNlci9qc29uL3Bhbi5qcyIsInNyYy9wYXJzZXIvanNvbi9wbG90LmpzIiwic3JjL3BhcnNlci9qc29uL3Bsb3RfbGVnZW5kLmpzIiwic3JjL3BhcnNlci9qc29uL3Bsb3RhcmVhLmpzIiwic3JjL3BhcnNlci9qc29uL3JlbmRlcmVyLmpzIiwic3JjL3BhcnNlci9qc29uL3RpdGxlLmpzIiwic3JjL3BhcnNlci9qc29uL3dpbmRvdy5qcyIsInNyYy9wYXJzZXIvanNvbi96b29tLmpzIiwic3JjL3BhcnNlci94bWwvYXhpcy5qcyIsInNyYy9wYXJzZXIveG1sL2F4aXNfdGl0bGUuanMiLCJzcmMvcGFyc2VyL3htbC9iYWNrZ3JvdW5kLmpzIiwic3JjL3BhcnNlci94bWwvZGF0YS5qcyIsInNyYy9wYXJzZXIveG1sL2RhdGFfdmFyaWFibGUuanMiLCJzcmMvcGFyc2VyL3htbC9kYXRhdGlwcy5qcyIsInNyYy9wYXJzZXIveG1sL2RhdGF0aXBzX3ZhcmlhYmxlLmpzIiwic3JjL3BhcnNlci94bWwvZmlsdGVyLmpzIiwic3JjL3BhcnNlci94bWwvZmlsdGVyX29wdGlvbi5qcyIsInNyYy9wYXJzZXIveG1sL2dyYXBoLmpzIiwic3JjL3BhcnNlci94bWwvZ3JpZC5qcyIsInNyYy9wYXJzZXIveG1sL2ljb24uanMiLCJzcmMvcGFyc2VyL3htbC9pbWcuanMiLCJzcmMvcGFyc2VyL3htbC9qcXVlcnlfeG1sX3BhcnNlci5qcyIsInNyYy9wYXJzZXIveG1sL2xhYmVsZXIuanMiLCJzcmMvcGFyc2VyL3htbC9sZWdlbmQuanMiLCJzcmMvcGFyc2VyL3htbC9tdWx0aWdyYXBoLmpzIiwic3JjL3BhcnNlci94bWwvcGFuLmpzIiwic3JjL3BhcnNlci94bWwvcGxvdC5qcyIsInNyYy9wYXJzZXIveG1sL3Bsb3RfbGVnZW5kLmpzIiwic3JjL3BhcnNlci94bWwvcGxvdGFyZWEuanMiLCJzcmMvcGFyc2VyL3htbC9yZW5kZXJlci5qcyIsInNyYy9wYXJzZXIveG1sL3RpdGxlLmpzIiwic3JjL3BhcnNlci94bWwvd2luZG93LmpzIiwic3JjL3BhcnNlci94bWwvem9vbS5qcyIsInNyYy91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMiLCJzcmMvdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzIiwic3JjL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3puQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25lQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIGFqYXh0aHJvdHRsZS5qc1xuICogXG4gKiBVc2FnZTpcbiAqIFxuICogICAgIHZhciB0ID0gJC5hamF4dGhyb3R0bGUoe1xuICogICAgICAgIG51bVJlcXVlc3RzUGVyVGltZVBlcmlvZCA6IE4sXG4gKiAgICAgICAgdGltZVBlcmlvZCAgICAgICAgICAgICAgIDogUCxcbiAqICAgICAgICBtYXhDb25jdXJyZW50ICAgICAgICAgICAgOiBNXG4gKiAgICAgfSk7XG4gKiAgICBcbiAqICAgICB0LmFqYXgoYXJncyk7XG4gKlxuICogVGhpcyBpcyBqdXN0IGxpa2UgY2FsbGluZyAkLmFqYXgoYXJncyksIGV4Y2VwdCB0aGF0IHJlcXVlc3RzIGFyZSB0aHJvdHRsZWRcbiAqIHNvIHRoYXQgbm8gbW9yZSB0aGFuIE4gYXJlIGluaXRpYXRlZCBpbiBhbnkgdGltZSBwZXJpb2Qgb2YgUCBtaWxsaXNlY29uZHMsXG4gKiBhbmQgbm8gbW9yZSB0aGFuIE0gY29uY3VycmVudCAob3V0c3RhbmRpbmcgYXQgdGhlIHNhbWUgdGltZSkgcmVxdWVzdHMgYXJlIGFsbG93ZWQuXG4gKiBJZiBOIG9yIFAgaXMgMCwgdGhlcmUgaXMgbm8gdGltZSBwZXJpb2QgYmFzZWQgY29uc3RyYWludCwgYW5kIGlmIE0gaXMgMCwgdGhlcmVcbiAqIGlzIG5vIGNvbnN0cmFpbnQgb24gdGhlIG51bWJlciBvZiBjb25jdXJyZW50IHJlcXVlc3RzLlxuICogXG4gKiBNYXJrIFBoaWxsaXBzIDxtcGhpbGxpcEB1bmNhLmVkdT5cbiAqIFRodSBEZWMgMjAgMTE6MDQ6MTkgMjAxMlxuICovXG4oZnVuY3Rpb24oJCkge1xuICAgICQuYWpheHRocm90dGxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgIHZhciB0aW1lb3V0LFxuXG4gICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBudW1SZXF1ZXN0c1BlclRpbWVQZXJpb2QgOiAwLFxuICAgICAgICAgICAgICAgIHRpbWVQZXJpb2QgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgbWF4Q29uY3VycmVudCAgICAgICAgICAgIDogMVxuICAgICAgICAgICAgfSwgb3B0aW9ucyksXG5cbiAgICAgICAgICAgIHRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEFycmF5IG9mIG91dHN0YW5kaW5nIHJlcXVlc3RzOyB0aGVzZSBhcmUgcmVxdWVzdHMgdGhhdCBoYXZlXG4gICAgICAgICAgICAvLyBiZWVuIGluaXRpYXRlZCB3aXRoIGEgY2FsbCB0byAkLmFqYXgoKSBidXQgdGhhdCBoYXZlIG5vdFxuICAgICAgICAgICAgLy8gY29tcGxldGVkIHlldC4gIEVhY2ggZW50cnkgaW4gdGhpcyBhcnJheSBpcyBhbiBvYmplY3Qgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgIC8vICAgIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgYXJndW1lbnRzOiB0aGUgb3JpZ2luYWwgYXJndW1lbnRzIGxpc3QgcGFzc2VkIHRvIC5hamF4KClcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICB0aW1lOiB0aGUgdGltZSB0aGlzIHJlcXVlc3Qgd2FzIHBhc3NlZCB0byAkLmFqYXgoKVxuICAgICAgICAgICAgLy8gICAgICAgICAgZGVmZXJyZWQ6IHRoZSBqUXVlcnkgZGVmZXJyZWQgb2JqZWN0IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgICAgICAgIC8vICAgIH1cbiAgICAgICAgICAgIG91dHN0YW5kaW5nX3JlcXMgPSBbXSxcblxuICAgICAgICAgICAgLy8gQXJyYXkgb2YgaW5pdGlhdGVkIHJlcXVlc3RzOyBlYWNoIGVudHJ5IGluIHRoaXMgYXJyYXlcbiAgICAgICAgICAgIC8vIGlzIGFuIG9iamVjdCBqdXN0IGxpa2UgdGhlIG9uZXMgaW4gdGhlIG91dHN0YW5kaW5nX3JlcXNcbiAgICAgICAgICAgIC8vIGFycmF5IGFib3ZlLCBidXQgdGhpcyBhcnJheSBrZWVwcyB0cmFjayBvZiBhbGxcbiAgICAgICAgICAgIC8vIHJlcXVlc3RzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleSBoYXZlIGNvbXBsZXRlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgbGlzdCBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgcmVxdWVzdHNcbiAgICAgICAgICAgIC8vIGhhdmUgYmVlbiBpbml0aWF0ZWQgaW4gc2V0dGluZ3MudGltZVBlcmlvZC4gIFJlcXVlc3RzXG4gICAgICAgICAgICAvLyB0aGF0IGFyZSBvbGRlciB0aGFuIHNldHRpbmdzLnRpbWVQZXJpb2QgbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAvLyBnZXQgcmVtb3ZlZCBmcm9tIHRoaXMgbGlzdCB3aGVuIGl0IGlzIHB1cmdlZC5cbiAgICAgICAgICAgIGluaXRpYXRlZF9yZXFzID0gW10sXG5cbiAgICAgICAgICAgIC8vIEFycmF5IG9mIHJlcXVlc3RzIHdhaXRpbmcgdG8gYmUgaW5pdGlhdGVkXG4gICAgICAgICAgICB3YWl0aW5nX3JlcXMgPSBbXSxcblxuICAgICAgICAgICAgLy8gUHVyZ2UgdGhlIGluaXRpYXRlZCByZXFzIGxpc3Qgc28gdGhhdCBpdCBkb2Vzbid0IGNvbnRhaW4gYW55XG4gICAgICAgICAgICAvLyByZXFzIGZyb20gbW9yZSB0aGFuIHNldHRpbmdzLnRpbWVQZXJpb2QgbXMgYWdvLiAgUmV0dXJuIHRoZVxuICAgICAgICAgICAgLy8gYW1vdW50IG9mIHRpbWUgdGhhdCBuZWVkcyB0byBiZSB3YWl0ZWQgdW50aWwgdGhlIG9sZGVzdCByZW1haW5pbmdcbiAgICAgICAgICAgIC8vIChhZnRlciBwdXJnaW5nKSByZXEgaW4gdGhlIGxpc3Qgd2lsbCBiZSBzZXR0aW5ncy50aW1lUGVyaW9kIG1zIG9sZC5cbiAgICAgICAgICAgIC8vIERvIGFsbCBvZiB0aGlzIHJlbGF0aXZlIHRvIHRoZSBwYXNzZWQgaW4gJ25vdycgdmFsdWUuXG4gICAgICAgICAgICBwdXJnZV9pbml0aWF0ZWRfcmVxcyA9IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy50aW1lUGVyaW9kID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChpbml0aWF0ZWRfcmVxcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbml0aWF0ZWRfcmVxc1swXS50aW1lICsgc2V0dGluZ3MudGltZVBlcmlvZCAtIG5vdyA8PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhdGVkX3JlcXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhdGVkX3JlcXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYXRlZF9yZXFzWzBdLnRpbWUgKyBzZXR0aW5ncy50aW1lUGVyaW9kIC0gbm93O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGEgcmVxIGZyb20gdGhlIG91dHN0YW5kaW5nX3JlcXMgbGlzdFxuICAgICAgICAgICAgcmVtb3ZlX291dHN0YW5kaW5nX3JlcSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgICQuZWFjaChvdXRzdGFuZGluZ19yZXFzLCBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRzdGFuZGluZ19yZXFzW2ldID09PSBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nX3JlcXMuc3BsaWNlKGksMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBJbml0aWF0ZSB0aGUgbmV4dCByZXF1ZXN0IG9uIHRoZSB3YWl0aW5nIGxpc3QsIHVubGVzcyB3ZSBuZWVkIHRvIHdhaXRcbiAgICAgICAgICAgIC8vIHRpbGwgc29tZSB0aW1lIGhhcyBwYXNzZWQgb3Igc29tZSBvdXRzdGFuZGluZyByZXF1ZXN0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgICAgICAgIHByb2Nlc3Nfd2FpdGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBub3cgPSB0aW1lKCksXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5LCByZXEsIGRlZmVycmVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHdhaXRpbmdfcmVxcy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsYXkgPSBwdXJnZV9pbml0aWF0ZWRfcmVxcyhub3cpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHRpbWVQZXJpb2QgY29uc3RyYWludCwgYW5kIHRoZSBtYXggbnVtYmVyIG9mIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0cyBoYXZlIGdvbmUgb3V0IGluIHRoYXQgdGltZSBwZXJpb2QsIGFycmFuZ2UgdG8gd2FpdCBmb3JcbiAgICAgICAgICAgICAgICAvLyAnZGVsYXknIG1zXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5udW1SZXF1ZXN0c1BlclRpbWVQZXJpb2QgPiAwKSAmJiAoc2V0dGluZ3MudGltZVBlcmlvZCA+IDApXG4gICAgICAgICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgICAgICAgIChkZWxheSA+IDApXG4gICAgICAgICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgICAgICAgIChpbml0aWF0ZWRfcmVxcy5sZW5ndGggPj0gc2V0dGluZ3MubnVtUmVxdWVzdHNQZXJUaW1lUGVyaW9kKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBhbnkgZXhpc3RpbmcgdGltZW91dCBmaXJzdCwgYmVjYXVzZSB0aGlzIG9uZSB3aWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcXVpcmUgd2FpdGluZyB0aWxsIGFmdGVyIGl0IHdvdWxkIGZpbmlzaCBhbnl3YXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Nfd2FpdGluZygpO1xuICAgICAgICAgICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbWF4IG51bWJlciBvZiBhbGxvd2VkIHJlcXVlc3RzIGlzIG91dHN0YW5kaW5nLCBkbyBub3RoaW5nO1xuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3Nfd2FpdGluZygpIHdpbGwgZ2V0IGNhbGxlZCBhZ2FpbiB3aGVuIGEgcmVxdWVzdCBjb21wbGV0ZXMuXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5tYXhDb25jdXJyZW50ID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAob3V0c3RhbmRpbmdfcmVxcy5sZW5ndGggPj0gc2V0dGluZ3MubWF4Q29uY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIG1ha2UgaXQgdG8gaGVyZSwgdGhlbiBpdCdzIE9LIHRvIGluaXRpYXRlIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBpbiB0aGUgd2FpdGluZyBsaXN0XG4gICAgICAgICAgICAgICAgcmVxID0gd2FpdGluZ19yZXFzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcmVxLnRpbWUgPSB0aW1lKCk7XG4gICAgICAgICAgICAgICAgaW5pdGlhdGVkX3JlcXMucHVzaChyZXEpO1xuICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nX3JlcXMucHVzaChyZXEpO1xuICAgICAgICAgICAgICAgICQuYWpheC5hcHBseSgkLHJlcS5hcmd1bWVudHMpLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5kZWZlcnJlZC5yZXNvbHZlLmFwcGx5KHJlcS5kZWZlcnJlZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9KS5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXEuZGVmZXJyZWQucmVqZWN0LmFwcGx5KHJlcS5kZWZlcnJlZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9KS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZV9vdXRzdGFuZGluZ19yZXEocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc193YWl0aW5nKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWpheCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICB3YWl0aW5nX3JlcXMucHVzaCh7IGFyZ3VtZW50cyA6IGFyZ3VtZW50cywgZGVmZXJyZWQgOiBkZWZlcnJlZCB9KTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzX3dhaXRpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59KGpRdWVyeSkpO1xuIiwiKGZ1bmN0aW9uICgkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgbWV0aG9kcyA9IHtcbiAgICAgICAgb24gOiBmdW5jdGlvbihvbikge1xuICAgICAgICAgICAgaWYgKG9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5kYXRhKCdidXN5X3NwaW5uZXInKS5vbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmRhdGEoJ2J1c3lfc3Bpbm5lcicpLm9uICAgID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuZGF0YSgnYnVzeV9zcGlubmVyJykubGV2ZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmRhdGEoJ2J1c3lfc3Bpbm5lcicpLm9uICAgID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmRhdGEoJ2J1c3lfc3Bpbm5lcicpLmxldmVsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIGxldmVsIDogZnVuY3Rpb24oZGVsdGEpIHtcbiAgICAgICAgICAgIGlmIChkZWx0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZGF0YSgnYnVzeV9zcGlubmVyJykubGV2ZWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmRhdGEoJ2J1c3lfc3Bpbm5lcicpLmxldmVsICsgZGVsdGEgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdidXN5X3NwaW5uZXInKS5sZXZlbCA9ICQodGhpcykuZGF0YSgnYnVzeV9zcGlubmVyJykubGV2ZWwgKyBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmRhdGEoJ2J1c3lfc3Bpbm5lcicpLmxldmVsID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5idXN5X3NwaW5uZXIoJ29uJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCQodGhpcykuZGF0YSgnYnVzeV9zcGlubmVyJykubGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmJ1c3lfc3Bpbm5lcignb24nLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdCA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoJ2J1c3lfc3Bpbm5lcicpLFxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uIDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKCAhIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ2J1c3lfc3Bpbm5lcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uICAgIDogc2V0dGluZ3Mub24sXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbCA6IDBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5vbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCAgOiAzMixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA6IDMyXG4gICAgICAgICAgICAgICAgICAgIH0pLmFwcGVuZCgkKCc8aW1nIHNyYz1cImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaElBQWdBUE1BQVAvLy93QUFBTWJHeG9TRWhMYTJ0cHFhbWpZMk5sWldWdGpZMk9UazVMeTh2QjRlSGdRRUJBQUFBQUFBQUFBQUFDSC9DMDVGVkZORFFWQkZNaTR3QXdFQUFBQWgvaHBEY21WaGRHVmtJSGRwZEdnZ1lXcGhlR3h2WVdRdWFXNW1id0FoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNXhESVNXbGhwZXJONTJKTGhTU2RSZ3dWbzFJQ1FaUlVzaXdIcFRKVDRpb3dOUzh2eVcyaWNDRjZrOEhNTUJrQ0VEc2t4VEJEQVp3dUFra3FJZnhJUXloQlFCRnZBUVNESVRNNVZEVzZYTkU0S2FnTmg2Qmd3ZTYwc21RVUIzZDRSejFaQkFwbkZBU0RkMGhpaGgxMkJrRTlrakFKVmx5Y1hJZzdDUUlGQTZTbG5KODdwYXFiU0tpS29xdXNuYk1kbURDMnRYUWxrVWh6aVl0eVdUeElmeTZCRThXSnQ1WUp2cEppdnhOYUdtTEhUMFZuT2dTWWYwZFpYUzdBUGRwQjMwOVJuSE9HNWdEcVhHTERhQzQ1N0QxelovVi9ubU9NODJYaUhSTFlLaEtQMW9abUFEZEVBQUFoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNmhESVNXbFpwT3JOcDFsR05SU2RScERVb2xJR3c1UlVZaGhIdWtxRnU4RHNyRXlxbldUaEd2QW1oVmx0ZUJ2b2pwVEREQlVFSUZ3TUZCUkFtQmtTZ09yQkZab2dDQVN3QkRFWS9DWlNnN0dTRTBnU0NqUUJNVkcwMjN4V0Joa2xBbm9FZGhRRWZ5TnFNSWNLamhSc2pFZG5lekIrQTRrOGdUd0poRnVpVzRkb2tYaWxvVWVwQkFwNXFhS3BwNitIbzdhV1c1NHdsN29idkVlMGtSdW9wbENHZXB3U3gyakp2cUhFbUd0NndoSnBHcGZKQ0htT29OSEthSHg2MVdpU1I5MkU0bGJGb3ErQjZRRHR1ZXRjYUJQblc2K083d0RIcElpSzlTYVZLNUdnVjU0M3R6amdHY2doQWdBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTdoRElTU2t4cE9yTjV6RkhOV1JkaFNpVm9WTEhzcFJVTW95VWFreUVlOFBUUENBVFc5QTE0RTBVdnVBS01OQVpLWVVaQ2lCTXVCYWtTUUtHOEcyRnpVV294MkFVdEFRRmNCS2xWUW9MZ1FSZVpoUWxDSUplc1FYSTVCMENCblVNT3hNQ2Vub0NmVENFV0JzSkNvbFRNQU5sZHgxNUJHczhCNXdsQ1o5UG82T0prd21ScG5xa3FudVNyYXlxZkttcXBMYWpvaVc1SEpxN0ZMMUdyMm1NTWNLVU1JaUpnSWVteTd4WnRKc1Rtc000eEhpS3Y1S01DWHFmeVVDSkVvblhQTjJyQU9JQW1zZkIzdVBvQUsrK0crdzQ4ZWRaUEsrTTZoTEpwUWc0ODRlblhJZFFGU1MxdTZVaGtzRU5FUUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQk9jUXlFbXBHS0xxeldjWlJWVVFuWllnMWFCU2gyR1VWRUlRMmFRT0UrRytjRDRudHBXa1pRajFKSWlaSW9nREZGeUhJMFV4UXdGdWdNU09GSVBKZnRmVkFFb1pMQmJjTEVGaGxRaXFHcDFWZDE0MEFVa2xVTjNlQ0E1MUMxRVdNek1DZXpDQkJta3hWSVZIQldkM0hIbDlKUU9JSlNkU25KMFRES0NoQ3dVSmpvV01QYUdxREthbm5hc01vNlduTTU2MlI1WWx1WlJ3dXIwd3BncVpFN05LVW0rRk5SUEloakJKeEtadGVXdUlCTU40elJNSVZJaGZmY2dvandDRjExN2k0bmxMblk1enRSTHNuT2srYVYrb0pZN1Y3bTc2UGRrUzR0cktjZGcwWmMwdFRjS2tSQUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQk80UXlFa3BLcWpxelNjcFJhVmtYWldRRXhpbXcxQlNDVUVJbERvaHJmdDZjcEtDazV4aWQ1TU5KVGFBSWtla0tHUWtXeUtIa3ZoS3NSN0FSbWl0a0FZRFlSSWJVUVJRaldCd0pSekNoaTlDUmxCY1kxVU40ZzAvVk5CMEFsY3ZjQVlIUnlaUGRFUUZZVjhjY3dSNUhXeEVKMDJZbVJNTG5KMXhDWXAwWTVpZHBRdWhvcG1tQzJLZ29qS2FzVVFEazVCTkF3d01PaDJSdFJxNXVRdVBaS0dJSlFJR3dBd0dmNkkwSlhNcEM4QzdrWFdEQklORk14UzRES01BV1ZXQUdZc0FkTnFXNXVhUnhrU0tKT1pLYVUzdFBPQlo0RHVLMkxBVGdKaGtQSk1nVHdLQ2RGanlQSEVuS3hGQ0RoRUFBQ0g1QkFrS0FBQUFMQUFBQUFBZ0FDQUFBQVR6RU1oSmFWS3A2czJuSWtvbElKMldrQlNocGtWUldxcVFyaExTRXU5TVpKS0s5eTFacnFZSzlXaUNsbXZvVWFGOGdJUVNOZUYxRXI0TU5GbjRTUlNEQVJXcm9BSUVUZzFpVnd1SGpZQjFrWWMxbXdydXdYS0M5Z21zSlhsaUd4YytYaVVDYnk5eWRoMXNPU2RNa3BNVEJwYVhCenNmaG9jNWw1OEdtNXlUb0FhWmhhT1VxamtEZ0NXTkhBVUxDd09MYVRtenN3YWRFcWdnUXdnSHVRc0hJb1pDSFFNTVFnUUd1YlZFY3hPUEZBY01EQVlVQTg1ZVdBUm1mU1JRQ2RjTWUwemVQMUFBeWd3TGxKdFBOQUFMMTlEQVJkUHpCT1dTbTFickpCaTQ1c29SQVdRQUFrclFJeWtTaFE5d1ZoSEN3Q1FDQUNINUJBa0tBQUFBTEFBQUFBQWdBQ0FBQUFUckVNaEphVktwNnMybklrcUZaRjJWSUJXaFVzSmFUb2txVUNvQnErRTcxU1JRZXlxVVRvTEE3VnhGMEpEeUlRaC9NVlZQTXQxRUNabGZjalpKOW1JS29hVGwxTVJJbDVvNENVS1hPd215ckNJbkNLcWNXdHZhZEwyU1loeUFTeU5ESjB1SWlSTURqSTBGZDMwL2lJMlVBNUdTUzVVRGoybDZOb3FnT2dONGdrc0VCZ1lGZjBGRHFLZ0hueVo5T1g4SHJnWUhkSHBjSFFVTFhBUzJxS3BFTlJnN2VBTUxDN2tUQmFpeFVZRmtLQXpXQUFuTEM3RkxWeExXREJMS0N3YUtUVUxnRXdiTEE0aEp0T2tTQk5xSVRUM3hFZ2ZMcEJ0ekUvaml1TDA0UkdFQmd3V2hTaFJnUUV4SEJBQWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU3eERJU1dsU3Flck5weUpLaFdSZGxTQVZvVkxDV2s2SktsQXFBYXZoTzlVa1VIc3FsRTZDd08xY1JkQ1E4aUVJZnpGVlR6TGRSQW1aWDNJMlNmWmlDcUdrNWRURVNKZWFPQWxDbHpzSnNxd2lKd2lxbkZyYjJuUzlrbUljZ0VzalF5ZExpSWxIZWhocGVqYUlqemg5ZW9tU2paUitpcHNsV0lSTEFnTURPUjJET3FLb2dUQjlwQ1VKQmFnREJYUjZYQjBFQmtJSXNhUnNHR01NQXhvREJnWUhUS0ppVVlFR0RBekhDOUVBQ2NVR2tJZ0Z6Z3daMFFzU0JjWEhpUXZPd2dEZEV3ZkZzMHNEenQ0UzZCSzR4WWprRE96bjB1bkZlQnpPQmlqSW0xRGdtZzVZRlF3c0NNanAxb0o4THlJQUFDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHdFTWhKYVZLcDZzMm5Ja3FGWkYyVklCV2hVc0phVG9rcVVDb0JxK0U3MVNSUWV5cVVUb0xBN1Z4RjBKRHlJUWgvTVZWUE10MUVDWmxmY2paSjltSUtvYVRsMU1SSWw1bzRDVUtYT3dteXJDSW5DS3FjV3R2YWRMMlNZaHlBU3lOREowdUlpVWQ2R0dsNk5vaVBPSDE2aVpLTmxINktteVdGT2dnSGhFRXZBd3dNQTBOOUdCc0VDNmFtaG5WY0V3YXZEQWF6R3dJRGFIMWlwYVlMQlVUQ0dnUURBOE5kSHowRnBxZ1RCd3NMcUFiV0FBbklBNEZXS2RNTEdkWUdFZ3JhaWdiVDBPSVRCY2c1UXdQVDR4THJST1pMNkF1UUFQVVM3YnhMcG9XaWRZMEp0eExIS2h3d01KQlRIZ1BLZEVRQUFDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHJFTWhKYVZLcDZzMm5Ja3FGWkYyVklCV2hVc0phVG9rcVVDb0JxK0U3MVNSUWV5cVVUb0xBN1Z4RjBKRHlJUWgvTVZWUE10MUVDWmxmY2paSjltSUtvYVRsMU1SSWw1bzRDVUtYT3dteXJDSW5DS3FjV3R2YWRMMlNZaHlBU3lOREowdUlpVWQ2R0FVTERKQ1JpWG8xQ3BHWERKT1VqWStZaXA5RGhUb0pBNFJCTHdNTEN3VkRmUmdiQkFhcXFvWjFYQk1Ic3dzSHR4dEZhSDFpcWFvR05nQUl4UnBiRkFnZlBRU3FwYmdHQnFVRDF3QlhlQ1lwMUFZWjE5SkpPWWdIMUt3QTRVQnZRd1hVQnhQcVZEOUwzc2JwMkJOazJ4dnZGUEpkK01GQ042SEFBSUtnTmdnWTBLdEVCQUFoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNkJESVNXbFNxZXJOcHlKS2hXUmRsU0FWb1ZMQ1drNkpLbEFxQWF2aE85VWtVSHNxbEU2Q3dPMWNSZENROGlFSWZ6RlZUekxkUkFtWlgzSTJTZllJRE1hQUZkVEVTSmVhRURBSU14WUZxck9VYU5XNEU0T2JZY0NYYWlCVkVnVUxlME5KYXh4dFlrc2poMk5Ma1pJU2dEZ0poSHRoa3BVNG1XNmJsUmlZbVpPbGg0SldrRHFJTHdVR0JuRTZUWUViQ2dldnIwTjFnSDRBdDdnSGlScEZhTE5ycnE4SE5nQUpBNzBBV3hRSUgxK3ZzWU1EQXpaUVBDOVZDTmtEV1VoR2t1RTVQeEpOd2lVSzRVZkx6T2xENFd2ekFIYW9HOW54UGk1ZCtqWVVxZkFoaHlrT0Z3SldpQUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQlBBUXlFbHBVcW5xemFjaVNvVmtYVlVNRmFGU3dscE9DY01ZbEVyQWF2aE9Nbk5MTm84S3Nac01aSXRKRUlESUZTa0xHUW9RVE5oSXNGZWhSd3cyQ1FMS0YwdFlHS1lTZyt5Z3NaSXVOcUprc0tnYmZnSUdlcE5vMmNJVUIzVjFCM0l2TmlCWU5RYURTVHRmaGh4MEN3VlBJMFVKZTArYm00ZzVWZ2NHb3FPY25qbWpxRFNkbmhnRW9hbWNzWnVYTzFhV1F5OEtBd09BdVRZWUd3aTd3NWgrS3IwU0o4TUZpaHBOYngrNEVycTdCWUJ1enNkaUgxakNBem9TZmwwclZpck5iUlhsQkJsTFgrQlAwWEpMQVBHelRrQXVBT3FiMFdUNUFIN09jZENtNUI4VGdSd1NSS0lIUXRhTEN3ZzFSQUFBT3dBQUFBQUFBQUFBQUE9PVwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIGFsdD1cImFqYXggbG9hZGluZ1wiPicpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4uYnVzeV9zcGlubmVyID0gZnVuY3Rpb24oIG1ldGhvZCApIHtcbiAgICAgICAgaWYgKCBtZXRob2RzW21ldGhvZF0gKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1sgbWV0aG9kIF0uYXBwbHkoIHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnIHx8ICEgbWV0aG9kICkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVycm9yKCAnTWV0aG9kICcgKyAgbWV0aG9kICsgJyBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkuYnVzeV9zcGlubmVyJyApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gICAgXG4gICAgfTtcbiAgICBcbn0oalF1ZXJ5KSk7XG4iLCIoZnVuY3Rpb24gKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBlcnJvckRpc3BsYXlIdG1sID0gKFxuICAgICAgICAnJ1xuICAgICAgICAgICAgKyAnPGRpdiBjbGFzcz1cImVycm9yRGlzcGxheVwiPidcbiAgICAgICAgICAgICsgICAnPHNwYW4gY2xhc3M9XCJlcnJvckRpc3BsYXlPcHRpb25zXCI+J1xuICAgICAgICAgICAgKyAgICAgJzxidXR0b24gY2xhc3M9XCJlcnJvckRpc3BsYXlEZXRhaWxzQnV0dG9uXCI+U2VlIERldGFpbHM8L2J1dHRvbj4nXG4gICAgICAgICAgICArICAgICAnPGEgaHJlZj1cIlwiIGNsYXNzPVwiZXJyb3JEaXNwbGF5WEJ1dHRvblwiPiYjMTAwMDY7PC9hPidcbiAgICAgICAgICAgICsgICAnPC9zcGFuPidcbiAgICAgICAgICAgICsgICAnPHNwYW4gY2xhc3M9XCJlcnJvckRpc3BsYXlTaG9ydE1lc3NhZ2VcIj48L3NwYW4+J1xuICAgICAgICAgICAgKyAnPC9kaXY+J1xuICAgICAgICAgICAgKyAnPHNwYW4gY2xhc3M9XCJlcnJvckRpc3BsYXlSZXRyaWV2ZXJcIj48L3NwYW4+J1xuICAgICk7XG4gICAgXG4gICAgdmFyIGRldGFpbERpc3BsYXlIdG1sID0gKFxuICAgICAgICAnJ1xuICAgICAgICAgICAgKyAnPGRpdiBjbGFzcz1cImVycm9yRGlzcGxheURldGFpbHNcIj4nXG4gICAgICAgICAgICArICAgJzxzcGFuIGNsYXNzPVwiZXJyb3JEaXNwbGF5T3B0aW9uc1wiPidcbiAgICAgICAgICAgICsgICAgICc8YSBocmVmPVwiXCIgY2xhc3M9XCJlcnJvckRpc3BsYXlYQnV0dG9uXCI+JiMxMDAwNjs8L2E+J1xuICAgICAgICAgICAgKyAgICc8L3NwYW4+J1xuICAgICAgICAgICAgKyAgICc8c3BhbiBjbGFzcz1cImVycm9yRGlzcGxheUZ1bGxNZXNzYWdlQXJlYVwiPjwvc3Bhbj4nXG4gICAgICAgICAgICArICc8L2Rpdj4nXG4gICAgKTtcbiAgICBcbiAgICB2YXIgZGV0YWlsRGlzcGxheUxpc3RIdG1sID0gKFxuICAgICAgICAnJ1xuICAgICAgICAgICAgKyAnPHVsIGNsYXNzPVwiZXJyb3JEaXNwbGF5RnVsbE1lc3NhZ2VMaXN0XCI+J1xuICAgICAgICAgICAgKyAnPC91bD4nXG4gICAgKTtcbiAgICBcbiAgICB2YXIgbWV0aG9kcyA9IHtcbiAgICAgICAgaW5pdCA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoJ2Vycm9yRGlzcGxheScpLFxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250Q29sb3InIDogJyNmZjAwMDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmRDb2xvcicgOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGlzcGxheVRpbWUnIDogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmRpY2F0b3JDb2xvcicgOiAnI2ZmMDAwMCdcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCAhIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hcHBlbmQoZXJyb3JEaXNwbGF5SHRtbCk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXknKS53aWR0aCgkdGhpcy53aWR0aCgpLTYpOyAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgZGV0YWlsRGlzcGxheSA9ICQoZGV0YWlsRGlzcGxheUh0bWwpLmFwcGVuZFRvKCQoXCJib2R5XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRldGFpbERpc3BsYXlMaXN0ID0gJChkZXRhaWxEaXNwbGF5TGlzdEh0bWwpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgJChkZXRhaWxEaXNwbGF5KS5maW5kKCcuZXJyb3JEaXNwbGF5WEJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChkZXRhaWxEaXNwbGF5KS5maW5kKCcuZXJyb3JEaXNwbGF5T3B0aW9ucycpLmhpZGUoKTsgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZGV0YWlsRGlzcGxheSkuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheVJldHJpZXZlcicpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHNldHRpbmdzLmluZGljYXRvckNvbG9yKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pOyAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnZXJyb3JEaXNwbGF5Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RldGFpbERpc3BsYXknIDogZGV0YWlsRGlzcGxheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXRhaWxEaXNwbGF5TGlzdCcgOiBkZXRhaWxEaXNwbGF5TGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250Q29sb3InIDogc2V0dGluZ3MuZm9udENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmRDb2xvcicgOiBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGlzcGxheVRpbWUnIDogc2V0dGluZ3MuZGlzcGxheVRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5kaWNhdG9yQ29sb3InIDogc2V0dGluZ3MuaW5kaWNhdG9yQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheVhCdXR0b24nKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5T3B0aW9ucycpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXknKS5zbGlkZVVwKHNldHRpbmdzLmRpc3BsYXlUaW1lLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlSZXRyaWV2ZXInKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7ICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheURldGFpbHNCdXR0b24nKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5Jykub2ZmKCk7IC8vc3RvcHMgbW91c2VsZWF2ZWV2ZW50IHdoZW4gZGV0YWlscyBidXR0b24gaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheScpLmhpZGUoKTsgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheVJldHJpZXZlcicpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZGV0YWlsRGlzcGxheSkuZmluZCgnLmVycm9yRGlzcGxheUZ1bGxNZXNzYWdlQXJlYScpLmVtcHR5KCkuYXBwZW5kKCQoZGV0YWlsRGlzcGxheUxpc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZGV0YWlsRGlzcGxheSkuZmluZCgnLmVycm9yRGlzcGxheU9wdGlvbnMnKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGRldGFpbERpc3BsYXkpLnNob3coKTsgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAvLyBpbml0KCkgbWV0aG9kXG4gICAgICAgIFxuICAgICAgICBkaXNwbGF5RXJyb3IgOiBmdW5jdGlvbihmdWxsTWVzc2FnZSwgc2hvcnRNZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCdlcnJvckRpc3BsYXknKSxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9udENvbG9yJyA6IGRhdGEuZm9udENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmRDb2xvcicgOiBkYXRhLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNwbGF5VGltZScgOiBkYXRhLmRpc3BsYXlUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2luZGljYXRvckNvbG9yJyA6IGRhdGEuaW5kaWNhdG9yQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheVJldHJpZXZlcicpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5T3B0aW9ucycpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5U2hvcnRNZXNzYWdlJykuY3NzKCdjb2xvcicsIHNldHRpbmdzLmZvbnRDb2xvcik7ICAgXG4gICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheScpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHNldHRpbmdzLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5T3B0aW9ucycpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHNldHRpbmdzLmJhY2tncm91bmRDb2xvcik7ICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlTaG9ydE1lc3NhZ2UnKS50ZXh0KHNob3J0TWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5Jykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheVJldHJpZXZlcicpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHNldHRpbmdzLmluZGljYXRvckNvbG9yKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgaWYoc2V0dGluZ3MuZGlzcGxheVRpbWUgIT0gLTEpeyAgIFxuICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheScpLnNsaWRlVXAoc2V0dGluZ3MuZGlzcGxheVRpbWUsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheVJldHJpZXZlcicpLnNob3coKTtcbiAgICAgICAgICAgICAgICAgIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICBlbHNleyAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5T3B0aW9ucycpLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5Jykuc2hvdygpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJChkYXRhLmRldGFpbERpc3BsYXlMaXN0KS5hcHBlbmQoJCgnPGxpPicrZnVsbE1lc3NhZ2UrJzwvbGk+JykuY3NzKCdjb2xvcicsIHNldHRpbmdzLmZvbnRDb2xvcikpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlSZXRyaWV2ZXInKS5ob3ZlcihmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlPcHRpb25zJykuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5U2hvcnRNZXNzYWdlJykudGV4dChzaG9ydE1lc3NhZ2UpLmNzcygnY29sb3InLCBzZXR0aW5ncy5mb250Q29sb3IpOyAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5Jykuc2xpZGVEb3duKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheU9wdGlvbnMnKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLmVycm9yRGlzcGxheScpLm1vdXNlbGVhdmUoZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5maW5kKCcuZXJyb3JEaXNwbGF5T3B0aW9ucycpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXknKS5zbGlkZVVwKHNldHRpbmdzLmRpc3BsYXlUaW1lLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlSZXRyaWV2ZXInKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICB9KTsgICAgIFxuICAgICAgICAgICAgICAgICAgICB9KTsgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmZpbmQoJy5lcnJvckRpc3BsYXlSZXRyaWV2ZXInKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IC8vIGRpc3BsYXlFcnJvcigpIG1ldGhvZFxuXG5cbiAgICB9O1xuXG4gICAgJC5mbi5lcnJvckRpc3BsYXkgPSBmdW5jdGlvbiggbWV0aG9kICkge1xuICAgICAgICBpZiAoIG1ldGhvZHNbbWV0aG9kXSApIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzWyBtZXRob2QgXS5hcHBseSggdGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApKTtcbiAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcgfHwgISBtZXRob2QgKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuZXJyb3IoICdNZXRob2QgJyArICBtZXRob2QgKyAnIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS5lcnJvckRpc3BsYXknICk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSAgICBcbiAgICB9O1xuXG59KGpRdWVyeSkpO1xualF1ZXJ5KCdoZWFkJykuYXBwZW5kKGpRdWVyeSgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPi5lcnJvckRpc3BsYXkgeyBmb250LWZhbWlseTogSGVsdmV0aWNhLCBzYW5zLXNlcmlmOyBjb2xvcjogIzMyNDQ2QjsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IHRleHQtYWxpZ246IGxlZnQ7IGZvbnQtc2l6ZTogMTJweDsgbGluZS1oZWlnaHQ6IDEycHg7IGhlaWdodDogNDVweDsgcG9zaXRpb246IGFic29sdXRlOyBib3R0b206IDBweDsgbGVmdDogMHB4OyB3aWR0aDogaW5oZXJpdDsgd2lkdGg6IGV4cHJlc3Npb24odGhpcy5wYXJlbnROb2RlLmN1cnJlbnRTdHlsZVtcXCd3aWR0aFxcJ10pOyBib3JkZXI6IHNvbGlkOyBib3JkZXItY29sb3I6ICNBOUJBREU7IGJvcmRlci1zdHlsZTogcmlkZ2U7IGRpc3BsYXk6IG5vbmU7IH0gLmVycm9yRGlzcGxheVJldHJpZXZlcnsgaGVpZ2h0OiA4cHg7IGJhY2tncm91bmQtY29sb3I6ICNmZjAwMDA7IGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAxMHB4OyB3aWR0aDogOHB4OyBwb3NpdGlvbjogYWJzb2x1dGU7IGJvdHRvbTogMHB4OyBsZWZ0OiAwcHg7IGRpc3BsYXk6IG5vbmU7IH0gLmVycm9yRGlzcGxheVNob3J0TWVzc2FnZXsgb3ZlcmZsb3cteDogaGlkZGVuOyBvdmVyZmxvdy15OiBoaWRkZW47IHdoaXRlLXNwYWNlOiBub3dyYXA7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAwcHg7IGxlZnQ6IDBweDsgd2lkdGg6IDk1JTsgbWFyZ2luLXRvcDogMjBweDsgbWFyZ2luLWxlZnQ6IDEwcHg7IG1hcmdpbi1ib3R0b206IDVweDsgfSAuZXJyb3JEaXNwbGF5WEJ1dHRvbiB7IHRleHQtZGVjb3JhdGlvbjogbm9uZTsgZm9udC1zaXplOiAxNXB4OyBtYXJnaW4tdG9wOiAycHg7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgcmlnaHQ6IDNweDsgdG9wOiAwcHg7IGNvbG9yOiAjNEQ2OEEzOyB9IC5lcnJvckRpc3BsYXlEZXRhaWxzQnV0dG9uIHsgbWFyZ2luLWxlZnQ6IDEwcHg7IG1hcmdpbi1yaWdodDogMTBweDsgcG9zaXRpb246IHJlbGF0aXZlOyB9IC5lcnJvckRpc3BsYXlEZXRhaWxzeyBwb3NpdGlvbjogZml4ZWQ7IHRvcDogMjUlOyBoZWlnaHQ6IDEwMHB4OyB3aWR0aDogNzUlOyB0ZXh0LWFsaWduOiBsZWZ0OyBib3JkZXI6IHNvbGlkOyBib3JkZXItY29sb3I6ICNBOUJBREU7IGJvcmRlci1zdHlsZTogcmlkZ2U7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyBkaXNwbGF5OiBub25lOyB9IC5lcnJvckRpc3BsYXlGdWxsTWVzc2FnZUFyZWEgeyBmb250LWZhbWlseTogSGVsdmV0aWNhLCBzYW5zLXNlcmlmOyBmb250LXNpemU6IC44MzNlbTsgY29sb3I6ICMzMjQ0NkI7IGhlaWdodDogODBweDsgd2lkdGg6IGluaGVyaXQ7IHdpZHRoOiBleHByZXNzaW9uKHRoaXMucGFyZW50Tm9kZS5jdXJyZW50U3R5bGVbXFwnd2lkdGhcXCddKTsgcG9zaXRpb246IGZpeGVkOyBtYXJnaW4tdG9wOiAxNXB4OyB9IC5lcnJvckRpc3BsYXlGdWxsTWVzc2FnZUxpc3QgeyBvdmVyZmxvdzogYXV0bzsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgaGVpZ2h0OiA4MHB4OyBtYXJnaW4tdG9wOiA1cHg7IH0gLmVycm9yRGlzcGxheU9wdGlvbnN7IGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7IGRpc3BsYXk6IGlubGluZTsgfSA8L3N0eWxlPicpKTtcbiIsIi8qKlxuICogQXR0clxuICogXG4gKiBDcmVhdGVzIGFuIGVuY2Fwc3VsYXRlZCwgY2hhaW5hYmxlIGF0dHJpYnV0ZSB0aGF0IGFyZSB2YWxpZGF0ZWQgYnkgXG4gKiB1c2VyLXNwZWNpZmllZCB2YWxpZGF0aW9uIGZ1bmN0aW9ucyBhbmQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIGFyYml0cmFyeVxuICogSmF2YVNjcmlwdCBvYmplY3QuIFRoZXkgY2FuIGFsc28gY2FsbCB1c2VyLXNwZWNpZmllZCBsaXN0ZW5lcnMgdXBvbiBiZWluZ1xuICogYWNjZXNzZWQgb3IgY2hhbmdlZC5cbiAqXG4gKiBKZXJtYWluZSBtb2RlbHMgaG9sZCBhbmQgbWFuaXB1bGF0ZSBBdHRyIChhbmQgQXR0ckxpc3QpIG9iamVjdHMgdW50aWwgdGhleVxuICogYXJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC5cbiAqL1xuXG4vKiFcbiAqXG4gKiBOb3RlcyBhbmQgVG9Eb3M6XG4gKiArIHdoYXQgYWJvdXQgaXNOb3RHcmVhdGVyVGhhbigpPywgaXNOb3RMZXNzVGhhbigpPyAgT3IsIGJldHRlciBzdGlsbDogYVxuICogICBnZW5lcmFsICdub3QnIG9wZXJhdG9yLCBhcyBpbiBqYXNtaW5lP1xuICpcbiAqICsgQXR0ciBzaG91bGQgYmUgZGVjb3VwbGVkIGZyb20gQXR0ckxpc3QsIHNlZSB0aGUgY2xvbmUoKSBtZXRob2RcbiAqXG4gKiArIFNlZSBpc3N1ZSAyNCBvbiBnaXRodWJcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG4gXG52YXIgQXR0ciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIEF0dHJMaXN0ID0gcmVxdWlyZSgnLi9hdHRyX2xpc3QuanMnKSxcbiAgICAgICAgVmFsaWRhdG9yID0gcmVxdWlyZSgnLi92YWxpZGF0b3IuanMnKTtcblxuICAgIHZhciB2YWxpZGF0b3JzID0gW10sXG4gICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICBlcnJvck1lc3NhZ2UgPSBcImludmFsaWQgc2V0dGVyIGNhbGwgZm9yIFwiICsgbmFtZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlT3JGdW5jdGlvbixcbiAgICAgICAgaSxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgYWRkVmFsaWRhdG9yLFxuICAgICAgICBpbW11dGFibGUgPSBmYWxzZSxcbiAgICAgICAgdmFsaWRhdG9yLFxuICAgICAgICBsaXN0ZW5lcnMgPSB7fTtcblxuICAgIC8vIGNoZWNrIGZvciBlcnJvcnMgd2l0aCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzXG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YobmFtZSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHI6IGNvbnN0cnVjdG9yIHJlcXVpcmVzIGEgbmFtZSBwYXJhbWV0ZXIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aGljaCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cblxuICAgIC8vIHNldCB1cCB0aGUgdmFsaWRhdG9yIHRoYXQgY29tYmluZXMgYWxsIHZhbGlkYXRvcnNcbiAgICB2YWxpZGF0b3IgPSBmdW5jdGlvbiAodGhpbmdCZWluZ1ZhbGlkYXRlZCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsaWRhdG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFsaWRhdG9yc1tpXSh0aGluZ0JlaW5nVmFsaWRhdGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gTU9ESUZJRVJTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoaXMgYXR0cmlidXRlIHdpdGggdGhlIGdpdmVuIHZhbGlkYXRvci4gVGhpcyBhbHNvIGFsbG93c1xuICAgICAqIHRoaXMubWVzc2FnZSB0byBiZSBvdmVycmlkZGVuIHRvIHNwZWNpZnkgdGhlIGVycm9yIG1lc3NhZ2Ugb25cbiAgICAgKiB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKlxuICAgICAqICAgICBhZ2UudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYWdlKSB7XG4gICAgICogICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcImFnZSBtdXN0IGJlIGJldHdlZW4gMTggYW5kIDk5LCBcIiArIGFnZSArXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBcIiBmYWlscy5cIjtcbiAgICAgKiAgICAgICAgIHJldHVybiBhZ2UgPj0gMTggJiYgYWdlIDw9IDk5O1xuICAgICAqICAgICB9KTtcbiAgICAgKlxuICAgICAqICAgICBuYW1lLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgKiAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nIGFuZCBjb250YWluIGF0IGxlYXN0XCIgK1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgXCIgMyBsZXR0ZXJzLCBcIiArIG5hbWUgKyBcIiBmYWlscy5cIjtcbiAgICAgKiAgICAgICAgIHJldHVybiB0eXBlb2YobmFtZSkgPT09IFwic3RyaW5nICYmIG5hbWUubGVuZ3RoID49IDM7XG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXR1cm5zIHRydWUgaWYgdGhlIGFyZ3VtZW50IHBhc3NlcyB2YWxpZGF0aW9uIFxuICAgICAqL1xuICAgIHRoaXMudmFsaWRhdGVzV2l0aCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh0eXBlb2YodikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChuZXcgVmFsaWRhdG9yKHYpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0cjogdmFsaWRhdG9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gYSBkZWZhdWx0IHZhbHVlIHRvIGFsbCBhdHRyaWJ1dGVzIG9mIHRoaXMgdHlwZS4gVGhlIGRlZmF1bHRcbiAgICAgKiB2YWx1ZSBtYXkgYmUgYW4gZXhwbGljaXQgdmFsdWUgb3Igb2JqZWN0LCBvciBpdCBtYXkgYmUgYSBmdW5jdGlvblxuICAgICAqIHRoYXQgcmV0dXJucyBhIGRlZmF1bHQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmFsdWV9IHRoZSBleHBsaWNpdCBkZWZhdWx0IHZhbHVlLCBvciBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiAgICAgICAgICAgICAgICByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0c1RvID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb24gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdGhpcyBhdHRyaWJ1dGUgcmVhZC1vbmx5LiBJZiBhIHNldHRlciBpcyBjYWxsZWQgb24gdGhpc1xuICAgICAqIGF0dHJpYnV0ZSwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICovXG4gICAgdGhpcy5pc1JlYWRPbmx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbW11dGFibGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aGlzIGF0dHJpYnV0ZSB3cml0YWJsZS4gTm90ZSB0aGF0IHRoaXMgaXMgdGhlIGRlZmF1bHQgZm9yIGFsbCBcbiAgICAgKiBhdHRyaWJ1dGVzLCBidXQgdGhpcyBtYXkgYmUgY2FsbGVkIGlmIGFuIGF0dHJpYnV0ZSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgKiByZWFkIG9ubHkgYW5kIHRoZW4gbmVlZHMgdG8gYmUgY2hhbmdlZCBiYWNrXG4gICAgICpcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKi9cbiAgICB0aGlzLmlzV3JpdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGltbXV0YWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBhIGxpc3RlbmVyIGZvciAnc2V0cycgb3IgJ2dldHMnIHRvIHRoaXMgYXR0cmlidXRlLiBJdCB0aHJvd3NcbiAgICAgKiBhbiBlcnJvciBpZiB0aGUgZXZlbnQgaXMgbm90IFwic2V0XCIgb3IgXCJnZXRcIiwgYW5kIGlmIGEgc2V0dGVyIGlzXG4gICAgICogYWxyZWFkeSBzZXQgdXAgZm9yIHRoZSBldmVudCwgaXQgb3ZlcnJpZGVzIGl0LlxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBTdHJpbmcgdGhhdCBjYW4gb25seSBiZSBcInNldFwiIG9yIFwiZ2V0XCJcbiAgICAgKiBAcGFyYW0ge2xpc3RlbmVyfSBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBvY2N1cnNcbiAgICAgKi9cbiAgICB0aGlzLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoZXZlbnQgIT09IFwic2V0XCIgJiYgZXZlbnQgIT09IFwiZ2V0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHI6IGZpcnN0IGFyZ3VtZW50IHRvIHRoZSAnb24nIG1ldGhvZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaG91bGQgYmUgJ3NldCcgb3IgJ2dldCdcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGxpc3RlbmVyKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyOiBzZWNvbmQgYXJndW1lbnQgdG8gdGhlICdvbicgbWV0aG9kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNob3VsZCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IGxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBFTkQgTU9ESUZJRVJTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEdFVFRFUlMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGlzIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNvbWJpbmVzIGFsbCBvZiB0aGUgdmFsaWRhdG9ycyBpbnRvXG4gICAgICogYSBzaW5nbGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgb3IgZmFsc2UuXG4gICAgICovXG4gICAgdGhpcy52YWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEVORCBHRVRURVJTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIFNZTlRBQ1RJQyBTVUdBUiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogQW4gYWxpYXMgZm9yIHRoaXMgb2JqZWN0LCBmb3IgcmVhZGFiaWxpdHkgd2hlbiBjYWxsaW5nIG11bHRpcGxlXG4gICAgICogbW9kaWZpZXJzXG4gICAgICpcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKi9cbiAgICB0aGlzLmFuZCA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbGlhcyBmb3IgdGhpcyBvYmplY3QsIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGVzOlxuICAgICAqL1xuICAgIHRoaXMud2hpY2ggPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWxpYXMgZm9yIGlzUmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmlzSW1tdXRhYmxlID0gdGhpcy5pc1JlYWRPbmx5O1xuXG4gICAgLyoqXG4gICAgICogQW4gYWxpYXMgZm9yIGlzV3JpdGFibGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTXV0YWJsZSA9IHRoaXMuaXNXcml0YWJsZTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEVORCBTWU5UQUNUSUMgU1VHQVIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIFVUSUxJVElFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgd2l0aCB0aGUgc2FtZSBtb2RpZmllcnMsIGRlZmF1bHRWYWx1ZSwgYW5kXG4gICAgICogdmFsaWRhdG9ycy4gVGhpcyBpcyB1c2VkIGluIEplcm1haW5lJ3MgYXBwcm9hY2ggdG8gaW5oZXJpdGFuY2UuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKi9cbiAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBzZXQgdGhlIHJlc3VsdCB0byB0aGUgZGVmYXVsdCBhdHRyaWJ1dGUgb3IgYXR0cmlidXRlIGxpc3RcbiAgICAgICAgLy8gVE9ETzogZmlndXJlIG91dCBob3cgdG8gbWFrZSB0aGlzIHdvcmsgd2l0aG91dCBleHBsaWNpdGx5XG4gICAgICAgIC8vICAgICAgIGtub3dpbmcgYWJvdXQgQXR0ckxpc3Qgc28gaXQgY2FuIGJlIGRlY291cGxlZCBmcm9tIHRoaXNcbiAgICAgICAgLy8gICAgICAgY29kZVxuICAgICAgICByZXN1bHQgPSB0aGlzIGluc3RhbmNlb2YgQXR0ckxpc3Q/bmV3IEF0dHJMaXN0KG5hbWUpOm5ldyBBdHRyKG5hbWUpO1xuXG4gICAgICAgIC8vIGFkZCB0aGlzIGF0dHJpYnV0ZXMgdmFsaWRhdG9ycyB0byB0aGUgbmV3IGF0dHJpYnV0ZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsaWRhdG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbGlkYXRlc1dpdGgodmFsaWRhdG9yc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdXAgdGhlIHNhbWUgZGVmYXVsdCBmb3IgdGhlIG5ldyBhdHRyaWJ1dGVcbiAgICAgICAgcmVzdWx0LmRlZmF1bHRzVG8oZGVmYXVsdFZhbHVlT3JGdW5jdGlvbik7XG5cbiAgICAgICAgLy8gaWYgdGhlIHRoaXMgYXR0ciBpcyBpbW11dGFibGUsIHRoZSBjbG9uZWQgYXR0ciBzaG91bGQgYWxzbyBiZVxuICAgICAgICAvLyBpbW11dGFibGVcbiAgICAgICAgaWYgKGltbXV0YWJsZSkge1xuICAgICAgICAgICAgcmVzdWx0LmlzSW1tdXRhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGF0dGFjaGVzIHRoZSBhdHRyaWJ1dGUgdG8gYSBjb25jcmV0ZSBvYmplY3QuIEl0IGFkZHMgdGhlXG4gICAgICogZ2V0dGVyL3NldHRlciBmdW5jdGlvbiB0byB0aGUgb2JqZWN0LCBhbmQgY2FwdHVyZXMgdGhlIGFjdHVhbFxuICAgICAqIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgaW4gYSBjbG9zdXJlLlxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdGluZyBnZXR0ZXIvc2V0dGVyIGNhbGxzIGFsbCB2YWxpZGF0b3JzIG9uIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlIGxpc3RlbmVyIG9uIHRoaXMgYXR0cmlidXRlLiBJdCBhbHNvXG4gICAgICogcmV0dXJucyB0aGUgb2JqZWN0IGl0c2VsZiBzbyB0aGF0IGF0dHJpYnV0ZSBzZXR0ZXJzIGNhbiBiZSBjaGFpbmVkLlxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29ian0gdGhlIG9iamVjdCB0byB3aGljaCB0aGlzIGF0dHJpYnV0ZSB3aWxsIGJlIGF0dGFjaGVkXG4gICAgICovXG4gICAgdGhpcy5hZGRUbyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgIGlmICghb2JqIHx8IHR5cGVvZihvYmopICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0cjogYWRkQXR0ciBtZXRob2QgcmVxdWlyZXMgYW4gb2JqZWN0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGF0dHJpYnV0ZSBnZXR0ZXIvc2V0dGVyIG1ldGhvZCB0aGF0IGdldHMgYWRkZGVkIHRvXG4gICAgICAgIC8vIHRoZSBvYmplY3RcbiAgICAgICAgb2JqW25hbWVdID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcHJlVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgICAgICAgICAgaWYgKGltbXV0YWJsZSAmJiBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3Qgc2V0IHRoZSBpbW11dGFibGUgcHJvcGVydHkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArIFwiIGFmdGVyIGl0IGhhcyBiZWVuIHNldFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF2YWxpZGF0b3IobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgb2xkVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgcHJlVmFsdWUgPSBhdHRyaWJ1dGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3Qgc2V0IHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgPSBuZXdWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBzZXQgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5zZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldC5jYWxsKG9iaiwgbmV3VmFsdWUsIHByZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBnZXQgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5nZXQuY2FsbChvYmosIGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cblxuICAgICAgICAvLyBhc3NpZ24gdGhlIGRlZmF1bHQgdmFsdWUsIGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIC8vIG9yIGFuIGV4cGxpY2l0IHZhbHVlXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IHR5cGVvZihkZWZhdWx0VmFsdWVPckZ1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJz9cbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb24oKTpcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb247XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgc2V0dGVyIHdpdGggdGhlIGRlZmF1bHRWYWx1ZSB1cG9uIGF0dGFjaGluZyBpdCB0byB0aGVcbiAgICAgICAgLy8gb2JqZWN0XG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWxpZGF0b3IoZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgICAgb2JqW25hbWVdKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXZhbGlkYXRvcihkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyOiBEZWZhdWx0IHZhbHVlIG9mIFwiICsgZGVmYXVsdFZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBkb2VzIG5vdCBwYXNzIHZhbGlkYXRpb24gZm9yIFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gRU5EIFVUSUxJVElFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gVkFMSURBVE9SIFJFTEFURUQgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvLyBhZGQgYSBzaW5nbGUgdmFsaWRhdG9yIG9iamVjdCB0byB0aGUgYXR0cmlidXRlXG4gICAgYWRkVmFsaWRhdG9yID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhhdFtuYW1lXSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvci5nZXRWYWxpZGF0b3IobmFtZSkocGFyYW0pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyB0aGUgVmFsaWRhdG9yIG9iamVjdCBjb250YWlucyBzZXZlcmFsIGRlZmF1bHQgdmFsaWRhdG9yc1xuICAgIC8vIHRoYXQgbmVlZCB0byBiZSBhdHRhY2hlZCB0byBhbGwgQXR0cnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgVmFsaWRhdG9yLnZhbGlkYXRvcnMoKS5sZW5ndGg7ICsraSkge1xuICAgICAgICBhZGRWYWxpZGF0b3IoVmFsaWRhdG9yLnZhbGlkYXRvcnMoKVtpXSk7XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gRU5EIFZBTElEQVRPUiBSRUxBVEVEIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHI7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIEF0dHIgPSByZXF1aXJlKCcuL2F0dHIuanMnKTtcblxudmFyIEF0dHJMaXN0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgbGlzdGVuZXJzID0ge307XG5cblxuICAgIC8vdGhpcyBpcyB3aGVyZSB0aGUgaW5oZXJpdGFuY2UgaGFwcGVucyBub3dcbiAgICBBdHRyLmNhbGwodGhpcywgbmFtZSk7XG5cbiAgICB2YXIgZGVsZWdhdGUgPSBmdW5jdGlvbiAob2JqLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpbZnVuY10uYXBwbHkob2JqLCBhcmd1bWVudHMpOyB9O1xuICAgIH07XG5cbiAgICAvL3N5bnRhY3RpYyBzdWdhciB0byBrZWVwIHRoaW5ncyBncmFtbWF0aWNhbGx5IGNvcnJlY3RcbiAgICB0aGlzLnZhbGlkYXRlV2l0aCA9IHRoaXMudmFsaWRhdGVzV2l0aDtcblxuICAgIC8vZGlzYWJsZSBkZWZhdWx0c1RvIGFuZCBpc0ltbXV0YWJsZSB1bnRpbCB3ZSBmaWd1cmUgb3V0IGhvdyB0byBtYWtlIGl0IG1ha2Ugc2Vuc2VcbiAgICB0aGlzLmRlZmF1bHRzVG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vbm8gb3BcbiAgICB9O1xuXG4gICAgdGhpcy5pc0ltbXV0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9ubyBvcFxuICAgIH07XG5cbiAgICB0aGlzLmlzTXV0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9ubyBvcFxuICAgIH07XG5cbiAgICB0aGlzLmVhY2hPZldoaWNoID0gdGhpcztcblxuICAgIHRoaXMub24gPSBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChldmVudCAhPT0gXCJhZGRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ckxpc3Q6ICdvbicgb25seSByZXNwb25kcyB0byAnYWRkJyBldmVudFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YobGlzdGVuZXIpICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHJMaXN0OiAnb24nIHJlcXVpcmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXI7XG4gICAgfTtcblxuXG4gICAgdGhpcy5hZGRUbyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIHByb3AsXG4gICAgICAgICAgICBhcnIgPSBbXSxcbiAgICAgICAgICAgIGFjdHVhbExpc3QgPSB7fTtcbiAgICAgICAgaWYoIW9iaiB8fCB0eXBlb2Yob2JqKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHJMaXN0OiBhZGRUbyBtZXRob2QgcmVxdWlyZXMgYW4gb2JqZWN0IHBhcmFtZXRlclwiKTsgICAgICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3R1YWxMaXN0LnBvcCA9IGRlbGVnYXRlKGFyciwgXCJwb3BcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGFjdHVhbExpc3QuYWRkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHRoYXQudmFsaWRhdG9yKCkpKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzLmFkZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xpc3RlbmVycy5hZGQuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmFkZC5jYWxsKG9iaiwgaXRlbSwgYWN0dWFsTGlzdC5zaXplKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGF0LmVycm9yTWVzc2FnZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhY3R1YWxMaXN0LnJlcGxhY2UgPSBmdW5jdGlvbiAoaW5kZXgsIG9iaikge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mKGluZGV4KSAhPT0gJ251bWJlcicpIHx8IChwYXJzZUludChpbmRleCwgMTApICE9PSBpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ckxpc3Q6IHJlcGxhY2UgbWV0aG9kIHJlcXVpcmVzIGluZGV4IHBhcmFtZXRlciB0byBiZSBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5zaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ckxpc3Q6IHJlcGxhY2UgbWV0aG9kIGluZGV4IHBhcmFtZXRlciBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHRoYXQudmFsaWRhdG9yKCkpKG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoYXQuZXJyb3JNZXNzYWdlKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFycltpbmRleF0gPSBvYmo7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhY3R1YWxMaXN0LmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnNpemUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyTGlzdDogSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycltpbmRleF07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL3RvIGtlZXAgdGhpbmdzIG1vcmUgamF2YS15XG4gICAgICAgICAgICBhY3R1YWxMaXN0LmdldCA9IGFjdHVhbExpc3QuYXQ7XG5cbiAgICAgICAgICAgIGFjdHVhbExpc3Quc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFjdHVhbExpc3QudG9KU09OID0gZnVuY3Rpb24gKEpTT05yZXBzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBcbiAgICAgICAgICAgICAgICAgICAgaSwgajtcblxuICAgICAgICAgICAgICAgIC8vY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBjdXJyZW50IGxpc3QgaXMgbm90IGluIEpTT05yZXBzXG4gICAgICAgICAgICAgICAgaWYgKEpTT05yZXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDtpIDwgSlNPTnJlcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChKU09OcmVwc1tpXS5vYmplY3QgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OcmVwc1tpXS5KU09OcmVwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS50b0pTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycltpXS50b0pTT04oSlNPTnJlcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycltpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9ialtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsTGlzdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLy8gLy90aGlzIG5lZWRzIHRvIHN0YXkgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGluc3RhbmNlb2Zcbi8vIC8vYnV0IG5vdGUgd2Ugb3ZlcnJpZGUgYWxsIG9mIHRoZSBtZXRob2RzIHZpYSBkZWxlZ2F0aW9uXG4vLyAvL3NvIGl0J3Mgbm90IGRvaW5nIGFueXRoaW5nIGV4Y2VwdCBmb3IgbWFraW5nIGFuIEF0dHJMaXN0XG4vLyAvL2FuIGluc3RhbmNlIG9mIEF0dHJcbi8vQXR0ckxpc3QucHJvdG90eXBlID0gbmV3IEF0dHIobmFtZSk7XG5BdHRyTGlzdC5wcm90b3R5cGUgPSBuZXcgQXR0cihcIj8/P1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyTGlzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIG1ldGhvZCkge1xuICAgIGlmICghbmFtZSB8fCB0eXBlb2YobmFtZSkgIT09IFwic3RyaW5nXCIpIHsgXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZDogY29uc3RydWN0b3IgcmVxdWlyZXMgYSBuYW1lIHBhcmFtZXRlciB3aGljaCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH0gZWxzZSBpZiAoIW1ldGhvZCB8fCB0eXBlb2YobWV0aG9kKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZDogc2Vjb25kIHBhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuYWRkVG8gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghb2JqIHx8IHR5cGVvZihvYmopICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kOiBhZGRUbyBtZXRob2QgcmVxdWlyZXMgYW4gb2JqZWN0IHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgb2JqW25hbWVdID0gbWV0aG9kO1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1ldGhvZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKCcuLi91dGlsL2luZGV4X29mLmpzJyk7XG5cbnZhciBtb2RlbHMgPSB7fTtcblxuLyoqXG4gKiB0aGlzIGZ1bmN0aW9uIHJldHVybiBhIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCBhIG5hbWVcbiAqL1xudmFyIGdldE1vZGVsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkplcm1haW5lOiBhcmd1bWVudCB0byBnZXRNb2RlbCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cblxuICAgIGlmIChtb2RlbHNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtb2RlbCBieSB0aGUgbmFtZSBvZiBcIiArIG5hbWUgKyBcIiBmb3VuZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbW9kZWxzW25hbWVdO1xuICAgIH1cbn07XG5cbi8qKlxuICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBtb2RlbCBuYW1lcyBzdG9yZWQgYnlcbiAqIGplcm1haW5lXG4gKi9cbnZhciBnZXRNb2RlbHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBtb2RlbCxcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgXG4gICAgZm9yIChtb2RlbCBpbiBtb2RlbHMpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kZWwpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtb2RlbCBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBNb2RlbCA9IGZ1bmN0aW9uIChzcGVjaWZpY2F0aW9uKSB7XG4gICAgdmFyIG1ldGhvZHMgPSB7fSxcbiAgICAgICAgYXR0cmlidXRlcyA9IHt9LFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBtb2RlbE5hbWUsXG4gICAgICAgIG1vZGlmaWVkID0gdHJ1ZSxcbiAgICAgICAgcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MgPSBbXSxcbiAgICAgICAgb3B0aW9uYWxDb25zdHJ1Y3RvckFyZ3MgPSBbXSxcbiAgICAgICAgcGFyZW50cyA9IFtdLFxuICAgICAgICBNZXRob2QgPSByZXF1aXJlKCcuL21ldGhvZC5qcycpLFxuICAgICAgICBBdHRyID0gcmVxdWlyZSgnLi9hdHRyLmpzJyksXG4gICAgICAgIEF0dHJMaXN0ID0gcmVxdWlyZSgnLi9hdHRyX2xpc3QuanMnKSxcbiAgICAgICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudF9lbWl0dGVyLmpzJyksXG4gICAgICAgIHByb3BlcnR5LFxuICAgICAgICBsaXN0UHJvcGVydGllcyxcbiAgICAgICAgdXBkYXRlQ29uc3RydWN0b3IsXG4gICAgICAgIGlzSW1tdXRhYmxlLFxuICAgICAgICBpbml0aWFsaXplciA9IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBtb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIC8vdmFsaWRhdGUgdGhlIG1vZGVsIGlmIGl0IGhhcyBiZWVuIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgbW9kZWwudmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodHlwZW9mKHNwZWNpZmljYXRpb24pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtb2RlbE5hbWUgPSBzcGVjaWZpY2F0aW9uO1xuICAgICAgICAgICAgc3BlY2lmaWNhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBtb2RlbE5hbWUgPSBzcGVjaWZpY2F0aW9uO1xuICAgICAgICBzcGVjaWZpY2F0aW9uID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV07XG4gICAgfVxuXG4gICAgLy9oYW5kbGUgc3BlY2lmaWNhdGlvbiBmdW5jdGlvblxuICAgIGlmIChzcGVjaWZpY2F0aW9uICYmIHR5cGVvZihzcGVjaWZpY2F0aW9uKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG1vZGVsID0gbmV3IE1vZGVsKG1vZGVsTmFtZSk7XG4gICAgICAgIHNwZWNpZmljYXRpb24uY2FsbChtb2RlbCk7XG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9IGVsc2UgaWYgKHNwZWNpZmljYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWw6IHNwZWNpZmljYXRpb24gcGFyYW1ldGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICAvL2hhbmRsZSBtb2RlbCBuYW1lXG4gICAgaWYgKG1vZGVsTmFtZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZihtb2RlbE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1vZGVsc1ttb2RlbE5hbWVdID0gbW9kZWw7XG4gICAgfSBlbHNlIGlmIChtb2RlbE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbDogbW9kZWwgbmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cblxuICAgIFxuICAgIC8qKioqKioqKioqIEJFR0lOIFBSSVZBVEUgTUVUSE9EUyAqKioqKioqKioqKioqKioqL1xuICAgIC8qIHByaXZhdGUgbWV0aG9kIHRoYXQgYWJzdHJhY3RzIGhhc0EvaGFzTWFueSAqL1xuICAgIHZhciBoYXNBUHJvcGVydHkgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSkge1xuICAgICAgICB2YXIgUHJvcGVydHksXG4gICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlO1xuXG4gICAgICAgIC8vUHJvcGVydHkgaXMgb25lIG9mIEF0dHIgb3IgQXR0ckxpc3RcbiAgICAgICAgUHJvcGVydHkgPSB0eXBlPT09XCJBdHRyXCI/QXR0cjpBdHRyTGlzdDtcblxuICAgICAgICAvL21ldGhvZE5hbWUgaXMgZWl0aGVyIGhhc0Egb3IgaGFzTWFueVxuICAgICAgICBtZXRob2ROYW1lID0gdHlwZT09PVwiQXR0clwiP1wiaGFzQVwiOlwiaGFzTWFueVwiO1xuXG4gICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2YobmFtZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgPSBuZXcgUHJvcGVydHkobmFtZSk7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0gYXR0cmlidXRlO1xuICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsOiBcIiArIG1ldGhvZE5hbWUgKyBcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKiBwcml2YXRlIG1ldGhvZCB0aGF0IGFic3RyYWN0cyBhdHRyaWJ1dGUvbWV0aG9kICovXG4gICAgcHJvcGVydHkgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGlmICh0eXBlb2YobmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsOiBleHBlY3RlZCBzdHJpbmcgYXJndW1lbnQgdG8gXCIgKyB0eXBlICsgXCIgbWV0aG9kLCBidXQgcmVjaWV2ZWQgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHR5cGU9PT1cImF0dHJpYnV0ZVwiID8gYXR0cmlidXRlc1tuYW1lXSA6IG1ldGhvZHNbbmFtZV07XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbDogXCIgKyB0eXBlICsgXCIgXCIgKyBuYW1lICArIFwiIGRvZXMgbm90IGV4aXN0IVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qIHByaXZhdGUgbWV0aG9kIHRoYXQgYWJzdHJhY3RzIGF0dHJpYnV0ZXMvbWV0aG9kcyAqL1xuICAgIGxpc3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsaXN0ID0gW10sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gdHlwZT09PVwiYXR0cmlidXRlc1wiP2F0dHJpYnV0ZXM6bWV0aG9kcztcblxuICAgICAgICBmb3IgKGkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgLyogcHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgdGhlIGNvbnN0cnVjdG9yICovXG4gICAgdXBkYXRlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGosXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVMaXN0ID0gbW9kZWwuYXR0cmlidXRlcygpLCBcbiAgICAgICAgICAgICAgICBtZXRob2RMaXN0ID0gbW9kZWwubWV0aG9kcygpLCBcbiAgICAgICAgICAgICAgICBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpLFxuICAgICAgICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgICAgICAgYXR0ckNoYW5nZUxpc3RlbmVycyA9IHt9LFxuICAgICAgICAgICAgICAgIGNoYW5nZUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgYWRkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIG1vZGVsKSkge1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvL2JhZCBmb3JtLCBidXQgaG9wZWZ1bGx5IHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgICAgICAvKmpzaGludCBuZXdjYXA6ZmFsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtb2RlbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vYmFkIGZvcm0sIGJ1dCBob3BlZnVsbHkgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgICAgIC8qanNoaW50IG5ld2NhcDpmYWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1vZGVsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiTW9kZWw6IGluc3RhbmNlcyBtdXN0IGJlIGNyZWF0ZWQgdXNpbmcgdGhlIG5ldyBvcGVyYXRvclwiKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLyBQVUJMSUMgQVBJIEZPUiBBTEwgSU5TVEFOQ0VTIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBtZXRob2QgYXNzb2NpYXRlZCB3aXRoIHVuaXQgdGVzdFxuICAgICAgICAgICAgLy8gaXQoXCJzaG91bGQgbm90IGluY3JlbWVudCB0aGUgbGlzdGVuZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGFzdCBvYmplY3QgY3JlYXRlZFwiXG4gICAgICAgICAgICAvLyBpdCBoYXMgYmVlbiByZW1vdmVkIG5vdyB0aGF0IHRoZSBidWcgaGFzIGJlZW4gZml4ZWRcbiAgICAgICAgICAgIC8qdGhpcy5hdHRyQ2hhbmdlTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHJldHVybiBhdHRyQ2hhbmdlTGlzdGVuZXJzO1xuICAgICAgICAgICAgIH07Ki9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBFdmVudEVtaXR0ZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdyYXBwZXIgbWV0aG9kcyBhZGRlZCB0byB0aGUgaW50ZXJuYWwgRXZlbnRFbWl0dGVyIG9iamVjdFxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlSmVybWFpbmVDaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihhdHRyTmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ck5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihvYmopICE9PSBcIm9iamVjdFwiIHx8IG9iai50b0pTT04gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmVtaXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmogbXVzdCBiZSBhIGplcm1haW5lIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmouZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKFwiY2hhbmdlXCIsIGF0dHJDaGFuZ2VMaXN0ZW5lcnNbYXR0ck5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIoKS5hZGRKZXJtYWluZUNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGF0dHJOYW1lLCBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGF0dHJOYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRyTmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLnRvSlNPTiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZW1pdHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iaiBtdXN0IGJlIGEgamVybWFpbmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyQ2hhbmdlTGlzdGVuZXJzW2F0dHJOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyQ2hhbmdlTGlzdGVuZXJzW2F0dHJOYW1lXSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoICYmIGVtaXQgPT09IHRydWU7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhLnB1c2goZGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldLm9yaWdpbiA9PT0gdGhhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGEucHVzaCh7a2V5OmF0dHJOYW1lLCBvcmlnaW46dGhhdH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmVtaXQoXCJjaGFuZ2VcIiwgbmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9iai5lbWl0dGVyKCkub24oXCJjaGFuZ2VcIiwgYXR0ckNoYW5nZUxpc3RlbmVyc1thdHRyTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3IgdGhpcyBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm9uID0gdGhpcy5lbWl0dGVyKCkub247XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW1pdHMgYW4gZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbWl0ID0gdGhpcy5lbWl0dGVyKCkuZW1pdDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50b0pTT04gPSBmdW5jdGlvbiAoSlNPTnJlcHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGksIGosXG4gICAgICAgICAgICAgICAgICAgIHRoaXNKU09OcmVwID0ge30sXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUpTT05yZXA7XG5cbiAgICAgICAgICAgICAgICBpZiAoSlNPTnJlcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBjYWxsXG4gICAgICAgICAgICAgICAgICAgIEpTT05yZXBzID0gW107XG4gICAgICAgICAgICAgICAgICAgIEpTT05yZXBzLnB1c2goe29iamVjdDp0aGlzLCBKU09OcmVwOnRoaXNKU09OcmVwfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoSlNPTnJlcHMpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIGNvbmRpdGlvbiBcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5zdGFuY2U6IHRvSlNPTiBzaG91bGQgbm90IHRha2UgYSBwYXJhbWV0ZXIgKHVubGVzcyBjYWxsZWQgcmVjdXJzaXZlbHkpXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdCwgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBKU09OcmVwcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEpTT05yZXBzW2ldLm9iamVjdCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNKU09OcmVwID0gSlNPTnJlcHNbaV0uSlNPTnJlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJ1dGVMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUpTT05yZXAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9IHRoaXNbYXR0cmlidXRlTGlzdFtpXV0oKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgdGhlIGF0dHJpYnV0ZSwgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBKU09OcmVwcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEpTT05yZXBzW2pdLm9iamVjdCA9PT0gYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVKU09OcmVwID0gSlNPTnJlcHNbal0uSlNPTnJlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGF0dHJpYnV0ZVZhbHVlICE9PSBudWxsICYmIGF0dHJpYnV0ZVZhbHVlLnRvSlNPTiAhPT0gdW5kZWZpbmVkICYmIGF0dHJpYnV0ZUpTT05yZXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBlbnRyeSBmb3IgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSlNPTnJlcCA9IChhdHRyaWJ1dGVzW2F0dHJpYnV0ZUxpc3RbaV1dIGluc3RhbmNlb2YgQXR0ckxpc3QpP1tdOnt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTnJlcHMucHVzaCh7b2JqZWN0OmF0dHJpYnV0ZVZhbHVlLCBKU09OcmVwOmF0dHJpYnV0ZUpTT05yZXB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT05yZXBzW0pTT05yZXBzLmxlbmd0aC0xXS5KU09OcmVwID0gYXR0cmlidXRlVmFsdWUudG9KU09OKEpTT05yZXBzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbGwgb3V0IHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIGZvciB0aGlzIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyaWJ1dGVKU09OcmVwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzSlNPTnJlcFthdHRyaWJ1dGVMaXN0W2ldXSA9IGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0pTT05yZXBbYXR0cmlidXRlTGlzdFtpXV0gPSBhdHRyaWJ1dGVKU09OcmVwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzSlNPTnJlcDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGluc3RhbmNlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gKHBhdHRlcm4gIT09IHVuZGVmaW5lZCk/cGF0dGVybjpmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiSmVybWFpbmUgTW9kZWwgSW5zdGFuY2VcIjtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8gRU5EIFBVQkxJQyBBUEkgRk9SIEFMTCBJTlNUQU5DRVMgLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBpcyBhIHByaXZhdGUgbWV0aG9kIHRoYXQgc2V0cyB1cCBoYW5kbGluZyBmb3IgdGhlIHNldHRlclxuICAgICAgICAgICAgICogSXQgYXR0YWNoZXMgYSBjaGFuZ2UgbGlzdGVuZXIgb24gbmV3IG9iamVjdHNcbiAgICAgICAgICAgICAqIGFuZCBpdCByZW1vdmVzIHRoZSBjaGFuZ2UgbGlzdGVuZXIgZnJvbSBvbGQgb2JqZWN0c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShhdHRyIGluc3RhbmNlb2YgQXR0ckxpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2hlbiBzZXQgaGFuZGxlciBpcyBjYWxsZWQsIHRoaXMgc2hvdWxkIGJlIHRoZSBjdXJyZW50IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBhdHRyLm9uKFwic2V0XCIsIGZ1bmN0aW9uIChuZXdWYWx1ZSwgcHJlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHByZVZhbHVlIGlzIGEgbW9kZWwgaW5zdGFuY2UsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcmVWYWx1ZSAhPT0gbnVsbCAmJiBwcmVWYWx1ZS5vbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlVmFsdWUudG9KU09OICE9PSB1bmRlZmluZWQgJiYgcHJlVmFsdWUuZW1pdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugbm93IGFzc3VtZSBwcmVWYWx1ZSBpcyBhIG1vZGVsIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FuaXR5IGNoZWNrIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlVmFsdWUuZW1pdHRlcigpLmxpc3RlbmVycyhcImNoYW5nZVwiKS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByZVZhbHVlIHNob3VsZCBhbHdheXMgaGF2ZSBhIGxpc3RlbmVyIGRlZmluZWQgaWYgaXQgaXMgYSBtb2RlbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlSmVybWFpbmVDaGFuZ2VMaXN0ZW5lcihhdHRyLm5hbWUoKSwgcHJlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBuZXdWYWx1ZSBpcyBhIG1vZGVsIGluc3RhbmNlLCB3ZSBuZWVkIHRvIGF0dGFjaCBhIGxpc3RlbmVyIHRvIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBuZXdWYWx1ZSAhPT0gbnVsbCAmJiBuZXdWYWx1ZS5vbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUudG9KU09OICE9PSB1bmRlZmluZWQgJiYgbmV3VmFsdWUuZW1pdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugbm93IGFzc3VtZSBuZXdWYWx1ZSBpcyBhIG1vZGVsIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXR0YWNoIGEgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIoKS5hZGRKZXJtYWluZUNoYW5nZUxpc3RlbmVyKGF0dHIubmFtZSgpLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmFsbHkgZW1pdCB0aGF0IGEgY2hhbmdlIGhhcyBoYXBwZW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIFt7a2V5OmF0dHIubmFtZSgpLCB2YWx1ZTpuZXdWYWx1ZSwgb3JpZ2luOnRoaXN9XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIub24oXCJhZGRcIiwgZnVuY3Rpb24gKG5ld1ZhbHVlLCBuZXdTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgW3thY3Rpb246XCJhZGRcIiwga2V5OmF0dHIubmFtZSgpLCB2YWx1ZTpuZXdWYWx1ZSwgb3JpZ2luOnRoaXN9XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vc2V0IHVwIGV2ZW50IGhhbmRsaW5nIGZvciBzdWIgb2JqZWN0c1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnV0ZUxpc3QubGVuZ3RoOyAgKytpKSB7XG4gICAgICAgICAgICAgICAgYXR0ciA9IG1vZGVsLmF0dHJpYnV0ZShhdHRyaWJ1dGVMaXN0W2ldKTtcblxuICAgICAgICAgICAgICAgIC8vIHRlbXBvcmFyaWx5IG5vdCBhZGRpbmcgaGFuZGxlcnMgdG8gYXR0ciBsaXN0c1xuICAgICAgICAgICAgICAgIC8vIHVudGlsIHdlIGdldCB0aGUgYnVncyBzb3J0ZWQgb3V0XG4gICAgICAgICAgICAgICAgLy8gc2VlIG1vZGVsIHRlc3QgXCJzaG91bGQgbm90IGFkZCBjaGFuZ2UgbGlzdGVuZXJzIHRvIGF0dHIgbGlzdFwiXG4gICAgICAgICAgICAgICAgLy9pZiAoIShhdHRyIGluc3RhbmNlb2YgQXR0ckxpc3QpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlSGFuZGxlci5jYWxsKHRoaXMsIGF0dHIpO1xuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGFkZCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgYW5kIHRoZSBtZXRob2RzIHRvIHRoZSBvYmplY3RcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJ1dGVMaXN0Lmxlbmd0aCArIG1ldGhvZExpc3QubGVuZ3RoOyArK2kpICB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBhdHRyaWJ1dGVMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBvYmplY3QgaXMgaW1tdXRhYmxlLCBhbGwgYXR0cmlidXRlcyBzaG91bGQgYmUgaW1tdXRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ltbXV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXR0cmlidXRlKGF0dHJpYnV0ZUxpc3RbaV0pLmlzSW1tdXRhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXR0cmlidXRlKGF0dHJpYnV0ZUxpc3RbaV0pLmFkZFRvKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLm1ldGhvZChtZXRob2RMaXN0W2ktYXR0cmlidXRlTGlzdC5sZW5ndGhdKS5hZGRUbyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJ1aWxkIHRoZSBvYmplY3QgdXNpbmcgdGhlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICAgICAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IHJlcXVpcmVkQ29uc3RydWN0b3JBcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0cnVjdCBhbmQgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJDb25zdHJ1Y3RvciByZXF1aXJlcyBcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciArPSByZXF1aXJlZENvbnN0cnVjdG9yQXJnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciArPSBpPT09cmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MubGVuZ3RoLTE/XCJcIjpcIiwgXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyICs9IFwiIHRvIGJlIHNwZWNpZmllZFwiO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGlmIChhcmd1bWVudHMubGVuZ3RoID4gcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MubGVuZ3RoICsgb3B0aW9uYWxDb25zdHJ1Y3RvckFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvbyBtYW55IGFyZ3VtZW50cyB0byBjb25zdHJ1Y3Rvci4gRXhwZWN0ZWQgXCIgKyByZXF1aXJlZENvbnN0cnVjdG9yQXJncy5sZW5ndGggKyBcIiByZXF1aXJlZCBhcmd1bWVudHMgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsQ29uc3RydWN0b3JBcmdzLmxlbmd0aCArIFwiIG9wdGlvbmFsIGFyZ3VtZW50c1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSA9IGkgPCByZXF1aXJlZENvbnN0cnVjdG9yQXJncy5sZW5ndGg/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3NbaV06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxDb25zdHJ1Y3RvckFyZ3NbaS1yZXF1aXJlZENvbnN0cnVjdG9yQXJncy5sZW5ndGhdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuYXR0cmlidXRlKGF0dHJpYnV0ZSkgaW5zdGFuY2VvZiBBdHRyTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIHRoYXQgYXJndW1lbnRzW2ldIGlzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHNbaV0pICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWw6IENvbnN0cnVjdG9yIHJlcXVpcmVzICduYW1lcycgYXR0cmlidXRlIHRvIGJlIHNldCB3aXRoIGFuIEFycmF5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaXRlcmF0ZSBvdmVyIHRoZSBhcnJheSBhZGRpbmcgdGhlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcmd1bWVudHNbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbYXR0cmlidXRlXSgpLmFkZChhcmd1bWVudHNbaV1bal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dvIGFoZWFkIGFuZCBzZXQgaXQgbGlrZSBub3JtYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2F0dHJpYnV0ZV0oYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmluYWxseSwgY2FsbCB0aGUgaW5pdGlhbGl6ZXJcbiAgICAgICAgICAgIGluaXRpYWxpemVyLmNhbGwodGhpcyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKioqKioqKioqKiogRU5EIFBSSVZBVEUgTUVUSE9EUyAqKioqKioqKioqKioqKi9cblxuXG4gICAgLyoqKioqKioqKioqIEJFR0lOIFBVQkxJQyBBUEkgKioqKioqKioqKioqKioqKiovXG4gICAgbW9kZWwuaGFzQSA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIHJldHVybiBoYXNBUHJvcGVydHkoXCJBdHRyXCIsIGF0dHIpO1xuICAgIH07XG4gICAgXG4gICAgbW9kZWwuaGFzQW4gPSBtb2RlbC5oYXNBO1xuICAgIG1vZGVsLmhhc1NvbWUgPSBtb2RlbC5oYXNBO1xuICAgIFxuICAgIG1vZGVsLmhhc01hbnkgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIGhhc0FQcm9wZXJ0eShcIkF0dHJMaXN0XCIsIGF0dHJzKTtcbiAgICB9O1xuXG4gICAgbW9kZWwuaXNBID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBwYXJlbnRNZXRob2RzLFxuICAgICAgICAgICAgaXNBTW9kZWw7XG5cbiAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vY2hlY2tzIHRvIG1ha2Ugc3VyZSBhIHBvdGVudGlhbE1vZGVsIGhhcyBhbGwgYXR0cmlidXRlcyBvZiBhIG1vZGVsXG4gICAgICAgIGlzQU1vZGVsID0gZnVuY3Rpb24gKHBvdGVudGlhbE1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBNID0gbmV3IE1vZGVsKCk7XG4gICAgICAgICAgICBmb3IgKGkgaW4gTSkge1xuICAgICAgICAgICAgICAgIGlmIChNLmhhc093blByb3BlcnR5KGkpICYmIHR5cGVvZihwb3RlbnRpYWxNb2RlbFtpXSkgIT09IHR5cGVvZihNW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9jb25maXJtIHBhcmVudCBpcyBhIG1vZGVsIHZpYSBkdWNrLXR5cGluZ1xuICAgICAgICBpZiAodHlwZW9mIChwYXJlbnQpICE9PSBcImZ1bmN0aW9uXCIgfHwgIWlzQU1vZGVsKHBhcmVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsOiBwYXJhbWV0ZXIgc2VudCB0byBpc0EgZnVuY3Rpb24gbXVzdCBiZSBhIE1vZGVsXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9vbmx5IGFsbG93IHNpbmdsZSBpbmhlcml0YW5jZSBmb3Igbm93XG4gICAgICAgIGlmIChwYXJlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbDogTW9kZWwgb25seSBzdXBwb3J0cyBzaW5nbGUgaW5oZXJpdGFuY2UgYXQgdGhpcyB0aW1lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9hZGQgYXR0cmlidXRlcyBhbmQgbWV0aG9kcyB0byBjdXJyZW50IG1vZGVsXG4gICAgICAgIHBhcmVudEF0dHJpYnV0ZXMgPSBwYXJlbnRzWzBdLmF0dHJpYnV0ZXMoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmVudEF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzW3BhcmVudEF0dHJpYnV0ZXNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW3BhcmVudEF0dHJpYnV0ZXNbaV1dID0gcGFyZW50c1swXS5hdHRyaWJ1dGUocGFyZW50QXR0cmlidXRlc1tpXSkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAvL3N1YmNsYXNzIGF0dHJpYnV0ZXMgYXJlIG11dGFibGUgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbcGFyZW50QXR0cmlidXRlc1tpXV0uaXNNdXRhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRNZXRob2RzID0gcGFyZW50c1swXS5tZXRob2RzKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJlbnRNZXRob2RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kc1twYXJlbnRNZXRob2RzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kc1twYXJlbnRNZXRob2RzW2ldXSA9IHBhcmVudHNbMF0ubWV0aG9kKHBhcmVudE1ldGhvZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICAgICAgICAgICAgXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1vZGVsLnByb3RvdHlwZSA9IG5ldyBwYXJlbnRzW2ldKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kZWwuaXNBbiA9IG1vZGVsLmlzQTtcblxuICAgIG1vZGVsLnBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudHNbMF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbW9kZWwuYXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5KFwiYXR0cmlidXRlXCIsIGF0dHIpO1xuICAgIH07XG5cbiAgICBtb2RlbC5hdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGlzdFByb3BlcnRpZXMoXCJhdHRyaWJ1dGVzXCIpO1xuICAgIH07XG5cbiAgICBtb2RlbC5tZXRob2QgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkoXCJtZXRob2RcIiwgbSk7XG4gICAgfTtcbiAgICBcbiAgICBtb2RlbC5tZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGlzdFByb3BlcnRpZXMoXCJtZXRob2RzXCIpO1xuICAgIH07XG5cbiAgICBtb2RlbC5pc0J1aWx0V2l0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbmFsUGFyYW1GbGFnID0gZmFsc2UsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MgPSBbXTtcbiAgICAgICAgb3B0aW9uYWxDb25zdHJ1Y3RvckFyZ3MgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGFyZ3VtZW50c1tpXSkgPT09IFwic3RyaW5nXCIgJiYgYXJndW1lbnRzW2ldLmNoYXJBdCgwKSAhPT0gJyUnKSB7XG4gICAgICAgICAgICAgICAgLy9pbiByZXF1aXJlZCBwYXJtc1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbFBhcmFtRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAvL3Rocm93IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsOiBpc0J1aWx0V2l0aCByZXF1aXJlcyBwYXJhbWV0ZXJzIHByZWNlZGVkIHdpdGggYSAlIHRvIGJlIHRoZSBmaW5hbCBwYXJhbWV0ZXJzIGJlZm9yZSB0aGUgb3B0aW9uYWwgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pbnNlcnQgaW50byByZXF1aXJlZCBhcnJheVxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZENvbnN0cnVjdG9yQXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZihhcmd1bWVudHNbaV0pID09PSBcInN0cmluZ1wiICYmIGFyZ3VtZW50c1tpXS5jaGFyQXQoMCkgPT09ICclJykge1xuICAgICAgICAgICAgICAgIC8vaW4gb3B0aW9uYWwgcGFybXNcbiAgICAgICAgICAgICAgICBvcHRpb25hbFBhcmFtRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy9pbnNlcnQgaW50byBvcHRpb25hbCBhcnJheVxuICAgICAgICAgICAgICAgIG9wdGlvbmFsQ29uc3RydWN0b3JBcmdzLnB1c2goYXJndW1lbnRzW2ldLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YoYXJndW1lbnRzW2ldKSA9PT0gXCJmdW5jdGlvblwiICYmIGkgPT09IGFyZ3VtZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgLy9pbml0IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZXIgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsOiBpc0J1aWx0V2l0aCBwYXJhbWV0ZXJzIG11c3QgYmUgc3RyaW5ncyBleGNlcHQgZm9yIGEgZnVuY3Rpb24gYXMgdGhlIG9wdGlvbmFsIGZpbmFsIHBhcmFtZXRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgbW9kZWwuaXNJbW11dGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzSW1tdXRhYmxlID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgbW9kZWwubG9va3NMaWtlID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICBwYXR0ZXJuID0gcDtcbiAgICB9O1xuXG4gICAgbW9kZWwucmVzcG9uZHNUbyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBtZXRob2RCb2R5KSB7XG4gICAgICAgIHZhciBtID0gbmV3IE1ldGhvZChtZXRob2ROYW1lLCBtZXRob2RCb2R5KTtcbiAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICBtZXRob2RzW21ldGhvZE5hbWVdID0gbTtcbiAgICB9O1xuICAgIFxuICAgIG1vZGVsLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMoKSxcbiAgICAgICAgICAgIG1ldGhvZHMgPSB0aGlzLm1ldGhvZHMoKTtcblxuICAgICAgICAvL2NoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IGlzQnVpbHRXaXRoIGhhcyBhY3R1YWwgYXR0cmlidXRlc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUocmVxdWlyZWRDb25zdHJ1Y3RvckFyZ3NbaV0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXF1aXJlZENvbnN0cnVjdG9yQXJnc1tpXSArIFwiLCBzcGVjaWZpZWQgaW4gdGhlIGlzQnVpbHRXaXRoIG1ldGhvZCwgaXMgbm90IGFuIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25hbENvbnN0cnVjdG9yQXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZShvcHRpb25hbENvbnN0cnVjdG9yQXJnc1tpXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbmFsQ29uc3RydWN0b3JBcmdzW2ldICsgXCIsIHNwZWNpZmllZCBpbiB0aGUgaXNCdWlsdFdpdGggbWV0aG9kLCBpcyBub3QgYW4gYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbWV0aG9kL2F0dHJpYnV0ZSBjb2xsaXNpb25zXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kcy5pbmRleE9mKGF0dHJpYnV0ZXNbaV0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbDogaW52YWxpZCBtb2RlbCBzcGVjaWZpY2F0aW9uIHRvIFwiICsgYXR0cmlidXRlc1tpXSArIFwiIGJlaW5nIGJvdGggYW4gYXR0cmlidXRlIGFuZCBtZXRob2RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBhdHRyaWJ1dGVzIGFyZSByZXF1aXJlZENvbnN0cnVjdG9yQXJncyBpZiB0aGUgb2JqZWN0IGlzIGltbXV0YWJsZVxuICAgICAgICBpZiAoaXNJbW11dGFibGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkQ29uc3RydWN0b3JBcmdzLmluZGV4T2YoYXR0cmlidXRlc1tpXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImltbXV0YWJsZSBvYmplY3RzIG11c3QgaGF2ZSBhbGwgYXR0cmlidXRlcyByZXF1aXJlZCBpbiBhIGNhbGwgdG8gaXNCdWlsdFdpdGhcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9zZXQgbW9kaWZpZWRTaW5jZUxhc3RWYWxpZGF0aW9uIHRvIGZhbHNlXG4gICAgICAgIG1vZGlmaWVkID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKioqKioqKioqKioqKiogRU5EIFBVQkxJQyBBUEkgKioqKioqKioqKioqKioqKi9cbiAgICBcbiAgICAvL2hlcmUgd2UgYXJlIHJldHVybmluZyBvdXIgbW9kZWwgb2JqZWN0XG4gICAgLy93aGljaCBpcyBhIGZ1bmN0aW9uIHdpdGggYSBidW5jaCBvZiBtZXRob2RzIHRoYXRcbiAgICAvL21hbmlwdWxhdGUgaG93IHRoZSBmdW5jdGlvbiBiZWhhdmVzXG4gICAgcmV0dXJuIG1vZGVsO1xufTtcblxuLy9ucy5nZXRNb2RlbCA9IGdldE1vZGVsO1xuLy9ucy5nZXRNb2RlbHMgPSBnZXRNb2RlbHM7XG5cbk1vZGVsLmdldE1vZGVsID0gZ2V0TW9kZWw7XG5Nb2RlbC5nZXRNb2RlbHMgPSBnZXRNb2RlbHM7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7XG5cblxuIiwiLyoqXG4gKiBWYWxpZGF0b3JcbiAqIFxuICogQ3JlYXRlcyBhIG5hbWVkIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGF0dHJpYnV0ZSBmb3IgdmFsaWRhdGlvbi5cbiAqIFRoZSBWYWxpZGF0b3IgZnVuY3Rpb24gYWxsb3dzIGZvciBjdXN0b21pemF0aW9uIG9mIHRoZSB0aHJvd24gZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGFsc28gaGFuZGxlcyBhbGwgZGVmYXVsdCB2YWxpZGF0b3JzIHRoYXQgY29tZSBwYWNrYWdlZCB3aXRoXG4gKiBKZXJtYWluZS4gVGhpcyBpbmNsdWRlcyBpc0EsIGlzT25lT2YsIGlzR3JlYXRlclRoYW4sIGlzTGVzc1RoYW4sIGV0Yy5cbiAqXG4gKiBTaW1wbGUgZXhhbXBsZTpcbiAqXG4gKiBpc0dyZWF0ZXJUaGFuID0gbmV3IFZhbGlkYXRvcihmdW5jdGlvbiAobnVtYmVyKSB7XG4gKiAgICAgLy90aGlzLm1lc3NhZ2UgcG9pbnRzIHRvIHRoZSBlcnJvciBtZXNzYWdlXG4gKiAgICAgLy90aGF0IHdpbGwgYmUgdGhyb3duXG4gKiAgICAgdGhpcy5tZXNzYWdlID0gXCJWYWxpZGF0aW9uIEVycm9yOiBcIiArIFxuICogICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW0gKyBcIiBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIFwiICsgbnVtYmVyO1xuICpcbiAqICAgICAvL3RoaXMucGFyYW0gcG9pbnRzIHRvIHRoZSBhY3R1YWwgcGFyYW1ldGVyIHNlbnQgdG8gdGhlIHZhbGlkYXRvclxuICogICAgIC8vcmV0dXJuIHRydWUgaWYgdGhlIHZhbGlkYXRpb24gcGFzc2VzLCBmYWxzZSBvdGhlcndpc2VcbiAqICAgICByZXR1cm4gdGhpcy5wYXJhbSA+IG51bWJlcjtcbiAqIH0pO1xuICpcbiAqIExhdGVyLCBhIHZhbGlkYXRvciBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIGF0dHJpYnV0ZSBvYmplY3QuXG4gKlxuICogQXR0ci5pc0dyZWF0ZXJUaGFuID0gaXNHcmVhdGVyVGhhbjtcbiAqXG4gKiBhbmQgY2FuIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhdHRyaWJ1dGVzOlxuICpcbiAqIHZhciBhZ2UgPSBuZXcgQXR0cihcImFnZVwiKS53aGljaC5pc0dyZWF0ZXJUaGFuKDApO1xuICpcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZSgnLi4vdXRpbC9pbmRleF9vZi5qcycpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsLmpzJyk7XG5cbnZhciB2YWxpZGF0b3JzID0ge307ICAvL3RoZSBzZXQgb2Ygc3RhdGljIHZhbGlkYXRvcnNcblxuLyoqXG4gKiBWYWxpZGF0b3IgJ0NvbnN0cnVjdG9yJ1xuICpcbiAqIFRoaXMgc2ltcGx5IHJldHVybnMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0aGUgY3VzdG9tIGVycm9yXG4gKiBtZXNzYWdlIGFuZCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gYXR0cmlidXRlLiBTbyBpdCdzIG5vdCByZWFsbHlcbiAqIHRlY2huaWNhbGx5IGEgY29uc3RydWN0b3IuIFRoaXMgaXMgb25seSBpbXBvcnRhbnQgdG8ga25vdyBzbyB0aGF0IHlvdVxuICogZG9uJ3QgdHJ5IHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gKlxuICogdmFyIHYgPSBuZXcgVmFsaWRhdG9yKCAuLi4gKTtcbiAqIFxuICogLy90aGlzIHdpbGwgYWx3YXlzIGZhaWwsIGJjIHYgaXMgbm90IGFuIG9iamVjdFxuICogaWYgKHYgaW5zdGFuY2VvZiBWYWxpZGF0b3IpIHsgLi4uIH1cbiAqIFxuICogVGhlIHNwZWMgZnVuY3Rpb24gaXMganVzdCBhIHNwZWNpZmljYXRpb24gZm9yIHRoZSB2YWxpZGF0b3IuIEl0IGFsbG93c1xuICogZm9yIGEgY291cGxlIG9mIHRoaW5ncyB0byBiZSBhdHRhY2hlZCB0byBcInRoaXNcIiB0aGF0IHdpbGwgYmUgdXNlZFxuICogaW4gdGhlIHJldHVybiBmdW5jdGlvbi4gVGhpcyBpbmNsdWRlcyBcInRoaXMubWVzc2FnZVwiIGFuZCBcInRoaXMucGFyYW1cIi5cbiAqIFRoZSBtZXNzYWdlIGlzIHRoZSBlcnJvciBzdHJpbmcgdGhhdCBpcyB0aHJvd24gb24gZmFpbHVyZSBhbmRcbiAqIHRoaXMucGFyYW0gaXMgdGhlIGFjdHVhbCBwYXJhbWV0ZXIgdGhhdCBnZXRzIHNlbnQgaW4gdG8gYmUgdmFsaWRhdGVkLlxuICovXG52YXIgVmFsaWRhdG9yID0gZnVuY3Rpb24gKHNwZWMpIHtcbiAgICAvLyB0aGlzIGlzIHRoZSBhY3R1YWwgZnVuY3Rpb24gdGhhdCBpcyByZXR1cm5lZFxuICAgIHZhciB2YWxpZGF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgXG4gICAgICAgICAgICByZXN1bHRPYmplY3QgPSB7fSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTtcblxuICAgICAgICAvLyBzcGVjIGlzIGNhbGxlZCBvbiB0aGUgYXJndW1lbnQgd2l0aCAndGhpcycgcG9pbnRpbmdcbiAgICAgICAgLy8gdG8gYW4gZW1wdHkgb2JqZWN0IChyZXN1bHRPYmplY3QpLFxuICAgICAgICAvLyBub3RlIHRoZSB2YWxpZGF0b3Igd2lsbCByZXR1cm4gZWl0aGVyIHRydWUgb3IgZmFsc2VcbiAgICAgICAgcmVzdWx0ID0gc3BlYy5jYWxsKHJlc3VsdE9iamVjdCwgYXJnKTtcblxuICAgICAgICAvLyBpZiBpdCdzIGZhbHNlLCB0aGUgcGFyYW1ldGVyIGhhcyBmYWlsZWQgdmFsaWRhdGlvblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgLy8gdGhyb3cgdGhlIGVycm9yXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSByZXN1bHRPYmplY3QubWVzc2FnZSB8fFxuICAgICAgICAgICAgICAgIFwidmFsaWRhdG9yIGZhaWxlZCB3aXRoIHBhcmFtZXRlciBcIiArIGFyZztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIHNlZT8gYWxsIHRoYXQncyBiZWluZyByZXR1cm5lZCBpcyBhIGZ1bmN0aW9uXG4gICAgLy8gYWxzbyBub3RlIHRoYXQgc2luY2UgJ3RoaXMnIGlzIG5ldmVyIHVzZWQsXG4gICAgLy8gd2UgY2FuIGNhbGwgdGhpcyBjb25zdHJ1Y3RvciB3aXRoIG9yIHdpdGhvdXQgJ25ldydcbiAgICByZXR1cm4gdmFsaWRhdG9yRnVuY3Rpb247XG59O1xuXG4vKipcbiAqIFRoaXMgc3RhdGljIGZ1bmN0aW9uIGFkZHMgYSBuYW1lZCB2YWxpZGF0b3IgdG8gdGhlIGxpc3Qgb2ZcbiAqIHZhbGlkYXRvcnMuIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gKiB0aGF0IHNpbXBseSByZXR1cm5zIGEgVmFsaWRhdG9yIGZ1bmN0aW9uIGNyZWF0ZWQgYXMgYWJvdmUuXG4gKlxuICogVGhlIG5pY2UgdGhpbmcgYWJvdXQgYWRkaW5nIGEgVmFsaWRhdG9yIHRoaXMgd2F5IGlzIHRoYXRcbiAqIHlvdSBjYW4gYWN0dWFsbHkgdmFsaWRhdGUgdGhlIHBhcmFtZXRlciBzZW50IHRvIHRoZSB2YWxpZGF0b3IhXG4gKiBXaHkgbWlnaHQgdGhhdCBiZSBpbXBvcnRhbnQ/IFdlbGwsIGNvbnNpZGVyIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogdmFyIGlzR3JlYXRlclRoYW5JbnRlZ2VyID0gbmV3IFZhbGlkYXRvcihmdW5jdGlvbiAodmFsKSB7XG4gKiAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wYXJhbSArIFwiIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gXCIgKyB2YWw7XG4gKiAgICAgcmV0dXJuIHRoaXMucGFyYW0gPiB2YWw7XG4gKiB9KTtcbiAqXG4gKiBOb3cgd2UgY2FuIGNhbGwgaXNHcmVhdGVyVGhhbk51bWJlciBsaWtlIHRoaXM6XG4gKlxuICogaXNHcmVhdGVyVGhhbk51bWJlcig1KSg2KTsgLy8gd2lsbCBwYXNzIHZhbGlkYXRpb25cbiAqIGlzR3JlYXRlclRoYW5OdW1iZXIoNSkoMyk7IC8vIHdpbGwgdGhyb3dcbiAqIGlzR3JlYXRlclRoYW5OdW1iZXIoXCJkb2dcIikoMyk7IC8vID8/P1xuICpcbiAqIFNvIHdlIG5lZWQgdG8gY29uZmlybSB0aGF0IHRoZSB1c2VyIHNlbmRzIGluIGFuIGludGVnZXIgYXMgYSBwYXJhbWV0ZXIuXG4gKiBZb3UgbWlnaHQgd2FudCB0byB0cnkgc29tZXRoaW5nIGxpa2UgdGhpczpcbiAqXG4gKiB2YXIgaXNHcmVhdGVyVGhhbkludGVnZXIgPSBuZXcgVmFsaWRhdG9yKGZ1bmN0aW9uICh2YWwpIHtcbiAqICAgICBpZiAodHlwZW9mKHZhbCkgIT09IFwibnVtYmVyXCIpIHRocm93IEVycm9yKFwiTm90IGNvb2whXCIpO1xuICogICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucGFyYW0gKyBcIiBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIFwiICsgdmFsO1xuICogICAgIHJldHVybiB0aGlzLnBhcmFtID4gdmFsO1xuICogfSk7XG4gKlxuICogVGhpcyB3aWxsIGFjdHVhbGx5IHdvcmsgb24gdGhlIGV4YW1wbGUgYWJvdmU6XG4gKlxuICogaXNHcmVhdGVyVGhhbk51bWJlcihcImRvZ1wiKSgzKTsgLy8gdGhyb3dzIGVycm9yIG5vd1xuICpcbiAqIFRoZSBwcm9ibGVtIGlzIHRoYXQgd2l0aCBKZXJtYWluZSwgd2UgY3JlYXRlIHRoZSB2YWxpZGF0b3JcbiAqIGFuZCB0aGVuIGRvbid0IGFjdHVhbGx5IGNhbGwgaXQgdW50aWwgYW4gYXR0cmlidXRlIGlzIGFib3V0IHRvIGJlXG4gKiBzZXQuIFNvLCBpbiBvdGhlciB3b3JkczpcbiAqXG4gKiB2YXIgYSA9IG5ldyBBdHRyKFwidGhpbmdcIikud2hpY2guaXNHcmVhdGVyVGhhbk51bWJlcihcImRvZ1wiKTsgLy9ubyBlcnJvciAoeWV0KVxuICpcbiAqIHdpbGwgbm90IGNhdXNlIGFuIGVycm9yIHVudGlsIGl0J3MgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IGFuZCB0aGluZ1xuICogaXMgYXR0ZW1wdGVkIHRvIGJlIHNldC5cbiAqXG4gKiBTbyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kIGlzIHRvIHZhbGlkYXRlIHRoZSB2YWxpZGF0b3IgaW4gdGhlXG4gKiBhZGRWYWxpZGF0b3IgZnVuY3Rpb24gYmVsb3cuIFRoYXQncyBoYW5kbGVkIGJ5IHRoZSBhcmdWYWxpZGF0b3JcbiAqIHZhbGlkYXRvci4gKFBoZXcsIHRoaXMgaXMgZ2V0dGluZyByZWFsbHkgbWV0YSlcbiAqXG4gKiBJJ20gbm90IHN1cmUgdGhpcyBpcyB0aGUgYmVzdCBzb2x1dGlvbi4gU2VlbXMgbGlrZSB0aGVyZSBzaG91bGQgYmVcbiAqIGEgd2F5IHRvIHZhbGlkYXRlIHRoZSBhcmd1bWVudCBpbiB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24sIGJ1dFxuICogdGhhdCBtaWdodCByZXF1aXJlIHNvbWUgcmV3aXJpbmcgdGhhdCBicmVha3MgbXVsdGlncmFwaC4gVGhpcyBpc1xuICogdGhlIGJlc3QgSSBjb3VsZCBjb21lIHVwIHdpdGggZm9yIG5vdy5cbiAqXG4gKiBAbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFsaWRhdG9yIGZvciB0aGUgYXR0cmlidXRlLCBtdXN0IGJlIGEgc3RyaW5nXG4gKiAgICAgICBvciBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICpcbiAqIEB2IFRoZSB2YWxpZGF0b3Igc3BlY2lmaWNhdGlvbiAocmV0dXJucyBhIGJvb2xlYW4pXG4gKiAgICBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqXG4gKiBAYXJnVmFsaWRhdG9yIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIHRoZSB0eXBlcyBvZiBhcmdzIHNlbnRcbiAqICAgICAgICAgICB0byB0aGUgdmFsaWRhdG9yLCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqXG4gKiBTbyBhbiBlcnJvciB3aWxsIGJlIHRocm93biBpbiB0aGUgY2FzZXMgdGhhdCBcIm5hbWVcIiBpcyBub3QgYSBzdHJpbmcsXG4gKiB2IGlzIG5vdCBhIGZ1bmN0aW9uLCBhcmdWYWxpZGF0b3IgaXMgbm90IGEgZnVuY3Rpb24sIG9yIGlmIHRoZSBzdGF0aWNcbiAqIHZhbGlkYXRvciBpcyBhbHJlYWR5IGRlZmluZWQuXG4gKi9cblZhbGlkYXRvci5hZGRWYWxpZGF0b3IgPSBmdW5jdGlvbiAobmFtZSwgdiwgYXJnVmFsaWRhdG9yKSB7XG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YobmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkVmFsaWRhdG9yIHJlcXVpcmVzIGEgbmFtZSB0byBiZSBzcGVjaWZpZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlclwiKTtcbiAgICB9XG5cbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZih2KSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZFZhbGlkYXRvciByZXF1aXJlcyBhIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyXCIpO1xuICAgIH1cblxuICAgIC8vIG9wdGlvbmFsIHRoaXJkIGFyZ3VtZW50IHRvIHZhbGlkYXRlIHRoZSBcbiAgICAvLyBleHBlY3RlZCB2YWx1ZSB0aGF0IGdldHMgc2VudCB0byB0aGUgdmFsaWRhdG9yXG4gICAgLy8gZm9yIGV4YW1wbGUsIGlzQShcIm51bWJlclwiKSB3b3JrcyBidXQgaXNBKFwibm1iZXJcIilcbiAgICAvLyBkb2Vzbid0IHdvcmtcbiAgICBpZiAoYXJnVmFsaWRhdG9yICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mKGFyZ1ZhbGlkYXRvcikgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRWYWxpZGF0b3IgdGhpcmQgb3B0aW9uYWwgYXJndW1lbnQgbXVzdCBiZSBhIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodmFsaWRhdG9yc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbGlkYXRvcnNbbmFtZV0gPSBmdW5jdGlvbiAoZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChhcmdWYWxpZGF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghYXJnVmFsaWRhdG9yKGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IgKFwiVmFsaWRhdG9yOiBJbnZhbGlkIGFyZ3VtZW50IGZvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArIFwiIHZhbGlkYXRvclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZhbGlkYXRvcihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdE9iamVjdCA9IHtcImFjdHVhbFwiOnZhbCwgXCJwYXJhbVwiOnZhbH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHYuY2FsbChyZXN1bHRPYmplY3QsIGV4cGVjdGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSByZXN1bHRPYmplY3QubWVzc2FnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdG9yICdcIiArIG5hbWUgK1wiJyBhbHJlYWR5IGRlZmluZWRcIik7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEdldCB0aGUgYnVpbHQtaW4gdmFsaWRhdG9yIGJ5IGl0cyBuYW1lLlxuICpcbiAqIEBuYW1lIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgdmFsaWRhdG9yIHRvIHJldHVyblxuICogXG4gKiB0aHJvd3MgYW4gZXJyb3IgaWYgbmFtZSBpcyBub3QgYSBzdHJpbmdcbiAqL1xuVmFsaWRhdG9yLmdldFZhbGlkYXRvciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdG9yOiBnZXRWYWxpZGF0b3IgbWV0aG9kIHJlcXVpcmVzIGEgc3RyaW5nIHBhcmFtZXRlclwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiAobmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdG9yOiBwYXJhbWV0ZXIgdG8gZ2V0VmFsaWRhdG9yIG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IHZhbGlkYXRvcnNbbmFtZV07XG5cbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdG9yOiAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLyoqXG4gKiByZXR1cm4gYW4gYXJyYXkgb2Ygb2Ygc3RhdGljIHZhbGlkYXRvciBuYW1lc1xuICovXG5WYWxpZGF0b3IudmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcCxcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgZm9yIChwcm9wIGluIHZhbGlkYXRvcnMpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRvcnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQnVpbHQtSW4gdmFsaWRhdG9ycy4gSG9wZWZ1bGx5IHRoZXNlIGFyZSBzZWxmLWV4cGxhbmF0b3J5XG4gKiBXaWxsIGRvY3VtZW50IHRoZW0gbW9yZSBsYXRlci5cbiAqL1xuVmFsaWRhdG9yLmFkZFZhbGlkYXRvcihcImlzR3JlYXRlclRoYW5cIiwgZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucGFyYW0gKyBcIiBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIFwiICsgdmFsO1xuICAgIHJldHVybiB0aGlzLnBhcmFtID4gdmFsO1xufSk7XG5cblZhbGlkYXRvci5hZGRWYWxpZGF0b3IoXCJpc0xlc3NUaGFuXCIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBhcmFtICsgXCIgc2hvdWxkIGJlIGxlc3MgdGhhbiBcIiArIHZhbDtcbiAgICByZXR1cm4gdGhpcy5wYXJhbSA8IHZhbDtcbn0pO1xuXG5cbi8vIFRPRE86IGFkZCBhcnJheSB2YWxpZGF0aW9uIGZvciB2YWxcblZhbGlkYXRvci5hZGRWYWxpZGF0b3IoXCJpc09uZU9mXCIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBhcmFtICsgXCIgc2hvdWxkIGJlIG9uZSBvZiB0aGUgc2V0OiBcIiArIHZhbDtcbiAgICByZXR1cm4gdmFsLmluZGV4T2YodGhpcy5wYXJhbSkgPiAtMTtcbn0pO1xuXG4vKipcbiAqIFRoaXMgb25lIGlzIHRoZSBvbmx5IG9uZSB0aGF0IHVzZXMgYW4gYXJndW1lbnQgdmFsaWRhdG9yLiBJdCBjb25maXJtc1xuICogdGhhdCB0aGUgYXJndW1lbnQgaXMgYSBwcmltaXRpdmUgamF2YXNjcmlwdCB0eXBlIG9yIGEgbmFtZWQgSmVybWFpbmVcbiAqIG1vZGVsLlxuICovXG5WYWxpZGF0b3IuYWRkVmFsaWRhdG9yKFwiaXNBXCIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgdHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCIsIFwiZnVuY3Rpb25cIiwgXCJvYmplY3RcIl0sXG4gICAgICAgIG1vZGVscyA9IE1vZGVsLmdldE1vZGVscygpO1xuICAgIGlmICh0eXBlb2YodmFsKSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlcy5pbmRleE9mKHZhbCkgPiAtMSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBhcmFtICsgXCIgc2hvdWxkIGJlIGEgXCIgKyB2YWw7XG4gICAgICAgIHJldHVybiB0eXBlb2YodGhpcy5wYXJhbSkgPT09IHZhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZih2YWwpID09PSBcInN0cmluZ1wiICYmIG1vZGVscy5pbmRleE9mKHZhbCkgPiAtMSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcInBhcmFtZXRlciBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgXCIgKyB2YWw7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtIGluc3RhbmNlb2YgTW9kZWwuZ2V0TW9kZWwodmFsKTtcbiAgICB9IGVsc2UgaWYgKHZhbCA9PT0gJ2ludGVnZXInKSB7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgJ2ludGVnZXInOyBzaW5jZSBqYXZhc2NyaXB0IGhhcyBubyBpbnRlZ2VyIHR5cGUsXG4gICAgICAgIC8vIGp1c3QgY2hlY2sgZm9yIG51bWJlciB0eXBlIGFuZCBjaGVjayB0aGF0IGl0J3MgbnVtZXJpY2FsbHkgYW4gaW50XG4gICAgICAgIGlmICh0aGlzLnBhcmFtLnRvU3RyaW5nICE9PSB1bmRlZmluZWQpICB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBhcmFtLnRvU3RyaW5nKCkgKyBcIiBzaG91bGQgYmUgYW4gaW50ZWdlclwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIGludGVnZXJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHR5cGVvZih0aGlzLnBhcmFtKSA9PT0gJ251bWJlcicpICYmIChwYXJzZUludCh0aGlzLnBhcmFtLDEwKSA9PT0gdGhpcy5wYXJhbSk7XG4gICAgfSAvKmVsc2UgaWYgKHR5cGVvZih2YWwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdG9yOiBpc0EgYWNjZXB0cyBhIHN0cmluZyB3aGljaCBpcyBvbmUgb2YgXCIgKyB0eXBlcyk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0b3I6IGlzQSBvbmx5IGFjY2VwdHMgYSBzdHJpbmcgZm9yIGEgcHJpbWl0aXZlIHR5cGVzIGZvciB0aGUgdGltZSBiZWluZ1wiKTtcbiAgICAgICB9Ki9cbn0sXG4gICAgICAgICAgICAgICAgICAgICAgIC8vYXJndW1lbnQgdmFsaWRhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlc0FuZE1vZGVscyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIiwgXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIsIFwiaW50ZWdlclwiXS5jb25jYXQoTW9kZWwuZ2V0TW9kZWxzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzQW5kTW9kZWxzLmluZGV4T2YodmFsKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4vLyBncmFtbWF0aWNhbCBhbGlhcyBmb3IgaXNBXG52YWxpZGF0b3JzLmlzQW4gPSB2YWxpZGF0b3JzLmlzQTtcblxubW9kdWxlLmV4cG9ydHMgPSBWYWxpZGF0b3I7XG4iLCJyZXF1aXJlKCcuL3V0aWwvaW5kZXhfb2YuanMnKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9jb3JlL21vZGVsLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdBdHRyJyAgICAgIDogcmVxdWlyZSgnLi9jb3JlL2F0dHIuanMnKSxcbiAgICAnQXR0ckxpc3QnICA6IHJlcXVpcmUoJy4vY29yZS9hdHRyX2xpc3QuanMnKSxcbiAgICAnTW9kZWwnICAgICA6IE1vZGVsLFxuICAgICdnZXRNb2RlbCcgIDogTW9kZWwuZ2V0TW9kZWwsXG4gICAgJ2dldE1vZGVscycgOiBNb2RlbC5nZXRNb2RlbHMsXG4gICAgJ1ZhbGlkYXRvcicgOiByZXF1aXJlKCcuL2NvcmUvdmFsaWRhdG9yLmpzJyksXG4gICAgJ01ldGhvZCcgICAgOiByZXF1aXJlKCcuL2NvcmUvbWV0aG9kLmpzJyksXG4gICAgJ3V0aWwnICAgICAgOiB7XG4gICAgICAgICdFdmVudEVtaXR0ZXInIDogcmVxdWlyZSgnLi91dGlsL2V2ZW50X2VtaXR0ZXIuanMnKSxcbiAgICAgICAgJ25hbWVzcGFjZScgICAgOiByZXF1aXJlKCcuL3V0aWwvbmFtZXNwYWNlLmpzJylcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoJy4vaW5kZXhfb2YuanMnKTtcblxudmFyIEV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGxpc3RlbmVycyA9IHt9O1xuXG4gICAgLy9hbiByZWdpc3RlcnMgZXZlbnQgYW5kIGEgbGlzdGVuZXJcbiAgICB0aGlzLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZW9mKGV2ZW50KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyOiBmaXJzdCBhcmd1bWVudCB0byAnb24nIHNob3VsZCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKGxpc3RlbmVyKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudEVtaXR0ZXI6IHNlY29uZCBhcmd1bWVudCB0byAnb24nIHNob3VsZCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVyc1tldmVudF0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICAvL2FsaWFzIGFkZExpc3RlbmVyXG4gICAgdGhpcy5hZGRMaXN0ZW5lciA9IHRoaXMub247XG4gICAgXG4gICAgdGhpcy5vbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGF0LnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGF0Lm9uKGV2ZW50LCBmKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBpbmRleDtcblxuICAgICAgICBpZiAodHlwZW9mKGV2ZW50KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyOiBmaXJzdCBwYXJhbWV0ZXIgdG8gcmVtb3ZlTGlzdGVuZXIgbWV0aG9kIG11c3QgYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV2ZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YobGlzdGVuZXIpICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlcjogc2Vjb25kIHBhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb24gdG8gcmVtb3ZlIGFzIGFuIGV2ZW50IGxpc3RlbmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbZXZlbnRdID09PSB1bmRlZmluZWQgfHwgbGlzdGVuZXJzW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlcjogdGhlcmUgYXJlIG5vIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciB0aGUgJ1wiICsgZXZlbnQgKyBcIicgZXZlbnRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9IGxpc3RlbmVyc1tldmVudF0uaW5kZXhPZihsaXN0ZW5lcik7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgLy9yZW1vdmUgaXQgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XS5zcGxpY2UoaW5kZXgsMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZihldmVudCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlcjogcGFyYW1ldGVyIHRvIHJlbW92ZUFsbExpc3RlbmVycyBzaG91bGQgYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV2ZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyc1tldmVudF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgLy9nZXQgdGhlIGxpc3RlbmVycyBmb3IgYW4gZXZlbnRcbiAgICB0aGlzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mKGV2ZW50KSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RW1pdHRlcjogbGlzdGVuZXJzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuYW1lIG9mIGFuIGV2ZW50XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyc1tldmVudF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnNbZXZlbnRdO1xuICAgIH07XG5cbiAgICAvL2V4ZWN1dGUgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIGluIG9yZGVyIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHNcbiAgICB0aGlzLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBwYXJhbXM7XG5cblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0ZW5lcnNbZXZlbnRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnNbZXZlbnRdLmxlbmd0aDsgaT1pKzEpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdW2ldLmFwcGx5KHRoaXMsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoYXQ7XG59OyAvL2VuZCBFdmVudEVtaXR0ZXJcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4iLCJpZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovICkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG4gPSBOdW1iZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICAgIGlmIChuICE9PSBuKSB7IC8vIHNob3J0Y3V0IGZvciB2ZXJpZnlpbmcgaWYgaXQncyBOYU5cbiAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSBJbmZpbml0eSAmJiBuICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuID49IGxlbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcbiAgICAgICAgZm9yICg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgaWYgKGsgaW4gdCAmJiB0W2tdID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBuYW1lc3BhY2UgKG5zLCBhbGlhc2VzLCBmdW5jKSB7XG4gICAgdmFyIG5zUmVnRXhwID0gL14oW2EtekEtWl0rKShcXC5bYS16QS1aXSopKiQvLFxuICAgICAgICBuc0FycmF5LFxuICAgICAgICBjdXJyZW50TlMsXG4gICAgICAgIGk7XG5cbiAgICAvL2NoZWNrIHRvIGFzc3VyZSBucyBpcyBhIHByb3Blcmx5IGZvcm1hdHRlZCBuYW1lc3BhY2Ugc3RyaW5nXG4gICAgaWYgKG5zLm1hdGNoKG5zUmVnRXhwKSA9PT0gbnVsbCB8fCBucyA9PT0gXCJ3aW5kb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lc3BhY2U6IFwiICsgbnMgKyBcIiBpcyBhIG1hbGZvcm1lZCBuYW1lc3BhY2Ugc3RyaW5nXCIpO1xuICAgIH1cblxuICAgIC8vY2hlY2sgdG8gYXNzdXJlIHRoYXQgaWYgYWxpYXMgaXMgZGVmaW5lZCB0aGF0IGZ1bmMgaXMgZGVmaW5lZFxuICAgIGlmIChhbGlhc2VzICE9PSB1bmRlZmluZWQgJiYgZnVuYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGFsaWFzZXMpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBhbGlhc2VzO1xuICAgICAgICAgICAgYWxpYXNlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGFsaWFzZXMpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lc3BhY2U6IGlmIHNlY29uZCBhcmd1bWVudCBleGlzdHMsIGZpbmFsIGZ1bmN0aW9uIGFyZ3VtZW50IG11c3QgZXhpc3RcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChhbGlhc2VzKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZXNwYWNlOiBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3Qgb2YgYWxpYXNlZCBsb2NhbCBuYW1lc3BhY2VzXCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKGFsaWFzZXMpICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiAoZnVuYykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lc3BhY2U6IHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCBvZiBhbGlhc2VkIGxvY2FsIG5hbWVzcGFjZXNcIik7XG4gICAgfVxuXG4gICAgLy9wYXJzZSBuYW1lc3BhY2Ugc3RyaW5nXG4gICAgbnNBcnJheSA9IG5zLnNwbGl0KFwiLlwiKTtcblxuICAgIC8vc2V0IHRoZSByb290IG5hbWVzcGFjZSB0byB3aW5kb3cgKGlmIGl0J3Mgbm90IGV4cGxpY3RseSBzdGF0ZWQpXG4gICAgaWYgKG5zQXJyYXlbMF0gPT09IFwid2luZG93XCIpIHtcbiAgICAgICAgY3VycmVudE5TID0gd2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnROUyA9ICh3aW5kb3dbbnNBcnJheVswXV0gPT09IHVuZGVmaW5lZCkgPyB3aW5kb3dbbnNBcnJheVswXV0gPSB7fSA6IHdpbmRvd1tuc0FycmF5WzBdXTtcbiAgICB9XG5cbiAgICAvL2NvbmZpcm0gZnVuYyBpcyBhY3R1YWxseSBhIGZ1bmN0aW9uXG4gICAgaWYgKGZ1bmMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgKGZ1bmMpICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZXNwYWNlOiBsYXN0IHBhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgbmFtZXNwYWNlIHBhcmFtZXRlclwiKTtcbiAgICB9XG5cbiAgICAvL2J1aWxkIG5hbWVzcGFjZVxuICAgIGZvciAoaSA9IDE7IGkgPCBuc0FycmF5Lmxlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICAgIGlmIChjdXJyZW50TlNbbnNBcnJheVtpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VycmVudE5TW25zQXJyYXlbaV1dID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE5TID0gY3VycmVudE5TW25zQXJyYXlbaV1dO1xuICAgIH1cblxuICAgIC8vbmFtZXNwYWNlcy5wdXNoKGN1cnJlbnROUyk7XG4gICAgLy9uYW1lc3BhY2UgPSBjdXJyZW50TlM7XG5cbiAgICAvL2lmIHRoZSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgYnV0IG5vIGFsaWFzZXMgcnVuIGl0IG9uIHRoZSBjdXJyZW50IG5hbWVzcGFjZVxuICAgIGlmIChhbGlhc2VzID09PSB1bmRlZmluZWQgJiYgZnVuYykge1xuICAgICAgICBmdW5jKGN1cnJlbnROUyk7XG4gICAgfSBlbHNlIGlmIChmdW5jKSB7XG4gICAgICAgIGZvciAoaSBpbiBhbGlhc2VzKSB7XG4gICAgICAgICAgICBpZiAoYWxpYXNlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIGFsaWFzZXNbaV0gPSBuYW1lc3BhY2UoYWxpYXNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuYy5jYWxsKGFsaWFzZXMsIGN1cnJlbnROUyk7XG4gICAgfVxuXG4gICAgLy9yZXR1cm4gbmFtZXNwYWNlXG4gICAgcmV0dXJuIGN1cnJlbnROUztcbn07XG4iLCIvKiEgalF1ZXJ5IHYxLjguMiBqcXVlcnkuY29tIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXG4oZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBHKGEpe3ZhciBiPUZbYV09e307cmV0dXJuIHAuZWFjaChhLnNwbGl0KHMpLGZ1bmN0aW9uKGEsYyl7YltjXT0hMH0pLGJ9ZnVuY3Rpb24gSihhLGMsZCl7aWYoZD09PWImJmEubm9kZVR5cGU9PT0xKXt2YXIgZT1cImRhdGEtXCIrYy5yZXBsYWNlKEksXCItJDFcIikudG9Mb3dlckNhc2UoKTtkPWEuZ2V0QXR0cmlidXRlKGUpO2lmKHR5cGVvZiBkPT1cInN0cmluZ1wiKXt0cnl7ZD1kPT09XCJ0cnVlXCI/ITA6ZD09PVwiZmFsc2VcIj8hMTpkPT09XCJudWxsXCI/bnVsbDorZCtcIlwiPT09ZD8rZDpILnRlc3QoZCk/cC5wYXJzZUpTT04oZCk6ZH1jYXRjaChmKXt9cC5kYXRhKGEsYyxkKX1lbHNlIGQ9Yn1yZXR1cm4gZH1mdW5jdGlvbiBLKGEpe3ZhciBiO2ZvcihiIGluIGEpe2lmKGI9PT1cImRhdGFcIiYmcC5pc0VtcHR5T2JqZWN0KGFbYl0pKWNvbnRpbnVlO2lmKGIhPT1cInRvSlNPTlwiKXJldHVybiExfXJldHVybiEwfWZ1bmN0aW9uIGJhKCl7cmV0dXJuITF9ZnVuY3Rpb24gYmIoKXtyZXR1cm4hMH1mdW5jdGlvbiBiaChhKXtyZXR1cm4hYXx8IWEucGFyZW50Tm9kZXx8YS5wYXJlbnROb2RlLm5vZGVUeXBlPT09MTF9ZnVuY3Rpb24gYmkoYSxiKXtkbyBhPWFbYl07d2hpbGUoYSYmYS5ub2RlVHlwZSE9PTEpO3JldHVybiBhfWZ1bmN0aW9uIGJqKGEsYixjKXtiPWJ8fDA7aWYocC5pc0Z1bmN0aW9uKGIpKXJldHVybiBwLmdyZXAoYSxmdW5jdGlvbihhLGQpe3ZhciBlPSEhYi5jYWxsKGEsZCxhKTtyZXR1cm4gZT09PWN9KTtpZihiLm5vZGVUeXBlKXJldHVybiBwLmdyZXAoYSxmdW5jdGlvbihhLGQpe3JldHVybiBhPT09Yj09PWN9KTtpZih0eXBlb2YgYj09XCJzdHJpbmdcIil7dmFyIGQ9cC5ncmVwKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGEubm9kZVR5cGU9PT0xfSk7aWYoYmUudGVzdChiKSlyZXR1cm4gcC5maWx0ZXIoYixkLCFjKTtiPXAuZmlsdGVyKGIsZCl9cmV0dXJuIHAuZ3JlcChhLGZ1bmN0aW9uKGEsZCl7cmV0dXJuIHAuaW5BcnJheShhLGIpPj0wPT09Y30pfWZ1bmN0aW9uIGJrKGEpe3ZhciBiPWJsLnNwbGl0KFwifFwiKSxjPWEuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2lmKGMuY3JlYXRlRWxlbWVudCl3aGlsZShiLmxlbmd0aCljLmNyZWF0ZUVsZW1lbnQoYi5wb3AoKSk7cmV0dXJuIGN9ZnVuY3Rpb24gYkMoYSxiKXtyZXR1cm4gYS5nZXRFbGVtZW50c0J5VGFnTmFtZShiKVswXXx8YS5hcHBlbmRDaGlsZChhLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChiKSl9ZnVuY3Rpb24gYkQoYSxiKXtpZihiLm5vZGVUeXBlIT09MXx8IXAuaGFzRGF0YShhKSlyZXR1cm47dmFyIGMsZCxlLGY9cC5fZGF0YShhKSxnPXAuX2RhdGEoYixmKSxoPWYuZXZlbnRzO2lmKGgpe2RlbGV0ZSBnLmhhbmRsZSxnLmV2ZW50cz17fTtmb3IoYyBpbiBoKWZvcihkPTAsZT1oW2NdLmxlbmd0aDtkPGU7ZCsrKXAuZXZlbnQuYWRkKGIsYyxoW2NdW2RdKX1nLmRhdGEmJihnLmRhdGE9cC5leHRlbmQoe30sZy5kYXRhKSl9ZnVuY3Rpb24gYkUoYSxiKXt2YXIgYztpZihiLm5vZGVUeXBlIT09MSlyZXR1cm47Yi5jbGVhckF0dHJpYnV0ZXMmJmIuY2xlYXJBdHRyaWJ1dGVzKCksYi5tZXJnZUF0dHJpYnV0ZXMmJmIubWVyZ2VBdHRyaWJ1dGVzKGEpLGM9Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLGM9PT1cIm9iamVjdFwiPyhiLnBhcmVudE5vZGUmJihiLm91dGVySFRNTD1hLm91dGVySFRNTCkscC5zdXBwb3J0Lmh0bWw1Q2xvbmUmJmEuaW5uZXJIVE1MJiYhcC50cmltKGIuaW5uZXJIVE1MKSYmKGIuaW5uZXJIVE1MPWEuaW5uZXJIVE1MKSk6Yz09PVwiaW5wdXRcIiYmYnYudGVzdChhLnR5cGUpPyhiLmRlZmF1bHRDaGVja2VkPWIuY2hlY2tlZD1hLmNoZWNrZWQsYi52YWx1ZSE9PWEudmFsdWUmJihiLnZhbHVlPWEudmFsdWUpKTpjPT09XCJvcHRpb25cIj9iLnNlbGVjdGVkPWEuZGVmYXVsdFNlbGVjdGVkOmM9PT1cImlucHV0XCJ8fGM9PT1cInRleHRhcmVhXCI/Yi5kZWZhdWx0VmFsdWU9YS5kZWZhdWx0VmFsdWU6Yz09PVwic2NyaXB0XCImJmIudGV4dCE9PWEudGV4dCYmKGIudGV4dD1hLnRleHQpLGIucmVtb3ZlQXR0cmlidXRlKHAuZXhwYW5kbyl9ZnVuY3Rpb24gYkYoYSl7cmV0dXJuIHR5cGVvZiBhLmdldEVsZW1lbnRzQnlUYWdOYW1lIT1cInVuZGVmaW5lZFwiP2EuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpOnR5cGVvZiBhLnF1ZXJ5U2VsZWN0b3JBbGwhPVwidW5kZWZpbmVkXCI/YS5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKTpbXX1mdW5jdGlvbiBiRyhhKXtidi50ZXN0KGEudHlwZSkmJihhLmRlZmF1bHRDaGVja2VkPWEuY2hlY2tlZCl9ZnVuY3Rpb24gYlkoYSxiKXtpZihiIGluIGEpcmV0dXJuIGI7dmFyIGM9Yi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStiLnNsaWNlKDEpLGQ9YixlPWJXLmxlbmd0aDt3aGlsZShlLS0pe2I9YldbZV0rYztpZihiIGluIGEpcmV0dXJuIGJ9cmV0dXJuIGR9ZnVuY3Rpb24gYlooYSxiKXtyZXR1cm4gYT1ifHxhLHAuY3NzKGEsXCJkaXNwbGF5XCIpPT09XCJub25lXCJ8fCFwLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKX1mdW5jdGlvbiBiJChhLGIpe3ZhciBjLGQsZT1bXSxmPTAsZz1hLmxlbmd0aDtmb3IoO2Y8ZztmKyspe2M9YVtmXTtpZighYy5zdHlsZSljb250aW51ZTtlW2ZdPXAuX2RhdGEoYyxcIm9sZGRpc3BsYXlcIiksYj8oIWVbZl0mJmMuc3R5bGUuZGlzcGxheT09PVwibm9uZVwiJiYoYy5zdHlsZS5kaXNwbGF5PVwiXCIpLGMuc3R5bGUuZGlzcGxheT09PVwiXCImJmJaKGMpJiYoZVtmXT1wLl9kYXRhKGMsXCJvbGRkaXNwbGF5XCIsY2MoYy5ub2RlTmFtZSkpKSk6KGQ9YkgoYyxcImRpc3BsYXlcIiksIWVbZl0mJmQhPT1cIm5vbmVcIiYmcC5fZGF0YShjLFwib2xkZGlzcGxheVwiLGQpKX1mb3IoZj0wO2Y8ZztmKyspe2M9YVtmXTtpZighYy5zdHlsZSljb250aW51ZTtpZighYnx8Yy5zdHlsZS5kaXNwbGF5PT09XCJub25lXCJ8fGMuc3R5bGUuZGlzcGxheT09PVwiXCIpYy5zdHlsZS5kaXNwbGF5PWI/ZVtmXXx8XCJcIjpcIm5vbmVcIn1yZXR1cm4gYX1mdW5jdGlvbiBiXyhhLGIsYyl7dmFyIGQ9YlAuZXhlYyhiKTtyZXR1cm4gZD9NYXRoLm1heCgwLGRbMV0tKGN8fDApKSsoZFsyXXx8XCJweFwiKTpifWZ1bmN0aW9uIGNhKGEsYixjLGQpe3ZhciBlPWM9PT0oZD9cImJvcmRlclwiOlwiY29udGVudFwiKT80OmI9PT1cIndpZHRoXCI/MTowLGY9MDtmb3IoO2U8NDtlKz0yKWM9PT1cIm1hcmdpblwiJiYoZis9cC5jc3MoYSxjK2JWW2VdLCEwKSksZD8oYz09PVwiY29udGVudFwiJiYoZi09cGFyc2VGbG9hdChiSChhLFwicGFkZGluZ1wiK2JWW2VdKSl8fDApLGMhPT1cIm1hcmdpblwiJiYoZi09cGFyc2VGbG9hdChiSChhLFwiYm9yZGVyXCIrYlZbZV0rXCJXaWR0aFwiKSl8fDApKTooZis9cGFyc2VGbG9hdChiSChhLFwicGFkZGluZ1wiK2JWW2VdKSl8fDAsYyE9PVwicGFkZGluZ1wiJiYoZis9cGFyc2VGbG9hdChiSChhLFwiYm9yZGVyXCIrYlZbZV0rXCJXaWR0aFwiKSl8fDApKTtyZXR1cm4gZn1mdW5jdGlvbiBjYihhLGIsYyl7dmFyIGQ9Yj09PVwid2lkdGhcIj9hLm9mZnNldFdpZHRoOmEub2Zmc2V0SGVpZ2h0LGU9ITAsZj1wLnN1cHBvcnQuYm94U2l6aW5nJiZwLmNzcyhhLFwiYm94U2l6aW5nXCIpPT09XCJib3JkZXItYm94XCI7aWYoZDw9MHx8ZD09bnVsbCl7ZD1iSChhLGIpO2lmKGQ8MHx8ZD09bnVsbClkPWEuc3R5bGVbYl07aWYoYlEudGVzdChkKSlyZXR1cm4gZDtlPWYmJihwLnN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGV8fGQ9PT1hLnN0eWxlW2JdKSxkPXBhcnNlRmxvYXQoZCl8fDB9cmV0dXJuIGQrY2EoYSxiLGN8fChmP1wiYm9yZGVyXCI6XCJjb250ZW50XCIpLGUpK1wicHhcIn1mdW5jdGlvbiBjYyhhKXtpZihiU1thXSlyZXR1cm4gYlNbYV07dmFyIGI9cChcIjxcIithK1wiPlwiKS5hcHBlbmRUbyhlLmJvZHkpLGM9Yi5jc3MoXCJkaXNwbGF5XCIpO2IucmVtb3ZlKCk7aWYoYz09PVwibm9uZVwifHxjPT09XCJcIil7Ykk9ZS5ib2R5LmFwcGVuZENoaWxkKGJJfHxwLmV4dGVuZChlLmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIikse2ZyYW1lQm9yZGVyOjAsd2lkdGg6MCxoZWlnaHQ6MH0pKTtpZighYkp8fCFiSS5jcmVhdGVFbGVtZW50KWJKPShiSS5jb250ZW50V2luZG93fHxiSS5jb250ZW50RG9jdW1lbnQpLmRvY3VtZW50LGJKLndyaXRlKFwiPCFkb2N0eXBlIGh0bWw+PGh0bWw+PGJvZHk+XCIpLGJKLmNsb3NlKCk7Yj1iSi5ib2R5LmFwcGVuZENoaWxkKGJKLmNyZWF0ZUVsZW1lbnQoYSkpLGM9YkgoYixcImRpc3BsYXlcIiksZS5ib2R5LnJlbW92ZUNoaWxkKGJJKX1yZXR1cm4gYlNbYV09YyxjfWZ1bmN0aW9uIGNpKGEsYixjLGQpe3ZhciBlO2lmKHAuaXNBcnJheShiKSlwLmVhY2goYixmdW5jdGlvbihiLGUpe2N8fGNlLnRlc3QoYSk/ZChhLGUpOmNpKGErXCJbXCIrKHR5cGVvZiBlPT1cIm9iamVjdFwiP2I6XCJcIikrXCJdXCIsZSxjLGQpfSk7ZWxzZSBpZighYyYmcC50eXBlKGIpPT09XCJvYmplY3RcIilmb3IoZSBpbiBiKWNpKGErXCJbXCIrZStcIl1cIixiW2VdLGMsZCk7ZWxzZSBkKGEsYil9ZnVuY3Rpb24gY3ooYSl7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7dHlwZW9mIGIhPVwic3RyaW5nXCImJihjPWIsYj1cIipcIik7dmFyIGQsZSxmLGc9Yi50b0xvd2VyQ2FzZSgpLnNwbGl0KHMpLGg9MCxpPWcubGVuZ3RoO2lmKHAuaXNGdW5jdGlvbihjKSlmb3IoO2g8aTtoKyspZD1nW2hdLGY9L15cXCsvLnRlc3QoZCksZiYmKGQ9ZC5zdWJzdHIoMSl8fFwiKlwiKSxlPWFbZF09YVtkXXx8W10sZVtmP1widW5zaGlmdFwiOlwicHVzaFwiXShjKX19ZnVuY3Rpb24gY0EoYSxjLGQsZSxmLGcpe2Y9Znx8Yy5kYXRhVHlwZXNbMF0sZz1nfHx7fSxnW2ZdPSEwO3ZhciBoLGk9YVtmXSxqPTAsaz1pP2kubGVuZ3RoOjAsbD1hPT09Y3Y7Zm9yKDtqPGsmJihsfHwhaCk7aisrKWg9aVtqXShjLGQsZSksdHlwZW9mIGg9PVwic3RyaW5nXCImJighbHx8Z1toXT9oPWI6KGMuZGF0YVR5cGVzLnVuc2hpZnQoaCksaD1jQShhLGMsZCxlLGgsZykpKTtyZXR1cm4obHx8IWgpJiYhZ1tcIipcIl0mJihoPWNBKGEsYyxkLGUsXCIqXCIsZykpLGh9ZnVuY3Rpb24gY0IoYSxjKXt2YXIgZCxlLGY9cC5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnN8fHt9O2ZvcihkIGluIGMpY1tkXSE9PWImJigoZltkXT9hOmV8fChlPXt9KSlbZF09Y1tkXSk7ZSYmcC5leHRlbmQoITAsYSxlKX1mdW5jdGlvbiBjQyhhLGMsZCl7dmFyIGUsZixnLGgsaT1hLmNvbnRlbnRzLGo9YS5kYXRhVHlwZXMsaz1hLnJlc3BvbnNlRmllbGRzO2ZvcihmIGluIGspZiBpbiBkJiYoY1trW2ZdXT1kW2ZdKTt3aGlsZShqWzBdPT09XCIqXCIpai5zaGlmdCgpLGU9PT1iJiYoZT1hLm1pbWVUeXBlfHxjLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpKTtpZihlKWZvcihmIGluIGkpaWYoaVtmXSYmaVtmXS50ZXN0KGUpKXtqLnVuc2hpZnQoZik7YnJlYWt9aWYoalswXWluIGQpZz1qWzBdO2Vsc2V7Zm9yKGYgaW4gZCl7aWYoIWpbMF18fGEuY29udmVydGVyc1tmK1wiIFwiK2pbMF1dKXtnPWY7YnJlYWt9aHx8KGg9Zil9Zz1nfHxofWlmKGcpcmV0dXJuIGchPT1qWzBdJiZqLnVuc2hpZnQoZyksZFtnXX1mdW5jdGlvbiBjRChhLGIpe3ZhciBjLGQsZSxmLGc9YS5kYXRhVHlwZXMuc2xpY2UoKSxoPWdbMF0saT17fSxqPTA7YS5kYXRhRmlsdGVyJiYoYj1hLmRhdGFGaWx0ZXIoYixhLmRhdGFUeXBlKSk7aWYoZ1sxXSlmb3IoYyBpbiBhLmNvbnZlcnRlcnMpaVtjLnRvTG93ZXJDYXNlKCldPWEuY29udmVydGVyc1tjXTtmb3IoO2U9Z1srK2pdOylpZihlIT09XCIqXCIpe2lmKGghPT1cIipcIiYmaCE9PWUpe2M9aVtoK1wiIFwiK2VdfHxpW1wiKiBcIitlXTtpZighYylmb3IoZCBpbiBpKXtmPWQuc3BsaXQoXCIgXCIpO2lmKGZbMV09PT1lKXtjPWlbaCtcIiBcIitmWzBdXXx8aVtcIiogXCIrZlswXV07aWYoYyl7Yz09PSEwP2M9aVtkXTppW2RdIT09ITAmJihlPWZbMF0sZy5zcGxpY2Uoai0tLDAsZSkpO2JyZWFrfX19aWYoYyE9PSEwKWlmKGMmJmFbXCJ0aHJvd3NcIl0pYj1jKGIpO2Vsc2UgdHJ5e2I9YyhiKX1jYXRjaChrKXtyZXR1cm57c3RhdGU6XCJwYXJzZXJlcnJvclwiLGVycm9yOmM/azpcIk5vIGNvbnZlcnNpb24gZnJvbSBcIitoK1wiIHRvIFwiK2V9fX1oPWV9cmV0dXJue3N0YXRlOlwic3VjY2Vzc1wiLGRhdGE6Yn19ZnVuY3Rpb24gY0woKXt0cnl7cmV0dXJuIG5ldyBhLlhNTEh0dHBSZXF1ZXN0fWNhdGNoKGIpe319ZnVuY3Rpb24gY00oKXt0cnl7cmV0dXJuIG5ldyBhLkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKX1jYXRjaChiKXt9fWZ1bmN0aW9uIGNVKCl7cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtjTj1ifSwwKSxjTj1wLm5vdygpfWZ1bmN0aW9uIGNWKGEsYil7cC5lYWNoKGIsZnVuY3Rpb24oYixjKXt2YXIgZD0oY1RbYl18fFtdKS5jb25jYXQoY1RbXCIqXCJdKSxlPTAsZj1kLmxlbmd0aDtmb3IoO2U8ZjtlKyspaWYoZFtlXS5jYWxsKGEsYixjKSlyZXR1cm59KX1mdW5jdGlvbiBjVyhhLGIsYyl7dmFyIGQsZT0wLGY9MCxnPWNTLmxlbmd0aCxoPXAuRGVmZXJyZWQoKS5hbHdheXMoZnVuY3Rpb24oKXtkZWxldGUgaS5lbGVtfSksaT1mdW5jdGlvbigpe3ZhciBiPWNOfHxjVSgpLGM9TWF0aC5tYXgoMCxqLnN0YXJ0VGltZStqLmR1cmF0aW9uLWIpLGQ9MS0oYy9qLmR1cmF0aW9ufHwwKSxlPTAsZj1qLnR3ZWVucy5sZW5ndGg7Zm9yKDtlPGY7ZSsrKWoudHdlZW5zW2VdLnJ1bihkKTtyZXR1cm4gaC5ub3RpZnlXaXRoKGEsW2osZCxjXSksZDwxJiZmP2M6KGgucmVzb2x2ZVdpdGgoYSxbal0pLCExKX0saj1oLnByb21pc2Uoe2VsZW06YSxwcm9wczpwLmV4dGVuZCh7fSxiKSxvcHRzOnAuZXh0ZW5kKCEwLHtzcGVjaWFsRWFzaW5nOnt9fSxjKSxvcmlnaW5hbFByb3BlcnRpZXM6YixvcmlnaW5hbE9wdGlvbnM6YyxzdGFydFRpbWU6Y058fGNVKCksZHVyYXRpb246Yy5kdXJhdGlvbix0d2VlbnM6W10sY3JlYXRlVHdlZW46ZnVuY3Rpb24oYixjLGQpe3ZhciBlPXAuVHdlZW4oYSxqLm9wdHMsYixjLGoub3B0cy5zcGVjaWFsRWFzaW5nW2JdfHxqLm9wdHMuZWFzaW5nKTtyZXR1cm4gai50d2VlbnMucHVzaChlKSxlfSxzdG9wOmZ1bmN0aW9uKGIpe3ZhciBjPTAsZD1iP2oudHdlZW5zLmxlbmd0aDowO2Zvcig7YzxkO2MrKylqLnR3ZWVuc1tjXS5ydW4oMSk7cmV0dXJuIGI/aC5yZXNvbHZlV2l0aChhLFtqLGJdKTpoLnJlamVjdFdpdGgoYSxbaixiXSksdGhpc319KSxrPWoucHJvcHM7Y1goayxqLm9wdHMuc3BlY2lhbEVhc2luZyk7Zm9yKDtlPGc7ZSsrKXtkPWNTW2VdLmNhbGwoaixhLGssai5vcHRzKTtpZihkKXJldHVybiBkfXJldHVybiBjVihqLGspLHAuaXNGdW5jdGlvbihqLm9wdHMuc3RhcnQpJiZqLm9wdHMuc3RhcnQuY2FsbChhLGopLHAuZngudGltZXIocC5leHRlbmQoaSx7YW5pbTpqLHF1ZXVlOmoub3B0cy5xdWV1ZSxlbGVtOmF9KSksai5wcm9ncmVzcyhqLm9wdHMucHJvZ3Jlc3MpLmRvbmUoai5vcHRzLmRvbmUsai5vcHRzLmNvbXBsZXRlKS5mYWlsKGoub3B0cy5mYWlsKS5hbHdheXMoai5vcHRzLmFsd2F5cyl9ZnVuY3Rpb24gY1goYSxiKXt2YXIgYyxkLGUsZixnO2ZvcihjIGluIGEpe2Q9cC5jYW1lbENhc2UoYyksZT1iW2RdLGY9YVtjXSxwLmlzQXJyYXkoZikmJihlPWZbMV0sZj1hW2NdPWZbMF0pLGMhPT1kJiYoYVtkXT1mLGRlbGV0ZSBhW2NdKSxnPXAuY3NzSG9va3NbZF07aWYoZyYmXCJleHBhbmRcImluIGcpe2Y9Zy5leHBhbmQoZiksZGVsZXRlIGFbZF07Zm9yKGMgaW4gZiljIGluIGF8fChhW2NdPWZbY10sYltjXT1lKX1lbHNlIGJbZF09ZX19ZnVuY3Rpb24gY1koYSxiLGMpe3ZhciBkLGUsZixnLGgsaSxqLGssbD10aGlzLG09YS5zdHlsZSxuPXt9LG89W10scT1hLm5vZGVUeXBlJiZiWihhKTtjLnF1ZXVlfHwoaj1wLl9xdWV1ZUhvb2tzKGEsXCJmeFwiKSxqLnVucXVldWVkPT1udWxsJiYoai51bnF1ZXVlZD0wLGs9ai5lbXB0eS5maXJlLGouZW1wdHkuZmlyZT1mdW5jdGlvbigpe2oudW5xdWV1ZWR8fGsoKX0pLGoudW5xdWV1ZWQrKyxsLmFsd2F5cyhmdW5jdGlvbigpe2wuYWx3YXlzKGZ1bmN0aW9uKCl7ai51bnF1ZXVlZC0tLHAucXVldWUoYSxcImZ4XCIpLmxlbmd0aHx8ai5lbXB0eS5maXJlKCl9KX0pKSxhLm5vZGVUeXBlPT09MSYmKFwiaGVpZ2h0XCJpbiBifHxcIndpZHRoXCJpbiBiKSYmKGMub3ZlcmZsb3c9W20ub3ZlcmZsb3csbS5vdmVyZmxvd1gsbS5vdmVyZmxvd1ldLHAuY3NzKGEsXCJkaXNwbGF5XCIpPT09XCJpbmxpbmVcIiYmcC5jc3MoYSxcImZsb2F0XCIpPT09XCJub25lXCImJighcC5zdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXR8fGNjKGEubm9kZU5hbWUpPT09XCJpbmxpbmVcIj9tLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIjptLnpvb209MSkpLGMub3ZlcmZsb3cmJihtLm92ZXJmbG93PVwiaGlkZGVuXCIscC5zdXBwb3J0LnNocmlua1dyYXBCbG9ja3N8fGwuZG9uZShmdW5jdGlvbigpe20ub3ZlcmZsb3c9Yy5vdmVyZmxvd1swXSxtLm92ZXJmbG93WD1jLm92ZXJmbG93WzFdLG0ub3ZlcmZsb3dZPWMub3ZlcmZsb3dbMl19KSk7Zm9yKGQgaW4gYil7Zj1iW2RdO2lmKGNQLmV4ZWMoZikpe2RlbGV0ZSBiW2RdO2lmKGY9PT0ocT9cImhpZGVcIjpcInNob3dcIikpY29udGludWU7by5wdXNoKGQpfX1nPW8ubGVuZ3RoO2lmKGcpe2g9cC5fZGF0YShhLFwiZnhzaG93XCIpfHxwLl9kYXRhKGEsXCJmeHNob3dcIix7fSkscT9wKGEpLnNob3coKTpsLmRvbmUoZnVuY3Rpb24oKXtwKGEpLmhpZGUoKX0pLGwuZG9uZShmdW5jdGlvbigpe3ZhciBiO3AucmVtb3ZlRGF0YShhLFwiZnhzaG93XCIsITApO2ZvcihiIGluIG4pcC5zdHlsZShhLGIsbltiXSl9KTtmb3IoZD0wO2Q8ZztkKyspZT1vW2RdLGk9bC5jcmVhdGVUd2VlbihlLHE/aFtlXTowKSxuW2VdPWhbZV18fHAuc3R5bGUoYSxlKSxlIGluIGh8fChoW2VdPWkuc3RhcnQscSYmKGkuZW5kPWkuc3RhcnQsaS5zdGFydD1lPT09XCJ3aWR0aFwifHxlPT09XCJoZWlnaHRcIj8xOjApKX19ZnVuY3Rpb24gY1ooYSxiLGMsZCxlKXtyZXR1cm4gbmV3IGNaLnByb3RvdHlwZS5pbml0KGEsYixjLGQsZSl9ZnVuY3Rpb24gYyQoYSxiKXt2YXIgYyxkPXtoZWlnaHQ6YX0sZT0wO2I9Yj8xOjA7Zm9yKDtlPDQ7ZSs9Mi1iKWM9YlZbZV0sZFtcIm1hcmdpblwiK2NdPWRbXCJwYWRkaW5nXCIrY109YTtyZXR1cm4gYiYmKGQub3BhY2l0eT1kLndpZHRoPWEpLGR9ZnVuY3Rpb24gZGEoYSl7cmV0dXJuIHAuaXNXaW5kb3coYSk/YTphLm5vZGVUeXBlPT09OT9hLmRlZmF1bHRWaWV3fHxhLnBhcmVudFdpbmRvdzohMX12YXIgYyxkLGU9YS5kb2N1bWVudCxmPWEubG9jYXRpb24sZz1hLm5hdmlnYXRvcixoPWEualF1ZXJ5LGk9YS4kLGo9QXJyYXkucHJvdG90eXBlLnB1c2gsaz1BcnJheS5wcm90b3R5cGUuc2xpY2UsbD1BcnJheS5wcm90b3R5cGUuaW5kZXhPZixtPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsbj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LG89U3RyaW5nLnByb3RvdHlwZS50cmltLHA9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IHAuZm4uaW5pdChhLGIsYyl9LHE9L1tcXC0rXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVtcXC0rXT9cXGQrfCkvLnNvdXJjZSxyPS9cXFMvLHM9L1xccysvLHQ9L15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLHU9L14oPzpbXiM8XSooPFtcXHdcXFddKz4pW14+XSokfCMoW1xcd1xcLV0qKSQpLyx2PS9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyx3PS9eW1xcXSw6e31cXHNdKiQvLHg9Lyg/Ol58OnwsKSg/OlxccypcXFspKy9nLHk9L1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbXFxkYS1mQS1GXXs0fSkvZyx6PS9cIlteXCJcXFxcXFxyXFxuXSpcInx0cnVlfGZhbHNlfG51bGx8LT8oPzpcXGRcXGQqXFwufClcXGQrKD86W2VFXVtcXC0rXT9cXGQrfCkvZyxBPS9eLW1zLS8sQj0vLShbXFxkYS16XSkvZ2ksQz1mdW5jdGlvbihhLGIpe3JldHVybihiK1wiXCIpLnRvVXBwZXJDYXNlKCl9LEQ9ZnVuY3Rpb24oKXtlLmFkZEV2ZW50TGlzdGVuZXI/KGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixELCExKSxwLnJlYWR5KCkpOmUucmVhZHlTdGF0ZT09PVwiY29tcGxldGVcIiYmKGUuZGV0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixEKSxwLnJlYWR5KCkpfSxFPXt9O3AuZm49cC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOnAsaW5pdDpmdW5jdGlvbihhLGMsZCl7dmFyIGYsZyxoLGk7aWYoIWEpcmV0dXJuIHRoaXM7aWYoYS5ub2RlVHlwZSlyZXR1cm4gdGhpcy5jb250ZXh0PXRoaXNbMF09YSx0aGlzLmxlbmd0aD0xLHRoaXM7aWYodHlwZW9mIGE9PVwic3RyaW5nXCIpe2EuY2hhckF0KDApPT09XCI8XCImJmEuY2hhckF0KGEubGVuZ3RoLTEpPT09XCI+XCImJmEubGVuZ3RoPj0zP2Y9W251bGwsYSxudWxsXTpmPXUuZXhlYyhhKTtpZihmJiYoZlsxXXx8IWMpKXtpZihmWzFdKXJldHVybiBjPWMgaW5zdGFuY2VvZiBwP2NbMF06YyxpPWMmJmMubm9kZVR5cGU/Yy5vd25lckRvY3VtZW50fHxjOmUsYT1wLnBhcnNlSFRNTChmWzFdLGksITApLHYudGVzdChmWzFdKSYmcC5pc1BsYWluT2JqZWN0KGMpJiZ0aGlzLmF0dHIuY2FsbChhLGMsITApLHAubWVyZ2UodGhpcyxhKTtnPWUuZ2V0RWxlbWVudEJ5SWQoZlsyXSk7aWYoZyYmZy5wYXJlbnROb2RlKXtpZihnLmlkIT09ZlsyXSlyZXR1cm4gZC5maW5kKGEpO3RoaXMubGVuZ3RoPTEsdGhpc1swXT1nfXJldHVybiB0aGlzLmNvbnRleHQ9ZSx0aGlzLnNlbGVjdG9yPWEsdGhpc31yZXR1cm4hY3x8Yy5qcXVlcnk/KGN8fGQpLmZpbmQoYSk6dGhpcy5jb25zdHJ1Y3RvcihjKS5maW5kKGEpfXJldHVybiBwLmlzRnVuY3Rpb24oYSk/ZC5yZWFkeShhKTooYS5zZWxlY3RvciE9PWImJih0aGlzLnNlbGVjdG9yPWEuc2VsZWN0b3IsdGhpcy5jb250ZXh0PWEuY29udGV4dCkscC5tYWtlQXJyYXkoYSx0aGlzKSl9LHNlbGVjdG9yOlwiXCIsanF1ZXJ5OlwiMS44LjJcIixsZW5ndGg6MCxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RofSx0b0FycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIGsuY2FsbCh0aGlzKX0sZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsP3RoaXMudG9BcnJheSgpOmE8MD90aGlzW3RoaXMubGVuZ3RoK2FdOnRoaXNbYV19LHB1c2hTdGFjazpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9cC5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksYSk7cmV0dXJuIGQucHJldk9iamVjdD10aGlzLGQuY29udGV4dD10aGlzLmNvbnRleHQsYj09PVwiZmluZFwiP2Quc2VsZWN0b3I9dGhpcy5zZWxlY3RvcisodGhpcy5zZWxlY3Rvcj9cIiBcIjpcIlwiKStjOmImJihkLnNlbGVjdG9yPXRoaXMuc2VsZWN0b3IrXCIuXCIrYitcIihcIitjK1wiKVwiKSxkfSxlYWNoOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHAuZWFjaCh0aGlzLGEsYil9LHJlYWR5OmZ1bmN0aW9uKGEpe3JldHVybiBwLnJlYWR5LnByb21pc2UoKS5kb25lKGEpLHRoaXN9LGVxOmZ1bmN0aW9uKGEpe3JldHVybiBhPSthLGE9PT0tMT90aGlzLnNsaWNlKGEpOnRoaXMuc2xpY2UoYSxhKzEpfSxmaXJzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxsYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoLTEpfSxzbGljZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB1c2hTdGFjayhrLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxcInNsaWNlXCIsay5jYWxsKGFyZ3VtZW50cykuam9pbihcIixcIikpfSxtYXA6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHAubWFwKHRoaXMsZnVuY3Rpb24oYixjKXtyZXR1cm4gYS5jYWxsKGIsYyxiKX0pKX0sZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJldk9iamVjdHx8dGhpcy5jb25zdHJ1Y3RvcihudWxsKX0scHVzaDpqLHNvcnQ6W10uc29ydCxzcGxpY2U6W10uc3BsaWNlfSxwLmZuLmluaXQucHJvdG90eXBlPXAuZm4scC5leHRlbmQ9cC5mbi5leHRlbmQ9ZnVuY3Rpb24oKXt2YXIgYSxjLGQsZSxmLGcsaD1hcmd1bWVudHNbMF18fHt9LGk9MSxqPWFyZ3VtZW50cy5sZW5ndGgsaz0hMTt0eXBlb2YgaD09XCJib29sZWFuXCImJihrPWgsaD1hcmd1bWVudHNbMV18fHt9LGk9MiksdHlwZW9mIGghPVwib2JqZWN0XCImJiFwLmlzRnVuY3Rpb24oaCkmJihoPXt9KSxqPT09aSYmKGg9dGhpcywtLWkpO2Zvcig7aTxqO2krKylpZigoYT1hcmd1bWVudHNbaV0pIT1udWxsKWZvcihjIGluIGEpe2Q9aFtjXSxlPWFbY107aWYoaD09PWUpY29udGludWU7ayYmZSYmKHAuaXNQbGFpbk9iamVjdChlKXx8KGY9cC5pc0FycmF5KGUpKSk/KGY/KGY9ITEsZz1kJiZwLmlzQXJyYXkoZCk/ZDpbXSk6Zz1kJiZwLmlzUGxhaW5PYmplY3QoZCk/ZDp7fSxoW2NdPXAuZXh0ZW5kKGssZyxlKSk6ZSE9PWImJihoW2NdPWUpfXJldHVybiBofSxwLmV4dGVuZCh7bm9Db25mbGljdDpmdW5jdGlvbihiKXtyZXR1cm4gYS4kPT09cCYmKGEuJD1pKSxiJiZhLmpRdWVyeT09PXAmJihhLmpRdWVyeT1oKSxwfSxpc1JlYWR5OiExLHJlYWR5V2FpdDoxLGhvbGRSZWFkeTpmdW5jdGlvbihhKXthP3AucmVhZHlXYWl0Kys6cC5yZWFkeSghMCl9LHJlYWR5OmZ1bmN0aW9uKGEpe2lmKGE9PT0hMD8tLXAucmVhZHlXYWl0OnAuaXNSZWFkeSlyZXR1cm47aWYoIWUuYm9keSlyZXR1cm4gc2V0VGltZW91dChwLnJlYWR5LDEpO3AuaXNSZWFkeT0hMDtpZihhIT09ITAmJi0tcC5yZWFkeVdhaXQ+MClyZXR1cm47ZC5yZXNvbHZlV2l0aChlLFtwXSkscC5mbi50cmlnZ2VyJiZwKGUpLnRyaWdnZXIoXCJyZWFkeVwiKS5vZmYoXCJyZWFkeVwiKX0saXNGdW5jdGlvbjpmdW5jdGlvbihhKXtyZXR1cm4gcC50eXBlKGEpPT09XCJmdW5jdGlvblwifSxpc0FycmF5OkFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGEpe3JldHVybiBwLnR5cGUoYSk9PT1cImFycmF5XCJ9LGlzV2luZG93OmZ1bmN0aW9uKGEpe3JldHVybiBhIT1udWxsJiZhPT1hLndpbmRvd30saXNOdW1lcmljOmZ1bmN0aW9uKGEpe3JldHVybiFpc05hTihwYXJzZUZsb2F0KGEpKSYmaXNGaW5pdGUoYSl9LHR5cGU6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PW51bGw/U3RyaW5nKGEpOkVbbS5jYWxsKGEpXXx8XCJvYmplY3RcIn0saXNQbGFpbk9iamVjdDpmdW5jdGlvbihhKXtpZighYXx8cC50eXBlKGEpIT09XCJvYmplY3RcInx8YS5ub2RlVHlwZXx8cC5pc1dpbmRvdyhhKSlyZXR1cm4hMTt0cnl7aWYoYS5jb25zdHJ1Y3RvciYmIW4uY2FsbChhLFwiY29uc3RydWN0b3JcIikmJiFuLmNhbGwoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsXCJpc1Byb3RvdHlwZU9mXCIpKXJldHVybiExfWNhdGNoKGMpe3JldHVybiExfXZhciBkO2ZvcihkIGluIGEpO3JldHVybiBkPT09Ynx8bi5jYWxsKGEsZCl9LGlzRW1wdHlPYmplY3Q6ZnVuY3Rpb24oYSl7dmFyIGI7Zm9yKGIgaW4gYSlyZXR1cm4hMTtyZXR1cm4hMH0sZXJyb3I6ZnVuY3Rpb24oYSl7dGhyb3cgbmV3IEVycm9yKGEpfSxwYXJzZUhUTUw6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO3JldHVybiFhfHx0eXBlb2YgYSE9XCJzdHJpbmdcIj9udWxsOih0eXBlb2YgYj09XCJib29sZWFuXCImJihjPWIsYj0wKSxiPWJ8fGUsKGQ9di5leGVjKGEpKT9bYi5jcmVhdGVFbGVtZW50KGRbMV0pXTooZD1wLmJ1aWxkRnJhZ21lbnQoW2FdLGIsYz9udWxsOltdKSxwLm1lcmdlKFtdLChkLmNhY2hlYWJsZT9wLmNsb25lKGQuZnJhZ21lbnQpOmQuZnJhZ21lbnQpLmNoaWxkTm9kZXMpKSl9LHBhcnNlSlNPTjpmdW5jdGlvbihiKXtpZighYnx8dHlwZW9mIGIhPVwic3RyaW5nXCIpcmV0dXJuIG51bGw7Yj1wLnRyaW0oYik7aWYoYS5KU09OJiZhLkpTT04ucGFyc2UpcmV0dXJuIGEuSlNPTi5wYXJzZShiKTtpZih3LnRlc3QoYi5yZXBsYWNlKHksXCJAXCIpLnJlcGxhY2UoeixcIl1cIikucmVwbGFjZSh4LFwiXCIpKSlyZXR1cm4obmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiK2IpKSgpO3AuZXJyb3IoXCJJbnZhbGlkIEpTT046IFwiK2IpfSxwYXJzZVhNTDpmdW5jdGlvbihjKXt2YXIgZCxlO2lmKCFjfHx0eXBlb2YgYyE9XCJzdHJpbmdcIilyZXR1cm4gbnVsbDt0cnl7YS5ET01QYXJzZXI/KGU9bmV3IERPTVBhcnNlcixkPWUucGFyc2VGcm9tU3RyaW5nKGMsXCJ0ZXh0L3htbFwiKSk6KGQ9bmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpLGQuYXN5bmM9XCJmYWxzZVwiLGQubG9hZFhNTChjKSl9Y2F0Y2goZil7ZD1ifXJldHVybighZHx8IWQuZG9jdW1lbnRFbGVtZW50fHxkLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RoKSYmcC5lcnJvcihcIkludmFsaWQgWE1MOiBcIitjKSxkfSxub29wOmZ1bmN0aW9uKCl7fSxnbG9iYWxFdmFsOmZ1bmN0aW9uKGIpe2ImJnIudGVzdChiKSYmKGEuZXhlY1NjcmlwdHx8ZnVuY3Rpb24oYil7YS5ldmFsLmNhbGwoYSxiKX0pKGIpfSxjYW1lbENhc2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZShBLFwibXMtXCIpLnJlcGxhY2UoQixDKX0sbm9kZU5hbWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09Yi50b0xvd2VyQ2FzZSgpfSxlYWNoOmZ1bmN0aW9uKGEsYyxkKXt2YXIgZSxmPTAsZz1hLmxlbmd0aCxoPWc9PT1ifHxwLmlzRnVuY3Rpb24oYSk7aWYoZCl7aWYoaCl7Zm9yKGUgaW4gYSlpZihjLmFwcGx5KGFbZV0sZCk9PT0hMSlicmVha31lbHNlIGZvcig7ZjxnOylpZihjLmFwcGx5KGFbZisrXSxkKT09PSExKWJyZWFrfWVsc2UgaWYoaCl7Zm9yKGUgaW4gYSlpZihjLmNhbGwoYVtlXSxlLGFbZV0pPT09ITEpYnJlYWt9ZWxzZSBmb3IoO2Y8ZzspaWYoYy5jYWxsKGFbZl0sZixhW2YrK10pPT09ITEpYnJlYWs7cmV0dXJuIGF9LHRyaW06byYmIW8uY2FsbChcIu+7v8KgXCIpP2Z1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsP1wiXCI6by5jYWxsKGEpfTpmdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD9cIlwiOihhK1wiXCIpLnJlcGxhY2UodCxcIlwiKX0sbWFrZUFycmF5OmZ1bmN0aW9uKGEsYil7dmFyIGMsZD1ifHxbXTtyZXR1cm4gYSE9bnVsbCYmKGM9cC50eXBlKGEpLGEubGVuZ3RoPT1udWxsfHxjPT09XCJzdHJpbmdcInx8Yz09PVwiZnVuY3Rpb25cInx8Yz09PVwicmVnZXhwXCJ8fHAuaXNXaW5kb3coYSk/ai5jYWxsKGQsYSk6cC5tZXJnZShkLGEpKSxkfSxpbkFycmF5OmZ1bmN0aW9uKGEsYixjKXt2YXIgZDtpZihiKXtpZihsKXJldHVybiBsLmNhbGwoYixhLGMpO2Q9Yi5sZW5ndGgsYz1jP2M8MD9NYXRoLm1heCgwLGQrYyk6YzowO2Zvcig7YzxkO2MrKylpZihjIGluIGImJmJbY109PT1hKXJldHVybiBjfXJldHVybi0xfSxtZXJnZTpmdW5jdGlvbihhLGMpe3ZhciBkPWMubGVuZ3RoLGU9YS5sZW5ndGgsZj0wO2lmKHR5cGVvZiBkPT1cIm51bWJlclwiKWZvcig7ZjxkO2YrKylhW2UrK109Y1tmXTtlbHNlIHdoaWxlKGNbZl0hPT1iKWFbZSsrXT1jW2YrK107cmV0dXJuIGEubGVuZ3RoPWUsYX0sZ3JlcDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZT1bXSxmPTAsZz1hLmxlbmd0aDtjPSEhYztmb3IoO2Y8ZztmKyspZD0hIWIoYVtmXSxmKSxjIT09ZCYmZS5wdXNoKGFbZl0pO3JldHVybiBlfSxtYXA6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlLGYsZz1bXSxoPTAsaT1hLmxlbmd0aCxqPWEgaW5zdGFuY2VvZiBwfHxpIT09YiYmdHlwZW9mIGk9PVwibnVtYmVyXCImJihpPjAmJmFbMF0mJmFbaS0xXXx8aT09PTB8fHAuaXNBcnJheShhKSk7aWYoailmb3IoO2g8aTtoKyspZT1jKGFbaF0saCxkKSxlIT1udWxsJiYoZ1tnLmxlbmd0aF09ZSk7ZWxzZSBmb3IoZiBpbiBhKWU9YyhhW2ZdLGYsZCksZSE9bnVsbCYmKGdbZy5sZW5ndGhdPWUpO3JldHVybiBnLmNvbmNhdC5hcHBseShbXSxnKX0sZ3VpZDoxLHByb3h5OmZ1bmN0aW9uKGEsYyl7dmFyIGQsZSxmO3JldHVybiB0eXBlb2YgYz09XCJzdHJpbmdcIiYmKGQ9YVtjXSxjPWEsYT1kKSxwLmlzRnVuY3Rpb24oYSk/KGU9ay5jYWxsKGFyZ3VtZW50cywyKSxmPWZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkoYyxlLmNvbmNhdChrLmNhbGwoYXJndW1lbnRzKSkpfSxmLmd1aWQ9YS5ndWlkPWEuZ3VpZHx8cC5ndWlkKyssZik6Yn0sYWNjZXNzOmZ1bmN0aW9uKGEsYyxkLGUsZixnLGgpe3ZhciBpLGo9ZD09bnVsbCxrPTAsbD1hLmxlbmd0aDtpZihkJiZ0eXBlb2YgZD09XCJvYmplY3RcIil7Zm9yKGsgaW4gZClwLmFjY2VzcyhhLGMsayxkW2tdLDEsZyxlKTtmPTF9ZWxzZSBpZihlIT09Yil7aT1oPT09YiYmcC5pc0Z1bmN0aW9uKGUpLGomJihpPyhpPWMsYz1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGkuY2FsbChwKGEpLGMpfSk6KGMuY2FsbChhLGUpLGM9bnVsbCkpO2lmKGMpZm9yKDtrPGw7aysrKWMoYVtrXSxkLGk/ZS5jYWxsKGFba10sayxjKGFba10sZCkpOmUsaCk7Zj0xfXJldHVybiBmP2E6aj9jLmNhbGwoYSk6bD9jKGFbMF0sZCk6Z30sbm93OmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCl9fSkscC5yZWFkeS5wcm9taXNlPWZ1bmN0aW9uKGIpe2lmKCFkKXtkPXAuRGVmZXJyZWQoKTtpZihlLnJlYWR5U3RhdGU9PT1cImNvbXBsZXRlXCIpc2V0VGltZW91dChwLnJlYWR5LDEpO2Vsc2UgaWYoZS5hZGRFdmVudExpc3RlbmVyKWUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixELCExKSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIscC5yZWFkeSwhMSk7ZWxzZXtlLmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsRCksYS5hdHRhY2hFdmVudChcIm9ubG9hZFwiLHAucmVhZHkpO3ZhciBjPSExO3RyeXtjPWEuZnJhbWVFbGVtZW50PT1udWxsJiZlLmRvY3VtZW50RWxlbWVudH1jYXRjaChmKXt9YyYmYy5kb1Njcm9sbCYmZnVuY3Rpb24gZygpe2lmKCFwLmlzUmVhZHkpe3RyeXtjLmRvU2Nyb2xsKFwibGVmdFwiKX1jYXRjaChhKXtyZXR1cm4gc2V0VGltZW91dChnLDUwKX1wLnJlYWR5KCl9fSgpfX1yZXR1cm4gZC5wcm9taXNlKGIpfSxwLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0XCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGEsYil7RVtcIltvYmplY3QgXCIrYitcIl1cIl09Yi50b0xvd2VyQ2FzZSgpfSksYz1wKGUpO3ZhciBGPXt9O3AuQ2FsbGJhY2tzPWZ1bmN0aW9uKGEpe2E9dHlwZW9mIGE9PVwic3RyaW5nXCI/RlthXXx8RyhhKTpwLmV4dGVuZCh7fSxhKTt2YXIgYyxkLGUsZixnLGgsaT1bXSxqPSFhLm9uY2UmJltdLGs9ZnVuY3Rpb24oYil7Yz1hLm1lbW9yeSYmYixkPSEwLGg9Znx8MCxmPTAsZz1pLmxlbmd0aCxlPSEwO2Zvcig7aSYmaDxnO2grKylpZihpW2hdLmFwcGx5KGJbMF0sYlsxXSk9PT0hMSYmYS5zdG9wT25GYWxzZSl7Yz0hMTticmVha31lPSExLGkmJihqP2oubGVuZ3RoJiZrKGouc2hpZnQoKSk6Yz9pPVtdOmwuZGlzYWJsZSgpKX0sbD17YWRkOmZ1bmN0aW9uKCl7aWYoaSl7dmFyIGI9aS5sZW5ndGg7KGZ1bmN0aW9uIGQoYil7cC5lYWNoKGIsZnVuY3Rpb24oYixjKXt2YXIgZT1wLnR5cGUoYyk7ZT09PVwiZnVuY3Rpb25cIiYmKCFhLnVuaXF1ZXx8IWwuaGFzKGMpKT9pLnB1c2goYyk6YyYmYy5sZW5ndGgmJmUhPT1cInN0cmluZ1wiJiZkKGMpfSl9KShhcmd1bWVudHMpLGU/Zz1pLmxlbmd0aDpjJiYoZj1iLGsoYykpfXJldHVybiB0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gaSYmcC5lYWNoKGFyZ3VtZW50cyxmdW5jdGlvbihhLGIpe3ZhciBjO3doaWxlKChjPXAuaW5BcnJheShiLGksYykpPi0xKWkuc3BsaWNlKGMsMSksZSYmKGM8PWcmJmctLSxjPD1oJiZoLS0pfSksdGhpc30saGFzOmZ1bmN0aW9uKGEpe3JldHVybiBwLmluQXJyYXkoYSxpKT4tMX0sZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gaT1bXSx0aGlzfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGk9aj1jPWIsdGhpc30sZGlzYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4haX0sbG9jazpmdW5jdGlvbigpe3JldHVybiBqPWIsY3x8bC5kaXNhYmxlKCksdGhpc30sbG9ja2VkOmZ1bmN0aW9uKCl7cmV0dXJuIWp9LGZpcmVXaXRoOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGI9Ynx8W10sYj1bYSxiLnNsaWNlP2Iuc2xpY2UoKTpiXSxpJiYoIWR8fGopJiYoZT9qLnB1c2goYik6ayhiKSksdGhpc30sZmlyZTpmdW5jdGlvbigpe3JldHVybiBsLmZpcmVXaXRoKHRoaXMsYXJndW1lbnRzKSx0aGlzfSxmaXJlZDpmdW5jdGlvbigpe3JldHVybiEhZH19O3JldHVybiBsfSxwLmV4dGVuZCh7RGVmZXJyZWQ6ZnVuY3Rpb24oYSl7dmFyIGI9W1tcInJlc29sdmVcIixcImRvbmVcIixwLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFwicmVzb2x2ZWRcIl0sW1wicmVqZWN0XCIsXCJmYWlsXCIscC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcInJlamVjdGVkXCJdLFtcIm5vdGlmeVwiLFwicHJvZ3Jlc3NcIixwLkNhbGxiYWNrcyhcIm1lbW9yeVwiKV1dLGM9XCJwZW5kaW5nXCIsZD17c3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gY30sYWx3YXlzOmZ1bmN0aW9uKCl7cmV0dXJuIGUuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSx0aGlzfSx0aGVuOmZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzO3JldHVybiBwLkRlZmVycmVkKGZ1bmN0aW9uKGMpe3AuZWFjaChiLGZ1bmN0aW9uKGIsZCl7dmFyIGY9ZFswXSxnPWFbYl07ZVtkWzFdXShwLmlzRnVuY3Rpb24oZyk/ZnVuY3Rpb24oKXt2YXIgYT1nLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthJiZwLmlzRnVuY3Rpb24oYS5wcm9taXNlKT9hLnByb21pc2UoKS5kb25lKGMucmVzb2x2ZSkuZmFpbChjLnJlamVjdCkucHJvZ3Jlc3MoYy5ub3RpZnkpOmNbZitcIldpdGhcIl0odGhpcz09PWU/Yzp0aGlzLFthXSl9OmNbZl0pfSksYT1udWxsfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGEpe3JldHVybiBhIT1udWxsP3AuZXh0ZW5kKGEsZCk6ZH19LGU9e307cmV0dXJuIGQucGlwZT1kLnRoZW4scC5lYWNoKGIsZnVuY3Rpb24oYSxmKXt2YXIgZz1mWzJdLGg9ZlszXTtkW2ZbMV1dPWcuYWRkLGgmJmcuYWRkKGZ1bmN0aW9uKCl7Yz1ofSxiW2FeMV1bMl0uZGlzYWJsZSxiWzJdWzJdLmxvY2spLGVbZlswXV09Zy5maXJlLGVbZlswXStcIldpdGhcIl09Zy5maXJlV2l0aH0pLGQucHJvbWlzZShlKSxhJiZhLmNhbGwoZSxlKSxlfSx3aGVuOmZ1bmN0aW9uKGEpe3ZhciBiPTAsYz1rLmNhbGwoYXJndW1lbnRzKSxkPWMubGVuZ3RoLGU9ZCE9PTF8fGEmJnAuaXNGdW5jdGlvbihhLnByb21pc2UpP2Q6MCxmPWU9PT0xP2E6cC5EZWZlcnJlZCgpLGc9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBmdW5jdGlvbihkKXtiW2FdPXRoaXMsY1thXT1hcmd1bWVudHMubGVuZ3RoPjE/ay5jYWxsKGFyZ3VtZW50cyk6ZCxjPT09aD9mLm5vdGlmeVdpdGgoYixjKTotLWV8fGYucmVzb2x2ZVdpdGgoYixjKX19LGgsaSxqO2lmKGQ+MSl7aD1uZXcgQXJyYXkoZCksaT1uZXcgQXJyYXkoZCksaj1uZXcgQXJyYXkoZCk7Zm9yKDtiPGQ7YisrKWNbYl0mJnAuaXNGdW5jdGlvbihjW2JdLnByb21pc2UpP2NbYl0ucHJvbWlzZSgpLmRvbmUoZyhiLGosYykpLmZhaWwoZi5yZWplY3QpLnByb2dyZXNzKGcoYixpLGgpKTotLWV9cmV0dXJuIGV8fGYucmVzb2x2ZVdpdGgoaixjKSxmLnByb21pc2UoKX19KSxwLnN1cHBvcnQ9ZnVuY3Rpb24oKXt2YXIgYixjLGQsZixnLGgsaSxqLGssbCxtLG49ZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO24uc2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIsXCJ0XCIpLG4uaW5uZXJIVE1MPVwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCIsYz1uLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSxkPW4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpWzBdLGQuc3R5bGUuY3NzVGV4dD1cInRvcDoxcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41XCI7aWYoIWN8fCFjLmxlbmd0aClyZXR1cm57fTtmPWUuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKSxnPWYuYXBwZW5kQ2hpbGQoZS5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKSxoPW4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXSxiPXtsZWFkaW5nV2hpdGVzcGFjZTpuLmZpcnN0Q2hpbGQubm9kZVR5cGU9PT0zLHRib2R5OiFuLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIikubGVuZ3RoLGh0bWxTZXJpYWxpemU6ISFuLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGlua1wiKS5sZW5ndGgsc3R5bGU6L3RvcC8udGVzdChkLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKSxocmVmTm9ybWFsaXplZDpkLmdldEF0dHJpYnV0ZShcImhyZWZcIik9PT1cIi9hXCIsb3BhY2l0eTovXjAuNS8udGVzdChkLnN0eWxlLm9wYWNpdHkpLGNzc0Zsb2F0OiEhZC5zdHlsZS5jc3NGbG9hdCxjaGVja09uOmgudmFsdWU9PT1cIm9uXCIsb3B0U2VsZWN0ZWQ6Zy5zZWxlY3RlZCxnZXRTZXRBdHRyaWJ1dGU6bi5jbGFzc05hbWUhPT1cInRcIixlbmN0eXBlOiEhZS5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKS5lbmN0eXBlLGh0bWw1Q2xvbmU6ZS5jcmVhdGVFbGVtZW50KFwibmF2XCIpLmNsb25lTm9kZSghMCkub3V0ZXJIVE1MIT09XCI8Om5hdj48LzpuYXY+XCIsYm94TW9kZWw6ZS5jb21wYXRNb2RlPT09XCJDU1MxQ29tcGF0XCIsc3VibWl0QnViYmxlczohMCxjaGFuZ2VCdWJibGVzOiEwLGZvY3VzaW5CdWJibGVzOiExLGRlbGV0ZUV4cGFuZG86ITAsbm9DbG9uZUV2ZW50OiEwLGlubGluZUJsb2NrTmVlZHNMYXlvdXQ6ITEsc2hyaW5rV3JhcEJsb2NrczohMSxyZWxpYWJsZU1hcmdpblJpZ2h0OiEwLGJveFNpemluZ1JlbGlhYmxlOiEwLHBpeGVsUG9zaXRpb246ITF9LGguY2hlY2tlZD0hMCxiLm5vQ2xvbmVDaGVja2VkPWguY2xvbmVOb2RlKCEwKS5jaGVja2VkLGYuZGlzYWJsZWQ9ITAsYi5vcHREaXNhYmxlZD0hZy5kaXNhYmxlZDt0cnl7ZGVsZXRlIG4udGVzdH1jYXRjaChvKXtiLmRlbGV0ZUV4cGFuZG89ITF9IW4uYWRkRXZlbnRMaXN0ZW5lciYmbi5hdHRhY2hFdmVudCYmbi5maXJlRXZlbnQmJihuLmF0dGFjaEV2ZW50KFwib25jbGlja1wiLG09ZnVuY3Rpb24oKXtiLm5vQ2xvbmVFdmVudD0hMX0pLG4uY2xvbmVOb2RlKCEwKS5maXJlRXZlbnQoXCJvbmNsaWNrXCIpLG4uZGV0YWNoRXZlbnQoXCJvbmNsaWNrXCIsbSkpLGg9ZS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksaC52YWx1ZT1cInRcIixoLnNldEF0dHJpYnV0ZShcInR5cGVcIixcInJhZGlvXCIpLGIucmFkaW9WYWx1ZT1oLnZhbHVlPT09XCJ0XCIsaC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsXCJjaGVja2VkXCIpLGguc2V0QXR0cmlidXRlKFwibmFtZVwiLFwidFwiKSxuLmFwcGVuZENoaWxkKGgpLGk9ZS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksaS5hcHBlbmRDaGlsZChuLmxhc3RDaGlsZCksYi5jaGVja0Nsb25lPWkuY2xvbmVOb2RlKCEwKS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5jaGVja2VkLGIuYXBwZW5kQ2hlY2tlZD1oLmNoZWNrZWQsaS5yZW1vdmVDaGlsZChoKSxpLmFwcGVuZENoaWxkKG4pO2lmKG4uYXR0YWNoRXZlbnQpZm9yKGsgaW57c3VibWl0OiEwLGNoYW5nZTohMCxmb2N1c2luOiEwfSlqPVwib25cIitrLGw9aiBpbiBuLGx8fChuLnNldEF0dHJpYnV0ZShqLFwicmV0dXJuO1wiKSxsPXR5cGVvZiBuW2pdPT1cImZ1bmN0aW9uXCIpLGJbaytcIkJ1YmJsZXNcIl09bDtyZXR1cm4gcChmdW5jdGlvbigpe3ZhciBjLGQsZixnLGg9XCJwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOjA7ZGlzcGxheTpibG9jaztvdmVyZmxvdzpoaWRkZW47XCIsaT1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtpZighaSlyZXR1cm47Yz1lLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYy5zdHlsZS5jc3NUZXh0PVwidmlzaWJpbGl0eTpoaWRkZW47Ym9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDtwb3NpdGlvbjpzdGF0aWM7dG9wOjA7bWFyZ2luLXRvcDoxcHhcIixpLmluc2VydEJlZm9yZShjLGkuZmlyc3RDaGlsZCksZD1lLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYy5hcHBlbmRDaGlsZChkKSxkLmlubmVySFRNTD1cIjx0YWJsZT48dHI+PHRkPjwvdGQ+PHRkPnQ8L3RkPjwvdHI+PC90YWJsZT5cIixmPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZFwiKSxmWzBdLnN0eWxlLmNzc1RleHQ9XCJwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOjA7ZGlzcGxheTpub25lXCIsbD1mWzBdLm9mZnNldEhlaWdodD09PTAsZlswXS5zdHlsZS5kaXNwbGF5PVwiXCIsZlsxXS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLGIucmVsaWFibGVIaWRkZW5PZmZzZXRzPWwmJmZbMF0ub2Zmc2V0SGVpZ2h0PT09MCxkLmlubmVySFRNTD1cIlwiLGQuc3R5bGUuY3NzVGV4dD1cImJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjFweDtib3JkZXI6MXB4O2Rpc3BsYXk6YmxvY2s7d2lkdGg6NHB4O21hcmdpbi10b3A6MSU7cG9zaXRpb246YWJzb2x1dGU7dG9wOjElO1wiLGIuYm94U2l6aW5nPWQub2Zmc2V0V2lkdGg9PT00LGIuZG9lc05vdEluY2x1ZGVNYXJnaW5JbkJvZHlPZmZzZXQ9aS5vZmZzZXRUb3AhPT0xLGEuZ2V0Q29tcHV0ZWRTdHlsZSYmKGIucGl4ZWxQb3NpdGlvbj0oYS5nZXRDb21wdXRlZFN0eWxlKGQsbnVsbCl8fHt9KS50b3AhPT1cIjElXCIsYi5ib3hTaXppbmdSZWxpYWJsZT0oYS5nZXRDb21wdXRlZFN0eWxlKGQsbnVsbCl8fHt3aWR0aDpcIjRweFwifSkud2lkdGg9PT1cIjRweFwiLGc9ZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGcuc3R5bGUuY3NzVGV4dD1kLnN0eWxlLmNzc1RleHQ9aCxnLnN0eWxlLm1hcmdpblJpZ2h0PWcuc3R5bGUud2lkdGg9XCIwXCIsZC5zdHlsZS53aWR0aD1cIjFweFwiLGQuYXBwZW5kQ2hpbGQoZyksYi5yZWxpYWJsZU1hcmdpblJpZ2h0PSFwYXJzZUZsb2F0KChhLmdldENvbXB1dGVkU3R5bGUoZyxudWxsKXx8e30pLm1hcmdpblJpZ2h0KSksdHlwZW9mIGQuc3R5bGUuem9vbSE9XCJ1bmRlZmluZWRcIiYmKGQuaW5uZXJIVE1MPVwiXCIsZC5zdHlsZS5jc3NUZXh0PWgrXCJ3aWR0aDoxcHg7cGFkZGluZzoxcHg7ZGlzcGxheTppbmxpbmU7em9vbToxXCIsYi5pbmxpbmVCbG9ja05lZWRzTGF5b3V0PWQub2Zmc2V0V2lkdGg9PT0zLGQuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsZC5zdHlsZS5vdmVyZmxvdz1cInZpc2libGVcIixkLmlubmVySFRNTD1cIjxkaXY+PC9kaXY+XCIsZC5maXJzdENoaWxkLnN0eWxlLndpZHRoPVwiNXB4XCIsYi5zaHJpbmtXcmFwQmxvY2tzPWQub2Zmc2V0V2lkdGghPT0zLGMuc3R5bGUuem9vbT0xKSxpLnJlbW92ZUNoaWxkKGMpLGM9ZD1mPWc9bnVsbH0pLGkucmVtb3ZlQ2hpbGQobiksYz1kPWY9Zz1oPWk9bj1udWxsLGJ9KCk7dmFyIEg9Lyg/Olxce1tcXHNcXFNdKlxcfXxcXFtbXFxzXFxTXSpcXF0pJC8sST0vKFtBLVpdKS9nO3AuZXh0ZW5kKHtjYWNoZTp7fSxkZWxldGVkSWRzOltdLHV1aWQ6MCxleHBhbmRvOlwialF1ZXJ5XCIrKHAuZm4uanF1ZXJ5K01hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLFwiXCIpLG5vRGF0YTp7ZW1iZWQ6ITAsb2JqZWN0OlwiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwXCIsYXBwbGV0OiEwfSxoYXNEYXRhOmZ1bmN0aW9uKGEpe3JldHVybiBhPWEubm9kZVR5cGU/cC5jYWNoZVthW3AuZXhwYW5kb11dOmFbcC5leHBhbmRvXSwhIWEmJiFLKGEpfSxkYXRhOmZ1bmN0aW9uKGEsYyxkLGUpe2lmKCFwLmFjY2VwdERhdGEoYSkpcmV0dXJuO3ZhciBmLGcsaD1wLmV4cGFuZG8saT10eXBlb2YgYz09XCJzdHJpbmdcIixqPWEubm9kZVR5cGUsaz1qP3AuY2FjaGU6YSxsPWo/YVtoXTphW2hdJiZoO2lmKCghbHx8IWtbbF18fCFlJiYha1tsXS5kYXRhKSYmaSYmZD09PWIpcmV0dXJuO2x8fChqP2FbaF09bD1wLmRlbGV0ZWRJZHMucG9wKCl8fHAuZ3VpZCsrOmw9aCksa1tsXXx8KGtbbF09e30sanx8KGtbbF0udG9KU09OPXAubm9vcCkpO2lmKHR5cGVvZiBjPT1cIm9iamVjdFwifHx0eXBlb2YgYz09XCJmdW5jdGlvblwiKWU/a1tsXT1wLmV4dGVuZChrW2xdLGMpOmtbbF0uZGF0YT1wLmV4dGVuZChrW2xdLmRhdGEsYyk7cmV0dXJuIGY9a1tsXSxlfHwoZi5kYXRhfHwoZi5kYXRhPXt9KSxmPWYuZGF0YSksZCE9PWImJihmW3AuY2FtZWxDYXNlKGMpXT1kKSxpPyhnPWZbY10sZz09bnVsbCYmKGc9ZltwLmNhbWVsQ2FzZShjKV0pKTpnPWYsZ30scmVtb3ZlRGF0YTpmdW5jdGlvbihhLGIsYyl7aWYoIXAuYWNjZXB0RGF0YShhKSlyZXR1cm47dmFyIGQsZSxmLGc9YS5ub2RlVHlwZSxoPWc/cC5jYWNoZTphLGk9Zz9hW3AuZXhwYW5kb106cC5leHBhbmRvO2lmKCFoW2ldKXJldHVybjtpZihiKXtkPWM/aFtpXTpoW2ldLmRhdGE7aWYoZCl7cC5pc0FycmF5KGIpfHwoYiBpbiBkP2I9W2JdOihiPXAuY2FtZWxDYXNlKGIpLGIgaW4gZD9iPVtiXTpiPWIuc3BsaXQoXCIgXCIpKSk7Zm9yKGU9MCxmPWIubGVuZ3RoO2U8ZjtlKyspZGVsZXRlIGRbYltlXV07aWYoIShjP0s6cC5pc0VtcHR5T2JqZWN0KShkKSlyZXR1cm59fWlmKCFjKXtkZWxldGUgaFtpXS5kYXRhO2lmKCFLKGhbaV0pKXJldHVybn1nP3AuY2xlYW5EYXRhKFthXSwhMCk6cC5zdXBwb3J0LmRlbGV0ZUV4cGFuZG98fGghPWgud2luZG93P2RlbGV0ZSBoW2ldOmhbaV09bnVsbH0sX2RhdGE6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBwLmRhdGEoYSxiLGMsITApfSxhY2NlcHREYXRhOmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZU5hbWUmJnAubm9EYXRhW2Eubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07cmV0dXJuIWJ8fGIhPT0hMCYmYS5nZXRBdHRyaWJ1dGUoXCJjbGFzc2lkXCIpPT09Yn19KSxwLmZuLmV4dGVuZCh7ZGF0YTpmdW5jdGlvbihhLGMpe3ZhciBkLGUsZixnLGgsaT10aGlzWzBdLGo9MCxrPW51bGw7aWYoYT09PWIpe2lmKHRoaXMubGVuZ3RoKXtrPXAuZGF0YShpKTtpZihpLm5vZGVUeXBlPT09MSYmIXAuX2RhdGEoaSxcInBhcnNlZEF0dHJzXCIpKXtmPWkuYXR0cmlidXRlcztmb3IoaD1mLmxlbmd0aDtqPGg7aisrKWc9ZltqXS5uYW1lLGcuaW5kZXhPZihcImRhdGEtXCIpfHwoZz1wLmNhbWVsQ2FzZShnLnN1YnN0cmluZyg1KSksSihpLGcsa1tnXSkpO3AuX2RhdGEoaSxcInBhcnNlZEF0dHJzXCIsITApfX1yZXR1cm4ga31yZXR1cm4gdHlwZW9mIGE9PVwib2JqZWN0XCI/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7cC5kYXRhKHRoaXMsYSl9KTooZD1hLnNwbGl0KFwiLlwiLDIpLGRbMV09ZFsxXT9cIi5cIitkWzFdOlwiXCIsZT1kWzFdK1wiIVwiLHAuYWNjZXNzKHRoaXMsZnVuY3Rpb24oYyl7aWYoYz09PWIpcmV0dXJuIGs9dGhpcy50cmlnZ2VySGFuZGxlcihcImdldERhdGFcIitlLFtkWzBdXSksaz09PWImJmkmJihrPXAuZGF0YShpLGEpLGs9SihpLGEsaykpLGs9PT1iJiZkWzFdP3RoaXMuZGF0YShkWzBdKTprO2RbMV09Yyx0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1wKHRoaXMpO2IudHJpZ2dlckhhbmRsZXIoXCJzZXREYXRhXCIrZSxkKSxwLmRhdGEodGhpcyxhLGMpLGIudHJpZ2dlckhhbmRsZXIoXCJjaGFuZ2VEYXRhXCIrZSxkKX0pfSxudWxsLGMsYXJndW1lbnRzLmxlbmd0aD4xLG51bGwsITEpKX0scmVtb3ZlRGF0YTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7cC5yZW1vdmVEYXRhKHRoaXMsYSl9KX19KSxwLmV4dGVuZCh7cXVldWU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO2lmKGEpcmV0dXJuIGI9KGJ8fFwiZnhcIikrXCJxdWV1ZVwiLGQ9cC5fZGF0YShhLGIpLGMmJighZHx8cC5pc0FycmF5KGMpP2Q9cC5fZGF0YShhLGIscC5tYWtlQXJyYXkoYykpOmQucHVzaChjKSksZHx8W119LGRlcXVldWU6ZnVuY3Rpb24oYSxiKXtiPWJ8fFwiZnhcIjt2YXIgYz1wLnF1ZXVlKGEsYiksZD1jLmxlbmd0aCxlPWMuc2hpZnQoKSxmPXAuX3F1ZXVlSG9va3MoYSxiKSxnPWZ1bmN0aW9uKCl7cC5kZXF1ZXVlKGEsYil9O2U9PT1cImlucHJvZ3Jlc3NcIiYmKGU9Yy5zaGlmdCgpLGQtLSksZSYmKGI9PT1cImZ4XCImJmMudW5zaGlmdChcImlucHJvZ3Jlc3NcIiksZGVsZXRlIGYuc3RvcCxlLmNhbGwoYSxnLGYpKSwhZCYmZiYmZi5lbXB0eS5maXJlKCl9LF9xdWV1ZUhvb2tzOmZ1bmN0aW9uKGEsYil7dmFyIGM9YitcInF1ZXVlSG9va3NcIjtyZXR1cm4gcC5fZGF0YShhLGMpfHxwLl9kYXRhKGEsYyx7ZW1wdHk6cC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24oKXtwLnJlbW92ZURhdGEoYSxiK1wicXVldWVcIiwhMCkscC5yZW1vdmVEYXRhKGEsYywhMCl9KX0pfX0pLHAuZm4uZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbihhLGMpe3ZhciBkPTI7cmV0dXJuIHR5cGVvZiBhIT1cInN0cmluZ1wiJiYoYz1hLGE9XCJmeFwiLGQtLSksYXJndW1lbnRzLmxlbmd0aDxkP3AucXVldWUodGhpc1swXSxhKTpjPT09Yj90aGlzOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPXAucXVldWUodGhpcyxhLGMpO3AuX3F1ZXVlSG9va3ModGhpcyxhKSxhPT09XCJmeFwiJiZiWzBdIT09XCJpbnByb2dyZXNzXCImJnAuZGVxdWV1ZSh0aGlzLGEpfSl9LGRlcXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3AuZGVxdWV1ZSh0aGlzLGEpfSl9LGRlbGF5OmZ1bmN0aW9uKGEsYil7cmV0dXJuIGE9cC5meD9wLmZ4LnNwZWVkc1thXXx8YTphLGI9Ynx8XCJmeFwiLHRoaXMucXVldWUoYixmdW5jdGlvbihiLGMpe3ZhciBkPXNldFRpbWVvdXQoYixhKTtjLnN0b3A9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZCl9fSl9LGNsZWFyUXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucXVldWUoYXx8XCJmeFwiLFtdKX0scHJvbWlzZTpmdW5jdGlvbihhLGMpe3ZhciBkLGU9MSxmPXAuRGVmZXJyZWQoKSxnPXRoaXMsaD10aGlzLmxlbmd0aCxpPWZ1bmN0aW9uKCl7LS1lfHxmLnJlc29sdmVXaXRoKGcsW2ddKX07dHlwZW9mIGEhPVwic3RyaW5nXCImJihjPWEsYT1iKSxhPWF8fFwiZnhcIjt3aGlsZShoLS0pZD1wLl9kYXRhKGdbaF0sYStcInF1ZXVlSG9va3NcIiksZCYmZC5lbXB0eSYmKGUrKyxkLmVtcHR5LmFkZChpKSk7cmV0dXJuIGkoKSxmLnByb21pc2UoYyl9fSk7dmFyIEwsTSxOLE89L1tcXHRcXHJcXG5dL2csUD0vXFxyL2csUT0vXig/OmJ1dHRvbnxpbnB1dCkkL2ksUj0vXig/OmJ1dHRvbnxpbnB1dHxvYmplY3R8c2VsZWN0fHRleHRhcmVhKSQvaSxTPS9eYSg/OnJlYXwpJC9pLFQ9L14oPzphdXRvZm9jdXN8YXV0b3BsYXl8YXN5bmN8Y2hlY2tlZHxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZHxzZWxlY3RlZCkkL2ksVT1wLnN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlO3AuZm4uZXh0ZW5kKHthdHRyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHAuYWNjZXNzKHRoaXMscC5hdHRyLGEsYixhcmd1bWVudHMubGVuZ3RoPjEpfSxyZW1vdmVBdHRyOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtwLnJlbW92ZUF0dHIodGhpcyxhKX0pfSxwcm9wOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHAuYWNjZXNzKHRoaXMscC5wcm9wLGEsYixhcmd1bWVudHMubGVuZ3RoPjEpfSxyZW1vdmVQcm9wOmZ1bmN0aW9uKGEpe3JldHVybiBhPXAucHJvcEZpeFthXXx8YSx0aGlzLmVhY2goZnVuY3Rpb24oKXt0cnl7dGhpc1thXT1iLGRlbGV0ZSB0aGlzW2FdfWNhdGNoKGMpe319KX0sYWRkQ2xhc3M6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGg7aWYocC5pc0Z1bmN0aW9uKGEpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYil7cCh0aGlzKS5hZGRDbGFzcyhhLmNhbGwodGhpcyxiLHRoaXMuY2xhc3NOYW1lKSl9KTtpZihhJiZ0eXBlb2YgYT09XCJzdHJpbmdcIil7Yj1hLnNwbGl0KHMpO2ZvcihjPTAsZD10aGlzLmxlbmd0aDtjPGQ7YysrKXtlPXRoaXNbY107aWYoZS5ub2RlVHlwZT09PTEpaWYoIWUuY2xhc3NOYW1lJiZiLmxlbmd0aD09PTEpZS5jbGFzc05hbWU9YTtlbHNle2Y9XCIgXCIrZS5jbGFzc05hbWUrXCIgXCI7Zm9yKGc9MCxoPWIubGVuZ3RoO2c8aDtnKyspZi5pbmRleE9mKFwiIFwiK2JbZ10rXCIgXCIpPDAmJihmKz1iW2ddK1wiIFwiKTtlLmNsYXNzTmFtZT1wLnRyaW0oZil9fX1yZXR1cm4gdGhpc30scmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oYSl7dmFyIGMsZCxlLGYsZyxoLGk7aWYocC5pc0Z1bmN0aW9uKGEpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYil7cCh0aGlzKS5yZW1vdmVDbGFzcyhhLmNhbGwodGhpcyxiLHRoaXMuY2xhc3NOYW1lKSl9KTtpZihhJiZ0eXBlb2YgYT09XCJzdHJpbmdcInx8YT09PWIpe2M9KGF8fFwiXCIpLnNwbGl0KHMpO2ZvcihoPTAsaT10aGlzLmxlbmd0aDtoPGk7aCsrKXtlPXRoaXNbaF07aWYoZS5ub2RlVHlwZT09PTEmJmUuY2xhc3NOYW1lKXtkPShcIiBcIitlLmNsYXNzTmFtZStcIiBcIikucmVwbGFjZShPLFwiIFwiKTtmb3IoZj0wLGc9Yy5sZW5ndGg7ZjxnO2YrKyl3aGlsZShkLmluZGV4T2YoXCIgXCIrY1tmXStcIiBcIik+PTApZD1kLnJlcGxhY2UoXCIgXCIrY1tmXStcIiBcIixcIiBcIik7ZS5jbGFzc05hbWU9YT9wLnRyaW0oZCk6XCJcIn19fXJldHVybiB0aGlzfSx0b2dnbGVDbGFzczpmdW5jdGlvbihhLGIpe3ZhciBjPXR5cGVvZiBhLGQ9dHlwZW9mIGI9PVwiYm9vbGVhblwiO3JldHVybiBwLmlzRnVuY3Rpb24oYSk/dGhpcy5lYWNoKGZ1bmN0aW9uKGMpe3AodGhpcykudG9nZ2xlQ2xhc3MoYS5jYWxsKHRoaXMsYyx0aGlzLmNsYXNzTmFtZSxiKSxiKX0pOnRoaXMuZWFjaChmdW5jdGlvbigpe2lmKGM9PT1cInN0cmluZ1wiKXt2YXIgZSxmPTAsZz1wKHRoaXMpLGg9YixpPWEuc3BsaXQocyk7d2hpbGUoZT1pW2YrK10paD1kP2g6IWcuaGFzQ2xhc3MoZSksZ1toP1wiYWRkQ2xhc3NcIjpcInJlbW92ZUNsYXNzXCJdKGUpfWVsc2UgaWYoYz09PVwidW5kZWZpbmVkXCJ8fGM9PT1cImJvb2xlYW5cIil0aGlzLmNsYXNzTmFtZSYmcC5fZGF0YSh0aGlzLFwiX19jbGFzc05hbWVfX1wiLHRoaXMuY2xhc3NOYW1lKSx0aGlzLmNsYXNzTmFtZT10aGlzLmNsYXNzTmFtZXx8YT09PSExP1wiXCI6cC5fZGF0YSh0aGlzLFwiX19jbGFzc05hbWVfX1wiKXx8XCJcIn0pfSxoYXNDbGFzczpmdW5jdGlvbihhKXt2YXIgYj1cIiBcIithK1wiIFwiLGM9MCxkPXRoaXMubGVuZ3RoO2Zvcig7YzxkO2MrKylpZih0aGlzW2NdLm5vZGVUeXBlPT09MSYmKFwiIFwiK3RoaXNbY10uY2xhc3NOYW1lK1wiIFwiKS5yZXBsYWNlKE8sXCIgXCIpLmluZGV4T2YoYik+PTApcmV0dXJuITA7cmV0dXJuITF9LHZhbDpmdW5jdGlvbihhKXt2YXIgYyxkLGUsZj10aGlzWzBdO2lmKCFhcmd1bWVudHMubGVuZ3RoKXtpZihmKXJldHVybiBjPXAudmFsSG9va3NbZi50eXBlXXx8cC52YWxIb29rc1tmLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLGMmJlwiZ2V0XCJpbiBjJiYoZD1jLmdldChmLFwidmFsdWVcIikpIT09Yj9kOihkPWYudmFsdWUsdHlwZW9mIGQ9PVwic3RyaW5nXCI/ZC5yZXBsYWNlKFAsXCJcIik6ZD09bnVsbD9cIlwiOmQpO3JldHVybn1yZXR1cm4gZT1wLmlzRnVuY3Rpb24oYSksdGhpcy5lYWNoKGZ1bmN0aW9uKGQpe3ZhciBmLGc9cCh0aGlzKTtpZih0aGlzLm5vZGVUeXBlIT09MSlyZXR1cm47ZT9mPWEuY2FsbCh0aGlzLGQsZy52YWwoKSk6Zj1hLGY9PW51bGw/Zj1cIlwiOnR5cGVvZiBmPT1cIm51bWJlclwiP2YrPVwiXCI6cC5pc0FycmF5KGYpJiYoZj1wLm1hcChmLGZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsP1wiXCI6YStcIlwifSkpLGM9cC52YWxIb29rc1t0aGlzLnR5cGVdfHxwLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07aWYoIWN8fCEoXCJzZXRcImluIGMpfHxjLnNldCh0aGlzLGYsXCJ2YWx1ZVwiKT09PWIpdGhpcy52YWx1ZT1mfSl9fSkscC5leHRlbmQoe3ZhbEhvb2tzOntvcHRpb246e2dldDpmdW5jdGlvbihhKXt2YXIgYj1hLmF0dHJpYnV0ZXMudmFsdWU7cmV0dXJuIWJ8fGIuc3BlY2lmaWVkP2EudmFsdWU6YS50ZXh0fX0sc2VsZWN0OntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZj1hLnNlbGVjdGVkSW5kZXgsZz1bXSxoPWEub3B0aW9ucyxpPWEudHlwZT09PVwic2VsZWN0LW9uZVwiO2lmKGY8MClyZXR1cm4gbnVsbDtjPWk/ZjowLGQ9aT9mKzE6aC5sZW5ndGg7Zm9yKDtjPGQ7YysrKXtlPWhbY107aWYoZS5zZWxlY3RlZCYmKHAuc3VwcG9ydC5vcHREaXNhYmxlZD8hZS5kaXNhYmxlZDplLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpPT09bnVsbCkmJighZS5wYXJlbnROb2RlLmRpc2FibGVkfHwhcC5ub2RlTmFtZShlLnBhcmVudE5vZGUsXCJvcHRncm91cFwiKSkpe2I9cChlKS52YWwoKTtpZihpKXJldHVybiBiO2cucHVzaChiKX19cmV0dXJuIGkmJiFnLmxlbmd0aCYmaC5sZW5ndGg/cChoW2ZdKS52YWwoKTpnfSxzZXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1wLm1ha2VBcnJheShiKTtyZXR1cm4gcChhKS5maW5kKFwib3B0aW9uXCIpLmVhY2goZnVuY3Rpb24oKXt0aGlzLnNlbGVjdGVkPXAuaW5BcnJheShwKHRoaXMpLnZhbCgpLGMpPj0wfSksYy5sZW5ndGh8fChhLnNlbGVjdGVkSW5kZXg9LTEpLGN9fX0sYXR0ckZuOnt9LGF0dHI6ZnVuY3Rpb24oYSxjLGQsZSl7dmFyIGYsZyxoLGk9YS5ub2RlVHlwZTtpZighYXx8aT09PTN8fGk9PT04fHxpPT09MilyZXR1cm47aWYoZSYmcC5pc0Z1bmN0aW9uKHAuZm5bY10pKXJldHVybiBwKGEpW2NdKGQpO2lmKHR5cGVvZiBhLmdldEF0dHJpYnV0ZT09XCJ1bmRlZmluZWRcIilyZXR1cm4gcC5wcm9wKGEsYyxkKTtoPWkhPT0xfHwhcC5pc1hNTERvYyhhKSxoJiYoYz1jLnRvTG93ZXJDYXNlKCksZz1wLmF0dHJIb29rc1tjXXx8KFQudGVzdChjKT9NOkwpKTtpZihkIT09Yil7aWYoZD09PW51bGwpe3AucmVtb3ZlQXR0cihhLGMpO3JldHVybn1yZXR1cm4gZyYmXCJzZXRcImluIGcmJmgmJihmPWcuc2V0KGEsZCxjKSkhPT1iP2Y6KGEuc2V0QXR0cmlidXRlKGMsZCtcIlwiKSxkKX1yZXR1cm4gZyYmXCJnZXRcImluIGcmJmgmJihmPWcuZ2V0KGEsYykpIT09bnVsbD9mOihmPWEuZ2V0QXR0cmlidXRlKGMpLGY9PT1udWxsP2I6Zil9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnPTA7aWYoYiYmYS5ub2RlVHlwZT09PTEpe2Q9Yi5zcGxpdChzKTtmb3IoO2c8ZC5sZW5ndGg7ZysrKWU9ZFtnXSxlJiYoYz1wLnByb3BGaXhbZV18fGUsZj1ULnRlc3QoZSksZnx8cC5hdHRyKGEsZSxcIlwiKSxhLnJlbW92ZUF0dHJpYnV0ZShVP2U6YyksZiYmYyBpbiBhJiYoYVtjXT0hMSkpfX0sYXR0ckhvb2tzOnt0eXBlOntzZXQ6ZnVuY3Rpb24oYSxiKXtpZihRLnRlc3QoYS5ub2RlTmFtZSkmJmEucGFyZW50Tm9kZSlwLmVycm9yKFwidHlwZSBwcm9wZXJ0eSBjYW4ndCBiZSBjaGFuZ2VkXCIpO2Vsc2UgaWYoIXAuc3VwcG9ydC5yYWRpb1ZhbHVlJiZiPT09XCJyYWRpb1wiJiZwLm5vZGVOYW1lKGEsXCJpbnB1dFwiKSl7dmFyIGM9YS52YWx1ZTtyZXR1cm4gYS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsYiksYyYmKGEudmFsdWU9YyksYn19fSx2YWx1ZTp7Z2V0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIEwmJnAubm9kZU5hbWUoYSxcImJ1dHRvblwiKT9MLmdldChhLGIpOmIgaW4gYT9hLnZhbHVlOm51bGx9LHNldDpmdW5jdGlvbihhLGIsYyl7aWYoTCYmcC5ub2RlTmFtZShhLFwiYnV0dG9uXCIpKXJldHVybiBMLnNldChhLGIsYyk7YS52YWx1ZT1ifX19LHByb3BGaXg6e3RhYmluZGV4OlwidGFiSW5kZXhcIixyZWFkb25seTpcInJlYWRPbmx5XCIsXCJmb3JcIjpcImh0bWxGb3JcIixcImNsYXNzXCI6XCJjbGFzc05hbWVcIixtYXhsZW5ndGg6XCJtYXhMZW5ndGhcIixjZWxsc3BhY2luZzpcImNlbGxTcGFjaW5nXCIsY2VsbHBhZGRpbmc6XCJjZWxsUGFkZGluZ1wiLHJvd3NwYW46XCJyb3dTcGFuXCIsY29sc3BhbjpcImNvbFNwYW5cIix1c2VtYXA6XCJ1c2VNYXBcIixmcmFtZWJvcmRlcjpcImZyYW1lQm9yZGVyXCIsY29udGVudGVkaXRhYmxlOlwiY29udGVudEVkaXRhYmxlXCJ9LHByb3A6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlLGYsZyxoPWEubm9kZVR5cGU7aWYoIWF8fGg9PT0zfHxoPT09OHx8aD09PTIpcmV0dXJuO3JldHVybiBnPWghPT0xfHwhcC5pc1hNTERvYyhhKSxnJiYoYz1wLnByb3BGaXhbY118fGMsZj1wLnByb3BIb29rc1tjXSksZCE9PWI/ZiYmXCJzZXRcImluIGYmJihlPWYuc2V0KGEsZCxjKSkhPT1iP2U6YVtjXT1kOmYmJlwiZ2V0XCJpbiBmJiYoZT1mLmdldChhLGMpKSE9PW51bGw/ZTphW2NdfSxwcm9wSG9va3M6e3RhYkluZGV4OntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGM9YS5nZXRBdHRyaWJ1dGVOb2RlKFwidGFiaW5kZXhcIik7cmV0dXJuIGMmJmMuc3BlY2lmaWVkP3BhcnNlSW50KGMudmFsdWUsMTApOlIudGVzdChhLm5vZGVOYW1lKXx8Uy50ZXN0KGEubm9kZU5hbWUpJiZhLmhyZWY/MDpifX19fSksTT17Z2V0OmZ1bmN0aW9uKGEsYyl7dmFyIGQsZT1wLnByb3AoYSxjKTtyZXR1cm4gZT09PSEwfHx0eXBlb2YgZSE9XCJib29sZWFuXCImJihkPWEuZ2V0QXR0cmlidXRlTm9kZShjKSkmJmQubm9kZVZhbHVlIT09ITE/Yy50b0xvd2VyQ2FzZSgpOmJ9LHNldDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ7cmV0dXJuIGI9PT0hMT9wLnJlbW92ZUF0dHIoYSxjKTooZD1wLnByb3BGaXhbY118fGMsZCBpbiBhJiYoYVtkXT0hMCksYS5zZXRBdHRyaWJ1dGUoYyxjLnRvTG93ZXJDYXNlKCkpKSxjfX0sVXx8KE49e25hbWU6ITAsaWQ6ITAsY29vcmRzOiEwfSxMPXAudmFsSG9va3MuYnV0dG9uPXtnZXQ6ZnVuY3Rpb24oYSxjKXt2YXIgZDtyZXR1cm4gZD1hLmdldEF0dHJpYnV0ZU5vZGUoYyksZCYmKE5bY10/ZC52YWx1ZSE9PVwiXCI6ZC5zcGVjaWZpZWQpP2QudmFsdWU6Yn0sc2V0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLmdldEF0dHJpYnV0ZU5vZGUoYyk7cmV0dXJuIGR8fChkPWUuY3JlYXRlQXR0cmlidXRlKGMpLGEuc2V0QXR0cmlidXRlTm9kZShkKSksZC52YWx1ZT1iK1wiXCJ9fSxwLmVhY2goW1wid2lkdGhcIixcImhlaWdodFwiXSxmdW5jdGlvbihhLGIpe3AuYXR0ckhvb2tzW2JdPXAuZXh0ZW5kKHAuYXR0ckhvb2tzW2JdLHtzZXQ6ZnVuY3Rpb24oYSxjKXtpZihjPT09XCJcIilyZXR1cm4gYS5zZXRBdHRyaWJ1dGUoYixcImF1dG9cIiksY319KX0pLHAuYXR0ckhvb2tzLmNvbnRlbnRlZGl0YWJsZT17Z2V0OkwuZ2V0LHNldDpmdW5jdGlvbihhLGIsYyl7Yj09PVwiXCImJihiPVwiZmFsc2VcIiksTC5zZXQoYSxiLGMpfX0pLHAuc3VwcG9ydC5ocmVmTm9ybWFsaXplZHx8cC5lYWNoKFtcImhyZWZcIixcInNyY1wiLFwid2lkdGhcIixcImhlaWdodFwiXSxmdW5jdGlvbihhLGMpe3AuYXR0ckhvb2tzW2NdPXAuZXh0ZW5kKHAuYXR0ckhvb2tzW2NdLHtnZXQ6ZnVuY3Rpb24oYSl7dmFyIGQ9YS5nZXRBdHRyaWJ1dGUoYywyKTtyZXR1cm4gZD09PW51bGw/YjpkfX0pfSkscC5zdXBwb3J0LnN0eWxlfHwocC5hdHRySG9va3Muc3R5bGU9e2dldDpmdW5jdGlvbihhKXtyZXR1cm4gYS5zdHlsZS5jc3NUZXh0LnRvTG93ZXJDYXNlKCl8fGJ9LHNldDpmdW5jdGlvbihhLGIpe3JldHVybiBhLnN0eWxlLmNzc1RleHQ9YitcIlwifX0pLHAuc3VwcG9ydC5vcHRTZWxlY3RlZHx8KHAucHJvcEhvb2tzLnNlbGVjdGVkPXAuZXh0ZW5kKHAucHJvcEhvb2tzLnNlbGVjdGVkLHtnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5wYXJlbnROb2RlO3JldHVybiBiJiYoYi5zZWxlY3RlZEluZGV4LGIucGFyZW50Tm9kZSYmYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpLG51bGx9fSkpLHAuc3VwcG9ydC5lbmN0eXBlfHwocC5wcm9wRml4LmVuY3R5cGU9XCJlbmNvZGluZ1wiKSxwLnN1cHBvcnQuY2hlY2tPbnx8cC5lYWNoKFtcInJhZGlvXCIsXCJjaGVja2JveFwiXSxmdW5jdGlvbigpe3AudmFsSG9va3NbdGhpc109e2dldDpmdW5jdGlvbihhKXtyZXR1cm4gYS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKT09PW51bGw/XCJvblwiOmEudmFsdWV9fX0pLHAuZWFjaChbXCJyYWRpb1wiLFwiY2hlY2tib3hcIl0sZnVuY3Rpb24oKXtwLnZhbEhvb2tzW3RoaXNdPXAuZXh0ZW5kKHAudmFsSG9va3NbdGhpc10se3NldDpmdW5jdGlvbihhLGIpe2lmKHAuaXNBcnJheShiKSlyZXR1cm4gYS5jaGVja2VkPXAuaW5BcnJheShwKGEpLnZhbCgpLGIpPj0wfX0pfSk7dmFyIFY9L14oPzp0ZXh0YXJlYXxpbnB1dHxzZWxlY3QpJC9pLFc9L14oW15cXC5dKnwpKD86XFwuKC4rKXwpJC8sWD0vKD86XnxcXHMpaG92ZXIoXFwuXFxTK3wpXFxiLyxZPS9ea2V5LyxaPS9eKD86bW91c2V8Y29udGV4dG1lbnUpfGNsaWNrLywkPS9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxfPWZ1bmN0aW9uKGEpe3JldHVybiBwLmV2ZW50LnNwZWNpYWwuaG92ZXI/YTphLnJlcGxhY2UoWCxcIm1vdXNlZW50ZXIkMSBtb3VzZWxlYXZlJDFcIil9O3AuZXZlbnQ9e2FkZDpmdW5jdGlvbihhLGMsZCxlLGYpe3ZhciBnLGgsaSxqLGssbCxtLG4sbyxxLHI7aWYoYS5ub2RlVHlwZT09PTN8fGEubm9kZVR5cGU9PT04fHwhY3x8IWR8fCEoZz1wLl9kYXRhKGEpKSlyZXR1cm47ZC5oYW5kbGVyJiYobz1kLGQ9by5oYW5kbGVyLGY9by5zZWxlY3RvciksZC5ndWlkfHwoZC5ndWlkPXAuZ3VpZCsrKSxpPWcuZXZlbnRzLGl8fChnLmV2ZW50cz1pPXt9KSxoPWcuaGFuZGxlLGh8fChnLmhhbmRsZT1oPWZ1bmN0aW9uKGEpe3JldHVybiB0eXBlb2YgcCE9XCJ1bmRlZmluZWRcIiYmKCFhfHxwLmV2ZW50LnRyaWdnZXJlZCE9PWEudHlwZSk/cC5ldmVudC5kaXNwYXRjaC5hcHBseShoLmVsZW0sYXJndW1lbnRzKTpifSxoLmVsZW09YSksYz1wLnRyaW0oXyhjKSkuc3BsaXQoXCIgXCIpO2ZvcihqPTA7ajxjLmxlbmd0aDtqKyspe2s9Vy5leGVjKGNbal0pfHxbXSxsPWtbMV0sbT0oa1syXXx8XCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKSxyPXAuZXZlbnQuc3BlY2lhbFtsXXx8e30sbD0oZj9yLmRlbGVnYXRlVHlwZTpyLmJpbmRUeXBlKXx8bCxyPXAuZXZlbnQuc3BlY2lhbFtsXXx8e30sbj1wLmV4dGVuZCh7dHlwZTpsLG9yaWdUeXBlOmtbMV0sZGF0YTplLGhhbmRsZXI6ZCxndWlkOmQuZ3VpZCxzZWxlY3RvcjpmLG5lZWRzQ29udGV4dDpmJiZwLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoZiksbmFtZXNwYWNlOm0uam9pbihcIi5cIil9LG8pLHE9aVtsXTtpZighcSl7cT1pW2xdPVtdLHEuZGVsZWdhdGVDb3VudD0wO2lmKCFyLnNldHVwfHxyLnNldHVwLmNhbGwoYSxlLG0saCk9PT0hMSlhLmFkZEV2ZW50TGlzdGVuZXI/YS5hZGRFdmVudExpc3RlbmVyKGwsaCwhMSk6YS5hdHRhY2hFdmVudCYmYS5hdHRhY2hFdmVudChcIm9uXCIrbCxoKX1yLmFkZCYmKHIuYWRkLmNhbGwoYSxuKSxuLmhhbmRsZXIuZ3VpZHx8KG4uaGFuZGxlci5ndWlkPWQuZ3VpZCkpLGY/cS5zcGxpY2UocS5kZWxlZ2F0ZUNvdW50KyssMCxuKTpxLnB1c2gobikscC5ldmVudC5nbG9iYWxbbF09ITB9YT1udWxsfSxnbG9iYWw6e30scmVtb3ZlOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZyxoLGksaixrLGwsbSxuLG8scSxyPXAuaGFzRGF0YShhKSYmcC5fZGF0YShhKTtpZighcnx8IShtPXIuZXZlbnRzKSlyZXR1cm47Yj1wLnRyaW0oXyhifHxcIlwiKSkuc3BsaXQoXCIgXCIpO2ZvcihmPTA7ZjxiLmxlbmd0aDtmKyspe2c9Vy5leGVjKGJbZl0pfHxbXSxoPWk9Z1sxXSxqPWdbMl07aWYoIWgpe2ZvcihoIGluIG0pcC5ldmVudC5yZW1vdmUoYSxoK2JbZl0sYyxkLCEwKTtjb250aW51ZX1uPXAuZXZlbnQuc3BlY2lhbFtoXXx8e30saD0oZD9uLmRlbGVnYXRlVHlwZTpuLmJpbmRUeXBlKXx8aCxvPW1baF18fFtdLGs9by5sZW5ndGgsaj1qP25ldyBSZWdFeHAoXCIoXnxcXFxcLilcIitqLnNwbGl0KFwiLlwiKS5zb3J0KCkuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpOm51bGw7Zm9yKGw9MDtsPG8ubGVuZ3RoO2wrKylxPW9bbF0sKGV8fGk9PT1xLm9yaWdUeXBlKSYmKCFjfHxjLmd1aWQ9PT1xLmd1aWQpJiYoIWp8fGoudGVzdChxLm5hbWVzcGFjZSkpJiYoIWR8fGQ9PT1xLnNlbGVjdG9yfHxkPT09XCIqKlwiJiZxLnNlbGVjdG9yKSYmKG8uc3BsaWNlKGwtLSwxKSxxLnNlbGVjdG9yJiZvLmRlbGVnYXRlQ291bnQtLSxuLnJlbW92ZSYmbi5yZW1vdmUuY2FsbChhLHEpKTtvLmxlbmd0aD09PTAmJmshPT1vLmxlbmd0aCYmKCghbi50ZWFyZG93bnx8bi50ZWFyZG93bi5jYWxsKGEsaixyLmhhbmRsZSk9PT0hMSkmJnAucmVtb3ZlRXZlbnQoYSxoLHIuaGFuZGxlKSxkZWxldGUgbVtoXSl9cC5pc0VtcHR5T2JqZWN0KG0pJiYoZGVsZXRlIHIuaGFuZGxlLHAucmVtb3ZlRGF0YShhLFwiZXZlbnRzXCIsITApKX0sY3VzdG9tRXZlbnQ6e2dldERhdGE6ITAsc2V0RGF0YTohMCxjaGFuZ2VEYXRhOiEwfSx0cmlnZ2VyOmZ1bmN0aW9uKGMsZCxmLGcpe2lmKCFmfHxmLm5vZGVUeXBlIT09MyYmZi5ub2RlVHlwZSE9PTgpe3ZhciBoLGksaixrLGwsbSxuLG8scSxyLHM9Yy50eXBlfHxjLHQ9W107aWYoJC50ZXN0KHMrcC5ldmVudC50cmlnZ2VyZWQpKXJldHVybjtzLmluZGV4T2YoXCIhXCIpPj0wJiYocz1zLnNsaWNlKDAsLTEpLGk9ITApLHMuaW5kZXhPZihcIi5cIik+PTAmJih0PXMuc3BsaXQoXCIuXCIpLHM9dC5zaGlmdCgpLHQuc29ydCgpKTtpZigoIWZ8fHAuZXZlbnQuY3VzdG9tRXZlbnRbc10pJiYhcC5ldmVudC5nbG9iYWxbc10pcmV0dXJuO2M9dHlwZW9mIGM9PVwib2JqZWN0XCI/Y1twLmV4cGFuZG9dP2M6bmV3IHAuRXZlbnQocyxjKTpuZXcgcC5FdmVudChzKSxjLnR5cGU9cyxjLmlzVHJpZ2dlcj0hMCxjLmV4Y2x1c2l2ZT1pLGMubmFtZXNwYWNlPXQuam9pbihcIi5cIiksYy5uYW1lc3BhY2VfcmU9Yy5uYW1lc3BhY2U/bmV3IFJlZ0V4cChcIihefFxcXFwuKVwiK3Quam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpOm51bGwsbT1zLmluZGV4T2YoXCI6XCIpPDA/XCJvblwiK3M6XCJcIjtpZighZil7aD1wLmNhY2hlO2ZvcihqIGluIGgpaFtqXS5ldmVudHMmJmhbal0uZXZlbnRzW3NdJiZwLmV2ZW50LnRyaWdnZXIoYyxkLGhbal0uaGFuZGxlLmVsZW0sITApO3JldHVybn1jLnJlc3VsdD1iLGMudGFyZ2V0fHwoYy50YXJnZXQ9ZiksZD1kIT1udWxsP3AubWFrZUFycmF5KGQpOltdLGQudW5zaGlmdChjKSxuPXAuZXZlbnQuc3BlY2lhbFtzXXx8e307aWYobi50cmlnZ2VyJiZuLnRyaWdnZXIuYXBwbHkoZixkKT09PSExKXJldHVybjtxPVtbZixuLmJpbmRUeXBlfHxzXV07aWYoIWcmJiFuLm5vQnViYmxlJiYhcC5pc1dpbmRvdyhmKSl7cj1uLmRlbGVnYXRlVHlwZXx8cyxrPSQudGVzdChyK3MpP2Y6Zi5wYXJlbnROb2RlO2ZvcihsPWY7aztrPWsucGFyZW50Tm9kZSlxLnB1c2goW2sscl0pLGw9aztsPT09KGYub3duZXJEb2N1bWVudHx8ZSkmJnEucHVzaChbbC5kZWZhdWx0Vmlld3x8bC5wYXJlbnRXaW5kb3d8fGEscl0pfWZvcihqPTA7ajxxLmxlbmd0aCYmIWMuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtqKyspaz1xW2pdWzBdLGMudHlwZT1xW2pdWzFdLG89KHAuX2RhdGEoayxcImV2ZW50c1wiKXx8e30pW2MudHlwZV0mJnAuX2RhdGEoayxcImhhbmRsZVwiKSxvJiZvLmFwcGx5KGssZCksbz1tJiZrW21dLG8mJnAuYWNjZXB0RGF0YShrKSYmby5hcHBseSYmby5hcHBseShrLGQpPT09ITEmJmMucHJldmVudERlZmF1bHQoKTtyZXR1cm4gYy50eXBlPXMsIWcmJiFjLmlzRGVmYXVsdFByZXZlbnRlZCgpJiYoIW4uX2RlZmF1bHR8fG4uX2RlZmF1bHQuYXBwbHkoZi5vd25lckRvY3VtZW50LGQpPT09ITEpJiYocyE9PVwiY2xpY2tcInx8IXAubm9kZU5hbWUoZixcImFcIikpJiZwLmFjY2VwdERhdGEoZikmJm0mJmZbc10mJihzIT09XCJmb2N1c1wiJiZzIT09XCJibHVyXCJ8fGMudGFyZ2V0Lm9mZnNldFdpZHRoIT09MCkmJiFwLmlzV2luZG93KGYpJiYobD1mW21dLGwmJihmW21dPW51bGwpLHAuZXZlbnQudHJpZ2dlcmVkPXMsZltzXSgpLHAuZXZlbnQudHJpZ2dlcmVkPWIsbCYmKGZbbV09bCkpLGMucmVzdWx0fXJldHVybn0sZGlzcGF0Y2g6ZnVuY3Rpb24oYyl7Yz1wLmV2ZW50LmZpeChjfHxhLmV2ZW50KTt2YXIgZCxlLGYsZyxoLGksaixsLG0sbixvPShwLl9kYXRhKHRoaXMsXCJldmVudHNcIil8fHt9KVtjLnR5cGVdfHxbXSxxPW8uZGVsZWdhdGVDb3VudCxyPWsuY2FsbChhcmd1bWVudHMpLHM9IWMuZXhjbHVzaXZlJiYhYy5uYW1lc3BhY2UsdD1wLmV2ZW50LnNwZWNpYWxbYy50eXBlXXx8e30sdT1bXTtyWzBdPWMsYy5kZWxlZ2F0ZVRhcmdldD10aGlzO2lmKHQucHJlRGlzcGF0Y2gmJnQucHJlRGlzcGF0Y2guY2FsbCh0aGlzLGMpPT09ITEpcmV0dXJuO2lmKHEmJighYy5idXR0b258fGMudHlwZSE9PVwiY2xpY2tcIikpZm9yKGY9Yy50YXJnZXQ7ZiE9dGhpcztmPWYucGFyZW50Tm9kZXx8dGhpcylpZihmLmRpc2FibGVkIT09ITB8fGMudHlwZSE9PVwiY2xpY2tcIil7aD17fSxqPVtdO2ZvcihkPTA7ZDxxO2QrKylsPW9bZF0sbT1sLnNlbGVjdG9yLGhbbV09PT1iJiYoaFttXT1sLm5lZWRzQ29udGV4dD9wKG0sdGhpcykuaW5kZXgoZik+PTA6cC5maW5kKG0sdGhpcyxudWxsLFtmXSkubGVuZ3RoKSxoW21dJiZqLnB1c2gobCk7ai5sZW5ndGgmJnUucHVzaCh7ZWxlbTpmLG1hdGNoZXM6an0pfW8ubGVuZ3RoPnEmJnUucHVzaCh7ZWxlbTp0aGlzLG1hdGNoZXM6by5zbGljZShxKX0pO2ZvcihkPTA7ZDx1Lmxlbmd0aCYmIWMuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtkKyspe2k9dVtkXSxjLmN1cnJlbnRUYXJnZXQ9aS5lbGVtO2ZvcihlPTA7ZTxpLm1hdGNoZXMubGVuZ3RoJiYhYy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpO2UrKyl7bD1pLm1hdGNoZXNbZV07aWYoc3x8IWMubmFtZXNwYWNlJiYhbC5uYW1lc3BhY2V8fGMubmFtZXNwYWNlX3JlJiZjLm5hbWVzcGFjZV9yZS50ZXN0KGwubmFtZXNwYWNlKSljLmRhdGE9bC5kYXRhLGMuaGFuZGxlT2JqPWwsZz0oKHAuZXZlbnQuc3BlY2lhbFtsLm9yaWdUeXBlXXx8e30pLmhhbmRsZXx8bC5oYW5kbGVyKS5hcHBseShpLmVsZW0sciksZyE9PWImJihjLnJlc3VsdD1nLGc9PT0hMSYmKGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpKSl9fXJldHVybiB0LnBvc3REaXNwYXRjaCYmdC5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLGMpLGMucmVzdWx0fSxwcm9wczpcImF0dHJDaGFuZ2UgYXR0ck5hbWUgcmVsYXRlZE5vZGUgc3JjRWxlbWVudCBhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksZml4SG9va3M6e30sa2V5SG9va3M6e3Byb3BzOlwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxmaWx0ZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS53aGljaD09bnVsbCYmKGEud2hpY2g9Yi5jaGFyQ29kZSE9bnVsbD9iLmNoYXJDb2RlOmIua2V5Q29kZSksYX19LG1vdXNlSG9va3M6e3Byb3BzOlwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLGZpbHRlcjpmdW5jdGlvbihhLGMpe3ZhciBkLGYsZyxoPWMuYnV0dG9uLGk9Yy5mcm9tRWxlbWVudDtyZXR1cm4gYS5wYWdlWD09bnVsbCYmYy5jbGllbnRYIT1udWxsJiYoZD1hLnRhcmdldC5vd25lckRvY3VtZW50fHxlLGY9ZC5kb2N1bWVudEVsZW1lbnQsZz1kLmJvZHksYS5wYWdlWD1jLmNsaWVudFgrKGYmJmYuc2Nyb2xsTGVmdHx8ZyYmZy5zY3JvbGxMZWZ0fHwwKS0oZiYmZi5jbGllbnRMZWZ0fHxnJiZnLmNsaWVudExlZnR8fDApLGEucGFnZVk9Yy5jbGllbnRZKyhmJiZmLnNjcm9sbFRvcHx8ZyYmZy5zY3JvbGxUb3B8fDApLShmJiZmLmNsaWVudFRvcHx8ZyYmZy5jbGllbnRUb3B8fDApKSwhYS5yZWxhdGVkVGFyZ2V0JiZpJiYoYS5yZWxhdGVkVGFyZ2V0PWk9PT1hLnRhcmdldD9jLnRvRWxlbWVudDppKSwhYS53aGljaCYmaCE9PWImJihhLndoaWNoPWgmMT8xOmgmMj8zOmgmND8yOjApLGF9fSxmaXg6ZnVuY3Rpb24oYSl7aWYoYVtwLmV4cGFuZG9dKXJldHVybiBhO3ZhciBiLGMsZD1hLGY9cC5ldmVudC5maXhIb29rc1thLnR5cGVdfHx7fSxnPWYucHJvcHM/dGhpcy5wcm9wcy5jb25jYXQoZi5wcm9wcyk6dGhpcy5wcm9wczthPXAuRXZlbnQoZCk7Zm9yKGI9Zy5sZW5ndGg7YjspYz1nWy0tYl0sYVtjXT1kW2NdO3JldHVybiBhLnRhcmdldHx8KGEudGFyZ2V0PWQuc3JjRWxlbWVudHx8ZSksYS50YXJnZXQubm9kZVR5cGU9PT0zJiYoYS50YXJnZXQ9YS50YXJnZXQucGFyZW50Tm9kZSksYS5tZXRhS2V5PSEhYS5tZXRhS2V5LGYuZmlsdGVyP2YuZmlsdGVyKGEsZCk6YX0sc3BlY2lhbDp7bG9hZDp7bm9CdWJibGU6ITB9LGZvY3VzOntkZWxlZ2F0ZVR5cGU6XCJmb2N1c2luXCJ9LGJsdXI6e2RlbGVnYXRlVHlwZTpcImZvY3Vzb3V0XCJ9LGJlZm9yZXVubG9hZDp7c2V0dXA6ZnVuY3Rpb24oYSxiLGMpe3AuaXNXaW5kb3codGhpcykmJih0aGlzLm9uYmVmb3JldW5sb2FkPWMpfSx0ZWFyZG93bjpmdW5jdGlvbihhLGIpe3RoaXMub25iZWZvcmV1bmxvYWQ9PT1iJiYodGhpcy5vbmJlZm9yZXVubG9hZD1udWxsKX19fSxzaW11bGF0ZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1wLmV4dGVuZChuZXcgcC5FdmVudCxjLHt0eXBlOmEsaXNTaW11bGF0ZWQ6ITAsb3JpZ2luYWxFdmVudDp7fX0pO2Q/cC5ldmVudC50cmlnZ2VyKGUsbnVsbCxiKTpwLmV2ZW50LmRpc3BhdGNoLmNhbGwoYixlKSxlLmlzRGVmYXVsdFByZXZlbnRlZCgpJiZjLnByZXZlbnREZWZhdWx0KCl9fSxwLmV2ZW50LmhhbmRsZT1wLmV2ZW50LmRpc3BhdGNoLHAucmVtb3ZlRXZlbnQ9ZS5yZW1vdmVFdmVudExpc3RlbmVyP2Z1bmN0aW9uKGEsYixjKXthLnJlbW92ZUV2ZW50TGlzdGVuZXImJmEucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLGMsITEpfTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9XCJvblwiK2I7YS5kZXRhY2hFdmVudCYmKHR5cGVvZiBhW2RdPT1cInVuZGVmaW5lZFwiJiYoYVtkXT1udWxsKSxhLmRldGFjaEV2ZW50KGQsYykpfSxwLkV2ZW50PWZ1bmN0aW9uKGEsYil7aWYodGhpcyBpbnN0YW5jZW9mIHAuRXZlbnQpYSYmYS50eXBlPyh0aGlzLm9yaWdpbmFsRXZlbnQ9YSx0aGlzLnR5cGU9YS50eXBlLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWEuZGVmYXVsdFByZXZlbnRlZHx8YS5yZXR1cm5WYWx1ZT09PSExfHxhLmdldFByZXZlbnREZWZhdWx0JiZhLmdldFByZXZlbnREZWZhdWx0KCk/YmI6YmEpOnRoaXMudHlwZT1hLGImJnAuZXh0ZW5kKHRoaXMsYiksdGhpcy50aW1lU3RhbXA9YSYmYS50aW1lU3RhbXB8fHAubm93KCksdGhpc1twLmV4cGFuZG9dPSEwO2Vsc2UgcmV0dXJuIG5ldyBwLkV2ZW50KGEsYil9LHAuRXZlbnQucHJvdG90eXBlPXtwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPWJiO3ZhciBhPXRoaXMub3JpZ2luYWxFdmVudDtpZighYSlyZXR1cm47YS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6YS5yZXR1cm5WYWx1ZT0hMX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1iYjt2YXIgYT10aGlzLm9yaWdpbmFsRXZlbnQ7aWYoIWEpcmV0dXJuO2Euc3RvcFByb3BhZ2F0aW9uJiZhLnN0b3BQcm9wYWdhdGlvbigpLGEuY2FuY2VsQnViYmxlPSEwfSxzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPWJiLHRoaXMuc3RvcFByb3BhZ2F0aW9uKCl9LGlzRGVmYXVsdFByZXZlbnRlZDpiYSxpc1Byb3BhZ2F0aW9uU3RvcHBlZDpiYSxpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDpiYX0scC5lYWNoKHttb3VzZWVudGVyOlwibW91c2VvdmVyXCIsbW91c2VsZWF2ZTpcIm1vdXNlb3V0XCJ9LGZ1bmN0aW9uKGEsYil7cC5ldmVudC5zcGVjaWFsW2FdPXtkZWxlZ2F0ZVR5cGU6YixiaW5kVHlwZTpiLGhhbmRsZTpmdW5jdGlvbihhKXt2YXIgYyxkPXRoaXMsZT1hLnJlbGF0ZWRUYXJnZXQsZj1hLmhhbmRsZU9iaixnPWYuc2VsZWN0b3I7aWYoIWV8fGUhPT1kJiYhcC5jb250YWlucyhkLGUpKWEudHlwZT1mLm9yaWdUeXBlLGM9Zi5oYW5kbGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxhLnR5cGU9YjtyZXR1cm4gY319fSkscC5zdXBwb3J0LnN1Ym1pdEJ1YmJsZXN8fChwLmV2ZW50LnNwZWNpYWwuc3VibWl0PXtzZXR1cDpmdW5jdGlvbigpe2lmKHAubm9kZU5hbWUodGhpcyxcImZvcm1cIikpcmV0dXJuITE7cC5ldmVudC5hZGQodGhpcyxcImNsaWNrLl9zdWJtaXQga2V5cHJlc3MuX3N1Ym1pdFwiLGZ1bmN0aW9uKGEpe3ZhciBjPWEudGFyZ2V0LGQ9cC5ub2RlTmFtZShjLFwiaW5wdXRcIil8fHAubm9kZU5hbWUoYyxcImJ1dHRvblwiKT9jLmZvcm06YjtkJiYhcC5fZGF0YShkLFwiX3N1Ym1pdF9hdHRhY2hlZFwiKSYmKHAuZXZlbnQuYWRkKGQsXCJzdWJtaXQuX3N1Ym1pdFwiLGZ1bmN0aW9uKGEpe2EuX3N1Ym1pdF9idWJibGU9ITB9KSxwLl9kYXRhKGQsXCJfc3VibWl0X2F0dGFjaGVkXCIsITApKX0pfSxwb3N0RGlzcGF0Y2g6ZnVuY3Rpb24oYSl7YS5fc3VibWl0X2J1YmJsZSYmKGRlbGV0ZSBhLl9zdWJtaXRfYnViYmxlLHRoaXMucGFyZW50Tm9kZSYmIWEuaXNUcmlnZ2VyJiZwLmV2ZW50LnNpbXVsYXRlKFwic3VibWl0XCIsdGhpcy5wYXJlbnROb2RlLGEsITApKX0sdGVhcmRvd246ZnVuY3Rpb24oKXtpZihwLm5vZGVOYW1lKHRoaXMsXCJmb3JtXCIpKXJldHVybiExO3AuZXZlbnQucmVtb3ZlKHRoaXMsXCIuX3N1Ym1pdFwiKX19KSxwLnN1cHBvcnQuY2hhbmdlQnViYmxlc3x8KHAuZXZlbnQuc3BlY2lhbC5jaGFuZ2U9e3NldHVwOmZ1bmN0aW9uKCl7aWYoVi50ZXN0KHRoaXMubm9kZU5hbWUpKXtpZih0aGlzLnR5cGU9PT1cImNoZWNrYm94XCJ8fHRoaXMudHlwZT09PVwicmFkaW9cIilwLmV2ZW50LmFkZCh0aGlzLFwicHJvcGVydHljaGFuZ2UuX2NoYW5nZVwiLGZ1bmN0aW9uKGEpe2Eub3JpZ2luYWxFdmVudC5wcm9wZXJ0eU5hbWU9PT1cImNoZWNrZWRcIiYmKHRoaXMuX2p1c3RfY2hhbmdlZD0hMCl9KSxwLmV2ZW50LmFkZCh0aGlzLFwiY2xpY2suX2NoYW5nZVwiLGZ1bmN0aW9uKGEpe3RoaXMuX2p1c3RfY2hhbmdlZCYmIWEuaXNUcmlnZ2VyJiYodGhpcy5fanVzdF9jaGFuZ2VkPSExKSxwLmV2ZW50LnNpbXVsYXRlKFwiY2hhbmdlXCIsdGhpcyxhLCEwKX0pO3JldHVybiExfXAuZXZlbnQuYWRkKHRoaXMsXCJiZWZvcmVhY3RpdmF0ZS5fY2hhbmdlXCIsZnVuY3Rpb24oYSl7dmFyIGI9YS50YXJnZXQ7Vi50ZXN0KGIubm9kZU5hbWUpJiYhcC5fZGF0YShiLFwiX2NoYW5nZV9hdHRhY2hlZFwiKSYmKHAuZXZlbnQuYWRkKGIsXCJjaGFuZ2UuX2NoYW5nZVwiLGZ1bmN0aW9uKGEpe3RoaXMucGFyZW50Tm9kZSYmIWEuaXNTaW11bGF0ZWQmJiFhLmlzVHJpZ2dlciYmcC5ldmVudC5zaW11bGF0ZShcImNoYW5nZVwiLHRoaXMucGFyZW50Tm9kZSxhLCEwKX0pLHAuX2RhdGEoYixcIl9jaGFuZ2VfYXR0YWNoZWRcIiwhMCkpfSl9LGhhbmRsZTpmdW5jdGlvbihhKXt2YXIgYj1hLnRhcmdldDtpZih0aGlzIT09Ynx8YS5pc1NpbXVsYXRlZHx8YS5pc1RyaWdnZXJ8fGIudHlwZSE9PVwicmFkaW9cIiYmYi50eXBlIT09XCJjaGVja2JveFwiKXJldHVybiBhLmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sdGVhcmRvd246ZnVuY3Rpb24oKXtyZXR1cm4gcC5ldmVudC5yZW1vdmUodGhpcyxcIi5fY2hhbmdlXCIpLCFWLnRlc3QodGhpcy5ub2RlTmFtZSl9fSkscC5zdXBwb3J0LmZvY3VzaW5CdWJibGVzfHxwLmVhY2goe2ZvY3VzOlwiZm9jdXNpblwiLGJsdXI6XCJmb2N1c291dFwifSxmdW5jdGlvbihhLGIpe3ZhciBjPTAsZD1mdW5jdGlvbihhKXtwLmV2ZW50LnNpbXVsYXRlKGIsYS50YXJnZXQscC5ldmVudC5maXgoYSksITApfTtwLmV2ZW50LnNwZWNpYWxbYl09e3NldHVwOmZ1bmN0aW9uKCl7YysrPT09MCYmZS5hZGRFdmVudExpc3RlbmVyKGEsZCwhMCl9LHRlYXJkb3duOmZ1bmN0aW9uKCl7LS1jPT09MCYmZS5yZW1vdmVFdmVudExpc3RlbmVyKGEsZCwhMCl9fX0pLHAuZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihhLGMsZCxlLGYpe3ZhciBnLGg7aWYodHlwZW9mIGE9PVwib2JqZWN0XCIpe3R5cGVvZiBjIT1cInN0cmluZ1wiJiYoZD1kfHxjLGM9Yik7Zm9yKGggaW4gYSl0aGlzLm9uKGgsYyxkLGFbaF0sZik7cmV0dXJuIHRoaXN9ZD09bnVsbCYmZT09bnVsbD8oZT1jLGQ9Yz1iKTplPT1udWxsJiYodHlwZW9mIGM9PVwic3RyaW5nXCI/KGU9ZCxkPWIpOihlPWQsZD1jLGM9YikpO2lmKGU9PT0hMSllPWJhO2Vsc2UgaWYoIWUpcmV0dXJuIHRoaXM7cmV0dXJuIGY9PT0xJiYoZz1lLGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHAoKS5vZmYoYSksZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGUuZ3VpZD1nLmd1aWR8fChnLmd1aWQ9cC5ndWlkKyspKSx0aGlzLmVhY2goZnVuY3Rpb24oKXtwLmV2ZW50LmFkZCh0aGlzLGEsZSxkLGMpfSl9LG9uZTpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5vbihhLGIsYyxkLDEpfSxvZmY6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlLGY7aWYoYSYmYS5wcmV2ZW50RGVmYXVsdCYmYS5oYW5kbGVPYmopcmV0dXJuIGU9YS5oYW5kbGVPYmoscChhLmRlbGVnYXRlVGFyZ2V0KS5vZmYoZS5uYW1lc3BhY2U/ZS5vcmlnVHlwZStcIi5cIitlLm5hbWVzcGFjZTplLm9yaWdUeXBlLGUuc2VsZWN0b3IsZS5oYW5kbGVyKSx0aGlzO2lmKHR5cGVvZiBhPT1cIm9iamVjdFwiKXtmb3IoZiBpbiBhKXRoaXMub2ZmKGYsYyxhW2ZdKTtyZXR1cm4gdGhpc31pZihjPT09ITF8fHR5cGVvZiBjPT1cImZ1bmN0aW9uXCIpZD1jLGM9YjtyZXR1cm4gZD09PSExJiYoZD1iYSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7cC5ldmVudC5yZW1vdmUodGhpcyxhLGQsYyl9KX0sYmluZDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMub24oYSxudWxsLGIsYyl9LHVuYmluZDpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLm9mZihhLG51bGwsYil9LGxpdmU6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBwKHRoaXMuY29udGV4dCkub24oYSx0aGlzLnNlbGVjdG9yLGIsYyksdGhpc30sZGllOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHAodGhpcy5jb250ZXh0KS5vZmYoYSx0aGlzLnNlbGVjdG9yfHxcIioqXCIsYiksdGhpc30sZGVsZWdhdGU6ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMub24oYixhLGMsZCl9LHVuZGVsZWdhdGU6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPT09MT90aGlzLm9mZihhLFwiKipcIik6dGhpcy5vZmYoYixhfHxcIioqXCIsYyl9LHRyaWdnZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7cC5ldmVudC50cmlnZ2VyKGEsYix0aGlzKX0pfSx0cmlnZ2VySGFuZGxlcjpmdW5jdGlvbihhLGIpe2lmKHRoaXNbMF0pcmV0dXJuIHAuZXZlbnQudHJpZ2dlcihhLGIsdGhpc1swXSwhMCl9LHRvZ2dsZTpmdW5jdGlvbihhKXt2YXIgYj1hcmd1bWVudHMsYz1hLmd1aWR8fHAuZ3VpZCsrLGQ9MCxlPWZ1bmN0aW9uKGMpe3ZhciBlPShwLl9kYXRhKHRoaXMsXCJsYXN0VG9nZ2xlXCIrYS5ndWlkKXx8MCklZDtyZXR1cm4gcC5fZGF0YSh0aGlzLFwibGFzdFRvZ2dsZVwiK2EuZ3VpZCxlKzEpLGMucHJldmVudERlZmF1bHQoKSxiW2VdLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8ITF9O2UuZ3VpZD1jO3doaWxlKGQ8Yi5sZW5ndGgpYltkKytdLmd1aWQ9YztyZXR1cm4gdGhpcy5jbGljayhlKX0saG92ZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5tb3VzZWVudGVyKGEpLm1vdXNlbGVhdmUoYnx8YSl9fSkscC5lYWNoKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhLGIpe3AuZm5bYl09ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYz09bnVsbCYmKGM9YSxhPW51bGwpLGFyZ3VtZW50cy5sZW5ndGg+MD90aGlzLm9uKGIsbnVsbCxhLGMpOnRoaXMudHJpZ2dlcihiKX0sWS50ZXN0KGIpJiYocC5ldmVudC5maXhIb29rc1tiXT1wLmV2ZW50LmtleUhvb2tzKSxaLnRlc3QoYikmJihwLmV2ZW50LmZpeEhvb2tzW2JdPXAuZXZlbnQubW91c2VIb29rcyl9KSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGJjKGEsYixjLGQpe2M9Y3x8W10sYj1ifHxyO3ZhciBlLGYsaSxqLGs9Yi5ub2RlVHlwZTtpZighYXx8dHlwZW9mIGEhPVwic3RyaW5nXCIpcmV0dXJuIGM7aWYoayE9PTEmJmshPT05KXJldHVybltdO2k9ZyhiKTtpZighaSYmIWQpaWYoZT1QLmV4ZWMoYSkpaWYoaj1lWzFdKXtpZihrPT09OSl7Zj1iLmdldEVsZW1lbnRCeUlkKGopO2lmKCFmfHwhZi5wYXJlbnROb2RlKXJldHVybiBjO2lmKGYuaWQ9PT1qKXJldHVybiBjLnB1c2goZiksY31lbHNlIGlmKGIub3duZXJEb2N1bWVudCYmKGY9Yi5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGopKSYmaChiLGYpJiZmLmlkPT09ailyZXR1cm4gYy5wdXNoKGYpLGN9ZWxzZXtpZihlWzJdKXJldHVybiB3LmFwcGx5KGMseC5jYWxsKGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSksMCkpLGM7aWYoKGo9ZVszXSkmJl8mJmIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSlyZXR1cm4gdy5hcHBseShjLHguY2FsbChiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaiksMCkpLGN9cmV0dXJuIGJwKGEucmVwbGFjZShMLFwiJDFcIiksYixjLGQsaSl9ZnVuY3Rpb24gYmQoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBjPWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gYz09PVwiaW5wdXRcIiYmYi50eXBlPT09YX19ZnVuY3Rpb24gYmUoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBjPWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4oYz09PVwiaW5wdXRcInx8Yz09PVwiYnV0dG9uXCIpJiZiLnR5cGU9PT1hfX1mdW5jdGlvbiBiZihhKXtyZXR1cm4geihmdW5jdGlvbihiKXtyZXR1cm4gYj0rYix6KGZ1bmN0aW9uKGMsZCl7dmFyIGUsZj1hKFtdLGMubGVuZ3RoLGIpLGc9Zi5sZW5ndGg7d2hpbGUoZy0tKWNbZT1mW2ddXSYmKGNbZV09IShkW2VdPWNbZV0pKX0pfSl9ZnVuY3Rpb24gYmcoYSxiLGMpe2lmKGE9PT1iKXJldHVybiBjO3ZhciBkPWEubmV4dFNpYmxpbmc7d2hpbGUoZCl7aWYoZD09PWIpcmV0dXJuLTE7ZD1kLm5leHRTaWJsaW5nfXJldHVybiAxfWZ1bmN0aW9uIGJoKGEsYil7dmFyIGMsZCxmLGcsaCxpLGosaz1DW29dW2FdO2lmKGspcmV0dXJuIGI/MDprLnNsaWNlKDApO2g9YSxpPVtdLGo9ZS5wcmVGaWx0ZXI7d2hpbGUoaCl7aWYoIWN8fChkPU0uZXhlYyhoKSkpZCYmKGg9aC5zbGljZShkWzBdLmxlbmd0aCkpLGkucHVzaChmPVtdKTtjPSExO2lmKGQ9Ti5leGVjKGgpKWYucHVzaChjPW5ldyBxKGQuc2hpZnQoKSkpLGg9aC5zbGljZShjLmxlbmd0aCksYy50eXBlPWRbMF0ucmVwbGFjZShMLFwiIFwiKTtmb3IoZyBpbiBlLmZpbHRlcikoZD1XW2ddLmV4ZWMoaCkpJiYoIWpbZ118fChkPWpbZ10oZCxyLCEwKSkpJiYoZi5wdXNoKGM9bmV3IHEoZC5zaGlmdCgpKSksaD1oLnNsaWNlKGMubGVuZ3RoKSxjLnR5cGU9ZyxjLm1hdGNoZXM9ZCk7aWYoIWMpYnJlYWt9cmV0dXJuIGI/aC5sZW5ndGg6aD9iYy5lcnJvcihhKTpDKGEsaSkuc2xpY2UoMCl9ZnVuY3Rpb24gYmkoYSxiLGQpe3ZhciBlPWIuZGlyLGY9ZCYmYi5kaXI9PT1cInBhcmVudE5vZGVcIixnPXUrKztyZXR1cm4gYi5maXJzdD9mdW5jdGlvbihiLGMsZCl7d2hpbGUoYj1iW2VdKWlmKGZ8fGIubm9kZVR5cGU9PT0xKXJldHVybiBhKGIsYyxkKX06ZnVuY3Rpb24oYixkLGgpe2lmKCFoKXt2YXIgaSxqPXQrXCIgXCIrZytcIiBcIixrPWorYzt3aGlsZShiPWJbZV0paWYoZnx8Yi5ub2RlVHlwZT09PTEpe2lmKChpPWJbb10pPT09aylyZXR1cm4gYi5zaXpzZXQ7aWYodHlwZW9mIGk9PVwic3RyaW5nXCImJmkuaW5kZXhPZihqKT09PTApe2lmKGIuc2l6c2V0KXJldHVybiBifWVsc2V7YltvXT1rO2lmKGEoYixkLGgpKXJldHVybiBiLnNpenNldD0hMCxiO2Iuc2l6c2V0PSExfX19ZWxzZSB3aGlsZShiPWJbZV0paWYoZnx8Yi5ub2RlVHlwZT09PTEpaWYoYShiLGQsaCkpcmV0dXJuIGJ9fWZ1bmN0aW9uIGJqKGEpe3JldHVybiBhLmxlbmd0aD4xP2Z1bmN0aW9uKGIsYyxkKXt2YXIgZT1hLmxlbmd0aDt3aGlsZShlLS0paWYoIWFbZV0oYixjLGQpKXJldHVybiExO3JldHVybiEwfTphWzBdfWZ1bmN0aW9uIGJrKGEsYixjLGQsZSl7dmFyIGYsZz1bXSxoPTAsaT1hLmxlbmd0aCxqPWIhPW51bGw7Zm9yKDtoPGk7aCsrKWlmKGY9YVtoXSlpZighY3x8YyhmLGQsZSkpZy5wdXNoKGYpLGomJmIucHVzaChoKTtyZXR1cm4gZ31mdW5jdGlvbiBibChhLGIsYyxkLGUsZil7cmV0dXJuIGQmJiFkW29dJiYoZD1ibChkKSksZSYmIWVbb10mJihlPWJsKGUsZikpLHooZnVuY3Rpb24oZixnLGgsaSl7aWYoZiYmZSlyZXR1cm47dmFyIGosayxsLG09W10sbj1bXSxvPWcubGVuZ3RoLHA9Znx8Ym8oYnx8XCIqXCIsaC5ub2RlVHlwZT9baF06aCxbXSxmKSxxPWEmJihmfHwhYik/YmsocCxtLGEsaCxpKTpwLHI9Yz9lfHwoZj9hOm98fGQpP1tdOmc6cTtjJiZjKHEscixoLGkpO2lmKGQpe2w9YmsocixuKSxkKGwsW10saCxpKSxqPWwubGVuZ3RoO3doaWxlKGotLSlpZihrPWxbal0pcltuW2pdXT0hKHFbbltqXV09ayl9aWYoZil7aj1hJiZyLmxlbmd0aDt3aGlsZShqLS0paWYoaz1yW2pdKWZbbVtqXV09IShnW21bal1dPWspfWVsc2Ugcj1iayhyPT09Zz9yLnNwbGljZShvLHIubGVuZ3RoKTpyKSxlP2UobnVsbCxnLHIsaSk6dy5hcHBseShnLHIpfSl9ZnVuY3Rpb24gYm0oYSl7dmFyIGIsYyxkLGY9YS5sZW5ndGgsZz1lLnJlbGF0aXZlW2FbMF0udHlwZV0saD1nfHxlLnJlbGF0aXZlW1wiIFwiXSxpPWc/MTowLGo9YmkoZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1ifSxoLCEwKSxrPWJpKGZ1bmN0aW9uKGEpe3JldHVybiB5LmNhbGwoYixhKT4tMX0saCwhMCksbT1bZnVuY3Rpb24oYSxjLGQpe3JldHVybiFnJiYoZHx8YyE9PWwpfHwoKGI9Yykubm9kZVR5cGU/aihhLGMsZCk6ayhhLGMsZCkpfV07Zm9yKDtpPGY7aSsrKWlmKGM9ZS5yZWxhdGl2ZVthW2ldLnR5cGVdKW09W2JpKGJqKG0pLGMpXTtlbHNle2M9ZS5maWx0ZXJbYVtpXS50eXBlXS5hcHBseShudWxsLGFbaV0ubWF0Y2hlcyk7aWYoY1tvXSl7ZD0rK2k7Zm9yKDtkPGY7ZCsrKWlmKGUucmVsYXRpdmVbYVtkXS50eXBlXSlicmVhaztyZXR1cm4gYmwoaT4xJiZiaihtKSxpPjEmJmEuc2xpY2UoMCxpLTEpLmpvaW4oXCJcIikucmVwbGFjZShMLFwiJDFcIiksYyxpPGQmJmJtKGEuc2xpY2UoaSxkKSksZDxmJiZibShhPWEuc2xpY2UoZCkpLGQ8ZiYmYS5qb2luKFwiXCIpKX1tLnB1c2goYyl9cmV0dXJuIGJqKG0pfWZ1bmN0aW9uIGJuKGEsYil7dmFyIGQ9Yi5sZW5ndGg+MCxmPWEubGVuZ3RoPjAsZz1mdW5jdGlvbihoLGksaixrLG0pe3ZhciBuLG8scCxxPVtdLHM9MCx1PVwiMFwiLHg9aCYmW10seT1tIT1udWxsLHo9bCxBPWh8fGYmJmUuZmluZC5UQUcoXCIqXCIsbSYmaS5wYXJlbnROb2RlfHxpKSxCPXQrPXo9PW51bGw/MTpNYXRoLkU7eSYmKGw9aSE9PXImJmksYz1nLmVsKTtmb3IoOyhuPUFbdV0pIT1udWxsO3UrKyl7aWYoZiYmbil7Zm9yKG89MDtwPWFbb107bysrKWlmKHAobixpLGopKXtrLnB1c2gobik7YnJlYWt9eSYmKHQ9QixjPSsrZy5lbCl9ZCYmKChuPSFwJiZuKSYmcy0tLGgmJngucHVzaChuKSl9cys9dTtpZihkJiZ1IT09cyl7Zm9yKG89MDtwPWJbb107bysrKXAoeCxxLGksaik7aWYoaCl7aWYocz4wKXdoaWxlKHUtLSkheFt1XSYmIXFbdV0mJihxW3VdPXYuY2FsbChrKSk7cT1iayhxKX13LmFwcGx5KGsscSkseSYmIWgmJnEubGVuZ3RoPjAmJnMrYi5sZW5ndGg+MSYmYmMudW5pcXVlU29ydChrKX1yZXR1cm4geSYmKHQ9QixsPXopLHh9O3JldHVybiBnLmVsPTAsZD96KGcpOmd9ZnVuY3Rpb24gYm8oYSxiLGMsZCl7dmFyIGU9MCxmPWIubGVuZ3RoO2Zvcig7ZTxmO2UrKyliYyhhLGJbZV0sYyxkKTtyZXR1cm4gY31mdW5jdGlvbiBicChhLGIsYyxkLGYpe3ZhciBnLGgsaixrLGwsbT1iaChhKSxuPW0ubGVuZ3RoO2lmKCFkJiZtLmxlbmd0aD09PTEpe2g9bVswXT1tWzBdLnNsaWNlKDApO2lmKGgubGVuZ3RoPjImJihqPWhbMF0pLnR5cGU9PT1cIklEXCImJmIubm9kZVR5cGU9PT05JiYhZiYmZS5yZWxhdGl2ZVtoWzFdLnR5cGVdKXtiPWUuZmluZC5JRChqLm1hdGNoZXNbMF0ucmVwbGFjZShWLFwiXCIpLGIsZilbMF07aWYoIWIpcmV0dXJuIGM7YT1hLnNsaWNlKGguc2hpZnQoKS5sZW5ndGgpfWZvcihnPVcuUE9TLnRlc3QoYSk/LTE6aC5sZW5ndGgtMTtnPj0wO2ctLSl7aj1oW2ddO2lmKGUucmVsYXRpdmVbaz1qLnR5cGVdKWJyZWFrO2lmKGw9ZS5maW5kW2tdKWlmKGQ9bChqLm1hdGNoZXNbMF0ucmVwbGFjZShWLFwiXCIpLFIudGVzdChoWzBdLnR5cGUpJiZiLnBhcmVudE5vZGV8fGIsZikpe2guc3BsaWNlKGcsMSksYT1kLmxlbmd0aCYmaC5qb2luKFwiXCIpO2lmKCFhKXJldHVybiB3LmFwcGx5KGMseC5jYWxsKGQsMCkpLGM7YnJlYWt9fX1yZXR1cm4gaShhLG0pKGQsYixmLGMsUi50ZXN0KGEpKSxjfWZ1bmN0aW9uIGJxKCl7fXZhciBjLGQsZSxmLGcsaCxpLGosayxsLG09ITAsbj1cInVuZGVmaW5lZFwiLG89KFwic2l6Y2FjaGVcIitNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKFwiLlwiLFwiXCIpLHE9U3RyaW5nLHI9YS5kb2N1bWVudCxzPXIuZG9jdW1lbnRFbGVtZW50LHQ9MCx1PTAsdj1bXS5wb3Asdz1bXS5wdXNoLHg9W10uc2xpY2UseT1bXS5pbmRleE9mfHxmdW5jdGlvbihhKXt2YXIgYj0wLGM9dGhpcy5sZW5ndGg7Zm9yKDtiPGM7YisrKWlmKHRoaXNbYl09PT1hKXJldHVybiBiO3JldHVybi0xfSx6PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGFbb109Yj09bnVsbHx8YixhfSxBPWZ1bmN0aW9uKCl7dmFyIGE9e30sYj1bXTtyZXR1cm4geihmdW5jdGlvbihjLGQpe3JldHVybiBiLnB1c2goYyk+ZS5jYWNoZUxlbmd0aCYmZGVsZXRlIGFbYi5zaGlmdCgpXSxhW2NdPWR9LGEpfSxCPUEoKSxDPUEoKSxEPUEoKSxFPVwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixGPVwiKD86XFxcXFxcXFwufFstXFxcXHddfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsRz1GLnJlcGxhY2UoXCJ3XCIsXCJ3I1wiKSxIPVwiKFsqXiR8IX5dPz0pXCIsST1cIlxcXFxbXCIrRStcIiooXCIrRitcIilcIitFK1wiKig/OlwiK0grRStcIiooPzooWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfChcIitHK1wiKXwpfClcIitFK1wiKlxcXFxdXCIsSj1cIjooXCIrRitcIikoPzpcXFxcKCg/OihbJ1xcXCJdKSgoPzpcXFxcXFxcXC58W15cXFxcXFxcXF0pKj8pXFxcXDJ8KFteKClbXFxcXF1dKnwoPzooPzpcIitJK1wiKXxbXjpdfFxcXFxcXFxcLikqfC4qKSlcXFxcKXwpXCIsSz1cIjooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIitFK1wiKigoPzotXFxcXGQpP1xcXFxkKilcIitFK1wiKlxcXFwpfCkoPz1bXi1dfCQpXCIsTD1uZXcgUmVnRXhwKFwiXlwiK0UrXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiK0UrXCIrJFwiLFwiZ1wiKSxNPW5ldyBSZWdFeHAoXCJeXCIrRStcIiosXCIrRStcIipcIiksTj1uZXcgUmVnRXhwKFwiXlwiK0UrXCIqKFtcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGY+K35dKVwiK0UrXCIqXCIpLE89bmV3IFJlZ0V4cChKKSxQPS9eKD86IyhbXFx3XFwtXSspfChcXHcrKXxcXC4oW1xcd1xcLV0rKSkkLyxRPS9eOm5vdC8sUj0vW1xceDIwXFx0XFxyXFxuXFxmXSpbK35dLyxTPS86bm90XFwoJC8sVD0vaFxcZC9pLFU9L2lucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24vaSxWPS9cXFxcKD8hXFxcXCkvZyxXPXtJRDpuZXcgUmVnRXhwKFwiXiMoXCIrRitcIilcIiksQ0xBU1M6bmV3IFJlZ0V4cChcIl5cXFxcLihcIitGK1wiKVwiKSxOQU1FOm5ldyBSZWdFeHAoXCJeXFxcXFtuYW1lPVsnXFxcIl0/KFwiK0YrXCIpWydcXFwiXT9cXFxcXVwiKSxUQUc6bmV3IFJlZ0V4cChcIl4oXCIrRi5yZXBsYWNlKFwid1wiLFwidypcIikrXCIpXCIpLEFUVFI6bmV3IFJlZ0V4cChcIl5cIitJKSxQU0VVRE86bmV3IFJlZ0V4cChcIl5cIitKKSxQT1M6bmV3IFJlZ0V4cChLLFwiaVwiKSxDSElMRDpuZXcgUmVnRXhwKFwiXjoob25seXxudGh8Zmlyc3R8bGFzdCktY2hpbGQoPzpcXFxcKFwiK0UrXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIitFK1wiKig/OihbKy1dfClcIitFK1wiKihcXFxcZCspfCkpXCIrRStcIipcXFxcKXwpXCIsXCJpXCIpLG5lZWRzQ29udGV4dDpuZXcgUmVnRXhwKFwiXlwiK0UrXCIqWz4rfl18XCIrSyxcImlcIil9LFg9ZnVuY3Rpb24oYSl7dmFyIGI9ci5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3RyeXtyZXR1cm4gYShiKX1jYXRjaChjKXtyZXR1cm4hMX1maW5hbGx5e2I9bnVsbH19LFk9WChmdW5jdGlvbihhKXtyZXR1cm4gYS5hcHBlbmRDaGlsZChyLmNyZWF0ZUNvbW1lbnQoXCJcIikpLCFhLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGh9KSxaPVgoZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5uZXJIVE1MPVwiPGEgaHJlZj0nIyc+PC9hPlwiLGEuZmlyc3RDaGlsZCYmdHlwZW9mIGEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUhPT1uJiZhLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKT09PVwiI1wifSksJD1YKGZ1bmN0aW9uKGEpe2EuaW5uZXJIVE1MPVwiPHNlbGVjdD48L3NlbGVjdD5cIjt2YXIgYj10eXBlb2YgYS5sYXN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIik7cmV0dXJuIGIhPT1cImJvb2xlYW5cIiYmYiE9PVwic3RyaW5nXCJ9KSxfPVgoZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5uZXJIVE1MPVwiPGRpdiBjbGFzcz0naGlkZGVuIGUnPjwvZGl2PjxkaXYgY2xhc3M9J2hpZGRlbic+PC9kaXY+XCIsIWEuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZXx8IWEuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImVcIikubGVuZ3RoPyExOihhLmxhc3RDaGlsZC5jbGFzc05hbWU9XCJlXCIsYS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZVwiKS5sZW5ndGg9PT0yKX0pLGJhPVgoZnVuY3Rpb24oYSl7YS5pZD1vKzAsYS5pbm5lckhUTUw9XCI8YSBuYW1lPSdcIitvK1wiJz48L2E+PGRpdiBuYW1lPSdcIitvK1wiJz48L2Rpdj5cIixzLmluc2VydEJlZm9yZShhLHMuZmlyc3RDaGlsZCk7dmFyIGI9ci5nZXRFbGVtZW50c0J5TmFtZSYmci5nZXRFbGVtZW50c0J5TmFtZShvKS5sZW5ndGg9PT0yK3IuZ2V0RWxlbWVudHNCeU5hbWUobyswKS5sZW5ndGg7cmV0dXJuIGQ9IXIuZ2V0RWxlbWVudEJ5SWQobykscy5yZW1vdmVDaGlsZChhKSxifSk7dHJ5e3guY2FsbChzLmNoaWxkTm9kZXMsMClbMF0ubm9kZVR5cGV9Y2F0Y2goYmIpe3g9ZnVuY3Rpb24oYSl7dmFyIGIsYz1bXTtmb3IoO2I9dGhpc1thXTthKyspYy5wdXNoKGIpO3JldHVybiBjfX1iYy5tYXRjaGVzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGJjKGEsbnVsbCxudWxsLGIpfSxiYy5tYXRjaGVzU2VsZWN0b3I9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYmMoYixudWxsLG51bGwsW2FdKS5sZW5ndGg+MH0sZj1iYy5nZXRUZXh0PWZ1bmN0aW9uKGEpe3ZhciBiLGM9XCJcIixkPTAsZT1hLm5vZGVUeXBlO2lmKGUpe2lmKGU9PT0xfHxlPT09OXx8ZT09PTExKXtpZih0eXBlb2YgYS50ZXh0Q29udGVudD09XCJzdHJpbmdcIilyZXR1cm4gYS50ZXh0Q29udGVudDtmb3IoYT1hLmZpcnN0Q2hpbGQ7YTthPWEubmV4dFNpYmxpbmcpYys9ZihhKX1lbHNlIGlmKGU9PT0zfHxlPT09NClyZXR1cm4gYS5ub2RlVmFsdWV9ZWxzZSBmb3IoO2I9YVtkXTtkKyspYys9ZihiKTtyZXR1cm4gY30sZz1iYy5pc1hNTD1mdW5jdGlvbihhKXt2YXIgYj1hJiYoYS5vd25lckRvY3VtZW50fHxhKS5kb2N1bWVudEVsZW1lbnQ7cmV0dXJuIGI/Yi5ub2RlTmFtZSE9PVwiSFRNTFwiOiExfSxoPWJjLmNvbnRhaW5zPXMuY29udGFpbnM/ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLm5vZGVUeXBlPT09OT9hLmRvY3VtZW50RWxlbWVudDphLGQ9YiYmYi5wYXJlbnROb2RlO3JldHVybiBhPT09ZHx8ISEoZCYmZC5ub2RlVHlwZT09PTEmJmMuY29udGFpbnMmJmMuY29udGFpbnMoZCkpfTpzLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uP2Z1bmN0aW9uKGEsYil7cmV0dXJuIGImJiEhKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikmMTYpfTpmdW5jdGlvbihhLGIpe3doaWxlKGI9Yi5wYXJlbnROb2RlKWlmKGI9PT1hKXJldHVybiEwO3JldHVybiExfSxiYy5hdHRyPWZ1bmN0aW9uKGEsYil7dmFyIGMsZD1nKGEpO3JldHVybiBkfHwoYj1iLnRvTG93ZXJDYXNlKCkpLChjPWUuYXR0ckhhbmRsZVtiXSk/YyhhKTpkfHwkP2EuZ2V0QXR0cmlidXRlKGIpOihjPWEuZ2V0QXR0cmlidXRlTm9kZShiKSxjP3R5cGVvZiBhW2JdPT1cImJvb2xlYW5cIj9hW2JdP2I6bnVsbDpjLnNwZWNpZmllZD9jLnZhbHVlOm51bGw6bnVsbCl9LGU9YmMuc2VsZWN0b3JzPXtjYWNoZUxlbmd0aDo1MCxjcmVhdGVQc2V1ZG86eixtYXRjaDpXLGF0dHJIYW5kbGU6Wj97fTp7aHJlZjpmdW5jdGlvbihhKXtyZXR1cm4gYS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIsMil9LHR5cGU6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZ2V0QXR0cmlidXRlKFwidHlwZVwiKX19LGZpbmQ6e0lEOmQ/ZnVuY3Rpb24oYSxiLGMpe2lmKHR5cGVvZiBiLmdldEVsZW1lbnRCeUlkIT09biYmIWMpe3ZhciBkPWIuZ2V0RWxlbWVudEJ5SWQoYSk7cmV0dXJuIGQmJmQucGFyZW50Tm9kZT9bZF06W119fTpmdW5jdGlvbihhLGMsZCl7aWYodHlwZW9mIGMuZ2V0RWxlbWVudEJ5SWQhPT1uJiYhZCl7dmFyIGU9Yy5nZXRFbGVtZW50QnlJZChhKTtyZXR1cm4gZT9lLmlkPT09YXx8dHlwZW9mIGUuZ2V0QXR0cmlidXRlTm9kZSE9PW4mJmUuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLnZhbHVlPT09YT9bZV06YjpbXX19LFRBRzpZP2Z1bmN0aW9uKGEsYil7aWYodHlwZW9mIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUhPT1uKXJldHVybiBiLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpfTpmdW5jdGlvbihhLGIpe3ZhciBjPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk7aWYoYT09PVwiKlwiKXt2YXIgZCxlPVtdLGY9MDtmb3IoO2Q9Y1tmXTtmKyspZC5ub2RlVHlwZT09PTEmJmUucHVzaChkKTtyZXR1cm4gZX1yZXR1cm4gY30sTkFNRTpiYSYmZnVuY3Rpb24oYSxiKXtpZih0eXBlb2YgYi5nZXRFbGVtZW50c0J5TmFtZSE9PW4pcmV0dXJuIGIuZ2V0RWxlbWVudHNCeU5hbWUobmFtZSl9LENMQVNTOl8mJmZ1bmN0aW9uKGEsYixjKXtpZih0eXBlb2YgYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lIT09biYmIWMpcmV0dXJuIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhKX19LHJlbGF0aXZlOntcIj5cIjp7ZGlyOlwicGFyZW50Tm9kZVwiLGZpcnN0OiEwfSxcIiBcIjp7ZGlyOlwicGFyZW50Tm9kZVwifSxcIitcIjp7ZGlyOlwicHJldmlvdXNTaWJsaW5nXCIsZmlyc3Q6ITB9LFwiflwiOntkaXI6XCJwcmV2aW91c1NpYmxpbmdcIn19LHByZUZpbHRlcjp7QVRUUjpmdW5jdGlvbihhKXtyZXR1cm4gYVsxXT1hWzFdLnJlcGxhY2UoVixcIlwiKSxhWzNdPShhWzRdfHxhWzVdfHxcIlwiKS5yZXBsYWNlKFYsXCJcIiksYVsyXT09PVwifj1cIiYmKGFbM109XCIgXCIrYVszXStcIiBcIiksYS5zbGljZSgwLDQpfSxDSElMRDpmdW5jdGlvbihhKXtyZXR1cm4gYVsxXT1hWzFdLnRvTG93ZXJDYXNlKCksYVsxXT09PVwibnRoXCI/KGFbMl18fGJjLmVycm9yKGFbMF0pLGFbM109KyhhWzNdP2FbNF0rKGFbNV18fDEpOjIqKGFbMl09PT1cImV2ZW5cInx8YVsyXT09PVwib2RkXCIpKSxhWzRdPSsoYVs2XSthWzddfHxhWzJdPT09XCJvZGRcIikpOmFbMl0mJmJjLmVycm9yKGFbMF0pLGF9LFBTRVVETzpmdW5jdGlvbihhKXt2YXIgYixjO2lmKFcuQ0hJTEQudGVzdChhWzBdKSlyZXR1cm4gbnVsbDtpZihhWzNdKWFbMl09YVszXTtlbHNlIGlmKGI9YVs0XSlPLnRlc3QoYikmJihjPWJoKGIsITApKSYmKGM9Yi5pbmRleE9mKFwiKVwiLGIubGVuZ3RoLWMpLWIubGVuZ3RoKSYmKGI9Yi5zbGljZSgwLGMpLGFbMF09YVswXS5zbGljZSgwLGMpKSxhWzJdPWI7cmV0dXJuIGEuc2xpY2UoMCwzKX19LGZpbHRlcjp7SUQ6ZD9mdW5jdGlvbihhKXtyZXR1cm4gYT1hLnJlcGxhY2UoVixcIlwiKSxmdW5jdGlvbihiKXtyZXR1cm4gYi5nZXRBdHRyaWJ1dGUoXCJpZFwiKT09PWF9fTpmdW5jdGlvbihhKXtyZXR1cm4gYT1hLnJlcGxhY2UoVixcIlwiKSxmdW5jdGlvbihiKXt2YXIgYz10eXBlb2YgYi5nZXRBdHRyaWJ1dGVOb2RlIT09biYmYi5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7cmV0dXJuIGMmJmMudmFsdWU9PT1hfX0sVEFHOmZ1bmN0aW9uKGEpe3JldHVybiBhPT09XCIqXCI/ZnVuY3Rpb24oKXtyZXR1cm4hMH06KGE9YS5yZXBsYWNlKFYsXCJcIikudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihiKXtyZXR1cm4gYi5ub2RlTmFtZSYmYi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09YX0pfSxDTEFTUzpmdW5jdGlvbihhKXt2YXIgYj1CW29dW2FdO3JldHVybiBifHwoYj1CKGEsbmV3IFJlZ0V4cChcIihefFwiK0UrXCIpXCIrYStcIihcIitFK1wifCQpXCIpKSksZnVuY3Rpb24oYSl7cmV0dXJuIGIudGVzdChhLmNsYXNzTmFtZXx8dHlwZW9mIGEuZ2V0QXR0cmlidXRlIT09biYmYS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIil9fSxBVFRSOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gZnVuY3Rpb24oZCxlKXt2YXIgZj1iYy5hdHRyKGQsYSk7cmV0dXJuIGY9PW51bGw/Yj09PVwiIT1cIjpiPyhmKz1cIlwiLGI9PT1cIj1cIj9mPT09YzpiPT09XCIhPVwiP2YhPT1jOmI9PT1cIl49XCI/YyYmZi5pbmRleE9mKGMpPT09MDpiPT09XCIqPVwiP2MmJmYuaW5kZXhPZihjKT4tMTpiPT09XCIkPVwiP2MmJmYuc3Vic3RyKGYubGVuZ3RoLWMubGVuZ3RoKT09PWM6Yj09PVwifj1cIj8oXCIgXCIrZitcIiBcIikuaW5kZXhPZihjKT4tMTpiPT09XCJ8PVwiP2Y9PT1jfHxmLnN1YnN0cigwLGMubGVuZ3RoKzEpPT09YytcIi1cIjohMSk6ITB9fSxDSElMRDpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gYT09PVwibnRoXCI/ZnVuY3Rpb24oYSl7dmFyIGIsZSxmPWEucGFyZW50Tm9kZTtpZihjPT09MSYmZD09PTApcmV0dXJuITA7aWYoZil7ZT0wO2ZvcihiPWYuZmlyc3RDaGlsZDtiO2I9Yi5uZXh0U2libGluZylpZihiLm5vZGVUeXBlPT09MSl7ZSsrO2lmKGE9PT1iKWJyZWFrfX1yZXR1cm4gZS09ZCxlPT09Y3x8ZSVjPT09MCYmZS9jPj0wfTpmdW5jdGlvbihiKXt2YXIgYz1iO3N3aXRjaChhKXtjYXNlXCJvbmx5XCI6Y2FzZVwiZmlyc3RcIjp3aGlsZShjPWMucHJldmlvdXNTaWJsaW5nKWlmKGMubm9kZVR5cGU9PT0xKXJldHVybiExO2lmKGE9PT1cImZpcnN0XCIpcmV0dXJuITA7Yz1iO2Nhc2VcImxhc3RcIjp3aGlsZShjPWMubmV4dFNpYmxpbmcpaWYoYy5ub2RlVHlwZT09PTEpcmV0dXJuITE7cmV0dXJuITB9fX0sUFNFVURPOmZ1bmN0aW9uKGEsYil7dmFyIGMsZD1lLnBzZXVkb3NbYV18fGUuc2V0RmlsdGVyc1thLnRvTG93ZXJDYXNlKCldfHxiYy5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIrYSk7cmV0dXJuIGRbb10/ZChiKTpkLmxlbmd0aD4xPyhjPVthLGEsXCJcIixiXSxlLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoYS50b0xvd2VyQ2FzZSgpKT96KGZ1bmN0aW9uKGEsYyl7dmFyIGUsZj1kKGEsYiksZz1mLmxlbmd0aDt3aGlsZShnLS0pZT15LmNhbGwoYSxmW2ddKSxhW2VdPSEoY1tlXT1mW2ddKX0pOmZ1bmN0aW9uKGEpe3JldHVybiBkKGEsMCxjKX0pOmR9fSxwc2V1ZG9zOntub3Q6eihmdW5jdGlvbihhKXt2YXIgYj1bXSxjPVtdLGQ9aShhLnJlcGxhY2UoTCxcIiQxXCIpKTtyZXR1cm4gZFtvXT96KGZ1bmN0aW9uKGEsYixjLGUpe3ZhciBmLGc9ZChhLG51bGwsZSxbXSksaD1hLmxlbmd0aDt3aGlsZShoLS0paWYoZj1nW2hdKWFbaF09IShiW2hdPWYpfSk6ZnVuY3Rpb24oYSxlLGYpe3JldHVybiBiWzBdPWEsZChiLG51bGwsZixjKSwhYy5wb3AoKX19KSxoYXM6eihmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIGJjKGEsYikubGVuZ3RoPjB9fSksY29udGFpbnM6eihmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuKGIudGV4dENvbnRlbnR8fGIuaW5uZXJUZXh0fHxmKGIpKS5pbmRleE9mKGEpPi0xfX0pLGVuYWJsZWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGlzYWJsZWQ9PT0hMX0sZGlzYWJsZWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGlzYWJsZWQ9PT0hMH0sY2hlY2tlZDpmdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGI9PT1cImlucHV0XCImJiEhYS5jaGVja2VkfHxiPT09XCJvcHRpb25cIiYmISFhLnNlbGVjdGVkfSxzZWxlY3RlZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5wYXJlbnROb2RlJiZhLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCxhLnNlbGVjdGVkPT09ITB9LHBhcmVudDpmdW5jdGlvbihhKXtyZXR1cm4hZS5wc2V1ZG9zLmVtcHR5KGEpfSxlbXB0eTpmdW5jdGlvbihhKXt2YXIgYjthPWEuZmlyc3RDaGlsZDt3aGlsZShhKXtpZihhLm5vZGVOYW1lPlwiQFwifHwoYj1hLm5vZGVUeXBlKT09PTN8fGI9PT00KXJldHVybiExO2E9YS5uZXh0U2libGluZ31yZXR1cm4hMH0saGVhZGVyOmZ1bmN0aW9uKGEpe3JldHVybiBULnRlc3QoYS5ub2RlTmFtZSl9LHRleHQ6ZnVuY3Rpb24oYSl7dmFyIGIsYztyZXR1cm4gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09XCJpbnB1dFwiJiYoYj1hLnR5cGUpPT09XCJ0ZXh0XCImJigoYz1hLmdldEF0dHJpYnV0ZShcInR5cGVcIikpPT1udWxsfHxjLnRvTG93ZXJDYXNlKCk9PT1iKX0scmFkaW86YmQoXCJyYWRpb1wiKSxjaGVja2JveDpiZChcImNoZWNrYm94XCIpLGZpbGU6YmQoXCJmaWxlXCIpLHBhc3N3b3JkOmJkKFwicGFzc3dvcmRcIiksaW1hZ2U6YmQoXCJpbWFnZVwiKSxzdWJtaXQ6YmUoXCJzdWJtaXRcIikscmVzZXQ6YmUoXCJyZXNldFwiKSxidXR0b246ZnVuY3Rpb24oYSl7dmFyIGI9YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiBiPT09XCJpbnB1dFwiJiZhLnR5cGU9PT1cImJ1dHRvblwifHxiPT09XCJidXR0b25cIn0saW5wdXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIFUudGVzdChhLm5vZGVOYW1lKX0sZm9jdXM6ZnVuY3Rpb24oYSl7dmFyIGI9YS5vd25lckRvY3VtZW50O3JldHVybiBhPT09Yi5hY3RpdmVFbGVtZW50JiYoIWIuaGFzRm9jdXN8fGIuaGFzRm9jdXMoKSkmJighIWEudHlwZXx8ISFhLmhyZWYpfSxhY3RpdmU6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1hLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudH0sZmlyc3Q6YmYoZnVuY3Rpb24oYSxiLGMpe3JldHVyblswXX0pLGxhc3Q6YmYoZnVuY3Rpb24oYSxiLGMpe3JldHVybltiLTFdfSksZXE6YmYoZnVuY3Rpb24oYSxiLGMpe3JldHVybltjPDA/YytiOmNdfSksZXZlbjpiZihmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPTA7ZDxiO2QrPTIpYS5wdXNoKGQpO3JldHVybiBhfSksb2RkOmJmKGZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9MTtkPGI7ZCs9MilhLnB1c2goZCk7cmV0dXJuIGF9KSxsdDpiZihmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWM8MD9jK2I6YzstLWQ+PTA7KWEucHVzaChkKTtyZXR1cm4gYX0pLGd0OmJmKGZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YzwwP2MrYjpjOysrZDxiOylhLnB1c2goZCk7cmV0dXJuIGF9KX19LGo9cy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj9mdW5jdGlvbihhLGIpe3JldHVybiBhPT09Yj8oaz0hMCwwKTooIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb258fCFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uP2EuY29tcGFyZURvY3VtZW50UG9zaXRpb246YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSY0KT8tMToxfTpmdW5jdGlvbihhLGIpe2lmKGE9PT1iKXJldHVybiBrPSEwLDA7aWYoYS5zb3VyY2VJbmRleCYmYi5zb3VyY2VJbmRleClyZXR1cm4gYS5zb3VyY2VJbmRleC1iLnNvdXJjZUluZGV4O3ZhciBjLGQsZT1bXSxmPVtdLGc9YS5wYXJlbnROb2RlLGg9Yi5wYXJlbnROb2RlLGk9ZztpZihnPT09aClyZXR1cm4gYmcoYSxiKTtpZighZylyZXR1cm4tMTtpZighaClyZXR1cm4gMTt3aGlsZShpKWUudW5zaGlmdChpKSxpPWkucGFyZW50Tm9kZTtpPWg7d2hpbGUoaSlmLnVuc2hpZnQoaSksaT1pLnBhcmVudE5vZGU7Yz1lLmxlbmd0aCxkPWYubGVuZ3RoO2Zvcih2YXIgaj0wO2o8YyYmajxkO2orKylpZihlW2pdIT09ZltqXSlyZXR1cm4gYmcoZVtqXSxmW2pdKTtyZXR1cm4gaj09PWM/YmcoYSxmW2pdLC0xKTpiZyhlW2pdLGIsMSl9LFswLDBdLnNvcnQoaiksbT0hayxiYy51bmlxdWVTb3J0PWZ1bmN0aW9uKGEpe3ZhciBiLGM9MTtrPW0sYS5zb3J0KGopO2lmKGspZm9yKDtiPWFbY107YysrKWI9PT1hW2MtMV0mJmEuc3BsaWNlKGMtLSwxKTtyZXR1cm4gYX0sYmMuZXJyb3I9ZnVuY3Rpb24oYSl7dGhyb3cgbmV3IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIrYSl9LGk9YmMuY29tcGlsZT1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9W10sZT1bXSxmPURbb11bYV07aWYoIWYpe2J8fChiPWJoKGEpKSxjPWIubGVuZ3RoO3doaWxlKGMtLSlmPWJtKGJbY10pLGZbb10/ZC5wdXNoKGYpOmUucHVzaChmKTtmPUQoYSxibihlLGQpKX1yZXR1cm4gZn0sci5xdWVyeVNlbGVjdG9yQWxsJiZmdW5jdGlvbigpe3ZhciBhLGI9YnAsYz0vJ3xcXFxcL2csZD0vXFw9W1xceDIwXFx0XFxyXFxuXFxmXSooW14nXCJcXF1dKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcXS9nLGU9W1wiOmZvY3VzXCJdLGY9W1wiOmFjdGl2ZVwiLFwiOmZvY3VzXCJdLGg9cy5tYXRjaGVzU2VsZWN0b3J8fHMubW96TWF0Y2hlc1NlbGVjdG9yfHxzLndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8cy5vTWF0Y2hlc1NlbGVjdG9yfHxzLm1zTWF0Y2hlc1NlbGVjdG9yO1goZnVuY3Rpb24oYSl7YS5pbm5lckhUTUw9XCI8c2VsZWN0PjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCIsYS5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGh8fGUucHVzaChcIlxcXFxbXCIrRStcIiooPzpjaGVja2VkfGRpc2FibGVkfGlzbWFwfG11bHRpcGxlfHJlYWRvbmx5fHNlbGVjdGVkfHZhbHVlKVwiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGh8fGUucHVzaChcIjpjaGVja2VkXCIpfSksWChmdW5jdGlvbihhKXthLmlubmVySFRNTD1cIjxwIHRlc3Q9Jyc+PC9wPlwiLGEucXVlcnlTZWxlY3RvckFsbChcIlt0ZXN0Xj0nJ11cIikubGVuZ3RoJiZlLnB1c2goXCJbKl4kXT1cIitFK1wiKig/OlxcXCJcXFwifCcnKVwiKSxhLmlubmVySFRNTD1cIjxpbnB1dCB0eXBlPSdoaWRkZW4nLz5cIixhLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGh8fGUucHVzaChcIjplbmFibGVkXCIsXCI6ZGlzYWJsZWRcIil9KSxlPW5ldyBSZWdFeHAoZS5qb2luKFwifFwiKSksYnA9ZnVuY3Rpb24oYSxkLGYsZyxoKXtpZighZyYmIWgmJighZXx8IWUudGVzdChhKSkpe3ZhciBpLGosaz0hMCxsPW8sbT1kLG49ZC5ub2RlVHlwZT09PTkmJmE7aWYoZC5ub2RlVHlwZT09PTEmJmQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSE9PVwib2JqZWN0XCIpe2k9YmgoYSksKGs9ZC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk/bD1rLnJlcGxhY2UoYyxcIlxcXFwkJlwiKTpkLnNldEF0dHJpYnV0ZShcImlkXCIsbCksbD1cIltpZD0nXCIrbCtcIiddIFwiLGo9aS5sZW5ndGg7d2hpbGUoai0tKWlbal09bCtpW2pdLmpvaW4oXCJcIik7bT1SLnRlc3QoYSkmJmQucGFyZW50Tm9kZXx8ZCxuPWkuam9pbihcIixcIil9aWYobil0cnl7cmV0dXJuIHcuYXBwbHkoZix4LmNhbGwobS5xdWVyeVNlbGVjdG9yQWxsKG4pLDApKSxmfWNhdGNoKHApe31maW5hbGx5e2t8fGQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIil9fXJldHVybiBiKGEsZCxmLGcsaCl9LGgmJihYKGZ1bmN0aW9uKGIpe2E9aC5jYWxsKGIsXCJkaXZcIik7dHJ5e2guY2FsbChiLFwiW3Rlc3QhPScnXTpzaXp6bGVcIiksZi5wdXNoKFwiIT1cIixKKX1jYXRjaChjKXt9fSksZj1uZXcgUmVnRXhwKGYuam9pbihcInxcIikpLGJjLm1hdGNoZXNTZWxlY3Rvcj1mdW5jdGlvbihiLGMpe2M9Yy5yZXBsYWNlKGQsXCI9JyQxJ11cIik7aWYoIWcoYikmJiFmLnRlc3QoYykmJighZXx8IWUudGVzdChjKSkpdHJ5e3ZhciBpPWguY2FsbChiLGMpO2lmKGl8fGF8fGIuZG9jdW1lbnQmJmIuZG9jdW1lbnQubm9kZVR5cGUhPT0xMSlyZXR1cm4gaX1jYXRjaChqKXt9cmV0dXJuIGJjKGMsbnVsbCxudWxsLFtiXSkubGVuZ3RoPjB9KX0oKSxlLnBzZXVkb3MubnRoPWUucHNldWRvcy5lcSxlLmZpbHRlcnM9YnEucHJvdG90eXBlPWUucHNldWRvcyxlLnNldEZpbHRlcnM9bmV3IGJxLGJjLmF0dHI9cC5hdHRyLHAuZmluZD1iYyxwLmV4cHI9YmMuc2VsZWN0b3JzLHAuZXhwcltcIjpcIl09cC5leHByLnBzZXVkb3MscC51bmlxdWU9YmMudW5pcXVlU29ydCxwLnRleHQ9YmMuZ2V0VGV4dCxwLmlzWE1MRG9jPWJjLmlzWE1MLHAuY29udGFpbnM9YmMuY29udGFpbnN9KGEpO3ZhciBiYz0vVW50aWwkLyxiZD0vXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxiZT0vXi5bXjojXFxbXFwuLF0qJC8sYmY9cC5leHByLm1hdGNoLm5lZWRzQ29udGV4dCxiZz17Y2hpbGRyZW46ITAsY29udGVudHM6ITAsbmV4dDohMCxwcmV2OiEwfTtwLmZuLmV4dGVuZCh7ZmluZDpmdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGcsaD10aGlzO2lmKHR5cGVvZiBhIT1cInN0cmluZ1wiKXJldHVybiBwKGEpLmZpbHRlcihmdW5jdGlvbigpe2ZvcihiPTAsYz1oLmxlbmd0aDtiPGM7YisrKWlmKHAuY29udGFpbnMoaFtiXSx0aGlzKSlyZXR1cm4hMH0pO2c9dGhpcy5wdXNoU3RhY2soXCJcIixcImZpbmRcIixhKTtmb3IoYj0wLGM9dGhpcy5sZW5ndGg7YjxjO2IrKyl7ZD1nLmxlbmd0aCxwLmZpbmQoYSx0aGlzW2JdLGcpO2lmKGI+MClmb3IoZT1kO2U8Zy5sZW5ndGg7ZSsrKWZvcihmPTA7ZjxkO2YrKylpZihnW2ZdPT09Z1tlXSl7Zy5zcGxpY2UoZS0tLDEpO2JyZWFrfX1yZXR1cm4gZ30saGFzOmZ1bmN0aW9uKGEpe3ZhciBiLGM9cChhLHRoaXMpLGQ9Yy5sZW5ndGg7cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKGI9MDtiPGQ7YisrKWlmKHAuY29udGFpbnModGhpcyxjW2JdKSlyZXR1cm4hMH0pfSxub3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGJqKHRoaXMsYSwhMSksXCJub3RcIixhKX0sZmlsdGVyOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnB1c2hTdGFjayhiaih0aGlzLGEsITApLFwiZmlsdGVyXCIsYSl9LGlzOmZ1bmN0aW9uKGEpe3JldHVybiEhYSYmKHR5cGVvZiBhPT1cInN0cmluZ1wiP2JmLnRlc3QoYSk/cChhLHRoaXMuY29udGV4dCkuaW5kZXgodGhpc1swXSk+PTA6cC5maWx0ZXIoYSx0aGlzKS5sZW5ndGg+MDp0aGlzLmZpbHRlcihhKS5sZW5ndGg+MCl9LGNsb3Nlc3Q6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPTAsZT10aGlzLmxlbmd0aCxmPVtdLGc9YmYudGVzdChhKXx8dHlwZW9mIGEhPVwic3RyaW5nXCI/cChhLGJ8fHRoaXMuY29udGV4dCk6MDtmb3IoO2Q8ZTtkKyspe2M9dGhpc1tkXTt3aGlsZShjJiZjLm93bmVyRG9jdW1lbnQmJmMhPT1iJiZjLm5vZGVUeXBlIT09MTEpe2lmKGc/Zy5pbmRleChjKT4tMTpwLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGMsYSkpe2YucHVzaChjKTticmVha31jPWMucGFyZW50Tm9kZX19cmV0dXJuIGY9Zi5sZW5ndGg+MT9wLnVuaXF1ZShmKTpmLHRoaXMucHVzaFN0YWNrKGYsXCJjbG9zZXN0XCIsYSl9LGluZGV4OmZ1bmN0aW9uKGEpe3JldHVybiBhP3R5cGVvZiBhPT1cInN0cmluZ1wiP3AuaW5BcnJheSh0aGlzWzBdLHAoYSkpOnAuaW5BcnJheShhLmpxdWVyeT9hWzBdOmEsdGhpcyk6dGhpc1swXSYmdGhpc1swXS5wYXJlbnROb2RlP3RoaXMucHJldkFsbCgpLmxlbmd0aDotMX0sYWRkOmZ1bmN0aW9uKGEsYil7dmFyIGM9dHlwZW9mIGE9PVwic3RyaW5nXCI/cChhLGIpOnAubWFrZUFycmF5KGEmJmEubm9kZVR5cGU/W2FdOmEpLGQ9cC5tZXJnZSh0aGlzLmdldCgpLGMpO3JldHVybiB0aGlzLnB1c2hTdGFjayhiaChjWzBdKXx8YmgoZFswXSk/ZDpwLnVuaXF1ZShkKSl9LGFkZEJhY2s6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYWRkKGE9PW51bGw/dGhpcy5wcmV2T2JqZWN0OnRoaXMucHJldk9iamVjdC5maWx0ZXIoYSkpfX0pLHAuZm4uYW5kU2VsZj1wLmZuLmFkZEJhY2sscC5lYWNoKHtwYXJlbnQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5wYXJlbnROb2RlO3JldHVybiBiJiZiLm5vZGVUeXBlIT09MTE/YjpudWxsfSxwYXJlbnRzOmZ1bmN0aW9uKGEpe3JldHVybiBwLmRpcihhLFwicGFyZW50Tm9kZVwiKX0scGFyZW50c1VudGlsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gcC5kaXIoYSxcInBhcmVudE5vZGVcIixjKX0sbmV4dDpmdW5jdGlvbihhKXtyZXR1cm4gYmkoYSxcIm5leHRTaWJsaW5nXCIpfSxwcmV2OmZ1bmN0aW9uKGEpe3JldHVybiBiaShhLFwicHJldmlvdXNTaWJsaW5nXCIpfSxuZXh0QWxsOmZ1bmN0aW9uKGEpe3JldHVybiBwLmRpcihhLFwibmV4dFNpYmxpbmdcIil9LHByZXZBbGw6ZnVuY3Rpb24oYSl7cmV0dXJuIHAuZGlyKGEsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRVbnRpbDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHAuZGlyKGEsXCJuZXh0U2libGluZ1wiLGMpfSxwcmV2VW50aWw6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBwLmRpcihhLFwicHJldmlvdXNTaWJsaW5nXCIsYyl9LHNpYmxpbmdzOmZ1bmN0aW9uKGEpe3JldHVybiBwLnNpYmxpbmcoKGEucGFyZW50Tm9kZXx8e30pLmZpcnN0Q2hpbGQsYSl9LGNoaWxkcmVuOmZ1bmN0aW9uKGEpe3JldHVybiBwLnNpYmxpbmcoYS5maXJzdENoaWxkKX0sY29udGVudHM6ZnVuY3Rpb24oYSl7cmV0dXJuIHAubm9kZU5hbWUoYSxcImlmcmFtZVwiKT9hLmNvbnRlbnREb2N1bWVudHx8YS5jb250ZW50V2luZG93LmRvY3VtZW50OnAubWVyZ2UoW10sYS5jaGlsZE5vZGVzKX19LGZ1bmN0aW9uKGEsYil7cC5mblthXT1mdW5jdGlvbihjLGQpe3ZhciBlPXAubWFwKHRoaXMsYixjKTtyZXR1cm4gYmMudGVzdChhKXx8KGQ9YyksZCYmdHlwZW9mIGQ9PVwic3RyaW5nXCImJihlPXAuZmlsdGVyKGQsZSkpLGU9dGhpcy5sZW5ndGg+MSYmIWJnW2FdP3AudW5pcXVlKGUpOmUsdGhpcy5sZW5ndGg+MSYmYmQudGVzdChhKSYmKGU9ZS5yZXZlcnNlKCkpLHRoaXMucHVzaFN0YWNrKGUsYSxrLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiLFwiKSl9fSkscC5leHRlbmQoe2ZpbHRlcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGMmJihhPVwiOm5vdChcIithK1wiKVwiKSxiLmxlbmd0aD09PTE/cC5maW5kLm1hdGNoZXNTZWxlY3RvcihiWzBdLGEpP1tiWzBdXTpbXTpwLmZpbmQubWF0Y2hlcyhhLGIpfSxkaXI6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlPVtdLGY9YVtjXTt3aGlsZShmJiZmLm5vZGVUeXBlIT09OSYmKGQ9PT1ifHxmLm5vZGVUeXBlIT09MXx8IXAoZikuaXMoZCkpKWYubm9kZVR5cGU9PT0xJiZlLnB1c2goZiksZj1mW2NdO3JldHVybiBlfSxzaWJsaW5nOmZ1bmN0aW9uKGEsYil7dmFyIGM9W107Zm9yKDthO2E9YS5uZXh0U2libGluZylhLm5vZGVUeXBlPT09MSYmYSE9PWImJmMucHVzaChhKTtyZXR1cm4gY319KTt2YXIgYmw9XCJhYmJyfGFydGljbGV8YXNpZGV8YXVkaW98YmRpfGNhbnZhc3xkYXRhfGRhdGFsaXN0fGRldGFpbHN8ZmlnY2FwdGlvbnxmaWd1cmV8Zm9vdGVyfGhlYWRlcnxoZ3JvdXB8bWFya3xtZXRlcnxuYXZ8b3V0cHV0fHByb2dyZXNzfHNlY3Rpb258c3VtbWFyeXx0aW1lfHZpZGVvXCIsYm09LyBqUXVlcnlcXGQrPVwiKD86bnVsbHxcXGQrKVwiL2csYm49L15cXHMrLyxibz0vPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vZ2ksYnA9LzwoW1xcdzpdKykvLGJxPS88dGJvZHkvaSxicj0vPHwmIz9cXHcrOy8sYnM9LzwoPzpzY3JpcHR8c3R5bGV8bGluaykvaSxidD0vPCg/OnNjcmlwdHxvYmplY3R8ZW1iZWR8b3B0aW9ufHN0eWxlKS9pLGJ1PW5ldyBSZWdFeHAoXCI8KD86XCIrYmwrXCIpW1xcXFxzLz5dXCIsXCJpXCIpLGJ2PS9eKD86Y2hlY2tib3h8cmFkaW8pJC8sYnc9L2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxieD0vXFwvKGphdmF8ZWNtYSlzY3JpcHQvaSxieT0vXlxccyo8ISg/OlxcW0NEQVRBXFxbfFxcLVxcLSl8W1xcXVxcLV17Mn0+XFxzKiQvZyxiej17b3B0aW9uOlsxLFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLFwiPC9zZWxlY3Q+XCJdLGxlZ2VuZDpbMSxcIjxmaWVsZHNldD5cIixcIjwvZmllbGRzZXQ+XCJdLHRoZWFkOlsxLFwiPHRhYmxlPlwiLFwiPC90YWJsZT5cIl0sdHI6WzIsXCI8dGFibGU+PHRib2R5PlwiLFwiPC90Ym9keT48L3RhYmxlPlwiXSx0ZDpbMyxcIjx0YWJsZT48dGJvZHk+PHRyPlwiLFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCJdLGNvbDpbMixcIjx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+XCIsXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLGFyZWE6WzEsXCI8bWFwPlwiLFwiPC9tYXA+XCJdLF9kZWZhdWx0OlswLFwiXCIsXCJcIl19LGJBPWJrKGUpLGJCPWJBLmFwcGVuZENoaWxkKGUuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7Ynoub3B0Z3JvdXA9Ynoub3B0aW9uLGJ6LnRib2R5PWJ6LnRmb290PWJ6LmNvbGdyb3VwPWJ6LmNhcHRpb249YnoudGhlYWQsYnoudGg9YnoudGQscC5zdXBwb3J0Lmh0bWxTZXJpYWxpemV8fChiei5fZGVmYXVsdD1bMSxcIlg8ZGl2PlwiLFwiPC9kaXY+XCJdKSxwLmZuLmV4dGVuZCh7dGV4dDpmdW5jdGlvbihhKXtyZXR1cm4gcC5hY2Nlc3ModGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gYT09PWI/cC50ZXh0KHRoaXMpOnRoaXMuZW1wdHkoKS5hcHBlbmQoKHRoaXNbMF0mJnRoaXNbMF0ub3duZXJEb2N1bWVudHx8ZSkuY3JlYXRlVGV4dE5vZGUoYSkpfSxudWxsLGEsYXJndW1lbnRzLmxlbmd0aCl9LHdyYXBBbGw6ZnVuY3Rpb24oYSl7aWYocC5pc0Z1bmN0aW9uKGEpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYil7cCh0aGlzKS53cmFwQWxsKGEuY2FsbCh0aGlzLGIpKX0pO2lmKHRoaXNbMF0pe3ZhciBiPXAoYSx0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKTt0aGlzWzBdLnBhcmVudE5vZGUmJmIuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLGIubWFwKGZ1bmN0aW9uKCl7dmFyIGE9dGhpczt3aGlsZShhLmZpcnN0Q2hpbGQmJmEuZmlyc3RDaGlsZC5ub2RlVHlwZT09PTEpYT1hLmZpcnN0Q2hpbGQ7cmV0dXJuIGF9KS5hcHBlbmQodGhpcyl9cmV0dXJuIHRoaXN9LHdyYXBJbm5lcjpmdW5jdGlvbihhKXtyZXR1cm4gcC5pc0Z1bmN0aW9uKGEpP3RoaXMuZWFjaChmdW5jdGlvbihiKXtwKHRoaXMpLndyYXBJbm5lcihhLmNhbGwodGhpcyxiKSl9KTp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1wKHRoaXMpLGM9Yi5jb250ZW50cygpO2MubGVuZ3RoP2Mud3JhcEFsbChhKTpiLmFwcGVuZChhKX0pfSx3cmFwOmZ1bmN0aW9uKGEpe3ZhciBiPXAuaXNGdW5jdGlvbihhKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGMpe3AodGhpcykud3JhcEFsbChiP2EuY2FsbCh0aGlzLGMpOmEpfSl9LHVud3JhcDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24oKXtwLm5vZGVOYW1lKHRoaXMsXCJib2R5XCIpfHxwKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyl9KS5lbmQoKX0sYXBwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCEwLGZ1bmN0aW9uKGEpeyh0aGlzLm5vZGVUeXBlPT09MXx8dGhpcy5ub2RlVHlwZT09PTExKSYmdGhpcy5hcHBlbmRDaGlsZChhKX0pfSxwcmVwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCEwLGZ1bmN0aW9uKGEpeyh0aGlzLm5vZGVUeXBlPT09MXx8dGhpcy5ub2RlVHlwZT09PTExKSYmdGhpcy5pbnNlcnRCZWZvcmUoYSx0aGlzLmZpcnN0Q2hpbGQpfSl9LGJlZm9yZTpmdW5jdGlvbigpe2lmKCFiaCh0aGlzWzBdKSlyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsITEsZnVuY3Rpb24oYSl7dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLHRoaXMpfSk7aWYoYXJndW1lbnRzLmxlbmd0aCl7dmFyIGE9cC5jbGVhbihhcmd1bWVudHMpO3JldHVybiB0aGlzLnB1c2hTdGFjayhwLm1lcmdlKGEsdGhpcyksXCJiZWZvcmVcIix0aGlzLnNlbGVjdG9yKX19LGFmdGVyOmZ1bmN0aW9uKCl7aWYoIWJoKHRoaXNbMF0pKXJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywhMSxmdW5jdGlvbihhKXt0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsdGhpcy5uZXh0U2libGluZyl9KTtpZihhcmd1bWVudHMubGVuZ3RoKXt2YXIgYT1wLmNsZWFuKGFyZ3VtZW50cyk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHAubWVyZ2UodGhpcyxhKSxcImFmdGVyXCIsdGhpcy5zZWxlY3Rvcil9fSxyZW1vdmU6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPTA7Zm9yKDsoYz10aGlzW2RdKSE9bnVsbDtkKyspaWYoIWF8fHAuZmlsdGVyKGEsW2NdKS5sZW5ndGgpIWImJmMubm9kZVR5cGU9PT0xJiYocC5jbGVhbkRhdGEoYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikpLHAuY2xlYW5EYXRhKFtjXSkpLGMucGFyZW50Tm9kZSYmYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO3JldHVybiB0aGlzfSxlbXB0eTpmdW5jdGlvbigpe3ZhciBhLGI9MDtmb3IoOyhhPXRoaXNbYl0pIT1udWxsO2IrKyl7YS5ub2RlVHlwZT09PTEmJnAuY2xlYW5EYXRhKGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpKTt3aGlsZShhLmZpcnN0Q2hpbGQpYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpfXJldHVybiB0aGlzfSxjbG9uZTpmdW5jdGlvbihhLGIpe3JldHVybiBhPWE9PW51bGw/ITE6YSxiPWI9PW51bGw/YTpiLHRoaXMubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIHAuY2xvbmUodGhpcyxhLGIpfSl9LGh0bWw6ZnVuY3Rpb24oYSl7cmV0dXJuIHAuYWNjZXNzKHRoaXMsZnVuY3Rpb24oYSl7dmFyIGM9dGhpc1swXXx8e30sZD0wLGU9dGhpcy5sZW5ndGg7aWYoYT09PWIpcmV0dXJuIGMubm9kZVR5cGU9PT0xP2MuaW5uZXJIVE1MLnJlcGxhY2UoYm0sXCJcIik6YjtpZih0eXBlb2YgYT09XCJzdHJpbmdcIiYmIWJzLnRlc3QoYSkmJihwLnN1cHBvcnQuaHRtbFNlcmlhbGl6ZXx8IWJ1LnRlc3QoYSkpJiYocC5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlfHwhYm4udGVzdChhKSkmJiFielsoYnAuZXhlYyhhKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKXthPWEucmVwbGFjZShibyxcIjwkMT48LyQyPlwiKTt0cnl7Zm9yKDtkPGU7ZCsrKWM9dGhpc1tkXXx8e30sYy5ub2RlVHlwZT09PTEmJihwLmNsZWFuRGF0YShjLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSksYy5pbm5lckhUTUw9YSk7Yz0wfWNhdGNoKGYpe319YyYmdGhpcy5lbXB0eSgpLmFwcGVuZChhKX0sbnVsbCxhLGFyZ3VtZW50cy5sZW5ndGgpfSxyZXBsYWNlV2l0aDpmdW5jdGlvbihhKXtyZXR1cm4gYmgodGhpc1swXSk/dGhpcy5sZW5ndGg/dGhpcy5wdXNoU3RhY2socChwLmlzRnVuY3Rpb24oYSk/YSgpOmEpLFwicmVwbGFjZVdpdGhcIixhKTp0aGlzOnAuaXNGdW5jdGlvbihhKT90aGlzLmVhY2goZnVuY3Rpb24oYil7dmFyIGM9cCh0aGlzKSxkPWMuaHRtbCgpO2MucmVwbGFjZVdpdGgoYS5jYWxsKHRoaXMsYixkKSl9KToodHlwZW9mIGEhPVwic3RyaW5nXCImJihhPXAoYSkuZGV0YWNoKCkpLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPXRoaXMubmV4dFNpYmxpbmcsYz10aGlzLnBhcmVudE5vZGU7cCh0aGlzKS5yZW1vdmUoKSxiP3AoYikuYmVmb3JlKGEpOnAoYykuYXBwZW5kKGEpfSkpfSxkZXRhY2g6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucmVtb3ZlKGEsITApfSxkb21NYW5pcDpmdW5jdGlvbihhLGMsZCl7YT1bXS5jb25jYXQuYXBwbHkoW10sYSk7dmFyIGUsZixnLGgsaT0wLGo9YVswXSxrPVtdLGw9dGhpcy5sZW5ndGg7aWYoIXAuc3VwcG9ydC5jaGVja0Nsb25lJiZsPjEmJnR5cGVvZiBqPT1cInN0cmluZ1wiJiZidy50ZXN0KGopKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtwKHRoaXMpLmRvbU1hbmlwKGEsYyxkKX0pO2lmKHAuaXNGdW5jdGlvbihqKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGUpe3ZhciBmPXAodGhpcyk7YVswXT1qLmNhbGwodGhpcyxlLGM/Zi5odG1sKCk6YiksZi5kb21NYW5pcChhLGMsZCl9KTtpZih0aGlzWzBdKXtlPXAuYnVpbGRGcmFnbWVudChhLHRoaXMsayksZz1lLmZyYWdtZW50LGY9Zy5maXJzdENoaWxkLGcuY2hpbGROb2Rlcy5sZW5ndGg9PT0xJiYoZz1mKTtpZihmKXtjPWMmJnAubm9kZU5hbWUoZixcInRyXCIpO2ZvcihoPWUuY2FjaGVhYmxlfHxsLTE7aTxsO2krKylkLmNhbGwoYyYmcC5ub2RlTmFtZSh0aGlzW2ldLFwidGFibGVcIik/YkModGhpc1tpXSxcInRib2R5XCIpOnRoaXNbaV0saT09PWg/ZzpwLmNsb25lKGcsITAsITApKX1nPWY9bnVsbCxrLmxlbmd0aCYmcC5lYWNoKGssZnVuY3Rpb24oYSxiKXtiLnNyYz9wLmFqYXg/cC5hamF4KHt1cmw6Yi5zcmMsdHlwZTpcIkdFVFwiLGRhdGFUeXBlOlwic2NyaXB0XCIsYXN5bmM6ITEsZ2xvYmFsOiExLFwidGhyb3dzXCI6ITB9KTpwLmVycm9yKFwibm8gYWpheFwiKTpwLmdsb2JhbEV2YWwoKGIudGV4dHx8Yi50ZXh0Q29udGVudHx8Yi5pbm5lckhUTUx8fFwiXCIpLnJlcGxhY2UoYnksXCJcIikpLGIucGFyZW50Tm9kZSYmYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpfSl9cmV0dXJuIHRoaXN9fSkscC5idWlsZEZyYWdtZW50PWZ1bmN0aW9uKGEsYyxkKXt2YXIgZixnLGgsaT1hWzBdO3JldHVybiBjPWN8fGUsYz0hYy5ub2RlVHlwZSYmY1swXXx8YyxjPWMub3duZXJEb2N1bWVudHx8YyxhLmxlbmd0aD09PTEmJnR5cGVvZiBpPT1cInN0cmluZ1wiJiZpLmxlbmd0aDw1MTImJmM9PT1lJiZpLmNoYXJBdCgwKT09PVwiPFwiJiYhYnQudGVzdChpKSYmKHAuc3VwcG9ydC5jaGVja0Nsb25lfHwhYncudGVzdChpKSkmJihwLnN1cHBvcnQuaHRtbDVDbG9uZXx8IWJ1LnRlc3QoaSkpJiYoZz0hMCxmPXAuZnJhZ21lbnRzW2ldLGg9ZiE9PWIpLGZ8fChmPWMuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHAuY2xlYW4oYSxjLGYsZCksZyYmKHAuZnJhZ21lbnRzW2ldPWgmJmYpKSx7ZnJhZ21lbnQ6ZixjYWNoZWFibGU6Z319LHAuZnJhZ21lbnRzPXt9LHAuZWFjaCh7YXBwZW5kVG86XCJhcHBlbmRcIixwcmVwZW5kVG86XCJwcmVwZW5kXCIsaW5zZXJ0QmVmb3JlOlwiYmVmb3JlXCIsaW5zZXJ0QWZ0ZXI6XCJhZnRlclwiLHJlcGxhY2VBbGw6XCJyZXBsYWNlV2l0aFwifSxmdW5jdGlvbihhLGIpe3AuZm5bYV09ZnVuY3Rpb24oYyl7dmFyIGQsZT0wLGY9W10sZz1wKGMpLGg9Zy5sZW5ndGgsaT10aGlzLmxlbmd0aD09PTEmJnRoaXNbMF0ucGFyZW50Tm9kZTtpZigoaT09bnVsbHx8aSYmaS5ub2RlVHlwZT09PTExJiZpLmNoaWxkTm9kZXMubGVuZ3RoPT09MSkmJmg9PT0xKXJldHVybiBnW2JdKHRoaXNbMF0pLHRoaXM7Zm9yKDtlPGg7ZSsrKWQ9KGU+MD90aGlzLmNsb25lKCEwKTp0aGlzKS5nZXQoKSxwKGdbZV0pW2JdKGQpLGY9Zi5jb25jYXQoZCk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGYsYSxnLnNlbGVjdG9yKX19KSxwLmV4dGVuZCh7Y2xvbmU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnO3Auc3VwcG9ydC5odG1sNUNsb25lfHxwLmlzWE1MRG9jKGEpfHwhYnUudGVzdChcIjxcIithLm5vZGVOYW1lK1wiPlwiKT9nPWEuY2xvbmVOb2RlKCEwKTooYkIuaW5uZXJIVE1MPWEub3V0ZXJIVE1MLGJCLnJlbW92ZUNoaWxkKGc9YkIuZmlyc3RDaGlsZCkpO2lmKCghcC5zdXBwb3J0Lm5vQ2xvbmVFdmVudHx8IXAuc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCkmJihhLm5vZGVUeXBlPT09MXx8YS5ub2RlVHlwZT09PTExKSYmIXAuaXNYTUxEb2MoYSkpe2JFKGEsZyksZD1iRihhKSxlPWJGKGcpO2ZvcihmPTA7ZFtmXTsrK2YpZVtmXSYmYkUoZFtmXSxlW2ZdKX1pZihiKXtiRChhLGcpO2lmKGMpe2Q9YkYoYSksZT1iRihnKTtmb3IoZj0wO2RbZl07KytmKWJEKGRbZl0sZVtmXSl9fXJldHVybiBkPWU9bnVsbCxnfSxjbGVhbjpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZixnLGgsaSxqLGssbCxtLG4sbyxxLHIscz1iPT09ZSYmYkEsdD1bXTtpZighYnx8dHlwZW9mIGIuY3JlYXRlRG9jdW1lbnRGcmFnbWVudD09XCJ1bmRlZmluZWRcIiliPWU7Zm9yKGY9MDsoaD1hW2ZdKSE9bnVsbDtmKyspe3R5cGVvZiBoPT1cIm51bWJlclwiJiYoaCs9XCJcIik7aWYoIWgpY29udGludWU7aWYodHlwZW9mIGg9PVwic3RyaW5nXCIpaWYoIWJyLnRlc3QoaCkpaD1iLmNyZWF0ZVRleHROb2RlKGgpO2Vsc2V7cz1zfHxiayhiKSxsPWIuY3JlYXRlRWxlbWVudChcImRpdlwiKSxzLmFwcGVuZENoaWxkKGwpLGg9aC5yZXBsYWNlKGJvLFwiPCQxPjwvJDI+XCIpLGk9KGJwLmV4ZWMoaCl8fFtcIlwiLFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpLGo9YnpbaV18fGJ6Ll9kZWZhdWx0LGs9alswXSxsLmlubmVySFRNTD1qWzFdK2gralsyXTt3aGlsZShrLS0pbD1sLmxhc3RDaGlsZDtpZighcC5zdXBwb3J0LnRib2R5KXttPWJxLnRlc3QoaCksbj1pPT09XCJ0YWJsZVwiJiYhbT9sLmZpcnN0Q2hpbGQmJmwuZmlyc3RDaGlsZC5jaGlsZE5vZGVzOmpbMV09PT1cIjx0YWJsZT5cIiYmIW0/bC5jaGlsZE5vZGVzOltdO2ZvcihnPW4ubGVuZ3RoLTE7Zz49MDstLWcpcC5ub2RlTmFtZShuW2ddLFwidGJvZHlcIikmJiFuW2ddLmNoaWxkTm9kZXMubGVuZ3RoJiZuW2ddLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobltnXSl9IXAuc3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSYmYm4udGVzdChoKSYmbC5pbnNlcnRCZWZvcmUoYi5jcmVhdGVUZXh0Tm9kZShibi5leGVjKGgpWzBdKSxsLmZpcnN0Q2hpbGQpLGg9bC5jaGlsZE5vZGVzLGwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsKX1oLm5vZGVUeXBlP3QucHVzaChoKTpwLm1lcmdlKHQsaCl9bCYmKGg9bD1zPW51bGwpO2lmKCFwLnN1cHBvcnQuYXBwZW5kQ2hlY2tlZClmb3IoZj0wOyhoPXRbZl0pIT1udWxsO2YrKylwLm5vZGVOYW1lKGgsXCJpbnB1dFwiKT9iRyhoKTp0eXBlb2YgaC5nZXRFbGVtZW50c0J5VGFnTmFtZSE9XCJ1bmRlZmluZWRcIiYmcC5ncmVwKGguZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKSxiRyk7aWYoYyl7cT1mdW5jdGlvbihhKXtpZighYS50eXBlfHxieC50ZXN0KGEudHlwZSkpcmV0dXJuIGQ/ZC5wdXNoKGEucGFyZW50Tm9kZT9hLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk6YSk6Yy5hcHBlbmRDaGlsZChhKX07Zm9yKGY9MDsoaD10W2ZdKSE9bnVsbDtmKyspaWYoIXAubm9kZU5hbWUoaCxcInNjcmlwdFwiKXx8IXEoaCkpYy5hcHBlbmRDaGlsZChoKSx0eXBlb2YgaC5nZXRFbGVtZW50c0J5VGFnTmFtZSE9XCJ1bmRlZmluZWRcIiYmKHI9cC5ncmVwKHAubWVyZ2UoW10saC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKSkscSksdC5zcGxpY2UuYXBwbHkodCxbZisxLDBdLmNvbmNhdChyKSksZis9ci5sZW5ndGgpfXJldHVybiB0fSxjbGVhbkRhdGE6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnPTAsaD1wLmV4cGFuZG8saT1wLmNhY2hlLGo9cC5zdXBwb3J0LmRlbGV0ZUV4cGFuZG8saz1wLmV2ZW50LnNwZWNpYWw7Zm9yKDsoZT1hW2ddKSE9bnVsbDtnKyspaWYoYnx8cC5hY2NlcHREYXRhKGUpKXtkPWVbaF0sYz1kJiZpW2RdO2lmKGMpe2lmKGMuZXZlbnRzKWZvcihmIGluIGMuZXZlbnRzKWtbZl0/cC5ldmVudC5yZW1vdmUoZSxmKTpwLnJlbW92ZUV2ZW50KGUsZixjLmhhbmRsZSk7aVtkXSYmKGRlbGV0ZSBpW2RdLGo/ZGVsZXRlIGVbaF06ZS5yZW1vdmVBdHRyaWJ1dGU/ZS5yZW1vdmVBdHRyaWJ1dGUoaCk6ZVtoXT1udWxsLHAuZGVsZXRlZElkcy5wdXNoKGQpKX19fX0pLGZ1bmN0aW9uKCl7dmFyIGEsYjtwLnVhTWF0Y2g9ZnVuY3Rpb24oYSl7YT1hLnRvTG93ZXJDYXNlKCk7dmFyIGI9LyhjaHJvbWUpWyBcXC9dKFtcXHcuXSspLy5leGVjKGEpfHwvKHdlYmtpdClbIFxcL10oW1xcdy5dKykvLmV4ZWMoYSl8fC8ob3BlcmEpKD86Lip2ZXJzaW9ufClbIFxcL10oW1xcdy5dKykvLmV4ZWMoYSl8fC8obXNpZSkgKFtcXHcuXSspLy5leGVjKGEpfHxhLmluZGV4T2YoXCJjb21wYXRpYmxlXCIpPDAmJi8obW96aWxsYSkoPzouKj8gcnY6KFtcXHcuXSspfCkvLmV4ZWMoYSl8fFtdO3JldHVybnticm93c2VyOmJbMV18fFwiXCIsdmVyc2lvbjpiWzJdfHxcIjBcIn19LGE9cC51YU1hdGNoKGcudXNlckFnZW50KSxiPXt9LGEuYnJvd3NlciYmKGJbYS5icm93c2VyXT0hMCxiLnZlcnNpb249YS52ZXJzaW9uKSxiLmNocm9tZT9iLndlYmtpdD0hMDpiLndlYmtpdCYmKGIuc2FmYXJpPSEwKSxwLmJyb3dzZXI9YixwLnN1Yj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYixjKXtyZXR1cm4gbmV3IGEuZm4uaW5pdChiLGMpfXAuZXh0ZW5kKCEwLGEsdGhpcyksYS5zdXBlcmNsYXNzPXRoaXMsYS5mbj1hLnByb3RvdHlwZT10aGlzKCksYS5mbi5jb25zdHJ1Y3Rvcj1hLGEuc3ViPXRoaXMuc3ViLGEuZm4uaW5pdD1mdW5jdGlvbiBjKGMsZCl7cmV0dXJuIGQmJmQgaW5zdGFuY2VvZiBwJiYhKGQgaW5zdGFuY2VvZiBhKSYmKGQ9YShkKSkscC5mbi5pbml0LmNhbGwodGhpcyxjLGQsYil9LGEuZm4uaW5pdC5wcm90b3R5cGU9YS5mbjt2YXIgYj1hKGUpO3JldHVybiBhfX0oKTt2YXIgYkgsYkksYkosYks9L2FscGhhXFwoW14pXSpcXCkvaSxiTD0vb3BhY2l0eT0oW14pXSopLyxiTT0vXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC8sYk49L14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLGJPPS9ebWFyZ2luLyxiUD1uZXcgUmVnRXhwKFwiXihcIitxK1wiKSguKikkXCIsXCJpXCIpLGJRPW5ldyBSZWdFeHAoXCJeKFwiK3ErXCIpKD8hcHgpW2EteiVdKyRcIixcImlcIiksYlI9bmV3IFJlZ0V4cChcIl4oWy0rXSk9KFwiK3ErXCIpXCIsXCJpXCIpLGJTPXt9LGJUPXtwb3NpdGlvbjpcImFic29sdXRlXCIsdmlzaWJpbGl0eTpcImhpZGRlblwiLGRpc3BsYXk6XCJibG9ja1wifSxiVT17bGV0dGVyU3BhY2luZzowLGZvbnRXZWlnaHQ6NDAwfSxiVj1bXCJUb3BcIixcIlJpZ2h0XCIsXCJCb3R0b21cIixcIkxlZnRcIl0sYlc9W1wiV2Via2l0XCIsXCJPXCIsXCJNb3pcIixcIm1zXCJdLGJYPXAuZm4udG9nZ2xlO3AuZm4uZXh0ZW5kKHtjc3M6ZnVuY3Rpb24oYSxjKXtyZXR1cm4gcC5hY2Nlc3ModGhpcyxmdW5jdGlvbihhLGMsZCl7cmV0dXJuIGQhPT1iP3Auc3R5bGUoYSxjLGQpOnAuY3NzKGEsYyl9LGEsYyxhcmd1bWVudHMubGVuZ3RoPjEpfSxzaG93OmZ1bmN0aW9uKCl7cmV0dXJuIGIkKHRoaXMsITApfSxoaWRlOmZ1bmN0aW9uKCl7cmV0dXJuIGIkKHRoaXMpfSx0b2dnbGU6ZnVuY3Rpb24oYSxiKXt2YXIgYz10eXBlb2YgYT09XCJib29sZWFuXCI7cmV0dXJuIHAuaXNGdW5jdGlvbihhKSYmcC5pc0Z1bmN0aW9uKGIpP2JYLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmVhY2goZnVuY3Rpb24oKXsoYz9hOmJaKHRoaXMpKT9wKHRoaXMpLnNob3coKTpwKHRoaXMpLmhpZGUoKX0pfX0pLHAuZXh0ZW5kKHtjc3NIb29rczp7b3BhY2l0eTp7Z2V0OmZ1bmN0aW9uKGEsYil7aWYoYil7dmFyIGM9YkgoYSxcIm9wYWNpdHlcIik7cmV0dXJuIGM9PT1cIlwiP1wiMVwiOmN9fX19LGNzc051bWJlcjp7ZmlsbE9wYWNpdHk6ITAsZm9udFdlaWdodDohMCxsaW5lSGVpZ2h0OiEwLG9wYWNpdHk6ITAsb3JwaGFuczohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITB9LGNzc1Byb3BzOntcImZsb2F0XCI6cC5zdXBwb3J0LmNzc0Zsb2F0P1wiY3NzRmxvYXRcIjpcInN0eWxlRmxvYXRcIn0sc3R5bGU6ZnVuY3Rpb24oYSxjLGQsZSl7aWYoIWF8fGEubm9kZVR5cGU9PT0zfHxhLm5vZGVUeXBlPT09OHx8IWEuc3R5bGUpcmV0dXJuO3ZhciBmLGcsaCxpPXAuY2FtZWxDYXNlKGMpLGo9YS5zdHlsZTtjPXAuY3NzUHJvcHNbaV18fChwLmNzc1Byb3BzW2ldPWJZKGosaSkpLGg9cC5jc3NIb29rc1tjXXx8cC5jc3NIb29rc1tpXTtpZihkPT09YilyZXR1cm4gaCYmXCJnZXRcImluIGgmJihmPWguZ2V0KGEsITEsZSkpIT09Yj9mOmpbY107Zz10eXBlb2YgZCxnPT09XCJzdHJpbmdcIiYmKGY9YlIuZXhlYyhkKSkmJihkPShmWzFdKzEpKmZbMl0rcGFyc2VGbG9hdChwLmNzcyhhLGMpKSxnPVwibnVtYmVyXCIpO2lmKGQ9PW51bGx8fGc9PT1cIm51bWJlclwiJiZpc05hTihkKSlyZXR1cm47Zz09PVwibnVtYmVyXCImJiFwLmNzc051bWJlcltpXSYmKGQrPVwicHhcIik7aWYoIWh8fCEoXCJzZXRcImluIGgpfHwoZD1oLnNldChhLGQsZSkpIT09Yil0cnl7altjXT1kfWNhdGNoKGspe319LGNzczpmdW5jdGlvbihhLGMsZCxlKXt2YXIgZixnLGgsaT1wLmNhbWVsQ2FzZShjKTtyZXR1cm4gYz1wLmNzc1Byb3BzW2ldfHwocC5jc3NQcm9wc1tpXT1iWShhLnN0eWxlLGkpKSxoPXAuY3NzSG9va3NbY118fHAuY3NzSG9va3NbaV0saCYmXCJnZXRcImluIGgmJihmPWguZ2V0KGEsITAsZSkpLGY9PT1iJiYoZj1iSChhLGMpKSxmPT09XCJub3JtYWxcIiYmYyBpbiBiVSYmKGY9YlVbY10pLGR8fGUhPT1iPyhnPXBhcnNlRmxvYXQoZiksZHx8cC5pc051bWVyaWMoZyk/Z3x8MDpmKTpmfSxzd2FwOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9e307Zm9yKGUgaW4gYilmW2VdPWEuc3R5bGVbZV0sYS5zdHlsZVtlXT1iW2VdO2Q9Yy5jYWxsKGEpO2ZvcihlIGluIGIpYS5zdHlsZVtlXT1mW2VdO3JldHVybiBkfX0pLGEuZ2V0Q29tcHV0ZWRTdHlsZT9iSD1mdW5jdGlvbihiLGMpe3ZhciBkLGUsZixnLGg9YS5nZXRDb21wdXRlZFN0eWxlKGIsbnVsbCksaT1iLnN0eWxlO3JldHVybiBoJiYoZD1oW2NdLGQ9PT1cIlwiJiYhcC5jb250YWlucyhiLm93bmVyRG9jdW1lbnQsYikmJihkPXAuc3R5bGUoYixjKSksYlEudGVzdChkKSYmYk8udGVzdChjKSYmKGU9aS53aWR0aCxmPWkubWluV2lkdGgsZz1pLm1heFdpZHRoLGkubWluV2lkdGg9aS5tYXhXaWR0aD1pLndpZHRoPWQsZD1oLndpZHRoLGkud2lkdGg9ZSxpLm1pbldpZHRoPWYsaS5tYXhXaWR0aD1nKSksZH06ZS5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlJiYoYkg9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU9YS5jdXJyZW50U3R5bGUmJmEuY3VycmVudFN0eWxlW2JdLGY9YS5zdHlsZTtyZXR1cm4gZT09bnVsbCYmZiYmZltiXSYmKGU9ZltiXSksYlEudGVzdChlKSYmIWJNLnRlc3QoYikmJihjPWYubGVmdCxkPWEucnVudGltZVN0eWxlJiZhLnJ1bnRpbWVTdHlsZS5sZWZ0LGQmJihhLnJ1bnRpbWVTdHlsZS5sZWZ0PWEuY3VycmVudFN0eWxlLmxlZnQpLGYubGVmdD1iPT09XCJmb250U2l6ZVwiP1wiMWVtXCI6ZSxlPWYucGl4ZWxMZWZ0K1wicHhcIixmLmxlZnQ9YyxkJiYoYS5ydW50aW1lU3R5bGUubGVmdD1kKSksZT09PVwiXCI/XCJhdXRvXCI6ZX0pLHAuZWFjaChbXCJoZWlnaHRcIixcIndpZHRoXCJdLGZ1bmN0aW9uKGEsYil7cC5jc3NIb29rc1tiXT17Z2V0OmZ1bmN0aW9uKGEsYyxkKXtpZihjKXJldHVybiBhLm9mZnNldFdpZHRoPT09MCYmYk4udGVzdChiSChhLFwiZGlzcGxheVwiKSk/cC5zd2FwKGEsYlQsZnVuY3Rpb24oKXtyZXR1cm4gY2IoYSxiLGQpfSk6Y2IoYSxiLGQpfSxzZXQ6ZnVuY3Rpb24oYSxjLGQpe3JldHVybiBiXyhhLGMsZD9jYShhLGIsZCxwLnN1cHBvcnQuYm94U2l6aW5nJiZwLmNzcyhhLFwiYm94U2l6aW5nXCIpPT09XCJib3JkZXItYm94XCIpOjApfX19KSxwLnN1cHBvcnQub3BhY2l0eXx8KHAuY3NzSG9va3Mub3BhY2l0eT17Z2V0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIGJMLnRlc3QoKGImJmEuY3VycmVudFN0eWxlP2EuY3VycmVudFN0eWxlLmZpbHRlcjphLnN0eWxlLmZpbHRlcil8fFwiXCIpPy4wMSpwYXJzZUZsb2F0KFJlZ0V4cC4kMSkrXCJcIjpiP1wiMVwiOlwiXCJ9LHNldDpmdW5jdGlvbihhLGIpe3ZhciBjPWEuc3R5bGUsZD1hLmN1cnJlbnRTdHlsZSxlPXAuaXNOdW1lcmljKGIpP1wiYWxwaGEob3BhY2l0eT1cIitiKjEwMCtcIilcIjpcIlwiLGY9ZCYmZC5maWx0ZXJ8fGMuZmlsdGVyfHxcIlwiO2Muem9vbT0xO2lmKGI+PTEmJnAudHJpbShmLnJlcGxhY2UoYkssXCJcIikpPT09XCJcIiYmYy5yZW1vdmVBdHRyaWJ1dGUpe2MucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpO2lmKGQmJiFkLmZpbHRlcilyZXR1cm59Yy5maWx0ZXI9YksudGVzdChmKT9mLnJlcGxhY2UoYkssZSk6ZitcIiBcIitlfX0pLHAoZnVuY3Rpb24oKXtwLnN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodHx8KHAuY3NzSG9va3MubWFyZ2luUmlnaHQ9e2dldDpmdW5jdGlvbihhLGIpe3JldHVybiBwLnN3YXAoYSx7ZGlzcGxheTpcImlubGluZS1ibG9ja1wifSxmdW5jdGlvbigpe2lmKGIpcmV0dXJuIGJIKGEsXCJtYXJnaW5SaWdodFwiKX0pfX0pLCFwLnN1cHBvcnQucGl4ZWxQb3NpdGlvbiYmcC5mbi5wb3NpdGlvbiYmcC5lYWNoKFtcInRvcFwiLFwibGVmdFwiXSxmdW5jdGlvbihhLGIpe3AuY3NzSG9va3NbYl09e2dldDpmdW5jdGlvbihhLGMpe2lmKGMpe3ZhciBkPWJIKGEsYik7cmV0dXJuIGJRLnRlc3QoZCk/cChhKS5wb3NpdGlvbigpW2JdK1wicHhcIjpkfX19fSl9KSxwLmV4cHImJnAuZXhwci5maWx0ZXJzJiYocC5leHByLmZpbHRlcnMuaGlkZGVuPWZ1bmN0aW9uKGEpe3JldHVybiBhLm9mZnNldFdpZHRoPT09MCYmYS5vZmZzZXRIZWlnaHQ9PT0wfHwhcC5zdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyYmKGEuc3R5bGUmJmEuc3R5bGUuZGlzcGxheXx8YkgoYSxcImRpc3BsYXlcIikpPT09XCJub25lXCJ9LHAuZXhwci5maWx0ZXJzLnZpc2libGU9ZnVuY3Rpb24oYSl7cmV0dXJuIXAuZXhwci5maWx0ZXJzLmhpZGRlbihhKX0pLHAuZWFjaCh7bWFyZ2luOlwiXCIscGFkZGluZzpcIlwiLGJvcmRlcjpcIldpZHRoXCJ9LGZ1bmN0aW9uKGEsYil7cC5jc3NIb29rc1thK2JdPXtleHBhbmQ6ZnVuY3Rpb24oYyl7dmFyIGQsZT10eXBlb2YgYz09XCJzdHJpbmdcIj9jLnNwbGl0KFwiIFwiKTpbY10sZj17fTtmb3IoZD0wO2Q8NDtkKyspZlthK2JWW2RdK2JdPWVbZF18fGVbZC0yXXx8ZVswXTtyZXR1cm4gZn19LGJPLnRlc3QoYSl8fChwLmNzc0hvb2tzW2ErYl0uc2V0PWJfKX0pO3ZhciBjZD0vJTIwL2csY2U9L1xcW1xcXSQvLGNmPS9cXHI/XFxuL2csY2c9L14oPzpjb2xvcnxkYXRlfGRhdGV0aW1lfGRhdGV0aW1lLWxvY2FsfGVtYWlsfGhpZGRlbnxtb250aHxudW1iZXJ8cGFzc3dvcmR8cmFuZ2V8c2VhcmNofHRlbHx0ZXh0fHRpbWV8dXJsfHdlZWspJC9pLGNoPS9eKD86c2VsZWN0fHRleHRhcmVhKS9pO3AuZm4uZXh0ZW5kKHtzZXJpYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gcC5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpfSxzZXJpYWxpemVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiB0aGlzLmVsZW1lbnRzP3AubWFrZUFycmF5KHRoaXMuZWxlbWVudHMpOnRoaXN9KS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lJiYhdGhpcy5kaXNhYmxlZCYmKHRoaXMuY2hlY2tlZHx8Y2gudGVzdCh0aGlzLm5vZGVOYW1lKXx8Y2cudGVzdCh0aGlzLnR5cGUpKX0pLm1hcChmdW5jdGlvbihhLGIpe3ZhciBjPXAodGhpcykudmFsKCk7cmV0dXJuIGM9PW51bGw/bnVsbDpwLmlzQXJyYXkoYyk/cC5tYXAoYyxmdW5jdGlvbihhLGMpe3JldHVybntuYW1lOmIubmFtZSx2YWx1ZTphLnJlcGxhY2UoY2YsXCJcXHJcXG5cIil9fSk6e25hbWU6Yi5uYW1lLHZhbHVlOmMucmVwbGFjZShjZixcIlxcclxcblwiKX19KS5nZXQoKX19KSxwLnBhcmFtPWZ1bmN0aW9uKGEsYyl7dmFyIGQsZT1bXSxmPWZ1bmN0aW9uKGEsYil7Yj1wLmlzRnVuY3Rpb24oYik/YigpOmI9PW51bGw/XCJcIjpiLGVbZS5sZW5ndGhdPWVuY29kZVVSSUNvbXBvbmVudChhKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoYil9O2M9PT1iJiYoYz1wLmFqYXhTZXR0aW5ncyYmcC5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWwpO2lmKHAuaXNBcnJheShhKXx8YS5qcXVlcnkmJiFwLmlzUGxhaW5PYmplY3QoYSkpcC5lYWNoKGEsZnVuY3Rpb24oKXtmKHRoaXMubmFtZSx0aGlzLnZhbHVlKX0pO2Vsc2UgZm9yKGQgaW4gYSljaShkLGFbZF0sYyxmKTtyZXR1cm4gZS5qb2luKFwiJlwiKS5yZXBsYWNlKGNkLFwiK1wiKX07dmFyIGNqLGNrLGNsPS8jLiokLyxjbT0vXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKilcXHI/JC9tZyxjbj0vXig/OmFib3V0fGFwcHxhcHBcXC1zdG9yYWdlfC4rXFwtZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sY289L14oPzpHRVR8SEVBRCkkLyxjcD0vXlxcL1xcLy8sY3E9L1xcPy8sY3I9LzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2ksY3M9LyhbPyZdKV89W14mXSovLGN0PS9eKFtcXHdcXCtcXC5cXC1dKzopKD86XFwvXFwvKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLGN1PXAuZm4ubG9hZCxjdj17fSxjdz17fSxjeD1bXCIqL1wiXStbXCIqXCJdO3RyeXtjaz1mLmhyZWZ9Y2F0Y2goY3kpe2NrPWUuY3JlYXRlRWxlbWVudChcImFcIiksY2suaHJlZj1cIlwiLGNrPWNrLmhyZWZ9Y2o9Y3QuZXhlYyhjay50b0xvd2VyQ2FzZSgpKXx8W10scC5mbi5sb2FkPWZ1bmN0aW9uKGEsYyxkKXtpZih0eXBlb2YgYSE9XCJzdHJpbmdcIiYmY3UpcmV0dXJuIGN1LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZighdGhpcy5sZW5ndGgpcmV0dXJuIHRoaXM7dmFyIGUsZixnLGg9dGhpcyxpPWEuaW5kZXhPZihcIiBcIik7cmV0dXJuIGk+PTAmJihlPWEuc2xpY2UoaSxhLmxlbmd0aCksYT1hLnNsaWNlKDAsaSkpLHAuaXNGdW5jdGlvbihjKT8oZD1jLGM9Yik6YyYmdHlwZW9mIGM9PVwib2JqZWN0XCImJihmPVwiUE9TVFwiKSxwLmFqYXgoe3VybDphLHR5cGU6ZixkYXRhVHlwZTpcImh0bWxcIixkYXRhOmMsY29tcGxldGU6ZnVuY3Rpb24oYSxiKXtkJiZoLmVhY2goZCxnfHxbYS5yZXNwb25zZVRleHQsYixhXSl9fSkuZG9uZShmdW5jdGlvbihhKXtnPWFyZ3VtZW50cyxoLmh0bWwoZT9wKFwiPGRpdj5cIikuYXBwZW5kKGEucmVwbGFjZShjcixcIlwiKSkuZmluZChlKTphKX0pLHRoaXN9LHAuZWFjaChcImFqYXhTdGFydCBhamF4U3RvcCBhamF4Q29tcGxldGUgYWpheEVycm9yIGFqYXhTdWNjZXNzIGFqYXhTZW5kXCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGEsYil7cC5mbltiXT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5vbihiLGEpfX0pLHAuZWFjaChbXCJnZXRcIixcInBvc3RcIl0sZnVuY3Rpb24oYSxjKXtwW2NdPWZ1bmN0aW9uKGEsZCxlLGYpe3JldHVybiBwLmlzRnVuY3Rpb24oZCkmJihmPWZ8fGUsZT1kLGQ9YikscC5hamF4KHt0eXBlOmMsdXJsOmEsZGF0YTpkLHN1Y2Nlc3M6ZSxkYXRhVHlwZTpmfSl9fSkscC5leHRlbmQoe2dldFNjcmlwdDpmdW5jdGlvbihhLGMpe3JldHVybiBwLmdldChhLGIsYyxcInNjcmlwdFwiKX0sZ2V0SlNPTjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHAuZ2V0KGEsYixjLFwianNvblwiKX0sYWpheFNldHVwOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGI/Y0IoYSxwLmFqYXhTZXR0aW5ncyk6KGI9YSxhPXAuYWpheFNldHRpbmdzKSxjQihhLGIpLGF9LGFqYXhTZXR0aW5nczp7dXJsOmNrLGlzTG9jYWw6Y24udGVzdChjalsxXSksZ2xvYmFsOiEwLHR5cGU6XCJHRVRcIixjb250ZW50VHlwZTpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLHByb2Nlc3NEYXRhOiEwLGFzeW5jOiEwLGFjY2VwdHM6e3htbDpcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixodG1sOlwidGV4dC9odG1sXCIsdGV4dDpcInRleHQvcGxhaW5cIixqc29uOlwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCIsXCIqXCI6Y3h9LGNvbnRlbnRzOnt4bWw6L3htbC8saHRtbDovaHRtbC8sanNvbjovanNvbi99LHJlc3BvbnNlRmllbGRzOnt4bWw6XCJyZXNwb25zZVhNTFwiLHRleHQ6XCJyZXNwb25zZVRleHRcIn0sY29udmVydGVyczp7XCIqIHRleHRcIjphLlN0cmluZyxcInRleHQgaHRtbFwiOiEwLFwidGV4dCBqc29uXCI6cC5wYXJzZUpTT04sXCJ0ZXh0IHhtbFwiOnAucGFyc2VYTUx9LGZsYXRPcHRpb25zOntjb250ZXh0OiEwLHVybDohMH19LGFqYXhQcmVmaWx0ZXI6Y3ooY3YpLGFqYXhUcmFuc3BvcnQ6Y3ooY3cpLGFqYXg6ZnVuY3Rpb24oYSxjKXtmdW5jdGlvbiB5KGEsYyxmLGkpe3ZhciBrLHMsdCx1LHcseT1jO2lmKHY9PT0yKXJldHVybjt2PTIsaCYmY2xlYXJUaW1lb3V0KGgpLGc9YixlPWl8fFwiXCIseC5yZWFkeVN0YXRlPWE+MD80OjAsZiYmKHU9Y0MobCx4LGYpKTtpZihhPj0yMDAmJmE8MzAwfHxhPT09MzA0KWwuaWZNb2RpZmllZCYmKHc9eC5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIiksdyYmKHAubGFzdE1vZGlmaWVkW2RdPXcpLHc9eC5nZXRSZXNwb25zZUhlYWRlcihcIkV0YWdcIiksdyYmKHAuZXRhZ1tkXT13KSksYT09PTMwND8oeT1cIm5vdG1vZGlmaWVkXCIsaz0hMCk6KGs9Y0QobCx1KSx5PWsuc3RhdGUscz1rLmRhdGEsdD1rLmVycm9yLGs9IXQpO2Vsc2V7dD15O2lmKCF5fHxhKXk9XCJlcnJvclwiLGE8MCYmKGE9MCl9eC5zdGF0dXM9YSx4LnN0YXR1c1RleHQ9KGN8fHkpK1wiXCIsaz9vLnJlc29sdmVXaXRoKG0sW3MseSx4XSk6by5yZWplY3RXaXRoKG0sW3gseSx0XSkseC5zdGF0dXNDb2RlKHIpLHI9YixqJiZuLnRyaWdnZXIoXCJhamF4XCIrKGs/XCJTdWNjZXNzXCI6XCJFcnJvclwiKSxbeCxsLGs/czp0XSkscS5maXJlV2l0aChtLFt4LHldKSxqJiYobi50cmlnZ2VyKFwiYWpheENvbXBsZXRlXCIsW3gsbF0pLC0tcC5hY3RpdmV8fHAuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpKX10eXBlb2YgYT09XCJvYmplY3RcIiYmKGM9YSxhPWIpLGM9Y3x8e307dmFyIGQsZSxmLGcsaCxpLGosayxsPXAuYWpheFNldHVwKHt9LGMpLG09bC5jb250ZXh0fHxsLG49bSE9PWwmJihtLm5vZGVUeXBlfHxtIGluc3RhbmNlb2YgcCk/cChtKTpwLmV2ZW50LG89cC5EZWZlcnJlZCgpLHE9cC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxyPWwuc3RhdHVzQ29kZXx8e30sdD17fSx1PXt9LHY9MCx3PVwiY2FuY2VsZWRcIix4PXtyZWFkeVN0YXRlOjAsc2V0UmVxdWVzdEhlYWRlcjpmdW5jdGlvbihhLGIpe2lmKCF2KXt2YXIgYz1hLnRvTG93ZXJDYXNlKCk7YT11W2NdPXVbY118fGEsdFthXT1ifXJldHVybiB0aGlzfSxnZXRBbGxSZXNwb25zZUhlYWRlcnM6ZnVuY3Rpb24oKXtyZXR1cm4gdj09PTI/ZTpudWxsfSxnZXRSZXNwb25zZUhlYWRlcjpmdW5jdGlvbihhKXt2YXIgYztpZih2PT09Mil7aWYoIWYpe2Y9e307d2hpbGUoYz1jbS5leGVjKGUpKWZbY1sxXS50b0xvd2VyQ2FzZSgpXT1jWzJdfWM9ZlthLnRvTG93ZXJDYXNlKCldfXJldHVybiBjPT09Yj9udWxsOmN9LG92ZXJyaWRlTWltZVR5cGU6ZnVuY3Rpb24oYSl7cmV0dXJuIHZ8fChsLm1pbWVUeXBlPWEpLHRoaXN9LGFib3J0OmZ1bmN0aW9uKGEpe3JldHVybiBhPWF8fHcsZyYmZy5hYm9ydChhKSx5KDAsYSksdGhpc319O28ucHJvbWlzZSh4KSx4LnN1Y2Nlc3M9eC5kb25lLHguZXJyb3I9eC5mYWlsLHguY29tcGxldGU9cS5hZGQseC5zdGF0dXNDb2RlPWZ1bmN0aW9uKGEpe2lmKGEpe3ZhciBiO2lmKHY8Milmb3IoYiBpbiBhKXJbYl09W3JbYl0sYVtiXV07ZWxzZSBiPWFbeC5zdGF0dXNdLHguYWx3YXlzKGIpfXJldHVybiB0aGlzfSxsLnVybD0oKGF8fGwudXJsKStcIlwiKS5yZXBsYWNlKGNsLFwiXCIpLnJlcGxhY2UoY3AsY2pbMV0rXCIvL1wiKSxsLmRhdGFUeXBlcz1wLnRyaW0obC5kYXRhVHlwZXx8XCIqXCIpLnRvTG93ZXJDYXNlKCkuc3BsaXQocyksbC5jcm9zc0RvbWFpbj09bnVsbCYmKGk9Y3QuZXhlYyhsLnVybC50b0xvd2VyQ2FzZSgpKXx8ITEsbC5jcm9zc0RvbWFpbj1pJiZpLmpvaW4oXCI6XCIpKyhpWzNdP1wiXCI6aVsxXT09PVwiaHR0cDpcIj84MDo0NDMpIT09Y2ouam9pbihcIjpcIikrKGNqWzNdP1wiXCI6Y2pbMV09PT1cImh0dHA6XCI/ODA6NDQzKSksbC5kYXRhJiZsLnByb2Nlc3NEYXRhJiZ0eXBlb2YgbC5kYXRhIT1cInN0cmluZ1wiJiYobC5kYXRhPXAucGFyYW0obC5kYXRhLGwudHJhZGl0aW9uYWwpKSxjQShjdixsLGMseCk7aWYodj09PTIpcmV0dXJuIHg7aj1sLmdsb2JhbCxsLnR5cGU9bC50eXBlLnRvVXBwZXJDYXNlKCksbC5oYXNDb250ZW50PSFjby50ZXN0KGwudHlwZSksaiYmcC5hY3RpdmUrKz09PTAmJnAuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtpZighbC5oYXNDb250ZW50KXtsLmRhdGEmJihsLnVybCs9KGNxLnRlc3QobC51cmwpP1wiJlwiOlwiP1wiKStsLmRhdGEsZGVsZXRlIGwuZGF0YSksZD1sLnVybDtpZihsLmNhY2hlPT09ITEpe3ZhciB6PXAubm93KCksQT1sLnVybC5yZXBsYWNlKGNzLFwiJDFfPVwiK3opO2wudXJsPUErKEE9PT1sLnVybD8oY3EudGVzdChsLnVybCk/XCImXCI6XCI/XCIpK1wiXz1cIit6OlwiXCIpfX0obC5kYXRhJiZsLmhhc0NvbnRlbnQmJmwuY29udGVudFR5cGUhPT0hMXx8Yy5jb250ZW50VHlwZSkmJnguc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLGwuY29udGVudFR5cGUpLGwuaWZNb2RpZmllZCYmKGQ9ZHx8bC51cmwscC5sYXN0TW9kaWZpZWRbZF0mJnguc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIscC5sYXN0TW9kaWZpZWRbZF0pLHAuZXRhZ1tkXSYmeC5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLHAuZXRhZ1tkXSkpLHguc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLGwuZGF0YVR5cGVzWzBdJiZsLmFjY2VwdHNbbC5kYXRhVHlwZXNbMF1dP2wuYWNjZXB0c1tsLmRhdGFUeXBlc1swXV0rKGwuZGF0YVR5cGVzWzBdIT09XCIqXCI/XCIsIFwiK2N4K1wiOyBxPTAuMDFcIjpcIlwiKTpsLmFjY2VwdHNbXCIqXCJdKTtmb3IoayBpbiBsLmhlYWRlcnMpeC5zZXRSZXF1ZXN0SGVhZGVyKGssbC5oZWFkZXJzW2tdKTtpZighbC5iZWZvcmVTZW5kfHxsLmJlZm9yZVNlbmQuY2FsbChtLHgsbCkhPT0hMSYmdiE9PTIpe3c9XCJhYm9ydFwiO2ZvcihrIGlue3N1Y2Nlc3M6MSxlcnJvcjoxLGNvbXBsZXRlOjF9KXhba10obFtrXSk7Zz1jQShjdyxsLGMseCk7aWYoIWcpeSgtMSxcIk5vIFRyYW5zcG9ydFwiKTtlbHNle3gucmVhZHlTdGF0ZT0xLGomJm4udHJpZ2dlcihcImFqYXhTZW5kXCIsW3gsbF0pLGwuYXN5bmMmJmwudGltZW91dD4wJiYoaD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7eC5hYm9ydChcInRpbWVvdXRcIil9LGwudGltZW91dCkpO3RyeXt2PTEsZy5zZW5kKHQseSl9Y2F0Y2goQil7aWYodjwyKXkoLTEsQik7ZWxzZSB0aHJvdyBCfX1yZXR1cm4geH1yZXR1cm4geC5hYm9ydCgpfSxhY3RpdmU6MCxsYXN0TW9kaWZpZWQ6e30sZXRhZzp7fX0pO3ZhciBjRT1bXSxjRj0vXFw/LyxjRz0vKD0pXFw/KD89JnwkKXxcXD9cXD8vLGNIPXAubm93KCk7cC5hamF4U2V0dXAoe2pzb25wOlwiY2FsbGJhY2tcIixqc29ucENhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGE9Y0UucG9wKCl8fHAuZXhwYW5kbytcIl9cIitjSCsrO3JldHVybiB0aGlzW2FdPSEwLGF9fSkscC5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLGZ1bmN0aW9uKGMsZCxlKXt2YXIgZixnLGgsaT1jLmRhdGEsaj1jLnVybCxrPWMuanNvbnAhPT0hMSxsPWsmJmNHLnRlc3QoaiksbT1rJiYhbCYmdHlwZW9mIGk9PVwic3RyaW5nXCImJiEoYy5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmY0cudGVzdChpKTtpZihjLmRhdGFUeXBlc1swXT09PVwianNvbnBcInx8bHx8bSlyZXR1cm4gZj1jLmpzb25wQ2FsbGJhY2s9cC5pc0Z1bmN0aW9uKGMuanNvbnBDYWxsYmFjayk/Yy5qc29ucENhbGxiYWNrKCk6Yy5qc29ucENhbGxiYWNrLGc9YVtmXSxsP2MudXJsPWoucmVwbGFjZShjRyxcIiQxXCIrZik6bT9jLmRhdGE9aS5yZXBsYWNlKGNHLFwiJDFcIitmKTprJiYoYy51cmwrPShjRi50ZXN0KGopP1wiJlwiOlwiP1wiKStjLmpzb25wK1wiPVwiK2YpLGMuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdPWZ1bmN0aW9uKCl7cmV0dXJuIGh8fHAuZXJyb3IoZitcIiB3YXMgbm90IGNhbGxlZFwiKSxoWzBdfSxjLmRhdGFUeXBlc1swXT1cImpzb25cIixhW2ZdPWZ1bmN0aW9uKCl7aD1hcmd1bWVudHN9LGUuYWx3YXlzKGZ1bmN0aW9uKCl7YVtmXT1nLGNbZl0mJihjLmpzb25wQ2FsbGJhY2s9ZC5qc29ucENhbGxiYWNrLGNFLnB1c2goZikpLGgmJnAuaXNGdW5jdGlvbihnKSYmZyhoWzBdKSxoPWc9Yn0pLFwic2NyaXB0XCJ9KSxwLmFqYXhTZXR1cCh7YWNjZXB0czp7c2NyaXB0OlwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIn0sY29udGVudHM6e3NjcmlwdDovamF2YXNjcmlwdHxlY21hc2NyaXB0L30sY29udmVydGVyczp7XCJ0ZXh0IHNjcmlwdFwiOmZ1bmN0aW9uKGEpe3JldHVybiBwLmdsb2JhbEV2YWwoYSksYX19fSkscC5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsZnVuY3Rpb24oYSl7YS5jYWNoZT09PWImJihhLmNhY2hlPSExKSxhLmNyb3NzRG9tYWluJiYoYS50eXBlPVwiR0VUXCIsYS5nbG9iYWw9ITEpfSkscC5hamF4VHJhbnNwb3J0KFwic2NyaXB0XCIsZnVuY3Rpb24oYSl7aWYoYS5jcm9zc0RvbWFpbil7dmFyIGMsZD1lLmhlYWR8fGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdfHxlLmRvY3VtZW50RWxlbWVudDtyZXR1cm57c2VuZDpmdW5jdGlvbihmLGcpe2M9ZS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpLGMuYXN5bmM9XCJhc3luY1wiLGEuc2NyaXB0Q2hhcnNldCYmKGMuY2hhcnNldD1hLnNjcmlwdENoYXJzZXQpLGMuc3JjPWEudXJsLGMub25sb2FkPWMub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKGEsZSl7aWYoZXx8IWMucmVhZHlTdGF0ZXx8L2xvYWRlZHxjb21wbGV0ZS8udGVzdChjLnJlYWR5U3RhdGUpKWMub25sb2FkPWMub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsZCYmYy5wYXJlbnROb2RlJiZkLnJlbW92ZUNoaWxkKGMpLGM9YixlfHxnKDIwMCxcInN1Y2Nlc3NcIil9LGQuaW5zZXJ0QmVmb3JlKGMsZC5maXJzdENoaWxkKX0sYWJvcnQ6ZnVuY3Rpb24oKXtjJiZjLm9ubG9hZCgwLDEpfX19fSk7dmFyIGNJLGNKPWEuQWN0aXZlWE9iamVjdD9mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiBjSSljSVthXSgwLDEpfTohMSxjSz0wO3AuYWpheFNldHRpbmdzLnhocj1hLkFjdGl2ZVhPYmplY3Q/ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pc0xvY2FsJiZjTCgpfHxjTSgpfTpjTCxmdW5jdGlvbihhKXtwLmV4dGVuZChwLnN1cHBvcnQse2FqYXg6ISFhLGNvcnM6ISFhJiZcIndpdGhDcmVkZW50aWFsc1wiaW4gYX0pfShwLmFqYXhTZXR0aW5ncy54aHIoKSkscC5zdXBwb3J0LmFqYXgmJnAuYWpheFRyYW5zcG9ydChmdW5jdGlvbihjKXtpZighYy5jcm9zc0RvbWFpbnx8cC5zdXBwb3J0LmNvcnMpe3ZhciBkO3JldHVybntzZW5kOmZ1bmN0aW9uKGUsZil7dmFyIGcsaCxpPWMueGhyKCk7Yy51c2VybmFtZT9pLm9wZW4oYy50eXBlLGMudXJsLGMuYXN5bmMsYy51c2VybmFtZSxjLnBhc3N3b3JkKTppLm9wZW4oYy50eXBlLGMudXJsLGMuYXN5bmMpO2lmKGMueGhyRmllbGRzKWZvcihoIGluIGMueGhyRmllbGRzKWlbaF09Yy54aHJGaWVsZHNbaF07Yy5taW1lVHlwZSYmaS5vdmVycmlkZU1pbWVUeXBlJiZpLm92ZXJyaWRlTWltZVR5cGUoYy5taW1lVHlwZSksIWMuY3Jvc3NEb21haW4mJiFlW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSYmKGVbXCJYLVJlcXVlc3RlZC1XaXRoXCJdPVwiWE1MSHR0cFJlcXVlc3RcIik7dHJ5e2ZvcihoIGluIGUpaS5zZXRSZXF1ZXN0SGVhZGVyKGgsZVtoXSl9Y2F0Y2goail7fWkuc2VuZChjLmhhc0NvbnRlbnQmJmMuZGF0YXx8bnVsbCksZD1mdW5jdGlvbihhLGUpe3ZhciBoLGosayxsLG07dHJ5e2lmKGQmJihlfHxpLnJlYWR5U3RhdGU9PT00KSl7ZD1iLGcmJihpLm9ucmVhZHlzdGF0ZWNoYW5nZT1wLm5vb3AsY0omJmRlbGV0ZSBjSVtnXSk7aWYoZSlpLnJlYWR5U3RhdGUhPT00JiZpLmFib3J0KCk7ZWxzZXtoPWkuc3RhdHVzLGs9aS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSxsPXt9LG09aS5yZXNwb25zZVhNTCxtJiZtLmRvY3VtZW50RWxlbWVudCYmKGwueG1sPW0pO3RyeXtsLnRleHQ9aS5yZXNwb25zZVRleHR9Y2F0Y2goYSl7fXRyeXtqPWkuc3RhdHVzVGV4dH1jYXRjaChuKXtqPVwiXCJ9IWgmJmMuaXNMb2NhbCYmIWMuY3Jvc3NEb21haW4/aD1sLnRleHQ/MjAwOjQwNDpoPT09MTIyMyYmKGg9MjA0KX19fWNhdGNoKG8pe2V8fGYoLTEsbyl9bCYmZihoLGosbCxrKX0sYy5hc3luYz9pLnJlYWR5U3RhdGU9PT00P3NldFRpbWVvdXQoZCwwKTooZz0rK2NLLGNKJiYoY0l8fChjST17fSxwKGEpLnVubG9hZChjSikpLGNJW2ddPWQpLGkub25yZWFkeXN0YXRlY2hhbmdlPWQpOmQoKX0sYWJvcnQ6ZnVuY3Rpb24oKXtkJiZkKDAsMSl9fX19KTt2YXIgY04sY08sY1A9L14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLGNRPW5ldyBSZWdFeHAoXCJeKD86KFstK10pPXwpKFwiK3ErXCIpKFthLXolXSopJFwiLFwiaVwiKSxjUj0vcXVldWVIb29rcyQvLGNTPVtjWV0sY1Q9e1wiKlwiOltmdW5jdGlvbihhLGIpe3ZhciBjLGQsZT10aGlzLmNyZWF0ZVR3ZWVuKGEsYiksZj1jUS5leGVjKGIpLGc9ZS5jdXIoKSxoPStnfHwwLGk9MSxqPTIwO2lmKGYpe2M9K2ZbMl0sZD1mWzNdfHwocC5jc3NOdW1iZXJbYV0/XCJcIjpcInB4XCIpO2lmKGQhPT1cInB4XCImJmgpe2g9cC5jc3MoZS5lbGVtLGEsITApfHxjfHwxO2RvIGk9aXx8XCIuNVwiLGg9aC9pLHAuc3R5bGUoZS5lbGVtLGEsaCtkKTt3aGlsZShpIT09KGk9ZS5jdXIoKS9nKSYmaSE9PTEmJi0tail9ZS51bml0PWQsZS5zdGFydD1oLGUuZW5kPWZbMV0/aCsoZlsxXSsxKSpjOmN9cmV0dXJuIGV9XX07cC5BbmltYXRpb249cC5leHRlbmQoY1cse3R3ZWVuZXI6ZnVuY3Rpb24oYSxiKXtwLmlzRnVuY3Rpb24oYSk/KGI9YSxhPVtcIipcIl0pOmE9YS5zcGxpdChcIiBcIik7dmFyIGMsZD0wLGU9YS5sZW5ndGg7Zm9yKDtkPGU7ZCsrKWM9YVtkXSxjVFtjXT1jVFtjXXx8W10sY1RbY10udW5zaGlmdChiKX0scHJlZmlsdGVyOmZ1bmN0aW9uKGEsYil7Yj9jUy51bnNoaWZ0KGEpOmNTLnB1c2goYSl9fSkscC5Ud2Vlbj1jWixjWi5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmNaLGluaXQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3RoaXMuZWxlbT1hLHRoaXMucHJvcD1jLHRoaXMuZWFzaW5nPWV8fFwic3dpbmdcIix0aGlzLm9wdGlvbnM9Yix0aGlzLnN0YXJ0PXRoaXMubm93PXRoaXMuY3VyKCksdGhpcy5lbmQ9ZCx0aGlzLnVuaXQ9Znx8KHAuY3NzTnVtYmVyW2NdP1wiXCI6XCJweFwiKX0sY3VyOmZ1bmN0aW9uKCl7dmFyIGE9Y1oucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIGEmJmEuZ2V0P2EuZ2V0KHRoaXMpOmNaLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcyl9LHJ1bjpmdW5jdGlvbihhKXt2YXIgYixjPWNaLnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiB0aGlzLm9wdGlvbnMuZHVyYXRpb24/dGhpcy5wb3M9Yj1wLmVhc2luZ1t0aGlzLmVhc2luZ10oYSx0aGlzLm9wdGlvbnMuZHVyYXRpb24qYSwwLDEsdGhpcy5vcHRpb25zLmR1cmF0aW9uKTp0aGlzLnBvcz1iPWEsdGhpcy5ub3c9KHRoaXMuZW5kLXRoaXMuc3RhcnQpKmIrdGhpcy5zdGFydCx0aGlzLm9wdGlvbnMuc3RlcCYmdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sdGhpcy5ub3csdGhpcyksYyYmYy5zZXQ/Yy5zZXQodGhpcyk6Y1oucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSx0aGlzfX0sY1oucHJvdG90eXBlLmluaXQucHJvdG90eXBlPWNaLnByb3RvdHlwZSxjWi5wcm9wSG9va3M9e19kZWZhdWx0OntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuIGEuZWxlbVthLnByb3BdPT1udWxsfHwhIWEuZWxlbS5zdHlsZSYmYS5lbGVtLnN0eWxlW2EucHJvcF0hPW51bGw/KGI9cC5jc3MoYS5lbGVtLGEucHJvcCwhMSxcIlwiKSwhYnx8Yj09PVwiYXV0b1wiPzA6Yik6YS5lbGVtW2EucHJvcF19LHNldDpmdW5jdGlvbihhKXtwLmZ4LnN0ZXBbYS5wcm9wXT9wLmZ4LnN0ZXBbYS5wcm9wXShhKTphLmVsZW0uc3R5bGUmJihhLmVsZW0uc3R5bGVbcC5jc3NQcm9wc1thLnByb3BdXSE9bnVsbHx8cC5jc3NIb29rc1thLnByb3BdKT9wLnN0eWxlKGEuZWxlbSxhLnByb3AsYS5ub3crYS51bml0KTphLmVsZW1bYS5wcm9wXT1hLm5vd319fSxjWi5wcm9wSG9va3Muc2Nyb2xsVG9wPWNaLnByb3BIb29rcy5zY3JvbGxMZWZ0PXtzZXQ6ZnVuY3Rpb24oYSl7YS5lbGVtLm5vZGVUeXBlJiZhLmVsZW0ucGFyZW50Tm9kZSYmKGEuZWxlbVthLnByb3BdPWEubm93KX19LHAuZWFjaChbXCJ0b2dnbGVcIixcInNob3dcIixcImhpZGVcIl0sZnVuY3Rpb24oYSxiKXt2YXIgYz1wLmZuW2JdO3AuZm5bYl09ZnVuY3Rpb24oZCxlLGYpe3JldHVybiBkPT1udWxsfHx0eXBlb2YgZD09XCJib29sZWFuXCJ8fCFhJiZwLmlzRnVuY3Rpb24oZCkmJnAuaXNGdW5jdGlvbihlKT9jLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmFuaW1hdGUoYyQoYiwhMCksZCxlLGYpfX0pLHAuZm4uZXh0ZW5kKHtmYWRlVG86ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuZmlsdGVyKGJaKS5jc3MoXCJvcGFjaXR5XCIsMCkuc2hvdygpLmVuZCgpLmFuaW1hdGUoe29wYWNpdHk6Yn0sYSxjLGQpfSxhbmltYXRlOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXAuaXNFbXB0eU9iamVjdChhKSxmPXAuc3BlZWQoYixjLGQpLGc9ZnVuY3Rpb24oKXt2YXIgYj1jVyh0aGlzLHAuZXh0ZW5kKHt9LGEpLGYpO2UmJmIuc3RvcCghMCl9O3JldHVybiBlfHxmLnF1ZXVlPT09ITE/dGhpcy5lYWNoKGcpOnRoaXMucXVldWUoZi5xdWV1ZSxnKX0sc3RvcDpmdW5jdGlvbihhLGMsZCl7dmFyIGU9ZnVuY3Rpb24oYSl7dmFyIGI9YS5zdG9wO2RlbGV0ZSBhLnN0b3AsYihkKX07cmV0dXJuIHR5cGVvZiBhIT1cInN0cmluZ1wiJiYoZD1jLGM9YSxhPWIpLGMmJmEhPT0hMSYmdGhpcy5xdWV1ZShhfHxcImZ4XCIsW10pLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPSEwLGM9YSE9bnVsbCYmYStcInF1ZXVlSG9va3NcIixmPXAudGltZXJzLGc9cC5fZGF0YSh0aGlzKTtpZihjKWdbY10mJmdbY10uc3RvcCYmZShnW2NdKTtlbHNlIGZvcihjIGluIGcpZ1tjXSYmZ1tjXS5zdG9wJiZjUi50ZXN0KGMpJiZlKGdbY10pO2ZvcihjPWYubGVuZ3RoO2MtLTspZltjXS5lbGVtPT09dGhpcyYmKGE9PW51bGx8fGZbY10ucXVldWU9PT1hKSYmKGZbY10uYW5pbS5zdG9wKGQpLGI9ITEsZi5zcGxpY2UoYywxKSk7KGJ8fCFkKSYmcC5kZXF1ZXVlKHRoaXMsYSl9KX19KSxwLmVhY2goe3NsaWRlRG93bjpjJChcInNob3dcIiksc2xpZGVVcDpjJChcImhpZGVcIiksc2xpZGVUb2dnbGU6YyQoXCJ0b2dnbGVcIiksZmFkZUluOntvcGFjaXR5Olwic2hvd1wifSxmYWRlT3V0OntvcGFjaXR5OlwiaGlkZVwifSxmYWRlVG9nZ2xlOntvcGFjaXR5OlwidG9nZ2xlXCJ9fSxmdW5jdGlvbihhLGIpe3AuZm5bYV09ZnVuY3Rpb24oYSxjLGQpe3JldHVybiB0aGlzLmFuaW1hdGUoYixhLGMsZCl9fSkscC5zcGVlZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YSYmdHlwZW9mIGE9PVwib2JqZWN0XCI/cC5leHRlbmQoe30sYSk6e2NvbXBsZXRlOmN8fCFjJiZifHxwLmlzRnVuY3Rpb24oYSkmJmEsZHVyYXRpb246YSxlYXNpbmc6YyYmYnx8YiYmIXAuaXNGdW5jdGlvbihiKSYmYn07ZC5kdXJhdGlvbj1wLmZ4Lm9mZj8wOnR5cGVvZiBkLmR1cmF0aW9uPT1cIm51bWJlclwiP2QuZHVyYXRpb246ZC5kdXJhdGlvbiBpbiBwLmZ4LnNwZWVkcz9wLmZ4LnNwZWVkc1tkLmR1cmF0aW9uXTpwLmZ4LnNwZWVkcy5fZGVmYXVsdDtpZihkLnF1ZXVlPT1udWxsfHxkLnF1ZXVlPT09ITApZC5xdWV1ZT1cImZ4XCI7cmV0dXJuIGQub2xkPWQuY29tcGxldGUsZC5jb21wbGV0ZT1mdW5jdGlvbigpe3AuaXNGdW5jdGlvbihkLm9sZCkmJmQub2xkLmNhbGwodGhpcyksZC5xdWV1ZSYmcC5kZXF1ZXVlKHRoaXMsZC5xdWV1ZSl9LGR9LHAuZWFzaW5nPXtsaW5lYXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGF9LHN3aW5nOmZ1bmN0aW9uKGEpe3JldHVybi41LU1hdGguY29zKGEqTWF0aC5QSSkvMn19LHAudGltZXJzPVtdLHAuZng9Y1oucHJvdG90eXBlLmluaXQscC5meC50aWNrPWZ1bmN0aW9uKCl7dmFyIGEsYj1wLnRpbWVycyxjPTA7Zm9yKDtjPGIubGVuZ3RoO2MrKylhPWJbY10sIWEoKSYmYltjXT09PWEmJmIuc3BsaWNlKGMtLSwxKTtiLmxlbmd0aHx8cC5meC5zdG9wKCl9LHAuZngudGltZXI9ZnVuY3Rpb24oYSl7YSgpJiZwLnRpbWVycy5wdXNoKGEpJiYhY08mJihjTz1zZXRJbnRlcnZhbChwLmZ4LnRpY2sscC5meC5pbnRlcnZhbCkpfSxwLmZ4LmludGVydmFsPTEzLHAuZnguc3RvcD1mdW5jdGlvbigpe2NsZWFySW50ZXJ2YWwoY08pLGNPPW51bGx9LHAuZnguc3BlZWRzPXtzbG93OjYwMCxmYXN0OjIwMCxfZGVmYXVsdDo0MDB9LHAuZnguc3RlcD17fSxwLmV4cHImJnAuZXhwci5maWx0ZXJzJiYocC5leHByLmZpbHRlcnMuYW5pbWF0ZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHAuZ3JlcChwLnRpbWVycyxmdW5jdGlvbihiKXtyZXR1cm4gYT09PWIuZWxlbX0pLmxlbmd0aH0pO3ZhciBjXz0vXig/OmJvZHl8aHRtbCkkL2k7cC5mbi5vZmZzZXQ9ZnVuY3Rpb24oYSl7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gYT09PWI/dGhpczp0aGlzLmVhY2goZnVuY3Rpb24oYil7cC5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsYSxiKX0pO3ZhciBjLGQsZSxmLGcsaCxpLGo9e3RvcDowLGxlZnQ6MH0saz10aGlzWzBdLGw9ayYmay5vd25lckRvY3VtZW50O2lmKCFsKXJldHVybjtyZXR1cm4oZD1sLmJvZHkpPT09az9wLm9mZnNldC5ib2R5T2Zmc2V0KGspOihjPWwuZG9jdW1lbnRFbGVtZW50LHAuY29udGFpbnMoYyxrKT8odHlwZW9mIGsuZ2V0Qm91bmRpbmdDbGllbnRSZWN0IT1cInVuZGVmaW5lZFwiJiYoaj1rLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxlPWRhKGwpLGY9Yy5jbGllbnRUb3B8fGQuY2xpZW50VG9wfHwwLGc9Yy5jbGllbnRMZWZ0fHxkLmNsaWVudExlZnR8fDAsaD1lLnBhZ2VZT2Zmc2V0fHxjLnNjcm9sbFRvcCxpPWUucGFnZVhPZmZzZXR8fGMuc2Nyb2xsTGVmdCx7dG9wOmoudG9wK2gtZixsZWZ0OmoubGVmdCtpLWd9KTpqKX0scC5vZmZzZXQ9e2JvZHlPZmZzZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5vZmZzZXRUb3AsYz1hLm9mZnNldExlZnQ7cmV0dXJuIHAuc3VwcG9ydC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCYmKGIrPXBhcnNlRmxvYXQocC5jc3MoYSxcIm1hcmdpblRvcFwiKSl8fDAsYys9cGFyc2VGbG9hdChwLmNzcyhhLFwibWFyZ2luTGVmdFwiKSl8fDApLHt0b3A6YixsZWZ0OmN9fSxzZXRPZmZzZXQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXAuY3NzKGEsXCJwb3NpdGlvblwiKTtkPT09XCJzdGF0aWNcIiYmKGEuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiKTt2YXIgZT1wKGEpLGY9ZS5vZmZzZXQoKSxnPXAuY3NzKGEsXCJ0b3BcIiksaD1wLmNzcyhhLFwibGVmdFwiKSxpPShkPT09XCJhYnNvbHV0ZVwifHxkPT09XCJmaXhlZFwiKSYmcC5pbkFycmF5KFwiYXV0b1wiLFtnLGhdKT4tMSxqPXt9LGs9e30sbCxtO2k/KGs9ZS5wb3NpdGlvbigpLGw9ay50b3AsbT1rLmxlZnQpOihsPXBhcnNlRmxvYXQoZyl8fDAsbT1wYXJzZUZsb2F0KGgpfHwwKSxwLmlzRnVuY3Rpb24oYikmJihiPWIuY2FsbChhLGMsZikpLGIudG9wIT1udWxsJiYoai50b3A9Yi50b3AtZi50b3ArbCksYi5sZWZ0IT1udWxsJiYoai5sZWZ0PWIubGVmdC1mLmxlZnQrbSksXCJ1c2luZ1wiaW4gYj9iLnVzaW5nLmNhbGwoYSxqKTplLmNzcyhqKX19LHAuZm4uZXh0ZW5kKHtwb3NpdGlvbjpmdW5jdGlvbigpe2lmKCF0aGlzWzBdKXJldHVybjt2YXIgYT10aGlzWzBdLGI9dGhpcy5vZmZzZXRQYXJlbnQoKSxjPXRoaXMub2Zmc2V0KCksZD1jXy50ZXN0KGJbMF0ubm9kZU5hbWUpP3t0b3A6MCxsZWZ0OjB9OmIub2Zmc2V0KCk7cmV0dXJuIGMudG9wLT1wYXJzZUZsb2F0KHAuY3NzKGEsXCJtYXJnaW5Ub3BcIikpfHwwLGMubGVmdC09cGFyc2VGbG9hdChwLmNzcyhhLFwibWFyZ2luTGVmdFwiKSl8fDAsZC50b3ArPXBhcnNlRmxvYXQocC5jc3MoYlswXSxcImJvcmRlclRvcFdpZHRoXCIpKXx8MCxkLmxlZnQrPXBhcnNlRmxvYXQocC5jc3MoYlswXSxcImJvcmRlckxlZnRXaWR0aFwiKSl8fDAse3RvcDpjLnRvcC1kLnRvcCxsZWZ0OmMubGVmdC1kLmxlZnR9fSxvZmZzZXRQYXJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9mZnNldFBhcmVudHx8ZS5ib2R5O3doaWxlKGEmJiFjXy50ZXN0KGEubm9kZU5hbWUpJiZwLmNzcyhhLFwicG9zaXRpb25cIik9PT1cInN0YXRpY1wiKWE9YS5vZmZzZXRQYXJlbnQ7cmV0dXJuIGF8fGUuYm9keX0pfX0pLHAuZWFjaCh7c2Nyb2xsTGVmdDpcInBhZ2VYT2Zmc2V0XCIsc2Nyb2xsVG9wOlwicGFnZVlPZmZzZXRcIn0sZnVuY3Rpb24oYSxjKXt2YXIgZD0vWS8udGVzdChjKTtwLmZuW2FdPWZ1bmN0aW9uKGUpe3JldHVybiBwLmFjY2Vzcyh0aGlzLGZ1bmN0aW9uKGEsZSxmKXt2YXIgZz1kYShhKTtpZihmPT09YilyZXR1cm4gZz9jIGluIGc/Z1tjXTpnLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtlXTphW2VdO2c/Zy5zY3JvbGxUbyhkP3AoZykuc2Nyb2xsTGVmdCgpOmYsZD9mOnAoZykuc2Nyb2xsVG9wKCkpOmFbZV09Zn0sYSxlLGFyZ3VtZW50cy5sZW5ndGgsbnVsbCl9fSkscC5lYWNoKHtIZWlnaHQ6XCJoZWlnaHRcIixXaWR0aDpcIndpZHRoXCJ9LGZ1bmN0aW9uKGEsYyl7cC5lYWNoKHtwYWRkaW5nOlwiaW5uZXJcIithLGNvbnRlbnQ6YyxcIlwiOlwib3V0ZXJcIithfSxmdW5jdGlvbihkLGUpe3AuZm5bZV09ZnVuY3Rpb24oZSxmKXt2YXIgZz1hcmd1bWVudHMubGVuZ3RoJiYoZHx8dHlwZW9mIGUhPVwiYm9vbGVhblwiKSxoPWR8fChlPT09ITB8fGY9PT0hMD9cIm1hcmdpblwiOlwiYm9yZGVyXCIpO3JldHVybiBwLmFjY2Vzcyh0aGlzLGZ1bmN0aW9uKGMsZCxlKXt2YXIgZjtyZXR1cm4gcC5pc1dpbmRvdyhjKT9jLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiK2FdOmMubm9kZVR5cGU9PT05PyhmPWMuZG9jdW1lbnRFbGVtZW50LE1hdGgubWF4KGMuYm9keVtcInNjcm9sbFwiK2FdLGZbXCJzY3JvbGxcIithXSxjLmJvZHlbXCJvZmZzZXRcIithXSxmW1wib2Zmc2V0XCIrYV0sZltcImNsaWVudFwiK2FdKSk6ZT09PWI/cC5jc3MoYyxkLGUsaCk6cC5zdHlsZShjLGQsZSxoKX0sYyxnP2U6YixnLG51bGwpfX0pfSksYS5qUXVlcnk9YS4kPXAsdHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUuYW1kLmpRdWVyeSYmZGVmaW5lKFwianF1ZXJ5XCIsW10sZnVuY3Rpb24oKXtyZXR1cm4gcH0pfSkod2luZG93KTtcbiIsIi8qISBDb3B5cmlnaHQgKGMpIDIwMTEgQnJhbmRvbiBBYXJvbiAoaHR0cDovL2JyYW5kb25hYXJvbi5uZXQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKExJQ0VOU0UudHh0KS5cbiAqXG4gKiBUaGFua3MgdG86IGh0dHA6Ly9hZG9tYXMub3JnL2phdmFzY3JpcHQtbW91c2Utd2hlZWwvIGZvciBzb21lIHBvaW50ZXJzLlxuICogVGhhbmtzIHRvOiBNYXRoaWFzIEJhbmsoaHR0cDovL3d3dy5tYXRoaWFzLWJhbmsuZGUpIGZvciBhIHNjb3BlIGJ1ZyBmaXguXG4gKiBUaGFua3MgdG86IFNlYW11cyBMZWFoeSBmb3IgYWRkaW5nIGRlbHRhWCBhbmQgZGVsdGFZXG4gKlxuICogVmVyc2lvbjogMy4wLjZcbiAqIFxuICogUmVxdWlyZXM6IDEuMi4yK1xuICovXG5cbihmdW5jdGlvbigkKSB7XG5cbnZhciB0eXBlcyA9IFsnRE9NTW91c2VTY3JvbGwnLCAnbW91c2V3aGVlbCddO1xuXG5pZiAoJC5ldmVudC5maXhIb29rcykge1xuICAgIGZvciAoIHZhciBpPXR5cGVzLmxlbmd0aDsgaTsgKSB7XG4gICAgICAgICQuZXZlbnQuZml4SG9va3NbIHR5cGVzWy0taV0gXSA9ICQuZXZlbnQubW91c2VIb29rcztcbiAgICB9XG59XG5cbiQuZXZlbnQuc3BlY2lhbC5tb3VzZXdoZWVsID0ge1xuICAgIHNldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaT10eXBlcy5sZW5ndGg7IGk7ICkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggdHlwZXNbLS1pXSwgaGFuZGxlciwgZmFsc2UgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25tb3VzZXdoZWVsID0gaGFuZGxlcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgIGZvciAoIHZhciBpPXR5cGVzLmxlbmd0aDsgaTsgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlc1stLWldLCBoYW5kbGVyLCBmYWxzZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbm1vdXNld2hlZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuJC5mbi5leHRlbmQoe1xuICAgIG1vdXNld2hlZWw6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHJldHVybiBmbiA/IHRoaXMuYmluZChcIm1vdXNld2hlZWxcIiwgZm4pIDogdGhpcy50cmlnZ2VyKFwibW91c2V3aGVlbFwiKTtcbiAgICB9LFxuICAgIFxuICAgIHVubW91c2V3aGVlbDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5iaW5kKFwibW91c2V3aGVlbFwiLCBmbik7XG4gICAgfVxufSk7XG5cblxuZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgIHZhciBvcmdFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudCwgYXJncyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLCBkZWx0YSA9IDAsIHJldHVyblZhbHVlID0gdHJ1ZSwgZGVsdGFYID0gMCwgZGVsdGFZID0gMDtcbiAgICBldmVudCA9ICQuZXZlbnQuZml4KG9yZ0V2ZW50KTtcbiAgICBldmVudC50eXBlID0gXCJtb3VzZXdoZWVsXCI7XG4gICAgXG4gICAgLy8gT2xkIHNjaG9vbCBzY3JvbGx3aGVlbCBkZWx0YVxuICAgIGlmICggb3JnRXZlbnQud2hlZWxEZWx0YSApIHsgZGVsdGEgPSBvcmdFdmVudC53aGVlbERlbHRhLzEyMDsgfVxuICAgIGlmICggb3JnRXZlbnQuZGV0YWlsICAgICApIHsgZGVsdGEgPSAtb3JnRXZlbnQuZGV0YWlsLzM7IH1cbiAgICBcbiAgICAvLyBOZXcgc2Nob29sIG11bHRpZGltZW5zaW9uYWwgc2Nyb2xsICh0b3VjaHBhZHMpIGRlbHRhc1xuICAgIGRlbHRhWSA9IGRlbHRhO1xuICAgIFxuICAgIC8vIEdlY2tvXG4gICAgaWYgKCBvcmdFdmVudC5heGlzICE9PSB1bmRlZmluZWQgJiYgb3JnRXZlbnQuYXhpcyA9PT0gb3JnRXZlbnQuSE9SSVpPTlRBTF9BWElTICkge1xuICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICBkZWx0YVggPSAtMSpkZWx0YTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2Via2l0XG4gICAgaWYgKCBvcmdFdmVudC53aGVlbERlbHRhWSAhPT0gdW5kZWZpbmVkICkgeyBkZWx0YVkgPSBvcmdFdmVudC53aGVlbERlbHRhWS8xMjA7IH1cbiAgICBpZiAoIG9yZ0V2ZW50LndoZWVsRGVsdGFYICE9PSB1bmRlZmluZWQgKSB7IGRlbHRhWCA9IC0xKm9yZ0V2ZW50LndoZWVsRGVsdGFYLzEyMDsgfVxuICAgIFxuICAgIC8vIEFkZCBldmVudCBhbmQgZGVsdGEgdG8gdGhlIGZyb250IG9mIHRoZSBhcmd1bWVudHNcbiAgICBhcmdzLnVuc2hpZnQoZXZlbnQsIGRlbHRhLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgXG4gICAgcmV0dXJuICgkLmV2ZW50LmRpc3BhdGNoIHx8ICQuZXZlbnQuaGFuZGxlKS5hcHBseSh0aGlzLCBhcmdzKTtcbn1cblxufSkoalF1ZXJ5KTtcbiIsIihmdW5jdGlvbiAoJCkge1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgZnVsbHNjcmVlbiA6IGZhbHNlLFxuICAgICAgICBzY2FsZSA6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0RXZlbnRIYW5kbGluZyA6IHRydWUsXG4gICAgICAgIHByZW9wZW4gOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgcG9zdG9wZW4gOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgcHJlY2xvc2UgOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgcG9zdGNsb3NlIDogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIHByZXJlc2l6ZSA6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBwb3N0cmVzaXplIDogZnVuY3Rpb24gKCkge31cbiAgICB9O1xuXG4gICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAgIG9wZW4gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lKHRydWUpLFxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEoXCJsaWdodGJveFwiKSxcbiAgICAgICAgICAgICAgICB3LCBoO1xuXG4gICAgICAgICAgICBkYXRhLmNvbnRlbnRzID0gY2xvbmU7XG4gICAgICAgICAgICBkYXRhLnByZW9wZW4uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNsb25lID0gZGF0YS5jb250ZW50czsgLy8gZGF0YS5jb250ZW50cyBtaWdodCBoYXZlIGJlZW4gYWx0ZXJlZCBieSBkYXRhLnByZW9wZW5cbiAgICAgICAgICAgIHZhciBjbG9uZURhdGEgPSBjbG9uZS5kYXRhKFwibGlnaHRib3hcIik7XG5cbiAgICAgICAgICAgIGRhdGEub3ZlcmxheSA9ICQoXCI8ZGl2Lz5cIilcbiAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiICAgICAgICAgOiBcImZpeGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGVmdFwiICAgICAgICAgICAgIDogXCIwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0b3BcIiAgICAgICAgICAgICAgOiBcIjBweFwiLFxuICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiICAgICAgICAgICA6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pbi1oZWlnaHRcIiAgICAgICA6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCIgICAgICAgICAgICA6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICBcInotaW5kZXhcIiAgICAgICAgICA6IFwiOTk5OVwiLFxuICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIiA6IFwiYmxhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvcGFjaXR5XCIgICAgICAgICAgOiBcIjAuNVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oXCJib2R5XCIpO1xuXG4gICAgICAgICAgICBkYXRhLmJveCA9ICQoXCI8ZGl2Lz5cIilcbiAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiICAgICAgICAgOiBcImZpeGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiei1pbmRleFwiICAgICAgICAgIDogXCI5OTk5XCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhcImJvZHlcIik7XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgZGF0YS5ib3guYXBwZW5kKGNsb25lKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuZnVsbHNjcmVlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHcgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBoID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gY2xvbmUud2lkdGgoKTtcbiAgICAgICAgICAgICAgICBoID0gY2xvbmUuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2NhbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjb21wdXRlUmF0aW8odywgaCk7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBwYXJzZUludCh3ICogciwgMTApO1xuICAgICAgICAgICAgICAgICAgICBoID0gcGFyc2VJbnQoaCAqIHIsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjYWxlRWxlbWVudChkYXRhLmJveCwgdywgaCk7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoZGF0YS5ib3gsIHcsIGgpO1xuXG4gICAgICAgICAgICBzY2FsZUVsZW1lbnQoY2xvbmUsIHcsIGgpO1xuICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50KGNsb25lLCB3LCBoKTtcbiAgICAgICAgICAgIGNsb25lLmNzcyhcInBvc2l0aW9uXCIsIFwiZml4ZWRcIilcbiAgICAgICAgICAgICAgICAuY3NzKFwiei1pbmRleFwiLCA5OTk5KTtcblxuICAgICAgICAgICAgZGF0YS5ib3guYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoXCI8aW1nIHNyYz1cXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDd0FBQUFzQ0FZQUFBQWVoRm9CQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5SnBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU15MWpNREV4SURZMkxqRTBOVFkyTVN3Z01qQXhNaTh3TWk4d05pMHhORG8xTmpveU55QWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTlROaUFvVjJsdVpHOTNjeWtpSUhodGNFMU5Pa2x1YzNSaGJtTmxTVVE5SW5odGNDNXBhV1E2TmtZNE9VRTRRVUUyTURFeU1URkZNa0ZCTUVNNFEwWTJSVGxGTmtJNFF6RWlJSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUTlJbmh0Y0M1a2FXUTZOa1k0T1VFNFFVSTJNREV5TVRGRk1rRkJNRU00UTBZMlJUbEZOa0k0UXpFaVBpQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjM1JTWldZNmFXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJSamc1UVRoQk9EWXdNVEl4TVVVeVFVRXdRemhEUmpaRk9VVTJRamhETVNJZ2MzUlNaV1k2Wkc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMlJqZzVRVGhCT1RZd01USXhNVVV5UVVFd1F6aERSalpGT1VVMlFqaERNU0l2UGlBOEwzSmtaanBFWlhOamNtbHdkR2x2Ymo0Z1BDOXlaR1k2VWtSR1BpQThMM2c2ZUcxd2JXVjBZVDRnUEQ5NGNHRmphMlYwSUdWdVpEMGljaUkvUHZYQy91a0FBQWNqU1VSQlZIamF4RmxwVEZWWEVKN0hEcklJVWtDUnpZaXRRSlFLL2tCVHhBb3AyRVFoYXFrRXFqWnFLOUZHYSsyQ2YycGFiZElsRWJFMEZFa1RBckZhRjZDQUtDQ1N0RzVCb2tYQWdscFVJa0txZ24wS3lOYjVqdmUrUEI5dmZ5eVRmSUY3MzczbnpKa3paNzZadVlxUmtSR3lVS3dZb1l3UXhxc01ENGFqOUZzUG80TnhnMUhQNkxSME1oc3ozN05seEROU0dMSHQ3ZTJlOSsvZnB3Y1BIdERUcDAvcCtmUG40aUZIUjBlYU9uVXFUWjgrblFJQ0FzalYxYldKYjVjd0NoaU41a3lzTU5IQ3NOd0hqRSt1WHIzcWUrblNKV3BzYkNTbFVtblV5ek5tektEdzhIQ0tpb29pWDEvZkdyNjFsMUU5WGdvbk1qTFBuRG5qWDFOVEk2eHBpVVJHUnRMU3BVc3BKQ1NrbEM4L1l2d3pWZ283TTdMcjYrdlR6cDQ5Uzlldlg2ZXhsSVNFQkVwT1RzWVdmY2dvdEZSaFgwWkZlWGw1MkpFalIyaThKRGc0bUpZdFd3Wlh5ZVRManhuRDVpZzhtMUYxN05peGdKS1NFaHB2c2JHeG9aU1VGSXFOamYyVkwxTVpRNllvN00zNG83Q3djUGFwVTZkb0ltWGR1blVVRnhmM0UvK2JicXpDQ0ZtMXg0OGZqenB4NGdSTmhtellzQUdXeGtITTBoYjBOZVdyaW9xS0tGYVlzSmpKd09uVHA2SEg5NHpYRFNrY3p0aDU5T2pSU1ZNV1lDS2kzTnhjTzlibFo0YTFQcWJMNUFkdHdGYTZaTTZjT1dSdmIwOVdWbGFrVUNoVTk1dWFtbFFNcHludTd1NGdDdkVPSUV0blp5ZDFkSFJvZmFlcXFvcG16Wm9WeWRIamZiN00xYVp3RExOV2RHVmxwVjcvNnUzdHBTVkxsZ2pLdGJXMVZkMzM4dktTdC9JbHNiT3pFOHcyYytaTWNuTnpVNzN6NU1rVE9uVG9FT2tMcTB4U0NIZGY4TCsvTUFZMUZkNkpDWWVIaC9VcTNOYldScTJ0cmJSOCtYSmhPZGxpc0NEeWlXdlhycjMwL1B6NTg4VnZnWUdCNU9ucFNkYldMM1k0TXpPVDlPMGs1TmF0VzNUaHdvVWdYbkFTWC82bTdzTmVTR1l1WHJ4b2xJOWh1MjdmdmkxY1lzcVVLZVRzN0N5VXgrbjI4UEJRUFJjVUZFUno1ODRWT1lTUGp3K1NIL0ZzYlcwdE1YTWFOZGU1YytlZzMzdWFoeTZKcldzek1EQWdMR3dNOHZQejZkNjllOVRmM3k4R2dPVzh2YjFweTVZdDRuY29GaEVSSVJRRmtMbGhnVGR2M2hTdVlPdzhWNjVjd2ZCdk1WelVGWTVwYUdnd2VoRGcwYU5IeEN3by9nNE9EcjRJNE95ZnNPaUtGU3NFL1B6OGhIVmhXYmdPL0gvLy92MG16UU1qc3RKdy9EZlVGVjdVM054c2N2aXBxNnNqSkVRNFFMTHZJNEtzV3JWS1dCZCtDeGNCN1VJNEF0SGR1M2RObnVmR0RlVC9GQ1VmT2llR1gxZFhGNWxUZlJRWEZ3dExRa0g0cyt6WGN1aVRsYTJ1cmhhbjNoekJJbGxla3hVTzVCc0tROUZCbHp4Nzlvd0tDZ3JJMzk5ZnVBUVVoVC9MMFFBQ0lzakx5eU56eXpFcDl3NlNYY0lWazVyaVY1cUFRa2cvdTd1N2FXaG9hRlRjUmdoNy9QaXgyZU5MNGM5VnRyQ2RIQjBzRVF6NjhPRkRjbkZ4SVNjbko5VjlCd2NIc1FoTHhwY2lrYjFzNFg1c3BTVVdCaUVzWExoUWU4TE5QcjF0MnpheENIUEhsOWl4VjFhNEI0ZkUzRVFGUHN2NUswMmJOazBBMTZQS0ZtWTY1TG5tem9GZFl2bFBkb2syUHVWd1BHdHp0aTBtSmtaRUNlUUtZRHYxdzZaS3NObENXQlFTSkxDa3FZSll6dElxVzdnUFNvT2xURjE1YUdpb2lucmhGbkppYy9Ma1NWSCtJM3ZEYzNBTE1OMzY5ZXVSZ1prOER3ekM4cmM2Y1p6bmN0c2t2MEoydG5qeDRsSFUyOUxTSXRoczM3NTlJbjcyOWZXOXlBRTRKdU9kOVBSMGszMDRMQ3dNUS95cHJuRDFnZ1VMVEJvRVBRWDRKcXlMeUNCVDc2NWR1OFR2VURZN08xdFFONktRWEdqQ01CczNialI2SHJnWWsxSy9wc0xGQ1FrSi9SalFtQzJDc3NqRW9DejhWbWF6ckt3c0Vkcms1eTVmdml5WXNLZW5SeFdmY1NnVEV4UEY3aGd6RjU2VDJsdTk2Z3AzUTJrY0RFTXJSc1dCcmcyVXhSYkxVWUhyUUNvcUtocjFQRmdRT1RMSVNmWm5oTGl0VzdlSzdNN1FmUEh4YU9GUnZyYWE3cnVrcENTRDRZV3JXZUd6YVBCaFlpaUFOSFBQbmowNjMwTTZDUmZSVEVXM2I5K3VkejcwNGRqQ2FCcVdheXVSNnZqRWx5VW5KNzk5K1BCaHJlRUZIVWhVRzZCZ0hDNDVoQ0VoMXhjU2tlem41T1RRdkhuelZJdUVJSXBneDZSc2JKVEFnS2ppMVR0Qm1uMkpZTVpmSzFldWROQlZIRTZVckYyN2xuYnMySUZ5NDAzR2lLNHlIOEg1eTdTMHRFa3Q4N0VUckt4U2F1Mk9HR3BvZjd0Njllb1lwVklaajFNLzBZTHFCQVdBMU0xc01hYnpneFc5eTZ6VXNHblRwZ20xTENJT2lJVkQ3RjVkclZkOTNVc2ZSaVVuM21FSER4NGNkOHNpVElLNjE2eFo4d002L09iMmg5MFpSUncxb3FHMG9UNkN1UklkSFUwSERoeUFJcC9ESlMzdHdNUFB2Mlo4bXBHUm9TZ3JLeHN6UlVIbmFBdHMzcnk1QzAxTDlYZzdGdDg0RmpGK1pFWUxSemtrOVF2TWJsN2pZTzNldlJ2eE5ZK1J3ZmgzUEw0aTRaQyt3L2lNYzl2dzB0SlN0SkpFYzhTUTRFQ0J1WkEvcDZhbURraXRwMjhZSm4wMFVWandZVEZDYXUzSGNZRVpDcVh2M0xrakVoMThCa051REZZREJhTS93U3lLNU9VODQzY0dxTFJySXI3VDZaSlhwSytod2RLWFVEY3dMd1BCdjExS3ZwdWxZc0VpR1N1RkoweitGMkFBeUNhcDM0TTJ1a1VBQUFBQVNVVk9SSzVDWUlJPVxcXCIgYWx0PVxcXCJjbG9zZVxcXCIvPlwiKVxuICAgICAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIiA6IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmlnaHRcIiAgICA6IFwiLTlweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0b3BcIiAgICAgIDogXCItOHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCIgICAgOiBcIjQ0cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCIgICA6IFwiNDRweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ6LWluZGV4XCIgIDogXCIxMDAwMFwiXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5saWdodGJveChcImNsb3NlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY2xvbmVEYXRhLmNvbnRlbnRXaWR0aCA9IHc7XG4gICAgICAgICAgICBjbG9uZURhdGEuY29udGVudEhlaWdodCA9IGg7XG4gICAgICAgICAgICBjbG9uZURhdGEub3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsb25lRGF0YS5yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNsb25lLmxpZ2h0Ym94KFwicmVzaXplXCIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgJCh3aW5kb3cpLm9uKFwicmVzaXplXCIsIGNsb25lRGF0YS5yZXNpemVIYW5kbGVyKTtcbiAgICAgICAgICAgICQod2luZG93KS5vbihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIGNsb25lRGF0YS5yZXNpemVIYW5kbGVyKTtcblxuICAgICAgICAgICAgZGF0YS5wb3N0b3Blbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgY2xvc2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YShcImxpZ2h0Ym94XCIpO1xuXG4gICAgICAgICAgICBkYXRhLnByZWNsb3NlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgICQod2luZG93KS5vZmYoXCJyZXNpemVcIiwgZGF0YS5yZXNpemVIYW5kbGVyKTtcbiAgICAgICAgICAgICQod2luZG93KS5vZmYoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCBkYXRhLnJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgICAgICAgICBkYXRhLm9wZW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YS5vdmVybGF5LnJlbW92ZSgpO1xuICAgICAgICAgICAgZGF0YS5vdmVybGF5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBkYXRhLnBvc3RjbG9zZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICBkYXRhLmJveC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFxuICAgICAgICByZXNpemUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YShcImxpZ2h0Ym94XCIpLFxuICAgICAgICAgICAgICAgIHcsIGg7XG5cbiAgICAgICAgICAgIGRhdGEucHJlcmVzaXplLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmZ1bGxzY3JlZW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB3ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgaCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IGRhdGEuY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGggPSBkYXRhLmNvbnRlbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2NhbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjb21wdXRlUmF0aW8odywgaCk7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBwYXJzZUludCh3ICogciwgMTApO1xuICAgICAgICAgICAgICAgICAgICBoID0gcGFyc2VJbnQoaCAqIHIsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjYWxlRWxlbWVudChkYXRhLmJveCwgdywgaCk7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoZGF0YS5ib3gsIHcsIGgpO1xuXG4gICAgICAgICAgICBzY2FsZUVsZW1lbnQoZGF0YS5jb250ZW50cywgdywgaCk7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoZGF0YS5jb250ZW50cywgdywgaCk7XG5cbiAgICAgICAgICAgIGRhdGEuY29udGVudFdpZHRoID0gdztcbiAgICAgICAgICAgIGRhdGEuY29udGVudEhlaWdodCA9IGg7XG5cbiAgICAgICAgICAgIGRhdGEucG9zdHJlc2l6ZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhKFwibGlnaHRib3hcIikub3BlbmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saWdodGJveChcImNsb3NlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpZ2h0Ym94KFwib3BlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXQgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKFwibGlnaHRib3hcIik7XG4gICAgICAgICAgICAgICAgaWYgKCAhZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMsIHsgb3BlbmVkIDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoXCJsaWdodGJveFwiLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCR0aGlzLmRhdGEoXCJsaWdodGJveFwiKS5kZWZhdWx0RXZlbnRIYW5kbGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb2RpZmllZCBmcm9tIGVjbWFuYXV0J3MgYW5zd2VyIGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzEwMzg0Mi9zYWZhcmktaXBhZC1wcmV2ZW50LXpvb20tb24tZG91YmxlLXRhcFxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbihcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0MiA9IGUudGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gJHRoaXMuZGF0YShcImxpZ2h0Ym94XCIpLmxhc3RUb3VjaCB8fCB0MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdCA9IHQyIC0gdDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZ2VycyA9IGUub3JpZ2luYWxFdmVudC50b3VjaGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoXCJsaWdodGJveFwiKS5sYXN0VG91Y2ggPSB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHQgfHwgZHQgPiA1MDAgfHwgZmluZ2VycyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIGRvdWJsZSB0YXAgLSBwcmV2ZW50IHRoZSB6b29tXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5saWdodGJveChcInRvZ2dsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLmxpZ2h0Ym94ID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICBpZiAoIG1ldGhvZHNbbWV0aG9kXSApIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzWyBtZXRob2QgXS5hcHBseSggdGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApKTtcbiAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIG1ldGhvZCA9PT0gXCJvYmplY3RcIiB8fCAhbWV0aG9kICkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVycm9yKCBcIk1ldGhvZCBcIiArICBtZXRob2QgKyBcIiBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkubGlnaHRib3hcIiApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNvbXB1dGVSYXRpbyA9IGZ1bmN0aW9uIChvcmlnaW5hbFdpZHRoLCBvcmlnaW5hbEhlaWdodCkge1xuICAgICAgICB2YXIgd3IgPSAob3JpZ2luYWxXaWR0aCA+IDApID8gd2luZG93LmlubmVyV2lkdGggLyBvcmlnaW5hbFdpZHRoIDogMSxcbiAgICAgICAgICAgIGhyID0gKG9yaWdpbmFsSGVpZ2h0ID4gMCkgPyB3aW5kb3cuaW5uZXJIZWlnaHQgLyBvcmlnaW5hbEhlaWdodCA6IDEsXG4gICAgICAgICAgICByID0gTWF0aC5taW4od3IsIGhyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHZhciBzY2FsZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBlbGVtLmNzcyhcIndpZHRoXCIsIHdpZHRoICsgXCJweFwiKVxuICAgICAgICAgICAgLmNzcyhcImhlaWdodFwiLCBoZWlnaHQgKyBcInB4XCIpO1xuICAgIH07XG5cbiAgICB2YXIgcG9zaXRpb25FbGVtZW50ID0gZnVuY3Rpb24gKGVsZW0sIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSAod2luZG93LmlubmVyV2lkdGggIC0gd2lkdGgpIC8gMixcbiAgICAgICAgICAgIHRvcCA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9wIDwgMCkge1xuICAgICAgICAgICAgdG9wID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0uY3NzKFwibGVmdFwiLCBsZWZ0ICsgXCJweFwiKVxuICAgICAgICAgICAgLmNzcyhcInRvcFwiLCB0b3AgKyBcInB4XCIpO1xuICAgIH07XG5cbn0oalF1ZXJ5KSk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgIHZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcbiAgICBmb3IodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0rJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSsnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdmVuZG9yc1t4XSsnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgfVxuIFxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgICAgICAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTsgfSwgXG4gICAgICAgICAgICAgIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH07XG4gICAgfVxuIFxuICAgIGlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG4iLCIvKipcbnNwcmludGYoKSBmb3IgSmF2YVNjcmlwdCAwLjctYmV0YTFcbmh0dHA6Ly93d3cuZGl2ZWludG9qYXZhc2NyaXB0LmNvbS9wcm9qZWN0cy9qYXZhc2NyaXB0LXNwcmludGZcblxuQ29weXJpZ2h0IChjKSBBbGV4YW5kcnUgTWFyYXN0ZWFudSA8YWxleGFob2xpYyBbYXQpIGdtYWlsIChkb3RdIGNvbT5cbkFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxubW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHNwcmludGYoKSBmb3IgSmF2YVNjcmlwdCBub3IgdGhlXG4gICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEFsZXhhbmRydSBNYXJhc3RlYW51IEJFIExJQUJMRSBGT1IgQU5ZXG5ESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG5PTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5cbkNoYW5nZWxvZzpcbjIwMTAuMTEuMDcgLSAwLjctYmV0YTEtbm9kZVxuICAtIGNvbnZlcnRlZCBpdCB0byBhIG5vZGUuanMgY29tcGF0aWJsZSBtb2R1bGVcblxuMjAxMC4wOS4wNiAtIDAuNy1iZXRhMVxuICAtIGZlYXR1cmVzOiB2c3ByaW50Ziwgc3VwcG9ydCBmb3IgbmFtZWQgcGxhY2Vob2xkZXJzXG4gIC0gZW5oYW5jZW1lbnRzOiBmb3JtYXQgY2FjaGUsIHJlZHVjZWQgZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cblxuMjAxMC4wNS4yMiAtIDAuNjpcbiAtIHJldmVydGVkIHRvIDAuNCBhbmQgZml4ZWQgdGhlIGJ1ZyByZWdhcmRpbmcgdGhlIHNpZ24gb2YgdGhlIG51bWJlciAwXG4gTm90ZTpcbiBUaGFua3MgdG8gUmFwaGFlbCBQaWd1bGxhIDxyYXBoIChhdF0gbjNyZCBbZG90KSBvcmc+IChodHRwOi8vd3d3Lm4zcmQub3JnLylcbiB3aG8gd2FybmVkIG1lIGFib3V0IGEgYnVnIGluIDAuNSwgSSBkaXNjb3ZlcmVkIHRoYXQgdGhlIGxhc3QgdXBkYXRlIHdhc1xuIGEgcmVncmVzcy4gSSBhcHBvbG9naXplIGZvciB0aGF0LlxuXG4yMDEwLjA1LjA5IC0gMC41OlxuIC0gYnVnIGZpeDogMCBpcyBub3cgcHJlY2VlZGVkIHdpdGggYSArIHNpZ25cbiAtIGJ1ZyBmaXg6IHRoZSBzaWduIHdhcyBub3QgYXQgdGhlIHJpZ2h0IHBvc2l0aW9uIG9uIHBhZGRlZCByZXN1bHRzIChLYW1hbCBBYmRhbGkpXG4gLSBzd2l0Y2hlZCBmcm9tIEdQTCB0byBCU0QgbGljZW5zZVxuXG4yMDA3LjEwLjIxIC0gMC40OlxuIC0gdW5pdCB0ZXN0IGFuZCBwYXRjaCAoRGF2aWQgQmFpcmQpXG5cbjIwMDcuMDkuMTcgLSAwLjM6XG4gLSBidWcgZml4OiBubyBsb25nZXIgdGhyb3dzIGV4Y2VwdGlvbiBvbiBlbXB0eSBwYXJhbWVudGVycyAoSGFucyBQdWZhbClcblxuMjAwNy4wOS4xMSAtIDAuMjpcbiAtIGZlYXR1cmU6IGFkZGVkIGFyZ3VtZW50IHN3YXBwaW5nXG5cbjIwMDcuMDQuMDMgLSAwLjE6XG4gLSBpbml0aWFsIHJlbGVhc2VcbioqL1xuXG52YXIgc3ByaW50ZiA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0X3R5cGUodmFyaWFibGUpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhcmlhYmxlKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcblx0fVxuXHRmdW5jdGlvbiBzdHJfcmVwZWF0KGlucHV0LCBtdWx0aXBsaWVyKSB7XG5cdFx0Zm9yICh2YXIgb3V0cHV0ID0gW107IG11bHRpcGxpZXIgPiAwOyBvdXRwdXRbLS1tdWx0aXBsaWVyXSA9IGlucHV0KSB7LyogZG8gbm90aGluZyAqL31cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0dmFyIHN0cl9mb3JtYXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXN0cl9mb3JtYXQuY2FjaGUuaGFzT3duUHJvcGVydHkoYXJndW1lbnRzWzBdKSkge1xuXHRcdFx0c3RyX2Zvcm1hdC5jYWNoZVthcmd1bWVudHNbMF1dID0gc3RyX2Zvcm1hdC5wYXJzZShhcmd1bWVudHNbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyX2Zvcm1hdC5mb3JtYXQuY2FsbChudWxsLCBzdHJfZm9ybWF0LmNhY2hlW2FyZ3VtZW50c1swXV0sIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0Ly8gY29udmVydCBvYmplY3QgdG8gc2ltcGxlIG9uZSBsaW5lIHN0cmluZyB3aXRob3V0IGluZGVudGF0aW9uIG9yXG5cdC8vIG5ld2xpbmVzLiBOb3RlIHRoYXQgdGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBwcmludCBhcnJheVxuXHQvLyB2YWx1ZXMgdG8gdGhlaXIgYWN0dWFsIHBsYWNlIGZvciBzcGFyc2UgYXJyYXlzLiBcblx0Ly9cblx0Ly8gRm9yIGV4YW1wbGUgc3BhcnNlIGFycmF5IGxpa2UgdGhpc1xuXHQvLyAgICBsID0gW11cblx0Ly8gICAgbFs0XSA9IDFcblx0Ly8gV291bGQgYmUgcHJpbnRlZCBhcyBcIlsxXVwiIGluc3RlYWQgb2YgXCJbLCAsICwgLCAxXVwiXG5cdC8vIFxuXHQvLyBJZiBhcmd1bWVudCAnc2VlbicgaXMgbm90IG51bGwgYW5kIGFycmF5IHRoZSBmdW5jdGlvbiB3aWxsIGNoZWNrIGZvciBcblx0Ly8gY2lyY3VsYXIgb2JqZWN0IHJlZmVyZW5jZXMgZnJvbSBhcmd1bWVudC5cblx0c3RyX2Zvcm1hdC5vYmplY3Rfc3RyaW5naWZ5ID0gZnVuY3Rpb24ob2JqLCBkZXB0aCwgbWF4ZGVwdGgsIHNlZW4pIHtcblx0XHR2YXIgc3RyID0gJyc7XG5cdFx0aWYgKG9iaiAhPSBudWxsKSB7XG5cdFx0XHRzd2l0Y2goIHR5cGVvZihvYmopICkge1xuXHRcdFx0Y2FzZSAnZnVuY3Rpb24nOiBcblx0XHRcdFx0cmV0dXJuICdbRnVuY3Rpb24nICsgKG9iai5uYW1lID8gJzogJytvYmoubmFtZSA6ICcnKSArICddJztcblx0XHRcdCAgICBicmVhaztcblx0XHRcdGNhc2UgJ29iamVjdCc6XG5cdFx0XHRcdGlmICggb2JqIGluc3RhbmNlb2YgRXJyb3IpIHsgcmV0dXJuICdbJyArIG9iai50b1N0cmluZygpICsgJ10nIH07XG5cdFx0XHRcdGlmIChkZXB0aCA+PSBtYXhkZXB0aCkgcmV0dXJuICdbT2JqZWN0XSdcblx0XHRcdFx0aWYgKHNlZW4pIHtcblx0XHRcdFx0XHQvLyBhZGQgb2JqZWN0IHRvIHNlZW4gbGlzdFxuXHRcdFx0XHRcdHNlZW4gPSBzZWVuLnNsaWNlKDApXG5cdFx0XHRcdFx0c2Vlbi5wdXNoKG9iaik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9iai5sZW5ndGggIT0gbnVsbCkgeyAvL2FycmF5XG5cdFx0XHRcdFx0c3RyICs9ICdbJztcblx0XHRcdFx0XHR2YXIgYXJyID0gW11cblx0XHRcdFx0XHRmb3IgKHZhciBpIGluIG9iaikge1xuXHRcdFx0XHRcdFx0aWYgKHNlZW4gJiYgc2Vlbi5pbmRleE9mKG9ialtpXSkgPj0gMCkgYXJyLnB1c2goJ1tDaXJjdWxhcl0nKTtcblx0XHRcdFx0XHRcdGVsc2UgYXJyLnB1c2goc3RyX2Zvcm1hdC5vYmplY3Rfc3RyaW5naWZ5KG9ialtpXSwgZGVwdGgrMSwgbWF4ZGVwdGgsIHNlZW4pKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RyICs9IGFyci5qb2luKCcsICcpICsgJ10nO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCdnZXRNb250aCcgaW4gb2JqKSB7IC8vIGRhdGVcblx0XHRcdFx0XHRyZXR1cm4gJ0RhdGUoJyArIG9iaiArICcpJztcblx0XHRcdFx0fSBlbHNlIHsgLy8gb2JqZWN0XG5cdFx0XHRcdFx0c3RyICs9ICd7Jztcblx0XHRcdFx0XHR2YXIgYXJyID0gW11cblx0XHRcdFx0XHRmb3IgKHZhciBrIGluIG9iaikgeyBcblx0XHRcdFx0XHRcdGlmKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc2VlbiAmJiBzZWVuLmluZGV4T2Yob2JqW2tdKSA+PSAwKSBhcnIucHVzaChrICsgJzogW0NpcmN1bGFyXScpO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGFyci5wdXNoKGsgKyc6ICcgK3N0cl9mb3JtYXQub2JqZWN0X3N0cmluZ2lmeShvYmpba10sIGRlcHRoKzEsIG1heGRlcHRoLCBzZWVuKSk7IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHIgKz0gYXJyLmpvaW4oJywgJykgKyAnfSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHN0cjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzdHJpbmcnOlx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiAnXCInICsgb2JqICsgJ1wiJztcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICcnICsgb2JqO1xuXHR9XG5cblx0c3RyX2Zvcm1hdC5mb3JtYXQgPSBmdW5jdGlvbihwYXJzZV90cmVlLCBhcmd2KSB7XG5cdFx0dmFyIGN1cnNvciA9IDEsIHRyZWVfbGVuZ3RoID0gcGFyc2VfdHJlZS5sZW5ndGgsIG5vZGVfdHlwZSA9ICcnLCBhcmcsIG91dHB1dCA9IFtdLCBpLCBrLCBtYXRjaCwgcGFkLCBwYWRfY2hhcmFjdGVyLCBwYWRfbGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0cmVlX2xlbmd0aDsgaSsrKSB7XG5cdFx0XHRub2RlX3R5cGUgPSBnZXRfdHlwZShwYXJzZV90cmVlW2ldKTtcblx0XHRcdGlmIChub2RlX3R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHBhcnNlX3RyZWVbaV0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobm9kZV90eXBlID09PSAnYXJyYXknKSB7XG5cdFx0XHRcdG1hdGNoID0gcGFyc2VfdHJlZVtpXTsgLy8gY29udmVuaWVuY2UgcHVycG9zZXMgb25seVxuXHRcdFx0XHRpZiAobWF0Y2hbMl0pIHsgLy8ga2V5d29yZCBhcmd1bWVudFxuXHRcdFx0XHRcdGFyZyA9IGFyZ3ZbY3Vyc29yXTtcblx0XHRcdFx0XHRmb3IgKGsgPSAwOyBrIDwgbWF0Y2hbMl0ubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdGlmICghYXJnLmhhc093blByb3BlcnR5KG1hdGNoWzJdW2tdKSkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3ByaW50ZignW3NwcmludGZdIHByb3BlcnR5IFwiJXNcIiBkb2VzIG5vdCBleGlzdCcsIG1hdGNoWzJdW2tdKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhcmcgPSBhcmdbbWF0Y2hbMl1ba11dO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChtYXRjaFsxXSkgeyAvLyBwb3NpdGlvbmFsIGFyZ3VtZW50IChleHBsaWNpdClcblx0XHRcdFx0XHRhcmcgPSBhcmd2W21hdGNoWzFdXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgLy8gcG9zaXRpb25hbCBhcmd1bWVudCAoaW1wbGljaXQpXG5cdFx0XHRcdFx0YXJnID0gYXJndltjdXJzb3IrK107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoL1tec09dLy50ZXN0KG1hdGNoWzhdKSAmJiAoZ2V0X3R5cGUoYXJnKSAhPSAnbnVtYmVyJykpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3ByaW50ZignW3NwcmludGZdIGV4cGVjdGluZyBudW1iZXIgYnV0IGZvdW5kICVzIFwiJyArIGFyZyArICdcIicsIGdldF90eXBlKGFyZykpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG1hdGNoWzhdKSB7XG5cdFx0XHRcdFx0Y2FzZSAnYic6IGFyZyA9IGFyZy50b1N0cmluZygyKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnYyc6IGFyZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJnKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZCc6IGFyZyA9IHBhcnNlSW50KGFyZywgMTApOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdlJzogYXJnID0gbWF0Y2hbN10gPyBhcmcudG9FeHBvbmVudGlhbChtYXRjaFs3XSkgOiBhcmcudG9FeHBvbmVudGlhbCgpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdmJzogYXJnID0gbWF0Y2hbN10gPyBwYXJzZUZsb2F0KGFyZykudG9GaXhlZChtYXRjaFs3XSkgOiBwYXJzZUZsb2F0KGFyZyk7IGJyZWFrO1xuXHRcdFx0XHQgICAgY2FzZSAnTyc6IGFyZyA9IHN0cl9mb3JtYXQub2JqZWN0X3N0cmluZ2lmeShhcmcsIDAsIHBhcnNlSW50KG1hdGNoWzddKSB8fCA1KTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbyc6IGFyZyA9IGFyZy50b1N0cmluZyg4KTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAncyc6IGFyZyA9ICgoYXJnID0gU3RyaW5nKGFyZykpICYmIG1hdGNoWzddID8gYXJnLnN1YnN0cmluZygwLCBtYXRjaFs3XSkgOiBhcmcpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICd1JzogYXJnID0gTWF0aC5hYnMoYXJnKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAneCc6IGFyZyA9IGFyZy50b1N0cmluZygxNik7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ1gnOiBhcmcgPSBhcmcudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFyZyA9ICgvW2RlZl0vLnRlc3QobWF0Y2hbOF0pICYmIG1hdGNoWzNdICYmIGFyZyA+PSAwID8gJysnKyBhcmcgOiBhcmcpO1xuXHRcdFx0XHRwYWRfY2hhcmFjdGVyID0gbWF0Y2hbNF0gPyBtYXRjaFs0XSA9PSAnMCcgPyAnMCcgOiBtYXRjaFs0XS5jaGFyQXQoMSkgOiAnICc7XG5cdFx0XHRcdHBhZF9sZW5ndGggPSBtYXRjaFs2XSAtIFN0cmluZyhhcmcpLmxlbmd0aDtcblx0XHRcdFx0cGFkID0gbWF0Y2hbNl0gPyBzdHJfcmVwZWF0KHBhZF9jaGFyYWN0ZXIsIHBhZF9sZW5ndGgpIDogJyc7XG5cdFx0XHRcdG91dHB1dC5wdXNoKG1hdGNoWzVdID8gYXJnICsgcGFkIDogcGFkICsgYXJnKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fTtcblxuXHRzdHJfZm9ybWF0LmNhY2hlID0ge307XG5cblx0c3RyX2Zvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uKGZtdCkge1xuXHRcdHZhciBfZm10ID0gZm10LCBtYXRjaCA9IFtdLCBwYXJzZV90cmVlID0gW10sIGFyZ19uYW1lcyA9IDA7XG5cdFx0d2hpbGUgKF9mbXQpIHtcblx0XHRcdGlmICgobWF0Y2ggPSAvXlteXFx4MjVdKy8uZXhlYyhfZm10KSkgIT09IG51bGwpIHtcblx0XHRcdFx0cGFyc2VfdHJlZS5wdXNoKG1hdGNoWzBdKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKChtYXRjaCA9IC9eXFx4MjV7Mn0vLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG5cdFx0XHRcdHBhcnNlX3RyZWUucHVzaCgnJScpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoKG1hdGNoID0gL15cXHgyNSg/OihbMS05XVxcZCopXFwkfFxcKChbXlxcKV0rKVxcKSk/KFxcKyk/KDB8J1teJF0pPygtKT8oXFxkKyk/KD86XFwuKFxcZCspKT8oW2ItZm9zT3V4WF0pLy5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAobWF0Y2hbMl0pIHtcblx0XHRcdFx0XHRhcmdfbmFtZXMgfD0gMTtcblx0XHRcdFx0XHR2YXIgZmllbGRfbGlzdCA9IFtdLCByZXBsYWNlbWVudF9maWVsZCA9IG1hdGNoWzJdLCBmaWVsZF9tYXRjaCA9IFtdO1xuXHRcdFx0XHRcdGlmICgoZmllbGRfbWF0Y2ggPSAvXihbYS16X11bYS16X1xcZF0qKS9pLmV4ZWMocmVwbGFjZW1lbnRfZmllbGQpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ZmllbGRfbGlzdC5wdXNoKGZpZWxkX21hdGNoWzFdKTtcblx0XHRcdFx0XHRcdHdoaWxlICgocmVwbGFjZW1lbnRfZmllbGQgPSByZXBsYWNlbWVudF9maWVsZC5zdWJzdHJpbmcoZmllbGRfbWF0Y2hbMF0ubGVuZ3RoKSkgIT09ICcnKSB7XG5cdFx0XHRcdFx0XHRcdGlmICgoZmllbGRfbWF0Y2ggPSAvXlxcLihbYS16X11bYS16X1xcZF0qKS9pLmV4ZWMocmVwbGFjZW1lbnRfZmllbGQpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoKGZpZWxkX21hdGNoID0gL15cXFsoXFxkKylcXF0vLmV4ZWMocmVwbGFjZW1lbnRfZmllbGQpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdbc3ByaW50Zl0gJyArIHJlcGxhY2VtZW50X2ZpZWxkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW3NwcmludGZdICcgKyByZXBsYWNlbWVudF9maWVsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1hdGNoWzJdID0gZmllbGRfbGlzdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRhcmdfbmFtZXMgfD0gMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYXJnX25hbWVzID09PSAzKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdbc3ByaW50Zl0gbWl4aW5nIHBvc2l0aW9uYWwgYW5kIG5hbWVkIHBsYWNlaG9sZGVycyBpcyBub3QgKHlldCkgc3VwcG9ydGVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VfdHJlZS5wdXNoKG1hdGNoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1tzcHJpbnRmXSAnICsgX2ZtdCk7XG5cdFx0XHR9XG5cdFx0XHRfZm10ID0gX2ZtdC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnNlX3RyZWU7XG5cdH07XG5cblx0cmV0dXJuIHN0cl9mb3JtYXQ7XG59KSgpO1xuXG52YXIgdnNwcmludGYgPSBmdW5jdGlvbihmbXQsIGFyZ3YpIHtcblx0dmFyIGFyZ3ZDbG9uZSA9IGFyZ3Yuc2xpY2UoKTtcblx0YXJndkNsb25lLnVuc2hpZnQoZm10KTtcblx0cmV0dXJuIHNwcmludGYuYXBwbHkobnVsbCwgYXJndkNsb25lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3ByaW50ZjtcbnNwcmludGYuc3ByaW50ZiA9IHNwcmludGY7XG5zcHJpbnRmLnZzcHJpbnRmID0gdnNwcmludGY7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBEYXRhID0gcmVxdWlyZSgnLi9kYXRhLmpzJyksXG4gICAgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyk7XG5cbi8qKlxuICogQGNsYXNzIEFycmF5RGF0YVxuICogQGZvciBBcnJheURhdGFcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHthcnJheX0gY29sdW1ucyBBIGFycmF5IG9mIERhdGFWYXJpYWJsZXNcbiAqIEBwYXJhbSB7YXJyYXl9IHN0cmluZ0FycmF5IEEgYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCB3aWxsIGxhdGVyIGJlIHBhcnNlZCBpbnRvIERhdGFWYWx1ZXNcbiAqL1xudmFyIEFycmF5RGF0YSA9IG5ldyBqZXJtYWluZS5Nb2RlbChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEFycmF5RGF0YSA9IHRoaXM7IC8vIGh1aD8gIFRoaXMgc2hhZG93cyB0aGUgQXJyYXlEYXRhIGRlZmluZWQgb24gdGhlIHByZXZpb3VzIGxpbmUuXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgIElzIHRoYXQgaW50ZW5kZWQvY29ycmVjdD8gIFByb2JhYmx5LCBidXQgbmVlZCB0byBjaGVjayBmb3Igc3VyZS5cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgbWJwIFdlZCBGZWIgMjUgMTg6MzE6MTUgMjAxNVxuXG4gICAgdGhpcy5pc0EoRGF0YSk7XG4gICAgdGhpcy5oYXNBbihcImFycmF5XCIpO1xuICAgIHRoaXMuaGFzQShcInN0cmluZ0FycmF5XCIpO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJjb2x1bW5zXCIsIFwic3RyaW5nQXJyYXlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihcImxpc3RlbmVyQWRkZWRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0VHlwZSA9PT0gXCJkYXRhUmVhZHlcIikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5hcnJheSgpO1xuICAgICAgICAgICAgICAgIGV2ZW50Lmxpc3RlbmVyKGRhdGFbMF1bMF0sIGRhdGFbZGF0YS5sZW5ndGgtMV1bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRJdGVyYXRvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nIGFycmF5fSBjb2x1bW5JRHNcbiAgICAgKiBAcGFyYW0ge0RhdGFWYWx1ZX0gbWluXG4gICAgICogQHBhcmFtIHtEYXRhVmFsdWV9IG1heFxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gYnVmZmVyXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImdldEl0ZXJhdG9yXCIsIGZ1bmN0aW9uIChjb2x1bW5JZHMsIG1pbiwgbWF4LCBidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5RGF0YS5nZXRBcnJheURhdGFJdGVyYXRvcih0aGlzLCBjb2x1bW5JZHMsIG1pbiwgbWF4LCBidWZmZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgdXBwZXIgYW5kIGxvd2VyIGJvdW5kcyBvZiBhIGNvbHVtbiBpbiBhIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEJvdW5kc1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gY29sdW1uTnVtYmVyIENvbHVtbiBpbiB0aGUgZGF0YXNldCB0byBoYXZlIGl0cyBib3VuZHMgZGV0ZXJtaW5lZC5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgaW4gdGhlIGZvcm06IFtsb3dlckJvdW5kLCB1cHBlckJvdW5kXS5cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZ2V0Qm91bmRzXCIsIGZ1bmN0aW9uIChjb2x1bW5OdW1iZXIpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmFycmF5KCksXG4gICAgICAgICAgICBtaW4gPSBkYXRhWzBdW2NvbHVtbk51bWJlcl0sXG4gICAgICAgICAgICBtYXggPSBtaW4sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtpXVtjb2x1bW5OdW1iZXJdIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gZGF0YVtpXVtjb2x1bW5OdW1iZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGFbaV1bY29sdW1uTnVtYmVyXSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGRhdGFbaV1bY29sdW1uTnVtYmVyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvblJlYWR5XG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGdldEFycmF5RGF0YUl0ZXJhdG9yXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXlEYXRhfSBhcnJheURhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZyBhcnJheX0gY29sdW1uSURzXG4gICAgICogQHBhcmFtIHtEYXRhVmFsdWV9IG1pblxuICAgICAqIEBwYXJhbSB7RGF0YVZhbHVlfSBtYXhcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGJ1ZmZlclxuICAgICAqIEByZXR1cm4gaXRlclxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICBBcnJheURhdGEuZ2V0QXJyYXlEYXRhSXRlcmF0b3IgPSBmdW5jdGlvbiAoYXJyYXlEYXRhLCBjb2x1bW5JZHMsIG1pbiwgbWF4LCBidWZmZXIpIHtcblxuICAgICAgICB2YXIgaSwgaixcbiAgICAgICAgICAgIGZpcnN0SW5kZXgsIGxhc3RJbmRleCxcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgIGNvbHVtbkluZGljZXMsXG4gICAgICAgICAgICBhcnJheSA9IGFycmF5RGF0YS5hcnJheSgpO1xuXG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciB8fCAwO1xuXG4gICAgICAgIC8vIGNvbHVtbklkcyBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShjb2x1bW5JZHMpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5RGF0YTogZ2V0SXRlcmF0b3IgbWV0aG9kIHJlcXVpcmVzIHRoYXQgdGhlIGZpcnN0IHBhcmFtZXRlciBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbklkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY29sdW1uSWRzW2ldKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheURhdGE6IGdldEl0ZXJhdG9yIG1ldGhvZCByZXF1aXJlcyB0aGF0IHRoZSBmaXJzdCBwYXJhbWV0ZXIgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL21pbixtYXggYXJndW1lbnRzIHNob3VsZCBiZSBkYXRhIHZhbHVlc1xuICAgICAgICBpZiAoIURhdGFWYWx1ZS5pc0luc3RhbmNlKG1pbikgfHwgIURhdGFWYWx1ZS5pc0luc3RhbmNlKG1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5RGF0YTogZ2V0SXRlcmF0b3IgbWV0aG9kIHJlcXVpcmVzIHRoZSBzZWNvbmQgYW5kIHRoaXJkIGFyZ3VtZW50IHRvIGJlIG51bWJlciB2YWx1ZXNcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2J1ZmZlciBhcmd1bWVudCBzaG91bGQgYmUgYW4gaW50ZWdlclxuICAgICAgICBpZiAodHlwZW9mKGJ1ZmZlcikgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5RGF0YTogZ2V0SXRlcmF0b3IgbWV0aG9kIHJlcXVpcmVzIGxhc3QgYXJndW1lbnQgdG8gYmUgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgbm8gZGF0YSwgcmV0dXJuIGFuIGVtcHR5IGl0ZXJhdG9yXG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgXCJuZXh0XCIgICAgOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgICAgICBcImhhc05leHRcIiA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHJvdyBpbiB0aGUgYXJyYXkgd2hvc2UgY29sdW1uMCB2YWx1ZSBpcyA+PSBtaW5cbiAgICAgICAgZm9yIChmaXJzdEluZGV4ID0gMDsgZmlyc3RJbmRleCA8IGFycmF5Lmxlbmd0aDsgKytmaXJzdEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlbZmlyc3RJbmRleF1bMF0uZ2UobWluKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGJhY2sgdXAgJ2J1ZmZlcicgc3RlcHNcbiAgICAgICAgZmlyc3RJbmRleCA9IGZpcnN0SW5kZXggLSBidWZmZXI7XG4gICAgICAgIGlmIChmaXJzdEluZGV4IDwgMCkge1xuICAgICAgICAgICAgZmlyc3RJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHJvdyBpbiB0aGUgYXJyYXkgd2hvc2UgY29sdW1uMCB2YWx1ZSBpcyA8PSBtYXhcbiAgICAgICAgaWYgKGZpcnN0SW5kZXggPT09IGFycmF5Lmxlbmd0aC0xKSB7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBmaXJzdEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsYXN0SW5kZXggPSBmaXJzdEluZGV4OyBsYXN0SW5kZXggPCBhcnJheS5sZW5ndGgtMTsgKytsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbbGFzdEluZGV4KzFdWzBdLmd0KG1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1vdmUgZm9yd2FyZCAnYnVmZmVyJyBzdGVwc1xuICAgICAgICBsYXN0SW5kZXggPSBsYXN0SW5kZXggKyBidWZmZXI7XG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBhcnJheS5sZW5ndGgtMSkge1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gYXJyYXkubGVuZ3RoLTE7XG4gICAgICAgIH1cblxuICAgICAgICBjb2x1bW5JbmRpY2VzID0gW107XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5JZHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrID0gYXJyYXlEYXRhLmNvbHVtbklkVG9Db2x1bW5OdW1iZXIoY29sdW1uSWRzW2pdKTtcbiAgICAgICAgICAgIGNvbHVtbkluZGljZXMucHVzaCggayApO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEluZGV4ID0gZmlyc3RJbmRleDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbkluZGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbi5wdXNoKGFycmF5W2N1cnJlbnRJbmRleF1bY29sdW1uSW5kaWNlc1tpXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2N1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNOZXh0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5kZXggPD0gbGFzdEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHRleHRUb0RhdGFWYWx1ZXNBcnJheVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBkYXRhVmFyaWFibGVBcnJheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybiB7YXJyYXl9IGRhdGFWYWx1ZXNcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICogQHRvZG8gSWYgdGhlIG51bWJlciBvZiBjb21tYS1zZXBhcmF0ZWQgdmFsdWVzIG9uIHRoZSBjdXJyZW50IGxpbmUgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWV0YWRhdGEsIHNob3VsZCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBBcnJheURhdGEudGV4dFRvRGF0YVZhbHVlc0FycmF5ID0gZnVuY3Rpb24gKGRhdGFWYXJpYWJsZUFycmF5LCB0ZXh0KSB7XG4gICAgICAgIC8vSU1QT1JUQU5UIE5PVEU6IGRhdGFWYXJpYWJsZUFycmF5IGlzIGEgcGxhaW4gamF2YXNjcmlwdCBhcnJheSBvZiBEYXRhVmFyaWFibGUgaW5zdGFuY2VzOyBpdFxuICAgICAgICAvL2lzIE5PVCBhIGplcm1haW5lIGF0dHJfbGlzdC5cbiAgICAgICAgdmFyIGRhdGFWYWx1ZXMgPSBbXSxcbiAgICAgICAgICAgIGxpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKC9cXGQvLnRlc3QobGluZXNbaV0pKSB7IC8vIHNraXAgbGluZSB1bmxlc3MgaXQgY29udGFpbnMgYSBkaWdpdFxuICAgICAgICAgICAgICAgIHZhciBzdHJpbmdWYWx1ZXNUaGlzUm93ID0gbGluZXNbaV0uc3BsaXQoL1xccyosXFxzKi8pLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVmFsdWVzVGhpc1JvdyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBqO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmdWYWx1ZXNUaGlzUm93Lmxlbmd0aCA9PT0gZGF0YVZhcmlhYmxlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzdHJpbmdWYWx1ZXNUaGlzUm93Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVmFsdWVzVGhpc1Jvdy5wdXNoKERhdGFWYWx1ZS5wYXJzZShkYXRhVmFyaWFibGVBcnJheVtqXS50eXBlKCksIHN0cmluZ1ZhbHVlc1RoaXNSb3dbal0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhVmFsdWVzLnB1c2goIGRhdGFWYWx1ZXNUaGlzUm93ICk7XG4gICAgICAgICAgICAgICAgICAgIC8vfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZ2V0IGhlcmUgaWYgdGhlIG51bWJlciBvZiBjb21tYS1zZXBhcmF0ZWQgdmFsdWVzIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gKGxpbmVzW2ldKSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtZXRhZGF0YS4gIFRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIHByb2JhYmx5IHRocm93IGFuIGVycm9yLCBvciBzb21ldGhpbmcgbGlrZSB0aGF0LiAgRm9yIG5vdywgdGhvdWdoLCB3ZVxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGlnbm9yZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYmFkIGxpbmU6ICcgKyBsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhVmFsdWVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHRleHRUb1N0cmluZ0FycmF5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFxuICAgICAqIEByZXR1cm4ge2FycmF5fSBzdHJpbmdWYWx1ZXNcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgQXJyYXlEYXRhLnRleHRUb1N0cmluZ0FycmF5ID0gZnVuY3Rpb24gKGRhdGFWYXJpYWJsZXMsIHRleHQpIHtcbiAgICAgICAgdmFyIHN0cmluZ1ZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgbGluZXMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgc3RyaW5nVmFsdWVzVGhpc1JvdyxcbiAgICAgICAgICAgIG51bUNvbHVtbnMsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGNsZWFuIHVwIGVhY2ggbGluZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxpbmVzW2ldID0gbGluZXNbaV1cbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxccysvLCAgICAgXCJcIikgICAvLyByZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccyskLywgICAgIFwiXCIpICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKixcXHMqL2csIFwiLFwiKSAgLy8gcmVtb3ZlIGFueSB3aGl0ZXNwYWNlIG5leHQgdG8gY29tbWFzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgICAgIFwiLFwiKTsgLy8gcmVwbGFjZSBhbnkgcmVtYWluaW5nIHdoaXRlc3BhY2UgcnVucyB3aXRoIGEgY29tbWFcbiAgICAgICAgICAgIC8vIG5vdyBsaW5lIGNvbnNpc3RzIG9mIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXMsIHdpdGggbm8gd2hpdGVzcGFjZVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoL1xcZC8udGVzdChsaW5lc1tpXSkpIHsgLy8gc2tpcCBsaW5lIHVubGVzcyBpdCBjb250YWlucyBhIGRpZ2l0XG4gICAgICAgICAgICAgICAgbnVtQ29sdW1ucyA9IGxpbmVzW2ldLnNwbGl0KC8sLykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoL1xcZC8udGVzdChsaW5lc1tpXSkpIHsgLy8gc2tpcCBsaW5lIHVubGVzcyBpdCBjb250YWlucyBhIGRpZ2l0XG4gICAgICAgICAgICAgICAgc3RyaW5nVmFsdWVzVGhpc1JvdyA9IGxpbmVzW2ldLnNwbGl0KC8sLyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZ1ZhbHVlc1RoaXNSb3cubGVuZ3RoID09PSBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1ZhbHVlcy5wdXNoKCBzdHJpbmdWYWx1ZXNUaGlzUm93ICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBQYXJzaW5nIEVycm9yOiBUaGUgbGluZSAnXCIgKyBsaW5lc1tpXSArIFwiJyBoYXMgXCIgKyBzdHJpbmdWYWx1ZXNUaGlzUm93Lmxlbmd0aCArIFwiIGRhdGEgY29sdW1ucyB3aGVuIGl0IHJlcXVpcmVzIFwiICsgbnVtQ29sdW1ucyArIFwiIGNvbHVtbnNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBhcnJheSBvZiBzdHJpbmdzIGludG8gYW4gYXJyYXkgb2YgRGF0YVZhbHVlcy5cbiAgICAgKiBcbiAgICAgKiBAbWV0aG9kIHRleHRUb1N0cmluZ0FycmF5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IGRhdGFWYXJpYWJsZUFycmF5IHBsYWluIGphdmFzY3JpcHQgYXJyYXkgb2YgRGF0YVZhcmlhYmxlc1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IHN0cmluZ0FycmF5IHBsYWluIGphdmFzY3JpcHQgYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAqIEByZXR1cm4ge2FycmF5fSBwbGFpbiBqYXZhc2NyaXB0IGFycmF5IG9mIERhdGFWYWx1ZSBpbnN0YW5jZXNcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgQXJyYXlEYXRhLnN0cmluZ0FycmF5VG9EYXRhVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAoZGF0YVZhcmlhYmxlQXJyYXksIHN0cmluZ0FycmF5KSB7XG4gICAgICAgIC8vSU1QT1JUQU5UIE5PVEU6IGRhdGFWYXJpYWJsZUFycmF5IGlzIGEgcGxhaW4gamF2YXNjcmlwdCBhcnJheSBvZiBEYXRhVmFyaWFibGUgaW5zdGFuY2VzOyBpdFxuICAgICAgICAvL2lzIE5PVCBhIGplcm1haW5lIGF0dHJfbGlzdC5cblxuICAgICAgICB2YXIgZGF0YVZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgZGF0YVZhbHVlc1RoaXNSb3csXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgajtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGRhdGFWYWx1ZXNUaGlzUm93ID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RyaW5nQXJyYXlbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBkYXRhVmFsdWVzVGhpc1Jvdy5wdXNoKERhdGFWYWx1ZS5wYXJzZShkYXRhVmFyaWFibGVBcnJheVtqXS50eXBlKCksIHN0cmluZ0FycmF5W2ldW2pdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhVmFsdWVzLnB1c2goIGRhdGFWYWx1ZXNUaGlzUm93ICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFWYWx1ZXM7XG4gICAgfTtcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXlEYXRhO1xuXG4iLCIvL3ZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcbnZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcyksXG4gICAgRGlzcGxhY2VtZW50ID0gcmVxdWlyZSgnLi4vbWF0aC9kaXNwbGFjZW1lbnQuanMnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICBEYXRhTWVhc3VyZSA9IHJlcXVpcmUoJy4uL2NvcmUvZGF0YV9tZWFzdXJlLmpzJyksXG4gICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgIEVudW0gPSByZXF1aXJlKCcuLi9tYXRoL2VudW0uanMnKSxcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL2V2ZW50X2VtaXR0ZXIuanMnKSxcbiAgICBUZXh0ID0gcmVxdWlyZSgnLi4vY29yZS90ZXh0LmpzJyksXG4gICAgQXhpc0JpbmRpbmcgPSByZXF1aXJlKCcuL2F4aXNfYmluZGluZy5qcycpLFxuICAgIEF4aXNUaXRsZSA9IHJlcXVpcmUoJy4vYXhpc190aXRsZS5qcycpLFxuICAgIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpLFxuICAgIEdyaWQgPSByZXF1aXJlKCcuL2dyaWQuanMnKSxcbiAgICBMYWJlbGVyID0gcmVxdWlyZSgnLi9sYWJlbGVyLmpzJyksXG4gICAgUGFuID0gcmVxdWlyZSgnLi9wYW4uanMnKSxcbiAgICBab29tID0gcmVxdWlyZSgnLi96b29tLmpzJyksXG5cbiAgICBVdGlsID0gcmVxdWlyZSgnLi4vbWF0aC91dGlsLmpzJyksXG5cbiAgICBPcmllbnRhdGlvbiA9IG5ldyBFbnVtKFwiQXhpc09yaWVudGF0aW9uXCIpO1xuXG52YXIgQXhpcyA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkF4aXNcIiwgZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5pc0EoRXZlbnRFbWl0dGVyKTtcblxuICAgIHRoaXMuaGFzQShcInRpdGxlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICAgIHJldHVybiB0aXRsZSBpbnN0YW5jZW9mIEF4aXNUaXRsZTtcbiAgICB9KTtcbiAgICB0aGlzLmhhc01hbnkoXCJsYWJlbGVyc1wiKS5lYWNoT2ZXaGljaC52YWxpZGF0ZVdpdGgoZnVuY3Rpb24gKGxhYmVsZXJzKSB7XG4gICAgICAgIHJldHVybiBsYWJlbGVycyBpbnN0YW5jZW9mIExhYmVsZXI7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiZ3JpZFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkIGluc3RhbmNlb2YgR3JpZDtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJwYW5cIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAocGFuKSB7XG4gICAgICAgIHJldHVybiBwYW4gaW5zdGFuY2VvZiBQYW47XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiem9vbVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh6b29tKSB7XG4gICAgICAgIHJldHVybiB6b29tIGluc3RhbmNlb2YgWm9vbTtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJiaW5kaW5nXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmcgPT09IG51bGwgfHwgYmluZGluZyBpbnN0YW5jZW9mIEF4aXNCaW5kaW5nO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQW4oXCJpZFwiKS53aGljaC5pc0EoXCJzdHJpbmdcIik7XG4gICAgdGhpcy5oYXNBKFwidHlwZVwiKS53aGljaC5pc09uZU9mKERhdGFWYWx1ZS50eXBlcygpKTtcbiAgICB0aGlzLmhhc0EoXCJsZW5ndGhcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggaW5zdGFuY2VvZiBEaXNwbGFjZW1lbnQ7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwicG9zaXRpb25cIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uIGluc3RhbmNlb2YgUG9pbnQ7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwicHJlZ2FwXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJwb3N0Z2FwXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0FuKFwiYW5jaG9yXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJiYXNlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGJhc2UgaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcblxuICAgIHRoaXMuaGFzQShcInZpc2libGVcIikud2hpY2guaXNBKFwiYm9vbGVhblwiKS5hbmQud2hpY2guZGVmYXVsdHNUbyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgXCJtaW5cIiB2YWx1ZSBmcm9tIHRoZSBtdWdsIGZpbGUgYXMgYSBzdHJpbmcsIGlmIHRoZXJlIHdhcyBvbmUuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBzdG9yZWQgYXMgYSBzdHJpbmcsIHJhdGhlciB0aGFuIGFzIGEgbnVtYmVyIG9yIGEgRGF0YVZhbHVlLFxuICAgICAqIGJlY2F1c2UgaXQgbWlnaHQgaGF2ZSB0aGUgdmFsdWUgXCJhdXRvXCIuXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwibWluXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IG1pbiBEYXRhVmFsdWUgZm9yIHRoZSBheGlzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRhdGFNaW5cbiAgICAgKiBAdHlwZSB7RGF0YVZhbHVlfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJkYXRhTWluXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YVZhbHVlLmlzSW5zdGFuY2UpO1xuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hlY2tpbmcgdG8gc2VlIGlmIGRhdGFNaW4gaGFzIGJlZW4gc2V0IG9yIG5vdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBoYXNEYXRhTWluXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaGFzRGF0YU1pblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNaW4oKSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgXG4gICAgdGhpcy5oYXNBKFwibWlub2Zmc2V0XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJtaW5wb3NpdGlvblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChtaW5wb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbWlucG9zaXRpb24gaW5zdGFuY2VvZiBEaXNwbGFjZW1lbnQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIFwibWF4XCIgdmFsdWUgZnJvbSB0aGUgbXVnbCBmaWxlIGFzIGEgc3RyaW5nLCBpZiB0aGVyZSB3YXMgb25lLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgc3RvcmVkIGFzIGEgc3RyaW5nLCByYXRoZXIgdGhhbiBhcyBhIG51bWJlciBvciBhIERhdGFWYWx1ZSxcbiAgICAgKiBiZWNhdXNlIGl0IG1pZ2h0IGhhdmUgdGhlIHZhbHVlIFwiYXV0b1wiLlxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcIm1heFwiKS53aGljaC5pc0EoXCJzdHJpbmdcIik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBtYXggRGF0YVZhbHVlIGZvciB0aGUgYXhpcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkYXRhTWF4XG4gICAgICogQHR5cGUge0RhdGFWYWx1ZX1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiZGF0YU1heFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFWYWx1ZS5pc0luc3RhbmNlKTtcbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoZWNraW5nIHRvIHNlZSBpZiBkYXRhTWF4IGhhcyBiZWVuIHNldCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGhhc0RhdGFNYXhcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJoYXNEYXRhTWF4XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1heCgpICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG5cblxuXG4gICAgdGhpcy5oYXNBKFwibWF4b2Zmc2V0XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJtYXhwb3NpdGlvblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChtYXhwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbWF4cG9zaXRpb24gaW5zdGFuY2VvZiBEaXNwbGFjZW1lbnQ7XG4gICAgfSk7XG5cblxuICAgIHRoaXMuaGFzQShcInBvc2l0aW9uYmFzZVwiKS53aGljaC5pc0EoXCJzdHJpbmdcIik7IC8vIGRlcHJlY2F0ZWRcbiAgICB0aGlzLmhhc0EoXCJjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJ0aWNrY29sb3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yID09PSBudWxsIHx8IGNvbG9yIGluc3RhbmNlb2YgUkdCQ29sb3I7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwidGlja3dpZHRoXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG4gICAgdGhpcy5oYXNBKFwidGlja21pblwiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuICAgIHRoaXMuaGFzQShcInRpY2ttYXhcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJoaWdobGlnaHRzdHlsZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChoaWdobGlnaHRzdHlsZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKGhpZ2hsaWdodHN0eWxlKSA9PT0gXCJzdHJpbmdcIjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJsaW5ld2lkdGhcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJvcmllbnRhdGlvblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKE9yaWVudGF0aW9uLmlzSW5zdGFuY2UpO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJvcmllbnRhdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ3JpZChuZXcgR3JpZCgpKTtcbiAgICAgICAgdGhpcy56b29tKG5ldyBab29tKCkpO1xuICAgICAgICB0aGlzLnBhbihuZXcgUGFuKCkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNBKFwicGl4ZWxMZW5ndGhcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaGFzQShcInBhcmFsbGVsT2Zmc2V0XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJwZXJwT2Zmc2V0XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIHRoaXMuaGFzQShcImF4aXNUb0RhdGFSYXRpb1wiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJpbml0aWFsaXplR2VvbWV0cnlcIiwgZnVuY3Rpb24gKGdyYXBoLCBncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgdmFyIHBsb3RCb3ggPSBncmFwaC5wbG90Qm94KCksXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24oKSxcbiAgICAgICAgICAgIGJhc2UgICAgID0gdGhpcy5iYXNlKCksXG4gICAgICAgICAgICBwaXhlbExlbmd0aCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgcGl4ZWxMZW5ndGggPSB0aGlzLmxlbmd0aCgpLmNhbGN1bGF0ZUxlbmd0aCggcGxvdEJveC53aWR0aCgpICk7XG4gICAgICAgICAgICB0aGlzLnBpeGVsTGVuZ3RoKHBpeGVsTGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMucGFyYWxsZWxPZmZzZXQoIHBvc2l0aW9uLngoKSArIChiYXNlLngoKSArIDEpICogcGxvdEJveC53aWR0aCgpLzIgLSAodGhpcy5hbmNob3IoKSArIDEpICogcGl4ZWxMZW5ndGggLyAyICk7XG4gICAgICAgICAgICB0aGlzLnBlcnBPZmZzZXQoIHBvc2l0aW9uLnkoKSArIChiYXNlLnkoKSArIDEpICogcGxvdEJveC5oZWlnaHQoKSAvIDIgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpeGVsTGVuZ3RoID0gdGhpcy5sZW5ndGgoKS5jYWxjdWxhdGVMZW5ndGgoIHBsb3RCb3guaGVpZ2h0KCkgKTtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxMZW5ndGgocGl4ZWxMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5wYXJhbGxlbE9mZnNldCggcG9zaXRpb24ueSgpICsgKGJhc2UueSgpICsgMSkgKiBwbG90Qm94LmhlaWdodCgpLzIgLSAodGhpcy5hbmNob3IoKSArIDEpICogcGl4ZWxMZW5ndGggLyAyICk7XG4gICAgICAgICAgICB0aGlzLnBlcnBPZmZzZXQoIHBvc2l0aW9uLngoKSArIChiYXNlLngoKSArIDEpICogcGxvdEJveC53aWR0aCgpIC8gMiApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWlub2Zmc2V0KHRoaXMubWlucG9zaXRpb24oKS5jYWxjdWxhdGVDb29yZGluYXRlKHBpeGVsTGVuZ3RoKSk7XG4gICAgICAgIHRoaXMubWF4b2Zmc2V0KHBpeGVsTGVuZ3RoIC0gdGhpcy5tYXhwb3NpdGlvbigpLmNhbGN1bGF0ZUNvb3JkaW5hdGUocGl4ZWxMZW5ndGgpKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzRGF0YU1pbigpICYmIHRoaXMuaGFzRGF0YU1heCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVBeGlzVG9EYXRhUmF0aW8oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sYWJlbGVycygpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsZXJzKCkuYXQoaSkuaW5pdGlhbGl6ZUdlb21ldHJ5KGdyYXBoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aXRsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnRpdGxlKCkuaW5pdGlhbGl6ZUdlb21ldHJ5KGdyYXBoLCBncmFwaGljc0NvbnRleHQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJjb21wdXRlQXhpc1RvRGF0YVJhdGlvXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRGF0YU1pbigpICYmIHRoaXMuaGFzRGF0YU1heCgpKSB7XG4gICAgICAgICAgICB0aGlzLmF4aXNUb0RhdGFSYXRpbygodGhpcy5waXhlbExlbmd0aCgpIC0gdGhpcy5tYXhvZmZzZXQoKSAtIHRoaXMubWlub2Zmc2V0KCkpIC8gKHRoaXMuZGF0YU1heCgpLmdldFJlYWxWYWx1ZSgpIC0gdGhpcy5kYXRhTWluKCkuZ2V0UmVhbFZhbHVlKCkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZGF0YVZhbHVlVG9BeGlzVmFsdWVcIiwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXhpc1RvRGF0YVJhdGlvKCkgKiAoIHYuZ2V0UmVhbFZhbHVlKCkgLSB0aGlzLmRhdGFNaW4oKS5nZXRSZWFsVmFsdWUoKSApICsgdGhpcy5taW5vZmZzZXQoKSArIHRoaXMucGFyYWxsZWxPZmZzZXQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImF4aXNWYWx1ZVRvRGF0YVZhbHVlXCIsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBEYXRhVmFsdWUuY3JlYXRlKCB0aGlzLnR5cGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggdGhpcy5kYXRhTWluKCkuZ2V0UmVhbFZhbHVlKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGEgLSB0aGlzLm1pbm9mZnNldCgpIC0gdGhpcy5wYXJhbGxlbE9mZnNldCgpICkgLyB0aGlzLmF4aXNUb0RhdGFSYXRpbygpKSApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNBKFwiY3VycmVudExhYmVsZXJcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAobGFiZWxlcikge1xuICAgICAgICByZXR1cm4gbGFiZWxlcj09PW51bGwgfHwgbGFiZWxlciBpbnN0YW5jZW9mIExhYmVsZXI7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiY3VycmVudExhYmVsRGVuc2l0eVwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5oYXNBKFwiY3VycmVudExhYmVsZXJJbmRleFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGVzIHdoaWNoIGxhYmVsZXIgdG8gdXNlOiB0YWtlIHRoZSBvbmUgd2l0aCB0aGUgbGFyZ2VzdCBkZW5zaXR5IDw9IDAuOC5cbiAgICAgKiBVbmxlc3MgYWxsIGhhdmUgZGVuc2l0eSA+IDAuOCwgaW4gd2hpY2ggY2FzZSB3ZSB0YWtlIHRoZSBmaXJzdCBvbmUuICBUaGlzIGFzc3VtZXNcbiAgICAgKiB0aGF0IHRoZSBsYWJlbGVycyBsaXN0IGlzIG9yZGVyZWQgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBsYWJlbCBkZW5zaXR5LlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2V0cyB0aGUgYGN1cnJlbnRMYWJlbGVyYCBhbmQgYGN1cnJlbnRMYWJlbERlbnNpdHlgIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXBhcmVSZW5kZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhpY3NDb250ZXh0XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInByZXBhcmVSZW5kZXJcIiwgZnVuY3Rpb24gKGdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRGF0YU1pbigpIHx8ICF0aGlzLmhhc0RhdGFNYXgoKSkge1xuICAgICAgICAgICAgLy8gaWYgZWl0aGVyIGVuZHBvaW50IGRhdGFNaW4oKSBvciBkYXRhTWF4KCkgaGFzbid0IGJlZW4gc3BlY2lmaWVkIHlldCxcbiAgICAgICAgICAgIC8vIHJldHVybiBpbW1lZGlhdGVseSB3aXRob3V0IGRvaW5nIGFueXRoaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRMYWJlbGVyLFxuICAgICAgICAgICAgY3VycmVudExhYmVsRGVuc2l0eSA9IDAsXG4gICAgICAgICAgICBzdG9yZWREZW5zaXR5ID0gMCxcbiAgICAgICAgICAgIGRlbnNpdHlUaHJlc2hvbGQgPSAwLjgsXG4gICAgICAgICAgICBsYWJlbGVycyAgPSB0aGlzLmxhYmVsZXJzKCksXG4gICAgICAgICAgICBubGFiZWxlcnMgPSBsYWJlbGVycy5zaXplKCksXG4gICAgICAgICAgICBpbmRleCAgICAgPSB0aGlzLmN1cnJlbnRMYWJlbGVySW5kZXgoKSxcbiAgICAgICAgICAgIHN0b3JlZEluZGV4O1xuXG4gICAgICAgIGlmIChubGFiZWxlcnMgPD0gMCkge1xuICAgICAgICAgICAgY3VycmVudExhYmVsZXIgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZsYWcgPSB0cnVlLFxuICAgICAgICAgICAgICAgIGxhc3RMYWJlbGVySW5kZXggPSBsYWJlbGVycy5zaXplKCkgLSAxO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjdXJyZW50TGFiZWxEZW5zaXR5ID0gbGFiZWxlcnMuYXQoaW5kZXgpLmdldExhYmVsRGVuc2l0eShncmFwaGljc0NvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudExhYmVsRGVuc2l0eSA+IGRlbnNpdHlUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHsgLy8gdXNlIGxhYmVsZXIgYXQgcG9zaXRpb24gMFxuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gY2hlY2sgdGhlIHByaW9yIGxhYmVsZXJcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkRGVuc2l0eSA9IGN1cnJlbnRMYWJlbERlbnNpdHk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGFiZWxEZW5zaXR5IDwgZGVuc2l0eVRocmVzaG9sZCkgeyAvLyBjaGVjayB0aGUgbmV4dCBsYWJlbGVyXG4gICAgICAgICAgICAgICAgc3RvcmVkRGVuc2l0eSA9IGN1cnJlbnRMYWJlbERlbnNpdHk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBsYXN0TGFiZWxlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudExhYmVsRGVuc2l0eSA9PT0gZGVuc2l0eVRocmVzaG9sZCkgeyAvLyB1c2UgbGFiZWxlciBhdCBwb3NpdGlvbiAwXG4gICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbERlbnNpdHkgPSBsYWJlbGVycy5hdChpbmRleCkuZ2V0TGFiZWxEZW5zaXR5KGdyYXBoaWNzQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMYWJlbERlbnNpdHkgPiBkZW5zaXR5VGhyZXNob2xkKSB7IC8vIGxhYmVsZXIgYmVmb3JlIGN1cnJlbnQgb25lXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkgeyAvLyB1c2UgbGFiZWxlciBhdCBwb3NpdGlvbiAwXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdG9yZWRJbmRleCA+IGluZGV4KSB7IC8vIGdvaW5nIGJhY2t3YXJkcyB0aHJvdWdoIGxhYmVsZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkRGVuc2l0eSA9IGN1cnJlbnRMYWJlbERlbnNpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB0aGUgcHJpb3IgbGFiZWxlciBoYWQgZGVuc2l0eSA8IHRocmVzaG9sZCBhbmQgd2FzIGNoZWNraW5nIHRoZSBuZXh0IGxhYmVsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc3RvcmVkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGFiZWxEZW5zaXR5ID0gc3RvcmVkRGVuc2l0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGFiZWxEZW5zaXR5IDwgZGVuc2l0eVRocmVzaG9sZCkgeyAvLyB0aGlzIGxhYmVsZXIgb3Igb25lIGFmdGVyIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yZWRJbmRleCA+IGluZGV4KSB7IC8vIGdvaW5nIGJhY2t3YXJkcyB0aHJvdWdoIGxhYmVsZXJzIHNvIHByaW9yIGxhYmVsZXIgaGFkIGRlbnNpdHkgPiB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsYXN0TGFiZWxlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gY2hlY2sgbmV4dCBsYWJlbGVyIHRvIHNlZSBpZiBpdCBoYXMgZGVuc2l0eSA8IHRocmVzaG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZERlbnNpdHkgPSBjdXJyZW50TGFiZWxEZW5zaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudExhYmVsRGVuc2l0eSA9PT0gZGVuc2l0eVRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExhYmVsZXIgPSBsYWJlbGVycy5hdChpbmRleCk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50TGFiZWxlcihjdXJyZW50TGFiZWxlcik7XG4gICAgICAgIHRoaXMuY3VycmVudExhYmVsZXJJbmRleChpbmRleCk7XG4gICAgICAgIHRoaXMuY3VycmVudExhYmVsRGVuc2l0eShjdXJyZW50TGFiZWxEZW5zaXR5KTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcInRvUmVhbFZhbHVlXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKERhdGFWYWx1ZS5pc0luc3RhbmNlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldFJlYWxWYWx1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB2YWx1ZSB0eXBlIGZvciBheGlzIHZhbHVlIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJ0b0RhdGFWYWx1ZVwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRhVmFsdWUuY3JlYXRlKHRoaXMudHlwZSgpLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoRGF0YVZhbHVlLmlzSW5zdGFuY2UodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHZhbHVlIHR5cGUgZm9yIGF4aXMgdmFsdWUgXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcInNldERhdGFSYW5nZU5vQmluZFwiLCBmdW5jdGlvbihtaW4sIG1heCwgZGlzcGF0Y2gpIHtcblxuICAgICAgICAvLyBOT1RFOiBtaW4gYW5kIG1heCBtYXkgZWl0aGVyIGJlIHBsYWluIG51bWJlcnMsIG9yXG4gICAgICAgIC8vIERhdGFWYWx1ZSBpbnN0YW5jZXMuICBJZiB0aGV5J3JlIHBsYWluIG51bWJlcnMsIHRoZXlcbiAgICAgICAgLy8gZ2V0IGNvbnZlcnRlZCB0byBEYXRhVmFsdWUgaW5zdGFuY2VzIGhlcmUgYmVmb3JlIGJlaW5nXG4gICAgICAgIC8vIHBhc3NlZCB0byB0aGUgZGF0YU1pbigpL2RhdGFNYXgoKSBzZXR0ZXJzIGJlbG93LlxuXG4gICAgICAgIHZhciBkYXRhVmFsdWVNaW4gPSB0aGlzLnRvRGF0YVZhbHVlKG1pbiksXG4gICAgICAgICAgICBkYXRhVmFsdWVNYXggPSB0aGlzLnRvRGF0YVZhbHVlKG1heCk7XG5cbiAgICAgICAgdGhpcy5kYXRhTWluKGRhdGFWYWx1ZU1pbik7XG4gICAgICAgIHRoaXMuZGF0YU1heChkYXRhVmFsdWVNYXgpO1xuICAgICAgICAvLyBpZiAoX2dyYXBoICE9IG51bGwpIHsgX2dyYXBoLmludmFsaWRhdGVEaXNwbGF5TGlzdCgpOyB9XG4gICAgICAgIGlmIChkaXNwYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoeyd0eXBlJyA6ICdkYXRhUmFuZ2VTZXQnLFxuICAgICAgICAgICAgICAgICAgICdtaW4nICA6IGRhdGFWYWx1ZU1pbixcbiAgICAgICAgICAgICAgICAgICAnbWF4JyAgOiBkYXRhVmFsdWVNYXh9KTtcbiAgICAgICAgLypcbiAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgLy9kaXNwYXRjaEV2ZW50KG5ldyBBeGlzRXZlbnQoQXhpc0V2ZW50LkNIQU5HRSxtaW4sbWF4KSk7ICBcbiAgICAgICAgIH1cbiAgICAgICAgICovXG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJzZXREYXRhUmFuZ2VcIiwgZnVuY3Rpb24gKG1pbiwgbWF4LCBkaXNwYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZygpLnNldERhdGFSYW5nZSh0aGlzLCBtaW4sIG1heCwgZGlzcGF0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhUmFuZ2VOb0JpbmQobWluLCBtYXgsIGRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZG9QYW5cIiwgZnVuY3Rpb24gKHBpeGVsQmFzZSwgcGl4ZWxEaXNwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIHBhbiA9IHRoaXMucGFuKCksXG4gICAgICAgICAgICBwYW5NaW4gPSBwYW4ubWluKCksXG4gICAgICAgICAgICBwYW5NYXggPSBwYW4ubWF4KCksXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBuZXdSZWFsTWluLFxuICAgICAgICAgICAgbmV3UmVhbE1heDtcblxuICAgICAgICBpZiAoIXBhbi5hbGxvd2VkKCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9mZnNldCA9IHBpeGVsRGlzcGxhY2VtZW50IC8gdGhpcy5heGlzVG9EYXRhUmF0aW8oKTtcbiAgICAgICAgbmV3UmVhbE1pbiA9IHRoaXMuZGF0YU1pbigpLmdldFJlYWxWYWx1ZSgpIC0gb2Zmc2V0O1xuICAgICAgICBuZXdSZWFsTWF4ID0gdGhpcy5kYXRhTWF4KCkuZ2V0UmVhbFZhbHVlKCkgLSBvZmZzZXQ7XG4gICAgICAgIFxuICAgICAgICBpZiAocGFuTWluICYmIG5ld1JlYWxNaW4gPCBwYW5NaW4uZ2V0UmVhbFZhbHVlKCkpIHtcbiAgICAgICAgICAgIG5ld1JlYWxNYXggKz0gKHBhbk1pbi5nZXRSZWFsVmFsdWUoKSAtIG5ld1JlYWxNaW4pO1xuICAgICAgICAgICAgbmV3UmVhbE1pbiA9IHBhbk1pbi5nZXRSZWFsVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFuTWF4ICYmIG5ld1JlYWxNYXggPiBwYW5NYXguZ2V0UmVhbFZhbHVlKCkpIHtcbiAgICAgICAgICAgIG5ld1JlYWxNaW4gLT0gKG5ld1JlYWxNYXggLSBwYW5NYXguZ2V0UmVhbFZhbHVlKCkpO1xuICAgICAgICAgICAgbmV3UmVhbE1heCA9IHBhbk1heC5nZXRSZWFsVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldERhdGFSYW5nZShEYXRhVmFsdWUuY3JlYXRlKHRoaXMudHlwZSgpLCBuZXdSZWFsTWluKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgRGF0YVZhbHVlLmNyZWF0ZSh0aGlzLnR5cGUoKSwgbmV3UmVhbE1heCkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZG9ab29tXCIsIGZ1bmN0aW9uIChwaXhlbEJhc2UsIHBpeGVsRGlzcGxhY2VtZW50KSB7XG4gICAgICAgIHZhciB6b29tID0gdGhpcy56b29tKCksXG4gICAgICAgICAgICBwYW4gID0gdGhpcy5wYW4oKSxcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGUoKSxcbiAgICAgICAgICAgIGRhdGFNaW4gPSB0aGlzLmRhdGFNaW4oKSxcbiAgICAgICAgICAgIGRhdGFNYXggPSB0aGlzLmRhdGFNYXgoKSxcbiAgICAgICAgICAgIHBhbk1pbiAgPSBwYW4ubWluKCksXG4gICAgICAgICAgICBwYW5NYXggID0gcGFuLm1heCgpLFxuICAgICAgICAgICAgem9vbU1pbiA9IHpvb20ubWluKCksXG4gICAgICAgICAgICB6b29tTWF4ID0gem9vbS5tYXgoKSxcbiAgICAgICAgICAgIGJhc2VSZWFsVmFsdWUsXG4gICAgICAgICAgICBmYWN0b3IsXG4gICAgICAgICAgICBuZXdNaW4sXG4gICAgICAgICAgICBuZXdNYXgsXG4gICAgICAgICAgICBkO1xuICAgICAgICBpZiAoIXpvb20uYWxsb3dlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYmFzZVJlYWxWYWx1ZSA9IHRoaXMuYXhpc1ZhbHVlVG9EYXRhVmFsdWUocGl4ZWxCYXNlKS5nZXRSZWFsVmFsdWUoKTtcbiAgICAgICAgaWYgKERhdGFWYWx1ZS5pc0luc3RhbmNlKHpvb20uYW5jaG9yKCkpKSB7XG4gICAgICAgICAgICBiYXNlUmVhbFZhbHVlID0gem9vbS5hbmNob3IoKS5nZXRSZWFsVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBmYWN0b3IgPSAxMCAqIE1hdGguYWJzKHBpeGVsRGlzcGxhY2VtZW50IC8gKHRoaXMucGl4ZWxMZW5ndGgoKSAtIHRoaXMubWF4b2Zmc2V0KCkgLSB0aGlzLm1pbm9mZnNldCgpKSk7XG4gICAgICAgIC8qVE9ETzogdW5jb21tZW50IGFmdGVyIHRoaXMucmV2ZXJzZWQoKSBoYXMgYmVlbiBpbXBsZW1lbnRlZFxuICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZWQoKSkgeyBmYWN0b3IgPSAtZmFjdG9yOyB9XG4gICAgICAgICAqL1xuICAgICAgICBpZiAocGl4ZWxEaXNwbGFjZW1lbnQgPD0gMCkge1xuICAgICAgICAgICAgbmV3TWluID0gRGF0YVZhbHVlLmNyZWF0ZSh0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YU1pbi5nZXRSZWFsVmFsdWUoKSAtIGJhc2VSZWFsVmFsdWUpICogKCAxICsgZmFjdG9yICkgKyBiYXNlUmVhbFZhbHVlKTtcbiAgICAgICAgICAgIG5ld01heCA9IERhdGFWYWx1ZS5jcmVhdGUodHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGFNYXguZ2V0UmVhbFZhbHVlKCkgLSBiYXNlUmVhbFZhbHVlKSAqICggMSArIGZhY3RvciApICsgYmFzZVJlYWxWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNaW4gPSBEYXRhVmFsdWUuY3JlYXRlKHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkYXRhTWluLmdldFJlYWxWYWx1ZSgpIC0gYmFzZVJlYWxWYWx1ZSkgKiAoIDEgLSBmYWN0b3IgKSArIGJhc2VSZWFsVmFsdWUpO1xuICAgICAgICAgICAgbmV3TWF4ID0gRGF0YVZhbHVlLmNyZWF0ZSh0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YU1heC5nZXRSZWFsVmFsdWUoKSAtIGJhc2VSZWFsVmFsdWUpICogKCAxIC0gZmFjdG9yICkgKyBiYXNlUmVhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFuTWluICYmIG5ld01pbi5sdChwYW5NaW4pKSB7XG4gICAgICAgICAgICBuZXdNaW4gPSBwYW5NaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhbk1heCAmJiBuZXdNYXguZ3QocGFuTWF4KSkge1xuICAgICAgICAgICAgbmV3TWF4ID0gcGFuTWF4O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoKGRhdGFNaW4ubGUoZGF0YU1heCkgJiYgbmV3TWluLmx0KG5ld01heCkpIHx8XG4gICAgICAgICAgICAoZGF0YU1pbi5nZShkYXRhTWF4KSAmJiBuZXdNaW4uZ3QobmV3TWF4KSkpIHtcbiAgICAgICAgICAgIGlmICh6b29tTWF4ICYmIChuZXdNYXguZ3QobmV3TWluLmFkZCh6b29tTWF4KSkpKSB7XG4gICAgICAgICAgICAgICAgZCA9IChuZXdNYXguZ2V0UmVhbFZhbHVlKCkgLSBuZXdNaW4uZ2V0UmVhbFZhbHVlKCkgLSB6b29tTWF4LmdldFJlYWxWYWx1ZSgpKSAvIDI7XG4gICAgICAgICAgICAgICAgbmV3TWF4ID0gbmV3TWF4LmFkZFJlYWxWYWx1ZSgtZCk7XG4gICAgICAgICAgICAgICAgbmV3TWluID0gbmV3TWluLmFkZFJlYWxWYWx1ZShkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoem9vbU1pbiAmJiAobmV3TWF4Lmx0KG5ld01pbi5hZGQoem9vbU1pbikpKSkge1xuICAgICAgICAgICAgICAgIGQgPSAoem9vbU1pbi5nZXRSZWFsVmFsdWUoKSAtIChuZXdNYXguZ2V0UmVhbFZhbHVlKCkgLSBuZXdNaW4uZ2V0UmVhbFZhbHVlKCkpKSAvIDI7XG4gICAgICAgICAgICAgICAgbmV3TWF4ID0gbmV3TWF4LmFkZFJlYWxWYWx1ZShkKTtcbiAgICAgICAgICAgICAgICBuZXdNaW4gPSBuZXdNaW4uYWRkUmVhbFZhbHVlKC1kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YVJhbmdlKG5ld01pbiwgbmV3TWF4KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZGlzdGFuY2UgZnJvbSBhbiBheGlzIHRvIGEgcG9pbnQuICBUaGUgcG9pbnRcbiAgICAgKiAoeCx5KSBpcyBleHByZXNzZWQgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgaW4gdGhlIHNhbWVcbiAgICAgKiBjb29yZGluYXRlIHN5c3RlbSBhcyB0aGUgYXhpcy5cbiAgICAgKiBcbiAgICAgKiBXZSB1c2UgdHdvIGRpZmZlcmVudCBraW5kcyBvZiBjb21wdXRhdGlvbnMgZGVwZW5kaW5nIG9uXG4gICAgICogd2hldGhlciB0aGUgcG9pbnQgbGllcyBpbnNpZGUgb3Igb3V0c2lkZSB0aGUgcmVnaW9uIGJvdW5kZWRcbiAgICAgKiBieSB0aGUgdHdvIGxpbmVzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGF4aXMgdGhyb3VnaCBpdHNcbiAgICAgKiBlbmRwb2ludHMuICBJZiB0aGUgcG9pbnQgbGllcyBpbnNpZGUgdGhpcyByZWdpb24sIHRoZVxuICAgICAqIGRpc3RhbmNlIGlzIHNpbXBseSB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgcGVycGVuZGljdWxhclxuICAgICAqIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGFuZCB0aGUgcGVycGVuZGljdWxhciBjb29yZGluYXRlIG9mXG4gICAgICogdGhlIGF4aXMuXG4gICAgICogXG4gICAgICogSWYgdGhlIHBvaW50IGxpZXMgb3V0c2lkZSB0aGUgcmVnaW9uLCB0aGVuIHRoZSBkaXN0YW5jZSBpc1xuICAgICAqIHRoZSBMMiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludCBhbmQgdGhlIGNsb3Nlc3QgZW5kcG9pbnRcbiAgICAgKiBvZiB0aGUgYXhpcy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGlzdGFuY2VUb1BvaW50XG4gICAgICogQHBhcmFtIHt9IHhcbiAgICAgKiBAcGFyYW0ge30geVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJkaXN0YW5jZVRvUG9pbnRcIiwgZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHBlcnBDb29yZCAgICAgPSAodGhpcy5vcmllbnRhdGlvbigpID09PSBBeGlzLkhPUklaT05UQUwpID8geSA6IHgsXG4gICAgICAgICAgICBwYXJhbGxlbENvb3JkID0gKHRoaXMub3JpZW50YXRpb24oKSA9PT0gQXhpcy5IT1JJWk9OVEFMKSA/IHggOiB5LFxuICAgICAgICAgICAgcGFyYWxsZWxPZmZzZXQgPSB0aGlzLnBhcmFsbGVsT2Zmc2V0KCksXG4gICAgICAgICAgICBwZXJwT2Zmc2V0ICAgICA9IHRoaXMucGVycE9mZnNldCgpLFxuICAgICAgICAgICAgcGl4ZWxMZW5ndGggICAgPSB0aGlzLnBpeGVsTGVuZ3RoKCksXG4gICAgICAgICAgICBsMmRpc3QgICAgICAgICA9IFV0aWwubDJkaXN0O1xuXG4gICAgICAgIGlmIChwYXJhbGxlbENvb3JkIDwgcGFyYWxsZWxPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHBvaW50IGlzIHVuZGVyIG9yIGxlZnQgb2YgdGhlIGF4aXM7IHJldHVybiBMMiBkaXN0YW5jZSB0byBib3R0b20gb3IgbGVmdCBheGlzIGVuZHBvaW50XG4gICAgICAgICAgICByZXR1cm4gbDJkaXN0KHBhcmFsbGVsQ29vcmQsIHBlcnBDb29yZCwgcGFyYWxsZWxPZmZzZXQsIHBlcnBPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbGxlbENvb3JkID4gcGFyYWxsZWxPZmZzZXQgKyBwaXhlbExlbmd0aCkge1xuICAgICAgICAgICAgLy8gcG9pbnQgaXMgYWJvdmUgb3IgcmlnaHQgb2YgdGhlIGF4aXM7IHJldHVybiBMMiBkaXN0YW5jZSB0byB0b3Agb3IgcmlnaHQgYXhpcyBlbmRwb2ludFxuICAgICAgICAgICAgcmV0dXJuIGwyZGlzdChwYXJhbGxlbENvb3JkLCBwZXJwQ29vcmQsIHBhcmFsbGVsT2Zmc2V0ICsgcGl4ZWxMZW5ndGgsIHBlcnBPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBvaW50IGlzIGJldHdlZW4gdGhlIGF4aXMgZW5kcG9pbnRzOyByZXR1cm4gZGlmZmVyZW5jZSBpbiBwZXJwZW5kaWN1bGFyIGNvb3Jkc1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMocGVycENvb3JkIC0gcGVycE9mZnNldCk7XG4gICAgfSk7XG5cblxuICAgIHRoaXMucmVzcG9uZHNUbyhcIm5vcm1hbGl6ZVwiLCBmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIGxhYmVsO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhhbmRsZXMgdGl0bGUgdGFnc1xuICAgICAgICAvL1xuICAgICAgICBpZiAodGhpcy50aXRsZSgpICYmIHRoaXMudGl0bGUoKS5jb250ZW50KCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy50aXRsZSgpLmNvbnRlbnQobmV3IFRleHQodGhpcy5pZCgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBIYW5kbGVzIG1pc3NpbmcgbGFiZWxlcnNcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHRoaXMubGFiZWxlcnMoKS5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWVzID0gKHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSkuaG9yaXpvbnRhbGF4aXMubGFiZWxzLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRTcGFjaW5ncyA9IHRoaXMudHlwZSgpID09PSBEYXRhVmFsdWUuTlVNQkVSID9cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlcy5kZWZhdWx0TnVtYmVyU3BhY2luZyA6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXMuZGVmYXVsdERhdGV0aW1lU3BhY2luZztcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlZmF1bHRTcGFjaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gbmV3IExhYmVsZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgbGFiZWwuc3BhY2luZyhEYXRhTWVhc3VyZS5wYXJzZSh0aGlzLnR5cGUoKSwgZGVmYXVsdFNwYWNpbmdzW2ldKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbGVycygpLmFkZChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBub3JtYWxpemVzIHRoZSBsYWJlbGVyc1xuICAgICAgICAvL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sYWJlbGVycygpLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsZXJzKCkuYXQoaSkubm9ybWFsaXplKCk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzLCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5BeGlzLkhPUklaT05UQUwgPSBuZXcgT3JpZW50YXRpb24oXCJob3Jpem9udGFsXCIpO1xuQXhpcy5WRVJUSUNBTCAgID0gbmV3IE9yaWVudGF0aW9uKFwidmVydGljYWxcIik7XG5cbkF4aXMuT3JpZW50YXRpb24gPSBPcmllbnRhdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlzO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgQXhpc0JpbmRpbmcgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJBeGlzQmluZGluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEF4aXNCaW5kaW5nID0gdGhpcztcbiAgICBcbiAgICBBeGlzQmluZGluZy5pbnN0YW5jZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiaWRcIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYXhlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYXhlc1wiKTsgLy8ganMgYXJyYXlcblxuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJpZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgQXhpc0JpbmRpbmcuaW5zdGFuY2VzW3RoaXMuaWQoKV0gPSB0aGlzO1xuICAgICAgICB0aGlzLmF4ZXMoW10pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZEF4aXNcbiAgICAgKiBAcGFyYW0ge0F4aXN9IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcnxEYXRhVmFsdWV9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfERhdGFWYWx1ZX0gbWF4XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImFkZEF4aXNcIiwgZnVuY3Rpb24oYXhpcywgbWluLCBtYXgsIG11bHRpZ3JhcGgvKm9wdGlvbmFsKi8pIHtcbiAgICAgICAgLy8gTk9URTogbWluL21heCBjYW4gYmUgZWl0aGVyIG51bWJlcnMsIG9yIERhdGFWYWx1ZVxuICAgICAgICAvLyBpbnN0YW5jZXMsIGJ1dCB0aGV5IENBTk5PVCBiZSBzdHJpbmdzLlxuXG4gICAgICAgIGlmIChheGlzLmJpbmRpbmcoKSkge1xuICAgICAgICAgICAgYXhpcy5iaW5kaW5nKCkucmVtb3ZlQXhpcyhheGlzKTtcbiAgICAgICAgfVxuICAgICAgICBheGlzLmJpbmRpbmcodGhpcyk7XG5cbiAgICAgICAgLy8gY29udmVydCBtaW4vbWF4IHRvIG51bWJlcnNcbiAgICAgICAgbWluID0gYXhpcy50b1JlYWxWYWx1ZShtaW4pO1xuICAgICAgICBtYXggPSBheGlzLnRvUmVhbFZhbHVlKG1heCk7XG5cbiAgICAgICAgdGhpcy5heGVzKCkucHVzaCh7XG4gICAgICAgICAgICBheGlzICAgICAgIDogYXhpcyxcbiAgICAgICAgICAgIG11bHRpZ3JhcGggOiBtdWx0aWdyYXBoLFxuICAgICAgICAgICAgZmFjdG9yICAgICA6IDEgLyAobWF4IC0gbWluKSxcbiAgICAgICAgICAgIG9mZnNldCAgICAgOiAtbWluIC8gKG1heCAtIG1pbiksXG4gICAgICAgICAgICBtaW4gICAgICAgIDogbWluLFxuICAgICAgICAgICAgbWF4ICAgICAgICA6IG1heFxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW1vdmVBeGlzXG4gICAgICogQHBhcmFtIHtBeGlzfSBheGlzXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInJlbW92ZUF4aXNcIiwgZnVuY3Rpb24oYXhpcykge1xuICAgICAgICB2YXIgYXhlcyA9IHRoaXMuYXhlcygpLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpPTA7IGk8YXhlcy5sZW5ndGgoKTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYXhlc1tpXS5heGlzID09PSBheGlzKSB7XG4gICAgICAgICAgICAgICAgYXhlcy5zcGxpY2UoaSwxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRm9yY2UgYWxsIHRoZSBheGVzIGluIHRoaXMgYmluZGluZyB0byBzeW5jIHVwIHdpdGggZWFjaFxuICAgICAqIG90aGVyLCBpZiBwb3NzaWJsZS5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGlzIGRvbmUgYnkgbG9va2luZyBmb3IgYW4gYXhpcyBpbiB0aGlzIGJpbmRpbmcgd2hpY2hcbiAgICAgKiBoYXMgaXRzIGRhdGFNaW4gYW5kIGRhdGFNYXggdmFsdWVzIHNldCwgYW5kIHRoZW4gY2FsbGluZ1xuICAgICAqIGl0cyBzZXREYXRhUmFuZ2UoKSBtZXRob2Qgd2l0aCB0aG9zZSB2YWx1ZXMuICBUaGUgbWFpblxuICAgICAqIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gZmFjaWxpdGF0ZSB0aGUgaW5pdGlhbCBzZXR0aW5nXG4gICAgICogb2YgZGF0YU1pbi9kYXRhTWF4IHZhbHVlcyBmb3IgYXhlcyBpbiBhIGJpbmRpbmcgdGhhdCBkbyBub3RcbiAgICAgKiBhbHJlYWR5IGhhdmUgZGF0YU1pbi9kYXRhTWF4IHZhbHVlcyBzZXQ7IHRoaXMgZm9yY2VzIHRoZW1cbiAgICAgKiB0byBiZSBzZXQgYmFzZWQgb24gdGhlIGJpbmRpbmcsIGFzIGRldGVybWluZWQgYnkgYW5vdGhlclxuICAgICAqIGF4aXMgaW4gdGhlIGJpbmRpbmcuXG4gICAgICogXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIE5PVCB0aGUgbm9ybWFsIHdheSBmb3IgYm91bmQgYXhlc1xuICAgICAqIHRvIGludGVyYWN0IHdpdGggZWFjaCBvdGhlciBvbmNlIGluaXRpYWxpemF0aW9uIGlzXG4gICAgICogY29tcGxldGU7IHRoYXQgaXMgZG9uZSB2aWEgdGhlIGF4ZXMnIG93biBzZXREYXRhUmFuZ2UoKVxuICAgICAqIG1ldGhvZC5cbiAgICAgKiBcbiAgICAgKiBAbWV0aG9kIHN5bmNcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3luYyB3YXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICBkb25lOyB0aGlzIHdpbGwgYmUgdHJ1ZSBpZiBhbmQgb25seSBpZlxuICAgICAqICAgICAgICAgICAgICAgICAgIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBheGlzIGluIHRoZSBiaW5kaW5nXG4gICAgICogICAgICAgICAgICAgICAgICAgaGF2aW5nIGJvdGggaXRzIGRhdGFNaW4gYW5kIGRhdGFNYXhcbiAgICAgKiAgICAgICAgICAgICAgICAgICB2YWx1ZXMgc2V0LlxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInN5bmNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgYXhlcyA9IHRoaXMuYXhlcygpLFxuICAgICAgICAgICAgYXhpcztcbiAgICAgICAgZm9yIChpPTA7IGk8YXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXhpcyA9IGF4ZXNbaV0uYXhpcztcbiAgICAgICAgICAgIGlmIChheGlzLmhhc0RhdGFNaW4oKSAmJiBheGlzLmhhc0RhdGFNYXgoKSkge1xuICAgICAgICAgICAgICAgIGF4aXMuc2V0RGF0YVJhbmdlKGF4aXMuZGF0YU1pbigpLCBheGlzLmRhdGFNYXgoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0RGF0YVJhbmdlXG4gICAgICogQHBhcmFtIHtBeGlzfSBpbml0aWF0aW5nQXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfERhdGFWYWx1ZX0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ8RGF0YVZhbHVlfSBtYXhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3BhdGNoXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInNldERhdGFSYW5nZVwiLCBmdW5jdGlvbihpbml0aWF0aW5nQXhpcywgbWluLCBtYXgsIGRpc3BhdGNoKSB7XG5cbiAgICAgICAgLy8gTk9URTogbWluIGFuZCBtYXggbWF5IGVpdGhlciBiZSBwbGFpbiBudW1iZXJzLCBvclxuICAgICAgICAvLyBEYXRhVmFsdWUgaW5zdGFuY2VzLiAgSWYgdGhleSdyZSBEYXRhVmFsdWUgaW5zdGFuY2VzLFxuICAgICAgICAvLyBnZXQgY29udmVydGVkIHRvIG51bWJlcnMgaGVyZSBiZWZvcmUgYmVpbmdcbiAgICAgICAgLy8gcGFzc2VkIHRvIHRoZSBpbmRpdmlkdWFsIGF4ZXMnIHNldERhdGFSYW5nZU5vQmluZCgpXG4gICAgICAgIC8vIG1ldGhvZCBiZWxvdy5cblxuICAgICAgICB2YXIgaW5pdGlhdGluZ0F4aXNJbmRleCxcbiAgICAgICAgICAgIGksIGosXG4gICAgICAgICAgICBheGVzID0gdGhpcy5heGVzKCksXG4gICAgICAgICAgICBheGlzLFxuICAgICAgICAgICAgbWluUmVhbFZhbHVlID0gaW5pdGlhdGluZ0F4aXMudG9SZWFsVmFsdWUobWluKSxcbiAgICAgICAgICAgIG1heFJlYWxWYWx1ZSA9IGluaXRpYXRpbmdBeGlzLnRvUmVhbFZhbHVlKG1heCksXG4gICAgICAgICAgICByZWRyYXduX211bHRpZ3JhcGhzID0gW10sXG4gICAgICAgICAgICByZWRyYXduO1xuXG4gICAgICAgIGlmIChkaXNwYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCA9IHRydWU7IC8vIGRpc3BhdGNoIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaT0wOyBpPGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChheGVzW2ldLmF4aXMgPT09IGluaXRpYXRpbmdBeGlzKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhdGluZ0F4aXNJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgcmVkcmF3bl9tdWx0aWdyYXBocyA9IFsgYXhlc1tpXS5tdWx0aWdyYXBoIF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpPTA7IGk8YXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXhpcyA9IGF4ZXNbaV07XG4gICAgICAgICAgICBpZiAoaSA9PT0gaW5pdGlhdGluZ0F4aXNJbmRleCkge1xuICAgICAgICAgICAgICAgIGF4aXMuYXhpcy5zZXREYXRhUmFuZ2VOb0JpbmQobWluUmVhbFZhbHVlLCBtYXhSZWFsVmFsdWUsIGRpc3BhdGNoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXhpcy5heGlzLnNldERhdGFSYW5nZU5vQmluZChcbiAgICAgICAgICAgICAgICAgICAgKG1pblJlYWxWYWx1ZSAqIGF4ZXNbaW5pdGlhdGluZ0F4aXNJbmRleF0uZmFjdG9yICsgYXhlc1tpbml0aWF0aW5nQXhpc0luZGV4XS5vZmZzZXQgLSBheGlzLm9mZnNldCkgLyBheGlzLmZhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgKG1heFJlYWxWYWx1ZSAqIGF4ZXNbaW5pdGlhdGluZ0F4aXNJbmRleF0uZmFjdG9yICsgYXhlc1tpbml0aWF0aW5nQXhpc0luZGV4XS5vZmZzZXQgLSBheGlzLm9mZnNldCkgLyBheGlzLmZhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChheGlzLm11bHRpZ3JhcGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGF4aXMgaGFzIGEgbXVsdGlncmFwaCBzdG9yZWQgd2l0aCBpdCwgYW5kIGlmIHRoYXQgbXVsdGlncmFwaCBpc24ndCBhbHJlYWR5IGluIHRoZSBgcmVkcmF3bl9tdWx0aWdyYXBoc2BcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXksIGNhbGwgaXRzIGByZWRyYXdgIG1ldGhvZCwgYW5kIGFkZCBpdCB0byB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqPTA7IGo8cmVkcmF3bl9tdWx0aWdyYXBocy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXMubXVsdGlncmFwaCA9PT0gcmVkcmF3bl9tdWx0aWdyYXBoc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZHJhd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVkcmF3bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5tdWx0aWdyYXBoLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVkcmF3bl9tdWx0aWdyYXBocy5wdXNoKGF4aXMubXVsdGlncmFwaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRJbnN0YW5jZUJ5SWRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIEF4aXNCaW5kaW5nLmdldEluc3RhbmNlQnlJZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiBBeGlzQmluZGluZy5pbnN0YW5jZXNbaWRdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZmluZEJ5SWRPckNyZWF0ZU5ld1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gaWRcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgQXhpc0JpbmRpbmcuZmluZEJ5SWRPckNyZWF0ZU5ldyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gQXhpc0JpbmRpbmcuZ2V0SW5zdGFuY2VCeUlkKGlkKTtcbiAgICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgICAgICBiaW5kaW5nID0gbmV3IEF4aXNCaW5kaW5nKGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHN5bmNBbGxCaW5kaW5nc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgQXhpc0JpbmRpbmcuc3luY0FsbEJpbmRpbmdzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgZm9yIChpZCBpbiBBeGlzQmluZGluZy5pbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIEF4aXNCaW5kaW5nLmluc3RhbmNlc1tpZF0uc3luYygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQG1ldGhvZCBmb3JnZXRBbGxCaW5kaW5nc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgQXhpc0JpbmRpbmcuZm9yZ2V0QWxsQmluZGluZ3MgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGp1c3QgZm9yIHVzZSBpbiB0ZXN0aW5nLCBzbyB3ZSBjYW4gY2xlYXIgb3V0IHRoZSBnbG9iYWwgbGlzdFxuICAgICAgICAvLyBvZiBiaW5kaW5ncyB0byBnZXQgYSBmcmVzaCBzdGFydCBiZXR3ZWVuIHRlc3RzLlxuXG4gICAgICAgIHZhciBpZCxqLGJpbmRpbmc7XG5cbiAgICAgICAgLy8gbG9vcCBvdmVyIGFsbCBiaW5kaW5ncywgYWxsIGF4ZXMsIHNldHRpbmcgdGhlIGF4aXMgYmluZGluZyB0byBudWxsXG4gICAgICAgIGZvciAoaWQgaW4gQXhpc0JpbmRpbmcuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBiaW5kaW5nID0gQXhpc0JpbmRpbmcuaW5zdGFuY2VzW2lkXTtcbiAgICAgICAgICAgIGZvciAoaj0wOyBqPGJpbmRpbmcuYXhlcygpLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZy5heGVzKClbal0uYXhpcy5iaW5kaW5nKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgdGhlIGdsb2JhbCBiaW5kaW5nIGxpc3RcbiAgICAgICAgQXhpc0JpbmRpbmcuaW5zdGFuY2VzID0ge307XG4gICAgfTtcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpc0JpbmRpbmc7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyAgICA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzICAgICAgID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMuaG9yaXpvbnRhbGF4aXMudGl0bGUpLFxuICAgIFBvaW50ICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9tYXRoL3BvaW50LmpzJyk7XG5cbi8qKlxuICogQXhpcyBUaXRsZSBpcyBhIEplcm1haW5lIG1vZGVsIHRoYXQgc3VwcG9ydHMgdGhlIHJlbmRlcmluZyBvZiBBeGlzIFRpdGxlcy5cbiAqXG4gKiBAY2xhc3MgQXhpc1RpdGxlXG4gKiBAZm9yIEF4aXNUaXRsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0F4aXN9IGF4aXNcbiAqL1xudmFyIEF4aXNUaXRsZSA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkF4aXNUaXRsZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgXG4gICAgLyoqXG4gICAgICogUG9pbnRlciB0byB0aGUgVGl0bGUncyBwYXJlbnQgQXhpcyBqZXJtaWFuZSBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBheGlzXG4gICAgICogQHR5cGUge0F4aXN9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImF4aXNcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB2YXIgQXhpcyA9IHJlcXVpcmUoJy4vYXhpcy5qcycpO1xuICAgICAgICByZXR1cm4gYXhpcyBpbnN0YW5jZW9mIEF4aXM7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGlzIHVzZWQgYXMgdGhlIHRpdGxlIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb250ZW50XG4gICAgICogQHR5cGUge1RleHR9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImNvbnRlbnRcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICB2YXIgVGV4dCA9IHJlcXVpcmUoJy4vdGV4dC5qcycpO1xuICAgICAgICByZXR1cm4gY29udGVudCBpbnN0YW5jZW9mIFRleHQ7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGdpdmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgVGl0bGUncyBhbmNob3IgcG9pbnQgdG8gYmUgYXR0YWNoZWQgdG8gdGhlXG4gICAgICogYmFzZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBhbmNob3JcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImFuY2hvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIGFuY2hvciBpbnN0YW5jZW9mIFBvaW50O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB3aGljaCBnaXZlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGJhc2UgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIFRpdGxlJ3MgQXhpcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBiYXNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYmFzZVwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgLyoqXG4gICAgICogQSBjb29yZGluYXRlIHBhaXIgb2YgcGl4ZWwgb2Zmc2V0cyBmb3IgdGhlIGJhc2UgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInBvc2l0aW9uXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbiBpbnN0YW5jZW9mIFBvaW50O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB3aGljaCBkZXRlcm1pbmVzIHRoZSByb3RhdGlvbiBvZiB0aGUgVGl0bGUgaW4gZGVncmVlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImFuZ2xlXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIHRoaXMuaGFzQShcImZvbnRcIikud2hpY2guaXNBKFwic3RyaW5nXCIpLmFuZC53aGljaC5kZWZhdWx0c1RvKFwiXCIpO1xuXG4gICAgdGhpcy5pc0J1aWx0V2l0aChcImF4aXNcIik7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHZhbHVlcyBmb3IgdGhlIGBwb3NpdGlvbmAgYW5kIGBhbmNob3JgIGF0dHJpYnV0ZXMgaWYgdGhleSB3ZXJlIG5vdCBzZXQ7IGRldGVybWluZXMgdGhlXG4gICAgICogZ2VvbWV0cnkgb2YgdGhlIGBjb250ZW50YCBhdHRyaWJ1dGUuIENhbGxlZCBieSBgQXhpcy5pbml0aWFsaXplR2VvbWV0cnkoKWAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVHZW9tZXRyeVxuICAgICAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoaWNzQ29udGV4dFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaW5pdGlhbGl6ZUdlb21ldHJ5XCIsIGZ1bmN0aW9uIChncmFwaCwgZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIHZhciBBeGlzID0gcmVxdWlyZSgnLi9heGlzLmpzJyk7XG4gICAgICAgIHZhciB0aXRsZURlZmF1bHRzID0gZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcy50aXRsZSxcbiAgICAgICAgICAgIGF4aXMgICAgID0gdGhpcy5heGlzKCksXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24sXG4gICAgICAgICAgICBhbmNob3IgICA9IHRoaXMuYW5jaG9yLFxuICAgICAgICAgICAgcGxvdEJveCAgPSBncmFwaC5wbG90Qm94KCksXG4gICAgICAgICAgICBheGlzUGVycE9mZnNldCAgID0gYXhpcy5wZXJwT2Zmc2V0KCksXG4gICAgICAgICAgICBheGlzSXNIb3Jpem9udGFsID0gKGF4aXMub3JpZW50YXRpb24oKSA9PT0gQXhpcy5IT1JJWk9OVEFMKTtcblxuICAgICAgICB2YXIgZ2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWVPckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHZhbHVlT3JGdW5jdGlvbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZU9yRnVuY3Rpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlT3JGdW5jdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocG9zaXRpb24oKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXhpc0lzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGlmIChheGlzUGVycE9mZnNldCA+IHBsb3RCb3guaGVpZ2h0KCkvMikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiggZ2V0VmFsdWUodGl0bGVEZWZhdWx0c1tcInBvc2l0aW9uLWhvcml6b250YWwtdG9wXCJdKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKCBnZXRWYWx1ZSh0aXRsZURlZmF1bHRzW1wicG9zaXRpb24taG9yaXpvbnRhbC1ib3R0b21cIl0pICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1BlcnBPZmZzZXQgPiBwbG90Qm94LndpZHRoKCkvMikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiggZ2V0VmFsdWUodGl0bGVEZWZhdWx0c1tcInBvc2l0aW9uLXZlcnRpY2FsLXJpZ2h0XCJdKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKCBnZXRWYWx1ZSh0aXRsZURlZmF1bHRzW1wicG9zaXRpb24tdmVydGljYWwtbGVmdFwiXSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5jaG9yKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGF4aXNJc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1BlcnBPZmZzZXQgPiBwbG90Qm94LmhlaWdodCgpLzIpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yKCBnZXRWYWx1ZSh0aXRsZURlZmF1bHRzW1wiYW5jaG9yLWhvcml6b250YWwtdG9wXCJdKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciggZ2V0VmFsdWUodGl0bGVEZWZhdWx0c1tcImFuY2hvci1ob3Jpem9udGFsLWJvdHRvbVwiXSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChheGlzUGVycE9mZnNldCA+IHBsb3RCb3gud2lkdGgoKS8yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciggZ2V0VmFsdWUodGl0bGVEZWZhdWx0c1tcImFuY2hvci12ZXJ0aWNhbC1yaWdodFwiXSkgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbmNob3IoIGdldFZhbHVlKHRpdGxlRGVmYXVsdHNbXCJhbmNob3ItdmVydGljYWwtbGVmdFwiXSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBncmFwaGljc0NvbnRleHQuYW5nbGUgPSB0aGlzLmFuZ2xlKCk7XG4gICAgICAgIHRoaXMuY29udGVudCgpLmluaXRpYWxpemVHZW9tZXRyeShncmFwaGljc0NvbnRleHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgQXhpcyBUaXRsZS4gT3ZlcnJpZGRlbiBieSBpbXBsZW1lbnRhdGlvbnMgaW4gZ3JhcGhpY3MgZHJpdmVycy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uICgpIHt9KTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcy50aXRsZSwgYXR0cmlidXRlcyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlzVGl0bGU7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyAgICA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzICAgICAgID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMuYmFja2dyb3VuZCksXG4gICAgUkdCQ29sb3IgICAgICAgICA9IHJlcXVpcmUoJy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgSW1nICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vaW1nLmpzJyk7XG5cbnZhciBCYWNrZ3JvdW5kID0gbmV3IGplcm1haW5lLk1vZGVsKFwiQmFja2dyb3VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXNBKFwiY29sb3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yIGluc3RhbmNlb2YgUkdCQ29sb3I7XG4gICAgfSkuZGVmYXVsdHNUbyhSR0JDb2xvci5wYXJzZShkZWZhdWx0VmFsdWVzLmJhY2tncm91bmQuY29sb3IpKTtcbiAgICB0aGlzLmhhc0EoXCJpbWdcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgIHJldHVybiBpbWcgaW5zdGFuY2VvZiBJbWc7XG4gICAgfSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrZ3JvdW5kO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xudmFyIHZGID0gcmVxdWlyZSgnLi4vdXRpbC92YWxpZGF0aW9uRnVuY3Rpb25zLmpzJyk7XG5cbnZhciBDYXRlZ29yeUZvcm1hdHRlciA9IGZ1bmN0aW9uIChmb3JtYXRWYWx1ZXMpIHtcbiAgICBpZiAodkYudHlwZU9mKGZvcm1hdFZhbHVlcykgIT09IFwiYXJyYXlcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXRWYWx1ZXMgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSBmb3JtYXRWYWx1ZXM7XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heC5hcHBseSh0aGlzLCB0aGlzLmZvcm1hdFZhbHVlcy5tYXAoZnVuY3Rpb24ocykgeyByZXR1cm4gcy5sZW5ndGg7IH0pKTtcbn07XG5cbkNhdGVnb3J5Rm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgaSA9IE1hdGgucm91bmQodmFsdWUuZ2V0UmVhbFZhbHVlKCkpO1xuICAgIHZhciBrID0gdGhpcy5mb3JtYXRWYWx1ZXMubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdFZhbHVlc1soKGkgJSBrKSArIGspICUga107XG59O1xuXG5DYXRlZ29yeUZvcm1hdHRlci5wcm90b3R5cGUuZ2V0TWF4TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbkNhdGVnb3J5Rm9ybWF0dGVyLnByb3RvdHlwZS5nZXRGb3JtYXRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0VmFsdWVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXRlZ29yeUZvcm1hdHRlcjtcbiIsInZhciBDb25zZWN1dGl2ZURpc3RhbmNlRmlsdGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucHJldlB4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucHJldlB5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGF2ZVByZXYgPSBmYWxzZTtcbiAgICB0aGlzLmRpc3RhbmNlID0gKFwiZGlzdGFuY2VcIiBpbiBvcHRpb25zKSA/IG9wdGlvbnMuZGlzdGFuY2UgOiA1O1xufTtcblxuQ29uc2VjdXRpdmVEaXN0YW5jZUZpbHRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXZlUHJldiA9IGZhbHNlO1xufTtcblxuQ29uc2VjdXRpdmVEaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGRhdGFwLCBwaXhlbHApIHtcbiAgICB2YXIgZmlsdGVyT3V0ID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5oYXZlUHJldikge1xuICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHBpeGVscFswXSAtIHRoaXMucHJldlB4KTtcbiAgICAgICAgICB2YXIgZHkgPSBNYXRoLmFicyhwaXhlbHBbMV0gLSB0aGlzLnByZXZQeSk7XG4gICAgICAgICAgZmlsdGVyT3V0ID0gKGR4ICsgZHkgPCB0aGlzLmRpc3RhbmNlKTtcbiAgICAgICAgICBpZiAoIWZpbHRlck91dCkge1xuICAgICAgICAgICAgICB0aGlzLnByZXZQeCA9IHBpeGVscFswXTtcbiAgICAgICAgICAgICAgdGhpcy5wcmV2UHkgPSBwaXhlbHBbMV07XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByZXZQeCA9IHBpeGVscFswXTtcbiAgICAgICAgICB0aGlzLnByZXZQeSA9IHBpeGVscFsxXTtcbiAgICAgIH1cbiAgICB0aGlzLmhhdmVQcmV2ID0gdHJ1ZTtcbiAgICByZXR1cm4gZmlsdGVyT3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25zZWN1dGl2ZURpc3RhbmNlRmlsdGVyO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG5cbnZhciBDb25zdGFudFBsb3QgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJDb25zdGFudFBsb3RcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgICAgIGRlZmF1bHRWYWx1ZXMgICAgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgICAgIGF0dHJpYnV0ZXMgICAgICAgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90KSxcbiAgICAgICAgUGxvdCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vcGxvdC5qcycpLFxuICAgICAgICBEYXRhVmFsdWUgICAgICAgID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyk7XG5cbiAgICB0aGlzLmlzQShQbG90KTtcbiAgICB0aGlzLmhhc0EoXCJjb25zdGFudFZhbHVlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YVZhbHVlLmlzSW5zdGFuY2UpO1xuXG4gICAgdGhpcy5pc0J1aWx0V2l0aChcImNvbnN0YW50VmFsdWVcIik7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMucGxvdCwgYXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZW5kZXJcIiwgZnVuY3Rpb24gKGdyYXBoLCBncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgLy8gZ3JhcGhpY3NDb250ZXh0IGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHBhc3NlZCB0byBDb25zdGFudFBsb3QucmVuZGVyKCkgYnkgdGhlXG4gICAgICAgIC8vIGdyYXBoaWNzIGRyaXZlciwgYW5kIHVzZWQgYnkgdGhhdCBkcml2ZXIncyBpbXBsZW1lbnRhdGlvbiBvZiBSZW5kZXJlci5iZWdpbigpLlxuICAgICAgICAvLyBJdCBjYW4gYmUgYW55IG9iamVjdCB1c2VkIGJ5IHRoZSBkcml2ZXIgLS0gdXN1YWxseSBzb21lIGtpbmQgb2YgZ3JhcGhpY3NcbiAgICAgICAgLy8gY29udGV4dCBvYmplY3QuICBJdCBjYW4gYWxzbyBiZSBvbWl0dGVkIGlmIGEgZHJpdmVyIGRvZXMgbm90IG5lZWQgaXQuXG5cbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUoKSkgeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgaGF4aXMgPSB0aGlzLmhvcml6b250YWxheGlzKCksXG4gICAgICAgICAgICByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIoKSxcbiAgICAgICAgICAgIGNvbnN0YW50VmFsdWUgPSB0aGlzLmNvbnN0YW50VmFsdWUoKTtcblxuICAgICAgICBpZiAoIWhheGlzLmhhc0RhdGFNaW4oKSB8fCAhaGF4aXMuaGFzRGF0YU1heCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5zZXRVcE1pc3NpbmcoKTsgLy9UT0RPOiB0aGlzIGlzIGF3a3dhcmQgLS0gZmlndXJlIG91dCBhIGJldHRlciB3YXkhXG4gICAgICAgIHJlbmRlcmVyLmJlZ2luKGdyYXBoaWNzQ29udGV4dCk7XG4gICAgICAgIHJlbmRlcmVyLmRhdGFQb2ludChbIGhheGlzLmRhdGFNaW4oKSwgY29uc3RhbnRWYWx1ZSBdKTtcbiAgICAgICAgcmVuZGVyZXIuZGF0YVBvaW50KFsgaGF4aXMuZGF0YU1heCgpLCBjb25zdGFudFZhbHVlIF0pO1xuICAgICAgICByZW5kZXJlci5lbmQoKTtcblxuICAgIH0pO1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25zdGFudFBsb3Q7XG5cbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG52YXIgQ1NWRGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIGlmICh0eXBlb2YoQ1NWRGF0YSkgIT09IFwidW5kZWZpbmVkXCIpIHsgcmV0dXJuIENTVkRhdGE7IH1cblxuICAgIHZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKSxcbiAgICAgICAgQXJyYXlEYXRhID0gcmVxdWlyZSgnLi9hcnJheV9kYXRhLmpzJyk7XG5cbiAgICBDU1ZEYXRhID0gbmV3IGplcm1haW5lLk1vZGVsKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLmlzQShBcnJheURhdGEpO1xuICAgICAgICB0aGlzLmhhc0EoXCJmaWxlbmFtZVwiKS53aGljaC5pc0EoXCJzdHJpbmdcIik7XG4gICAgICAgIHRoaXMuaGFzQShcIm1lc3NhZ2VIYW5kbGVyXCIpO1xuICAgICAgICB0aGlzLmhhc0EoXCJhamF4dGhyb3R0bGVcIik7XG4gICAgICAgIHRoaXMuaGFzQShcImRhdGFJc1JlYWR5XCIpLndoaWNoLmlzQShcImJvb2xlYW5cIikuYW5kLmRlZmF1bHRzVG8oZmFsc2UpO1xuXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcImdldEl0ZXJhdG9yXCIsIGZ1bmN0aW9uIChjb2x1bW5JZHMsIG1pbiwgbWF4LCBidWZmZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFJc1JlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXlEYXRhLmdldEFycmF5RGF0YUl0ZXJhdG9yKHRoaXMsIGNvbHVtbklkcywgbWluLCBtYXgsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIFwibmV4dFwiICAgIDogZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgICAgICAgICAgIFwiaGFzTmV4dFwiIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJfZGlzcGxheUVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlcigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcigpLmVycm9yKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmlzQnVpbHRXaXRoKFwiY29sdW1uc1wiLCBcImZpbGVuYW1lXCIsIFwiJW1lc3NhZ2VIYW5kbGVyXCIsIFwiJWFqYXh0aHJvdHRsZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhamF4dGhyb3R0bGUgPSB0aGlzLmFqYXh0aHJvdHRsZSgpO1xuXG4gICAgICAgICAgICBpZiAoYWpheHRocm90dGxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhamF4dGhyb3R0bGUgPSAkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIoQXJyYXlEYXRhKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuXG4gICAgICAgICAgICBpZiAodGhhdC5maWxlbmFtZSgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmVtaXQoe3R5cGUgOiAnYWpheEV2ZW50JywgYWN0aW9uIDogJ3N0YXJ0J30pO1xuICAgICAgICAgICAgICAgIGFqYXh0aHJvdHRsZS5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsIDogdGhhdC5maWxlbmFtZSgpLFxuXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9wYXJzZSB0aGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFWYWx1ZXMgPSB0aGF0LmFkYXB0ZXIoKS50ZXh0VG9TdHJpbmdBcnJheSh0aGF0LmdldENvbHVtbnMoKSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnN0cmluZ0FycmF5KGRhdGFWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVub3JtYWxpemUgJiBwb3B1bGF0ZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hamF4Tm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRhdGFJc1JlYWR5KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5lbWl0KHt0eXBlIDogXCJkYXRhUmVhZHlcIn0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yIDogZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnJvclRocm93bjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqcVhIUi5zdGF0dXNDb2RlKCkuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJGaWxlIG5vdCBmb3VuZDogJ1wiICsgdGhhdC5maWxlbmFtZSgpICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHRleHRTdGF0dXMgKyBcIjogXCIgKyBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2Rpc3BsYXlFcnJvcihuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vICdjb21wbGV0ZScgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYWZ0ZXIgZWl0aGVyICdzdWNjZXNzJyBvciAnZXJyb3InLCB3aGljaGV2ZXI6XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlIDogZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmVtaXQoe3R5cGUgOiAnYWpheEV2ZW50JywgYWN0aW9uIDogJ2NvbXBsZXRlJ30pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ1NWRGF0YTtcbn07XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL2V2ZW50X2VtaXR0ZXIuanMnKSxcbiAgICBEYXRhVmFsdWUgPSByZXF1aXJlKCcuLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICBEYXRhVmFyaWFibGUgPSByZXF1aXJlKCcuL2RhdGFfdmFyaWFibGUuanMnKTtcblxudmFyIERhdGEgPSBuZXcgamVybWFpbmUuTW9kZWwoZnVuY3Rpb24gKCkge1xuICAgIFxuICAgIHRoaXMuaXNBKEV2ZW50RW1pdHRlcik7XG5cbiAgICB0aGlzLmhhc0FuKFwiaWRcIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuXG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhIGplcm1haW5lIGF0dHJfbGlzdCBvZiBEYXRhVmFyaWFibGVzIChjb2x1bW5zKSBmb3JcbiAgICAgKiBhbiBlbnRyeSBoYXZpbmcgYSBnaXZlbiBpZCBvciBjb2x1bW4gbnVtYmVyLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBmaW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ck5hbWUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBzZWFyY2ggb247XG4gICAgICogICAgIHNob3VsZCBiZSBlaXRoZXIgXCJpZFwiIG9yIFwiY29sdW1uXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SW50ZWdlcn0gYXR0clZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLiBJZiBhdHRyTmFtZVxuICAgICAqICAgICBpcyBcImlkXCIsIHRoaXMgdmFsdWUgc2hvdWxkIGJlIGEgc3RyaW5nLiAgSWYgYXR0ck5hbWUgaXMgXCJjb2x1bW5cIixcbiAgICAgKiAgICAgdGhpcyB2YWx1ZSBzaG91bGQgYmUgYW4gaW50LlxuICAgICAqIEBwYXJhbSB7RGF0YVZhcmlhYmxlIEF0dHJfTGlzdH0gY29sdW1ucyBUaGUgYXR0cl9saXN0IHRvIHNlYXJjaCB0aHJvdWdoLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtJbnRlZ2VyfSBUaGUgaW5kZXggKGFuIGludCkgb2YgdGhlIERhdGFWYXJpYWJsZSBlbnRyeSBoYXZpbmdcbiAgICAgKiAgICAgdGhlIGdpdmVuIGF0dHJpYnV0ZSB2YWx1ZSwgaWYgYW55LCBvciAtMSBpZiBub25lIHdhcyBmb3VuZFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgZmluZChcImlkXCIsIFwieFwiLCBjb2x1bW5zKVxuICAgICAqXG4gICAgICogICAgICAgICBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIERhdGFWYXJpYWJsZSBpbiB0aGUgY29sdW1ucyBhdHRyX2xpc3RcbiAgICAgKiAgICAgICAgIGhhdmluZyBhbiBpZCBvZiBcInhcIlxuICAgICAqXG4gICAgICogICAgIGZpbmQoXCJjb2x1bW5cIiwgMSwgY29sdW1ucylcbiAgICAgKlxuICAgICAqICAgICAgICAgZmluZHMgdGhlIGluZGV4IG9mIHRoZSBEYXRhVmFyaWFibGUgaW4gdGhlIGNvbHVtbnMgYXR0cl9saXN0XG4gICAgICogICAgICAgICBoYXZpbmcgYSBcImNvbHVtblwiIGF0dHJpYnV0ZSBvZiAxXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIGF0dHJWYWx1ZSwgY29sdW1ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gLTEsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNvbHVtbnMuYXQoaSlbYXR0ck5hbWVdKCkgPT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBgZGF0YWAgYXR0cmlidXRlIG9mIGVhY2ggb2YgdGhpcyBkYXRhIG9iamVjdCdzIGNvbHVtbnNcbiAgICAgKiB0byBwb2ludCB0byB0aGUgZGF0YSBvYmplY3QgaXRzZWxmLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbml0aWFsaXplQ29sdW1uc1xuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJpbml0aWFsaXplQ29sdW1uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zKCkuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucygpLmF0KGkpLmRhdGEodGhpcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaGFzTWFueShcImNvbHVtbnNcIikuZWFjaE9mV2hpY2gudmFsaWRhdGVXaXRoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJEYXRhOiBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIGFycmF5IG9mIERhdGFWYXJpYWJsZSBvYmplY3RzXCI7XG4gICAgICAgIHJldHVybiBjb2x1bW4gaW5zdGFuY2VvZiBEYXRhVmFyaWFibGU7XG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc0EoXCJkZWZhdWx0TWlzc2luZ3ZhbHVlXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKTtcbiAgICB0aGlzLmhhc0EoXCJkZWZhdWx0TWlzc2luZ29wXCIpLndoaWNoLmlzQShcInN0cmluZ1wiKS5hbmQuZGVmYXVsdHNUbyhcImVxXCIpO1xuICAgIHRoaXMuaGFzQW4oXCJhZGFwdGVyXCIpO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6YXRpb24gZnVuY3Rpb24gLS0tIHNob3VsZCBiZSBjYWxsZWQgZnJvbSBpc0J1aWx0V2l0aCBpbml0aWFsaXplci4gIFRoaXMgaXMgc3BsaXRcbiAgICAgKiBvZmYgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBmcm9tIHN1Ym1vZGVsJ3MgaXNCdWlsdFdpdGggaW5pdGlhbGl6ZXJzXG4gICAgICogYXMgd2VsbCwgc2luY2UgSmVybWFpbmUgZG9lcyBub3QgcHJvdmlkZSBhIHdheSB0byBjYWxsIHRoZSBwYXJlbnQgbW9kZWxzJyBpc0J1aWx0V2l0aCBpbml0aWFsaXplclxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbml0XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImluaXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbHVtbnMoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJjb2x1bW5zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJjb2x1bW5JZFRvQ29sdW1uTnVtYmVyXCIsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAodHlwZW9mKGlkKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YTogY29sdW1uSWRUb0NvbHVtbk51bWJlciBleHBlY3RzIHBhcmFtZXRlciB0byBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2x1bW5JbmRleCA9IGZpbmQoXCJpZFwiLCBpZCwgdGhpcy5jb2x1bW5zKCkpLFxuICAgICAgICAgICAgY29sdW1uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSB0aGlzLmNvbHVtbnMoKS5hdChjb2x1bW5JbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGE6IG5vIGNvbHVtbiB3aXRoIHRoZSBsYWJlbCBcIiArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5jb2x1bW4oKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImNvbHVtbklkVG9EYXRhVmFyaWFibGVcIiwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICh0eXBlb2YoaWQpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhOiBjb2x1bW5JZFRvRGF0YVZhcmlhYmxlIHJlcXVpcmVzIGEgc3RyaW5nIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoKSxcbiAgICAgICAgICAgIGR2ID0gZmluZChcImlkXCIsIGlkLCBjb2x1bW5zKSAhPT0gLTEgPyBjb2x1bW5zLmF0KGZpbmQoXCJpZFwiLCBpZCwgY29sdW1ucykpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChkdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhOiBubyBjb2x1bW4gd2l0aCB0aGUgbGFiZWwgXCIgKyBpZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZHY7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJnZXRDb2x1bW5JZFwiLCBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIGlmICh0eXBlb2YoY29sdW1uKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YTogZ2V0Q29sdW1uSWQgbWV0aG9kIGV4cGVjdHMgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBmaW5kKFwiY29sdW1uXCIsIGNvbHVtbiwgdGhpcy5jb2x1bW5zKCkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhOiBjb2x1bW4gXCIgKyBjb2x1bW4gKyBcIiBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1ucygpLmF0KHJlc3VsdCkuaWQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImdldENvbHVtbnNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBjb2x1bW5zID0gdGhpcy5jb2x1bW5zKCksXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2x1bW5zLmF0KGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJnZXRCb3VuZHNcIiwgZnVuY3Rpb24gKGNvbHVtbk51bWJlcikge1xuICAgICAgICAvLyBzdWJtb2RlbHMgbXVzdCBpbXBsZW1lbnQgdGhpc1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZ2V0SXRlcmF0b3JcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBzdWJtb2RlbHMgbXVzdCBpbXBsZW1lbnQgdGhpc1xuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiBUaGUgXCJvblJlYWR5XCIgY29udHJhY3Q6XG4gICAgICogXG4gICAgICogRWFjaCBzdWJtb2RlbCBvZiB0aGlzIERhdGEgbW9kZWwgc2hvdWxkIGRvIHRoZSBmb2xsb3dpbmc6XG4gICAgICogXG4gICAgICogMS4gRW1pdCBhbiBcIm9uUmVhZHlcIiBldmVudCB3aGVuZXZlciBuZXcgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICogICAgVGhlIGFyZ3VtZW50cyB0byB0aGUgZXZlbnQgbGlzdGVuZXIgYXJlIHRoZSBtaW4gYW5kIG1heFxuICAgICAqICAgIHZhbHVlcyBvZiB0aGUgcmFuZ2Ugb2YgKG5ld2x5KSBhdmFpbGFibGUgZGF0YS5cbiAgICAgKiBcbiAgICAgKiAyLiBPcHRpb25hbGx5LCByZWdpc3RlciBhIGxpc3RlbmVyIGZvciBpdHMgb3duIFwibGlzdGVuZXJBZGRlZFwiXG4gICAgICogICAgZXZlbnRzLCB3aGljaCBwZXJmb3JtcyB3aGF0ZXZlciBhY3Rpb25zIGFyZSBuZWVkZWQsIGlmIGFueSxcbiAgICAgKiAgICB3aGVuIGEgbmV3IFwib25SZWFkeVwiIGxpc3RlbmVyIGlzIHJlZ2lzdGVyZWQuXG4gICAgICovXG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJwYXVzZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9ubyBvcFxuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInJlc3VtZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9ubyBvcFxuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaXNNaXNzaW5nXCIsIGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlIERhdGFWYWx1ZSBcInZhbHVlXCIgbWVldHMgdGhlIFwibWlzc2luZ1wiIGNyaXRlcmlhIG9mXG4gICAgICAgIC8vIHRoZSBpLXRoIGNvbHVtblxuICAgICAgICB2YXIgY29sdW1uO1xuICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmNvbHVtbnMoKS5zaXplKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGFkYXRhLmlzTWlzc2luZygpOiBpbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29sdW1uID0gdGhpcy5jb2x1bW5zKCkuYXQoaSk7XG4gICAgICAgIGlmICghY29sdW1uLm1pc3Npbmd2YWx1ZSgpIHx8ICFjb2x1bW4ubWlzc2luZ29wKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVbY29sdW1uLm1pc3NpbmdvcCgpXShjb2x1bW4ubWlzc2luZ3ZhbHVlKCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU29ydHMgdmFyaWFibGVzIGludG8gYXBwcm9wcmlhdGUgb3JkZXJcbiAgICB2YXIgc29ydFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChkYXRhLCBzb3J0ZWRWYXJpYWJsZXMsIHVuc29ydGVkVmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gZGF0YS5jb2x1bW5zKCksXG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgY29sdW1uID0gY29sdW1ucy5hdChpKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uY29sdW1uKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNvcnRlZFZhcmlhYmxlc1tjb2x1bW4uY29sdW1uKCldID0gY29sdW1uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bnNvcnRlZFZhcmlhYmxlcy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY3JlYXRlcyBwbGFjZWhvbGRlciB2YXJpYWJsZXNcbiAgICB2YXIgY3JlYXRlUGxhY2Vob2xkZXJWYXJpYWJsZXMgPSBmdW5jdGlvbiAoZGF0YSwgdW5zb3J0ZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIG51bU1pc3NpbmdWYXJpYWJsZXMgPSBkYXRhLnN0cmluZ0FycmF5KClbMF0ubGVuZ3RoIC0gZGF0YS5jb2x1bW5zKCkuc2l6ZSgpLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgaWYgKG51bU1pc3NpbmdWYXJpYWJsZXMgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtTWlzc2luZ1ZhcmlhYmxlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdW5zb3J0ZWRWYXJpYWJsZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBpbnNlcnRzIHVuc29ydGVkIHZhcmlhYmxlcyBpbnRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uXG4gICAgdmFyIGluc2VydFVuc29ydGVkVmFyaWFibGVzID0gZnVuY3Rpb24gKHNvcnRlZFZhcmlhYmxlcywgdW5zb3J0ZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIGluZGV4LCBpO1xuICAgICAgICBmb3IgKGkgPSAwLCBpbmRleCA9IDA7IGkgPCB1bnNvcnRlZFZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkVmFyaWFibGVzW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ydGVkVmFyaWFibGVzW2luZGV4XSA9IHVuc29ydGVkVmFyaWFibGVzW2ldO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGNoZWNrcyB0aGF0IGNvbHVtbnMgd2VyZSBjb3JyZWN0bHkgc3BlY2lmaWVkXG4gICAgdmFyIGNoZWNrQ29sdW1uSW5kaWNpZXMgPSBmdW5jdGlvbiAoZGF0YSwgc29ydGVkVmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhLnN0cmluZ0FycmF5KClbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgaWYgKHNvcnRlZFZhcmlhYmxlcy5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3J0ZWRWYXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkVmFyaWFibGVzW2ldIGluc3RhbmNlb2YgRGF0YVZhcmlhYmxlICYmIHNvcnRlZFZhcmlhYmxlc1tpXS5jb2x1bW4oKSA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFZhcmlhYmxlIEVycm9yOiBBdHRlbXB0aW5nIHRvIHNwZWNpZnkgY29sdW1uICdcIiArIHNvcnRlZFZhcmlhYmxlc1tpXS5jb2x1bW4oKSArIFwiJyBmb3IgYSB2YXJpYWJsZSwgd2hpbGUgdGhlcmUgYXJlIG9ubHkgXCIgKyBsZW5ndGggKyBcIiBkYXRhIGNvbHVtbnMgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZXMgbWlzc2luZyBhdHRyaWJ1dGVzXG4gICAgLy8gY3JlYXRlcyB0aGUgYXBwcm9wcmlhdGUgdmFyaWFibGVzIGlmIG1pc3NpbmdcbiAgICB2YXIgaGFuZGxlTWlzc2luZ0F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc29ydGVkVmFyaWFibGVzLCBkZWZhdWx0TWlzc2luZ29wLCBkZWZhdWx0TWlzc2luZ3ZhbHVlKSB7XG4gICAgICAgIHZhciBkZWZhdWx0aWQsXG4gICAgICAgICAgICBpO1xuICAgICAgICBkZWZhdWx0TWlzc2luZ29wID0gRGF0YVZhbHVlLnBhcnNlQ29tcGFyYXRvcihkZWZhdWx0TWlzc2luZ29wKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvcnRlZFZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFzb3J0ZWRWYXJpYWJsZXNbaV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0aWQgPSBcInhcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdGlkID0gXCJ5XCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdGlkID0gXCJ5XCIgKyAoaS0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc29ydGVkVmFyaWFibGVzW2ldID0gbmV3IERhdGFWYXJpYWJsZShkZWZhdWx0aWQsIGksIERhdGFWYWx1ZS5OVU1CRVIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkVmFyaWFibGVzW2ldLmNvbHVtbigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVmFyaWFibGVzW2ldLmNvbHVtbihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZFZhcmlhYmxlc1tpXS50eXBlKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRWYXJpYWJsZXNbaV0udHlwZShEYXRhVmFsdWUuTlVNQkVSKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZWZhdWx0TWlzc2luZ3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkVmFyaWFibGVzW2ldLm1pc3Npbmd2YWx1ZSgpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVmFyaWFibGVzW2ldLm1pc3Npbmd2YWx1ZShEYXRhVmFsdWUucGFyc2Uoc29ydGVkVmFyaWFibGVzW2ldLnR5cGUoKSwgZGVmYXVsdE1pc3Npbmd2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3J0ZWRWYXJpYWJsZXNbaV0ubWlzc2luZ29wKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNvcnRlZFZhcmlhYmxlc1tpXS5taXNzaW5nb3AoZGVmYXVsdE1pc3NpbmdvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW5zZXJ0cyB0aGUgbm9ybWFsaXplZCB2YXJpYWJsZXMgaW50byB0aGUgZGF0YSBpbnN0YW5jZVxuICAgIHZhciBpbnNlcnROb3JtYWxpemVkVmFyaWFibGVzID0gZnVuY3Rpb24gKGRhdGEsIHNvcnRlZFZhcmlhYmxlcykge1xuICAgICAgICB2YXIgY29sdW1ucyA9IGRhdGEuY29sdW1ucygpLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgd2hpbGUgKGNvbHVtbnMuc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgY29sdW1ucy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkVmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmFkZChzb3J0ZWRWYXJpYWJsZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuaW5pdGlhbGl6ZUNvbHVtbnMoKTtcbiAgICB9O1xuXG5cbiAgICAvLyBwYXJzZXMgc3RyaW5nIHZhbHVlcyBpbnRvIHRoZSBwcm9wZXIgZGF0YSB0eXBlc1xuICAgIC8vIElmIHRoZXJlIHdhcyBhY3R1YWwgZGF0YSwgdmFsaWRhdGUgdGhhdCB0aGUgbnVtYmVyIG9mIHZhbHVlcyBmb3VuZCBpbiBzdHJpbmdBcnJheVxuICAgIC8vIGFzIGxhcmdlIGFzIHRoZSB0aGUgbnVtYmVyIG9mIHZhcmlhYmxlcyBkZWNsYXJlZC4gIEFycmF5RGF0YS50ZXh0VG9TdHJpbmdBcnJheSgpLFxuICAgIC8vIHdoaWNoIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGNvbnN0cnVjdGVkIHN0cmluZ0FycmF5LCBoYXMgYWxyZWFkeSBndWFyYW50ZWVkIHRoYXRcbiAgICAvLyBldmVyeSByb3cgaW4gc3RyaW5nQXJyYXkgaXMgb2YgdGhlIHNhbWUgbGVuZ3RoLCBzbyB3ZSBjYW4gdXNlIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgLy8gZmlyc3Qgcm93IGFzIHRoZSBudW1iZXIgb2YgdmFyaWFibGVzLlxuICAgIHZhciBjcmVhdGVEYXRhVmFsdWVBcnJheSA9IGZ1bmN0aW9uIChkYXRhLCBzb3J0ZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIEFycmF5RGF0YSA9IHJlcXVpcmUoJy4vYXJyYXlfZGF0YS5qcycpO1xuICAgICAgICB2YXIgc3RyaW5nQXJyYXkgPSBkYXRhLnN0cmluZ0FycmF5KCk7XG4gICAgICAgIGlmIChzdHJpbmdBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoc3RyaW5nQXJyYXlbMF0ubGVuZ3RoIDwgc29ydGVkVmFyaWFibGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgY29udGFpbnMgb25seSBcIiArIHN0cmluZ0FycmF5WzBdLmxlbmd0aCArIFwiIGNvbHVtbihzKSwgYnV0IHNob3VsZCBjb250YWluIFwiICsgc29ydGVkVmFyaWFibGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YVZhbHVlcyA9IEFycmF5RGF0YS5zdHJpbmdBcnJheVRvRGF0YVZhbHVlc0FycmF5KHNvcnRlZFZhcmlhYmxlcywgc3RyaW5nQXJyYXkpO1xuXG4gICAgICAgIGRhdGEuYXJyYXkoZGF0YVZhbHVlcyk7XG4gICAgICAgIGRhdGEuc3RyaW5nQXJyYXkoW10pO1xuICAgIH07XG5cbiAgICB0aGlzLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBBcnJheURhdGEgPSByZXF1aXJlKCcuL2FycmF5X2RhdGEuanMnKSxcbiAgICAgICAgICAgIHNvcnRlZFZhcmlhYmxlcyAgID0gW10sXG4gICAgICAgICAgICB1bnNvcnRlZFZhcmlhYmxlcyA9IFtdLFxuICAgICAgICAgICAgLy8gIG1icCBUdWUgTWFyICAzIDEwOjUxOjQwIDIwMTU6XG4gICAgICAgICAgICAvLyAgICBhdm9pZCByZXF1aXJpbmcgd2ViX3NlcnZpY2VfZGF0YS5qcyBhbmQgY3N2X2RhdGEuanMgaGVyZSBiZWNhdXNlIHRoZXkgaGF2ZVxuICAgICAgICAgICAgLy8gICAgYSBkZXBlbmRlbmN5IG9uIGpRdWVyeTsgYWxzbyBhdm9pZCBpbnN0YW5jZW9mXG4gICAgICAgICAgICAvL0NTVkRhdGEgPSByZXF1aXJlKCcuL2Nzdl9kYXRhLmpzJyksXG4gICAgICAgICAgICAvL1dlYlNlcnZpY2VEYXRhID0gcmVxdWlyZSgnLi93ZWJfc2VydmljZV9kYXRhLmpzJyksXG4gICAgICAgICAgICAvL2lzQ3N2T3JXZWJTZXJ2aWNlID0gdGhpcyBpbnN0YW5jZW9mIENTVkRhdGEgfHwgdGhpcyBpbnN0YW5jZW9mIFdlYlNlcnZpY2VEYXRhLFxuICAgICAgICAgICAgaXNXZWJTZXJ2aWNlRGF0YSA9ICh0eXBlb2YodGhpcy5zZXJ2aWNlYWRkcmVzcykgPT09IFwiZnVuY3Rpb25cIiksXG4gICAgICAgICAgICBpc0NTVkRhdGEgPSAodHlwZW9mKHRoaXMuZmlsZW5hbWUpID09PSBcImZ1bmN0aW9uXCIpLFxuICAgICAgICAgICAgaXNDc3ZPcldlYlNlcnZpY2UgPSBpc1dlYlNlcnZpY2VEYXRhIHx8IGlzQ1NWRGF0YTtcblxuICAgICAgICAvLyBIYW5kbGVzIG1pc3NpbmcgdmFyaWFibGUgdGFncyBpZiB0aGUgZGF0YSB0YWcgaGFzIGEgJ2Nzdicgb3IgJ3NlcnZpY2UnIHRhZ1xuICAgICAgICBpZiAoaXNDc3ZPcldlYlNlcnZpY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbnMoKS5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIE5vcm1hbGl6YXRpb246IERhdGEgZ290dGVuIGZyb20gY3N2IGFuZCB3ZWIgc2VydmljZSBzb3VyY2VzIHJlcXVpcmUgdmFyaWFibGVzIHRvIGJlIHNwZWNpZmllZCBpbiB0aGUgbXVnbC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzb3J0VmFyaWFibGVzKHRoaXMsIHNvcnRlZFZhcmlhYmxlcywgdW5zb3J0ZWRWYXJpYWJsZXMpO1xuXG4gICAgICAgIC8vIGNyZWF0ZXMgcGxhY2Vob2xkZXIgdmFyaWFibGVzIGlmIHRoZSBkYXRhIHRhZyBoYXMgYSAndmFsdWVzJyB0YWdcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBBcnJheURhdGEgPT09IHRydWUgJiYgIWlzQ3N2T3JXZWJTZXJ2aWNlKSB7XG4gICAgICAgICAgICBjcmVhdGVQbGFjZWhvbGRlclZhcmlhYmxlcyh0aGlzLCB1bnNvcnRlZFZhcmlhYmxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnNlcnRVbnNvcnRlZFZhcmlhYmxlcyhzb3J0ZWRWYXJpYWJsZXMsIHVuc29ydGVkVmFyaWFibGVzKTtcblxuICAgICAgICAvLyBjaGVja3MgdGhhdCBjb2x1bW5zIHdlcmUgY29ycmVjdGx5IHNwZWNpZmllZCBmb3IgJ3ZhbHVlcycgZGF0YSB0YWdzXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQXJyYXlEYXRhID09PSB0cnVlICYmICFpc0Nzdk9yV2ViU2VydmljZSkge1xuICAgICAgICAgICAgY2hlY2tDb2x1bW5JbmRpY2llcyh0aGlzLCBzb3J0ZWRWYXJpYWJsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlTWlzc2luZ0F0dHJpYnV0ZXMoc29ydGVkVmFyaWFibGVzLCB0aGlzLmRlZmF1bHRNaXNzaW5nb3AoKSwgdGhpcy5kZWZhdWx0TWlzc2luZ3ZhbHVlKCkpO1xuICAgICAgICBpbnNlcnROb3JtYWxpemVkVmFyaWFibGVzKHRoaXMsIHNvcnRlZFZhcmlhYmxlcyk7XG5cbiAgICAgICAgLy8gcGFyc2VzIHN0cmluZyB2YWx1ZXMgaW50byB0aGUgcHJvcGVyIGRhdGEgdHlwZXMgaWYgdGhlIGRhdGEgdGFnIGhhcyBhICd2YWx1ZXMnIHRhZ1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEFycmF5RGF0YSA9PT0gdHJ1ZSAmJiAhaXNDc3ZPcldlYlNlcnZpY2UpIHtcbiAgICAgICAgICAgIGNyZWF0ZURhdGFWYWx1ZUFycmF5KHRoaXMsIHNvcnRlZFZhcmlhYmxlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wcm90b3R5cGUuYWpheE5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNvcnRlZFZhcmlhYmxlcyAgID0gW10sXG4gICAgICAgICAgICB1bnNvcnRlZFZhcmlhYmxlcyA9IFtdO1xuXG4gICAgICAgIHNvcnRWYXJpYWJsZXModGhpcywgc29ydGVkVmFyaWFibGVzLCB1bnNvcnRlZFZhcmlhYmxlcyk7XG4gICAgICAgIGNyZWF0ZVBsYWNlaG9sZGVyVmFyaWFibGVzKHRoaXMsIHVuc29ydGVkVmFyaWFibGVzKTtcbiAgICAgICAgaW5zZXJ0VW5zb3J0ZWRWYXJpYWJsZXMoc29ydGVkVmFyaWFibGVzLCB1bnNvcnRlZFZhcmlhYmxlcyk7XG4gICAgICAgIGNoZWNrQ29sdW1uSW5kaWNpZXModGhpcywgc29ydGVkVmFyaWFibGVzKTtcbiAgICAgICAgaGFuZGxlTWlzc2luZ0F0dHJpYnV0ZXMoc29ydGVkVmFyaWFibGVzLCB0aGlzLmRlZmF1bHRNaXNzaW5nb3AoKSwgdGhpcy5kZWZhdWx0TWlzc2luZ3ZhbHVlKCkpO1xuICAgICAgICBpbnNlcnROb3JtYWxpemVkVmFyaWFibGVzKHRoaXMsIHNvcnRlZFZhcmlhYmxlcyk7XG4gICAgICAgIGNyZWF0ZURhdGFWYWx1ZUFycmF5KHRoaXMsIHNvcnRlZFZhcmlhYmxlcyk7XG4gICAgfTtcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YTtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpLFxuICAgIE51bWJlckZvcm1hdHRlciA9IHJlcXVpcmUoJy4vbnVtYmVyX2Zvcm1hdHRlci5qcycpLFxuICAgIERhdGV0aW1lRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9kYXRldGltZV9mb3JtYXR0ZXIuanMnKTtcblxudmFyIERhdGFGb3JtYXR0ZXIgPSB7fTtcbi8qXG4gKiBSZXR1cm4gdHJ1ZSBvciBmYWxzZSBkZXBlbmRpbmcgb24gd2hldGhlciBvYmogaXMgYW4gaW5zdGFuY2Ugb2YgYSBEYXRhRm9ybWF0dGVyIHR5cGVcbiAqL1xuRGF0YUZvcm1hdHRlci5pc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiAob2JqICYmICh0eXBlb2Yob2JqLmZvcm1hdCkgPT09IFwiZnVuY3Rpb25cIikgJiYgKHR5cGVvZihvYmouZ2V0TWF4TGVuZ3RoKSA9PT0gXCJmdW5jdGlvblwiKSk7XG59O1xuXG4vKlxuICogQ3JlYXRlIGEgbmV3IERhdGFGb3JtYXR0ZXIgc3VidHlwZSBvZiBhIGdpdmVuIHR5cGVcbiAqL1xuRGF0YUZvcm1hdHRlci5jcmVhdGUgPSBmdW5jdGlvbiAodHlwZSwgZm9ybWF0KSB7XG4gICAgaWYgKHR5cGUgPT09IERhdGFWYWx1ZS5OVU1CRVIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJGb3JtYXR0ZXIoZm9ybWF0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IERhdGFWYWx1ZS5EQVRFVElNRSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGV0aW1lRm9ybWF0dGVyKGZvcm1hdCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImF0dGVtcHQgdG8gY3JlYXRlIGFuIHVua25vd24gRGF0YUZvcm1hdHRlciB0eXBlXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhRm9ybWF0dGVyO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyksXG4gICAgTnVtYmVyTWVhc3VyZSA9IHJlcXVpcmUoJy4vbnVtYmVyX21lYXN1cmUuanMnKSxcbiAgICBEYXRldGltZU1lYXN1cmUgPSByZXF1aXJlKCcuL2RhdGV0aW1lX21lYXN1cmUuanMnKTtcblxudmFyIERhdGFNZWFzdXJlID0ge307XG5cbi8qXG4gKiBSZXR1cm4gdHJ1ZSBvciBmYWxzZSBkZXBlbmRpbmcgb24gd2hldGhlciBvYmogaXMgYW4gaW5zdGFuY2Ugb2YgYSBEYXRhTWVhc3VyZSB0eXBlXG4gKi9cbkRhdGFNZWFzdXJlLmlzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIChvYmogJiYgKHR5cGVvZihvYmouZ2V0UmVhbFZhbHVlKSA9PT0gXCJmdW5jdGlvblwiKSAmJiAoIW9iai5jb21wYXJlVG8pKTtcbn07XG5cbi8qXG4gKiBDcmVhdGUgYSBuZXcgRGF0YU1lYXN1cmUgc3VidHlwZSBvZiBhIGdpdmVuIHR5cGUgYnkgcGFyc2luZyBhIHN0cmluZ1xuICovXG5EYXRhTWVhc3VyZS5wYXJzZSA9IGZ1bmN0aW9uICh0eXBlLCBzdHJpbmcpIHtcbiAgICBpZiAodHlwZSA9PT0gRGF0YVZhbHVlLk5VTUJFUikge1xuICAgICAgICByZXR1cm4gTnVtYmVyTWVhc3VyZS5wYXJzZShzdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gRGF0YVZhbHVlLkRBVEVUSU1FKSB7XG4gICAgICAgIHJldHVybiBEYXRldGltZU1lYXN1cmUucGFyc2Uoc3RyaW5nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdCB0byBwYXJzZSBhbiB1bmtub3duIERhdGFNZWFzdXJlIHR5cGVcIik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFNZWFzdXJlO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgUGxvdCA9IHJlcXVpcmUoJy4vcGxvdC5qcycpLFxuICAgIERhdGFWYXJpYWJsZSA9IHJlcXVpcmUoJy4vZGF0YV92YXJpYWJsZS5qcycpLFxuICAgIEZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyLmpzJyksXG4gICAgRGF0YXRpcHMgPSByZXF1aXJlKCcuL2RhdGF0aXBzLmpzJyksXG4gICAgRGF0YSA9IHJlcXVpcmUoJy4vZGF0YS5qcycpLFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90KTtcblxudmFyIGdyYXBoQ29vcmRzVG9QaXhlbENvb3JkcyA9IGZ1bmN0aW9uIChncmFwaENvb3JkcywgZ3JhcGgsIGhlaWdodCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGdyYXBoQ29vcmRzWzBdICsgZ3JhcGgueDAoKSxcbiAgICAgICAgaGVpZ2h0IC0gKGdyYXBoQ29vcmRzWzFdICsgZ3JhcGgueTAoKSlcbiAgICBdO1xufTtcblxudmFyIERhdGFQbG90ID0gbmV3IGplcm1haW5lLk1vZGVsKFwiRGF0YVBsb3RcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFBsb3QpO1xuICAgIHRoaXMuaGFzTWFueShcInZhcmlhYmxlXCIpLmVhY2hPZldoaWNoLnZhbGlkYXRlV2l0aChmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlIGluc3RhbmNlb2YgRGF0YVZhcmlhYmxlIHx8IHZhcmlhYmxlID09PSBudWxsO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImZpbHRlclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlciBpbnN0YW5jZW9mIEZpbHRlcjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJkYXRhdGlwc1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChkYXRhdGlwcykge1xuICAgICAgICByZXR1cm4gZGF0YXRpcHMgaW5zdGFuY2VvZiBEYXRhdGlwcztcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJkYXRhXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBEYXRhO1xuICAgIH0pO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLnBsb3QsIGF0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uIChncmFwaCwgZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIC8vIGdyYXBoaWNzQ29udGV4dCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCBwYXNzZWQgdG8gRGF0YVBsb3QucmVuZGVyKCkgYnkgdGhlXG4gICAgICAgIC8vIGdyYXBoaWNzIGRyaXZlciwgYW5kIHVzZWQgYnkgdGhhdCBkcml2ZXIncyBpbXBsZW1lbnRhdGlvbiBvZiBSZW5kZXJlci5iZWdpbigpLlxuICAgICAgICAvLyBJdCBjYW4gYmUgYW55IG9iamVjdGRlZCBieSB0aGUgZHJpdmVyIC0tIHVzdWFsbHkgc29tZSBraW5kIG9mIGdyYXBoaWNzXG4gICAgICAgIC8vIGNvbnRleHQgb2JqZWN0LiAgSXQgY2FuIGFsc28gYmUgb21pdHRlZCBpZiBhIGRyaXZlciBkb2VzIG5vdCBuZWVkIGl0LlxuICAgICAgICAvL3ZhciBkYXRhID0gdGhpcy5kYXRhKCkuYXJyYXlkYXRhKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUoKSkgeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSgpO1xuICAgICAgICBpZiAoISBkYXRhKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBoYXhpcyA9IHRoaXMuaG9yaXpvbnRhbGF4aXMoKSxcbiAgICAgICAgICAgIHZheGlzID0gdGhpcy52ZXJ0aWNhbGF4aXMoKTtcblxuICAgICAgICBpZiAoIWhheGlzLmhhc0RhdGFNaW4oKSB8fCAhaGF4aXMuaGFzRGF0YU1heCgpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIHBsb3QncyBob3Jpem9udGFsIGF4aXMgZG9lcyBub3QgaGF2ZSBhIG1pbiBvciBtYXggdmFsdWUgeWV0LFxuICAgICAgICAgICAgLy8gcmV0dXJuIGltbWVkaWF0ZWx5IHdpdGhvdXQgZG9pbmcgYW55dGhpbmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YXJpYWJsZXMgICA9IHRoaXMudmFyaWFibGUoKSxcbiAgICAgICAgICAgIHZhcmlhYmxlSWRzID0gW10sXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFyaWFibGVzLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICB2YXJpYWJsZUlkcy5wdXNoKCB2YXJpYWJsZXMuYXQoaSkuaWQoKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXIgPSBkYXRhLmdldEl0ZXJhdG9yKHZhcmlhYmxlSWRzLCBoYXhpcy5kYXRhTWluKCksIGhheGlzLmRhdGFNYXgoKSwgMSksXG4gICAgICAgICAgICByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIoKTtcblxuICAgICAgICByZW5kZXJlci5zZXRVcE1pc3NpbmcoKTsgLy9UT0RPOiB0aGlzIGlzIGF3a3dhcmQgLS0gZmlndXJlIG91dCBhIGJldHRlciB3YXkhXG4gICAgICAgIHJlbmRlcmVyLmJlZ2luKGdyYXBoaWNzQ29udGV4dCk7XG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgdmFyIGRhdGFwID0gaXRlci5uZXh0KCk7XG4gICAgICAgICAgICByZW5kZXJlci5kYXRhUG9pbnQoZGF0YXApO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLmVuZCgpO1xuXG4gICAgfSk7XG5cblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImdldERhdGF0aXBzRGF0YVwiLCBmdW5jdGlvbiAobG9jLCBncmFwaFdpZHRoLCBncmFwaEhlaWdodCwgZ3JhcGgsIHRlc3RFbGVtKSB7XG4gICAgICAgIHZhciBkYXRhdGlwcyA9IHRoaXMuZGF0YXRpcHMoKTtcbiAgICAgICAgaWYgKCFkYXRhdGlwcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEoKTtcblxuICAgICAgICBpZiAoIWRhdGEpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIGhheGlzID0gdGhpcy5ob3Jpem9udGFsYXhpcygpLFxuICAgICAgICAgICAgdmF4aXMgPSB0aGlzLnZlcnRpY2FsYXhpcygpO1xuXG4gICAgICAgIGlmICghaGF4aXMuaGFzRGF0YU1pbigpIHx8ICFoYXhpcy5oYXNEYXRhTWF4KCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgcGxvdCdzIGhvcml6b250YWwgYXhpcyBkb2VzIG5vdCBoYXZlIGEgbWluIG9yIG1heCB2YWx1ZSB5ZXQsXG4gICAgICAgICAgICAvLyByZXR1cm4gaW1tZWRpYXRlbHkgd2l0aG91dCBkb2luZyBhbnl0aGluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhcmlhYmxlcyAgID0gdGhpcy52YXJpYWJsZSgpLFxuICAgICAgICAgICAgdmFyaWFibGVJZHMgPSBbXSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhcmlhYmxlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgdmFyaWFibGVJZHMucHVzaCggdmFyaWFibGVzLmF0KGkpLmlkKCkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyICAgICAgICA9IGRhdGEuZ2V0SXRlcmF0b3IodmFyaWFibGVJZHMsIGhheGlzLmRhdGFNaW4oKSwgaGF4aXMuZGF0YU1heCgpLCAxKSxcbiAgICAgICAgICAgIHJlbmRlcmVyICAgID0gdGhpcy5yZW5kZXJlcigpLFxuICAgICAgICAgICAgcG9pbnRzICAgICAgPSBbXSxcbiAgICAgICAgICAgIHggICAgICAgICAgID0gbG9jLngoKSxcbiAgICAgICAgICAgIHkgICAgICAgICAgID0gbG9jLnkoKSxcbiAgICAgICAgICAgIG1heERpc3RhbmNlID0gMjAsXG4gICAgICAgICAgICBjdXJEaXN0LFxuICAgICAgICAgICAgZGF0YXA7XG5cbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBkYXRhcCA9IHJlbmRlcmVyLnRyYW5zZm9ybVBvaW50KGl0ZXIubmV4dCgpKTtcbiAgICAgICAgICAgIGN1ckRpc3QgPSB3aW5kb3cubXVsdGlncmFwaC5tYXRoLnV0aWwubDJkaXN0KHgsIHksIGRhdGFwWzBdLCBkYXRhcFsxXSk7XG4gICAgICAgICAgICBpZiAoY3VyRGlzdCA8IG1heERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBcImRhdGFwXCIgIDogZGF0YXAsXG4gICAgICAgICAgICAgICAgICAgIFwiZGlzdFwiICAgOiBjdXJEaXN0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pbkluZGV4ID0gMCxcbiAgICAgICAgICAgIG1pbkRpc3QgID0gcG9pbnRzWzBdLmRpc3Q7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGluZGV4IG9mIGNsb3Nlc3QgcG9pbnQgdG8gbW91c2VcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBvaW50c1tpXS5kaXN0IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gcG9pbnRzW2ldLmRpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWNoZSBjbG9zZXN0IHBvaW50IHRvIG1vdXNlXG4gICAgICAgIHZhciBwb2ludCAgICAgID0gcG9pbnRzW21pbkluZGV4XSxcbiAgICAgICAgICAgIGF4aXNWYWx1ZXMgPSBbXTtcblxuICAgICAgICAvLyBjYWNoZSBkYXRhIGZvciBwb2ludFxuICAgICAgICBkYXRhcCA9IHBvaW50LmRhdGFwO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBwaXhlbCBsb2NhdGlvbiBvZiBkYXRhIHBvaW50XG4gICAgICAgIHBvaW50LnBpeGVscCA9IGdyYXBoQ29vcmRzVG9QaXhlbENvb3JkcyhkYXRhcCwgZ3JhcGgsIGdyYXBoSGVpZ2h0KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgcmVhbCBEYXRhVmFsdWVzIGZvciB0aGUgZGF0YXBvaW50XG4gICAgICAgIGF4aXNWYWx1ZXNbMF0gPSBoYXhpcy5heGlzVmFsdWVUb0RhdGFWYWx1ZShkYXRhcFswXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBkYXRhcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXhpc1ZhbHVlc1tpXSA9IHZheGlzLmF4aXNWYWx1ZVRvRGF0YVZhbHVlKGRhdGFwW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZW50ICAgID0gZGF0YXRpcHMuZm9ybWF0KGF4aXNWYWx1ZXMpLFxuICAgICAgICAgICAgZGltZW5zaW9ucyA9IGRhdGF0aXBzLmNvbXB1dGVEaW1lbnNpb25zKGNvbnRlbnQsIHRlc3RFbGVtKTtcblxuICAgICAgICBwb2ludC5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgcG9pbnQuZGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG5cbiAgICAgICAgLy8gZm9yIG5vdyBqdXN0IHVzZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgcmVzdWx0c1xuICAgICAgICBwb2ludC50eXBlID0gZGF0YXRpcHMuY29tcHV0ZU9yaWVudGF0aW9uKHBvaW50LCBncmFwaFdpZHRoLCBncmFwaEhlaWdodClbMF07XG5cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiY3JlYXRlRGF0YXRpcFwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgJCAgICAgICAgICAgPSB3aW5kb3cubXVsdGlncmFwaC5qUXVlcnksXG4gICAgICAgICAgICBjb250ZW50ICAgICA9IGRhdGEuY29udGVudCxcbiAgICAgICAgICAgIHR5cGUgICAgICAgID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgZGltZW5zaW9ucyAgPSBkYXRhLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICBwaXhlbHAgICAgICA9IGRhdGEucGl4ZWxwLFxuICAgICAgICAgICAgdyAgICAgICAgICAgPSBkaW1lbnNpb25zLndpZHRoLFxuICAgICAgICAgICAgaCAgICAgICAgICAgPSBkaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgICAgIHggICAgICAgICAgID0gcGl4ZWxwWzBdLFxuICAgICAgICAgICAgeSAgICAgICAgICAgPSBwaXhlbHBbMV0sXG4gICAgICAgICAgICBhcnJvd0xlbmd0aCA9IGRhdGEuYXJyb3csXG4gICAgICAgICAgICBvZmZzZXQgICAgICA9IGRldGVybWluZU9mZnNldHModHlwZSwgeCwgeSwgdywgaCwgYXJyb3dMZW5ndGgpLFxuICAgICAgICAgICAgZGF0YXRpcHMgICAgPSB0aGlzLmRhdGF0aXBzKCksXG4gICAgICAgICAgICBib3JkZXJjb2xvciA9IGRhdGF0aXBzLmJvcmRlcmNvbG9yKCkuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcblxuICAgICAgICB2YXIgYm94ICAgICA9ICQoXCI8ZGl2PlwiICsgY29udGVudCArIFwiPC9kaXY+XCIpLFxuICAgICAgICAgICAgYXJyb3cgICA9ICQoXCI8ZGl2PiZuYnNwPC9kaXY+XCIpLFxuICAgICAgICAgICAgZGF0YXRpcCA9ICQoXCI8ZGl2PjwvZGl2PlwiKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBEYXRhdGlwcy5ET1dOOlxuICAgICAgICAgICAgYXJyb3cuY3NzKHtcbiAgICAgICAgICAgICAgICBcImxlZnRcIiAgICAgICAgICA6ICgody8yKSAtIDUpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLWJvdHRvbVwiIDogYXJyb3dMZW5ndGggKyBcInB4IHNvbGlkIFwiICsgYm9yZGVyY29sb3IsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItbGVmdFwiICAgOiBcIjVweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLXJpZ2h0XCIgIDogXCI1cHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICBcImJvcmRlci10b3BcIiAgICA6IFwiMHB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YXRpcC5hcHBlbmQoYXJyb3cpO1xuICAgICAgICAgICAgZGF0YXRpcC5hcHBlbmQoYm94KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERhdGF0aXBzLlJJR0hUOlxuICAgICAgICAgICAgYXJyb3cuY3NzKHtcbiAgICAgICAgICAgICAgICBcInRvcFwiICAgICAgICAgICA6ICgoaC8yKSAtIDUpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLWJvdHRvbVwiIDogXCI1cHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICBcImJvcmRlci10b3BcIiAgICA6IFwiNXB4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItcmlnaHRcIiAgOiBhcnJvd0xlbmd0aCArIFwicHggc29saWQgXCIgKyBib3JkZXJjb2xvcixcbiAgICAgICAgICAgICAgICBcImJvcmRlci1sZWZ0XCIgICA6IFwiMHB4XCIsXG4gICAgICAgICAgICAgICAgXCJmbG9hdFwiICAgICAgICAgOiBcImxlZnRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBib3guY3NzKFwiZmxvYXRcIiwgXCJsZWZ0XCIpO1xuICAgICAgICAgICAgZGF0YXRpcC5hcHBlbmQoYXJyb3cpO1xuICAgICAgICAgICAgZGF0YXRpcC5hcHBlbmQoYm94KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERhdGF0aXBzLlVQOlxuICAgICAgICAgICAgYXJyb3cuY3NzKHtcbiAgICAgICAgICAgICAgICBcImxlZnRcIiAgICAgICAgICA6ICgody8yKSAtIDUpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLXRvcFwiICAgIDogYXJyb3dMZW5ndGggKyBcInB4IHNvbGlkIFwiICsgYm9yZGVyY29sb3IsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItbGVmdFwiICAgOiBcIjVweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLXJpZ2h0XCIgIDogXCI1cHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICBcImJvcmRlci1ib3R0b21cIiA6IFwiMHB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YXRpcC5hcHBlbmQoYm94KTtcbiAgICAgICAgICAgIGRhdGF0aXAuYXBwZW5kKGFycm93KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERhdGF0aXBzLkxFRlQ6XG4gICAgICAgICAgICBhcnJvdy5jc3Moe1xuICAgICAgICAgICAgICAgIFwidG9wXCIgICAgICAgICAgIDogKChoLzIpIC0gNSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgXCJib3JkZXItYm90dG9tXCIgOiBcIjVweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLXRvcFwiICAgIDogXCI1cHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICBcImJvcmRlci1sZWZ0XCIgICA6IGFycm93TGVuZ3RoICsgXCJweCBzb2xpZCBcIiArIGJvcmRlcmNvbG9yLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyLXJpZ2h0XCIgIDogXCIwcHhcIixcbiAgICAgICAgICAgICAgICBcImZsb2F0XCIgICAgICAgICA6IFwibGVmdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJveC5jc3MoXCJmbG9hdFwiLCBcImxlZnRcIik7XG4gICAgICAgICAgICBkYXRhdGlwLmFwcGVuZChib3gpO1xuICAgICAgICAgICAgZGF0YXRpcC5hcHBlbmQoYXJyb3cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhdGlwLmNzcyh7XG4gICAgICAgICAgICBcInRleHQtYWxpZ25cIiA6IFwibGVmdFwiLFxuICAgICAgICAgICAgXCJwb3NpdGlvblwiICAgOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICBcImNsZWFyXCIgICAgICA6IFwiYm90aFwiLFxuICAgICAgICAgICAgXCJsZWZ0XCIgICAgICAgOiBvZmZzZXRbMF0gKyBcInB4XCIsXG4gICAgICAgICAgICBcInRvcFwiICAgICAgICA6IG9mZnNldFsxXSArIFwicHhcIixcbiAgICAgICAgICAgIFwibWFyZ2luXCIgICAgIDogXCIwcHhcIixcbiAgICAgICAgICAgIFwicGFkZGluZ1wiICAgIDogXCIwcHhcIlxuICAgICAgICB9KTtcblxuICAgICAgICBib3guY3NzKHtcbiAgICAgICAgICAgIFwiZGlzcGxheVwiICAgICAgICAgIDogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgICAgIFwicG9zaXRpb25cIiAgICAgICAgIDogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCIgOiBkYXRhdGlwcy5iZ2NvbG9yKCkudG9SR0JBKGRhdGF0aXBzLmJnYWxwaGEoKSksXG4gICAgICAgICAgICBcInRleHQtYWxpZ25cIiAgICAgICA6IFwibGVmdFwiLFxuICAgICAgICAgICAgXCJtYXJnaW5cIiAgICAgICAgICAgOiBcIjBweFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nLWxlZnRcIiAgICAgOiBcIjVweFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCIgICAgOiBcIjVweFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nLXRvcFwiICAgICAgOiBcIjFweFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nLWJvdHRvbVwiICAgOiBcIjFweFwiLFxuICAgICAgICAgICAgXCJib3JkZXJcIiAgICAgICAgICAgOiBkYXRhdGlwcy5ib3JkZXIoKSArIFwicHggc29saWQgXCIgKyBib3JkZXJjb2xvcixcbiAgICAgICAgICAgIFwiYm9yZGVyLXJhZGl1c1wiICAgIDogXCI1cHhcIlxuICAgICAgICB9KSxcblxuICAgICAgICBhcnJvdy5jc3Moe1xuICAgICAgICAgICAgXCJoZWlnaHRcIiAgICAgOiBcIjBweFwiLFxuICAgICAgICAgICAgXCJ3aWR0aFwiICAgICAgOiBcIjBweFwiLFxuICAgICAgICAgICAgXCJwb3NpdGlvblwiICAgOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICBcInRleHQtYWxpZ25cIiA6IFwibGVmdFwiLFxuICAgICAgICAgICAgXCJtYXJnaW5cIiAgICAgOiBcIjBweFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nXCIgICAgOiBcIjBweFwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhdGlwO1xuICAgIH0pO1xuXG4gICAgdmFyIGRldGVybWluZU9mZnNldHMgPSBmdW5jdGlvbiAodHlwZSwgeCwgeSwgdywgaCwgYXJyb3dMZW5ndGgpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgRGF0YXRpcHMuRE9XTjpcbiAgICAgICAgICAgIHJldHVybiBbeCAtIHcvMiwgeV07XG4gICAgICAgIGNhc2UgRGF0YXRpcHMuUklHSFQ6XG4gICAgICAgICAgICByZXR1cm4gW3gsIHkgLSBoLzJdO1xuICAgICAgICBjYXNlIERhdGF0aXBzLlVQOlxuICAgICAgICAgICAgcmV0dXJuIFt4IC0gdy8yLCB5IC0gaCAtIGFycm93TGVuZ3RoXTtcbiAgICAgICAgY2FzZSBEYXRhdGlwcy5MRUZUOlxuICAgICAgICAgICAgcmV0dXJuIFt4IC0gdyAtIGFycm93TGVuZ3RoLCB5IC0gaC8yXTtcbiAgICAgICAgfVxuICAgIH07XG5cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVBsb3Q7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbi8qXG4gKiBEYXRhVmFsdWUgaXMgYSBQT0pTTyAocGxhaW4gb2xkIGphdmFzY3JpcHQgb2JqZWN0KSB0aGF0IHNpbXBseVxuICogc2VydmVzIGFzIGFuIGVjYXBzdWxhdGlvbiBmb3Igc2V2ZXJhbCBnZW5lcmljXG4gKiBkYXRhLXZhbHVlLXJlbGF0ZWQgY29uc3RhbnRzIGFuZCBmdW5jdGlvbnMuICBUaGVyZSBpcyBubyBhY3R1YWxcbiAqIERhdGFWYWx1ZSBtb2RlbCB0aGF0IGNhbiBiZSBpbnN0YW50aWF0ZWQ7IGFsbCBkYXRhIHZhbHVlcyBhcmVcbiAqIGluc3RhbmNlcyBvZiBlaXRoZXIgdGhlIE51bWJlclZhbHVlIG9yIERhdGV0aW1lVmFsdWUgbW9kZWwuXG4gKi9cblxudmFyIERhdGFWYWx1ZSA9IHt9O1xuXG5EYXRhVmFsdWUuTlVNQkVSID0gXCJudW1iZXJcIjtcbkRhdGFWYWx1ZS5EQVRFVElNRSA9IFwiZGF0ZXRpbWVcIjtcbkRhdGFWYWx1ZS5VTktOT1dOID0gXCJ1bmtub3duXCI7XG5cbi8qXG4gKiBSZXR1cm4gYSBsaXN0IG9mIHRoZSB0eXBlIGNvbnN0YW50cyBhYm92ZVxuICovXG5EYXRhVmFsdWUudHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFsgRGF0YVZhbHVlLk5VTUJFUiwgRGF0YVZhbHVlLkRBVEVUSU1FLCBEYXRhVmFsdWUuVU5LTk9XTiBdO1xufTtcblxuLypcbiAqIENyZWF0ZSBhIG5ldyBEYXRhVmFsdWUgc3VidHlwZSBvZiBhIGdpdmVuIHR5cGUgYnkgcGFyc2luZyBhIHN0cmluZ1xuICovXG5EYXRhVmFsdWUucGFyc2VUeXBlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmIChzdHJpbmcudG9Mb3dlckNhc2UoKSA9PT0gRGF0YVZhbHVlLk5VTUJFUikgeyByZXR1cm4gRGF0YVZhbHVlLk5VTUJFUjsgfVxuICAgIGlmIChzdHJpbmcudG9Mb3dlckNhc2UoKSA9PT0gRGF0YVZhbHVlLkRBVEVUSU1FKSB7IHJldHVybiBEYXRhVmFsdWUuREFURVRJTUU7IH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIERhdGFWYWx1ZSB0eXBlOiBcIiArIHN0cmluZyk7XG59O1xuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBhIFwidHlwZVwiIGVudW0gb2JqZWN0IHRvIGEgc3RyaW5nLiAgSW4gcmVhbGl0eSwgdGhlIG9iamVjdHMgQVJFXG4gKiB0aGUgc3RyaW5ncywgc28gd2UganVzdCByZXR1cm4gdGhlIG9iamVjdC5cbiAqL1xuRGF0YVZhbHVlLnNlcmlhbGl6ZVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiB0eXBlO1xufTtcblxuLypcbiAqIFJldHVybiB0cnVlIG9yIGZhbHNlIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9iaiBpcyBhbiBpbnN0YW5jZSBvZiBhIERhdGFWYWx1ZSB0eXBlXG4gKi9cbkRhdGFWYWx1ZS5pc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiAob2JqICYmICh0eXBlb2Yob2JqLmdldFJlYWxWYWx1ZSkgPT09IFwiZnVuY3Rpb25cIikgJiYgKHR5cGVvZihvYmouY29tcGFyZVRvKSA9PT0gXCJmdW5jdGlvblwiKSk7XG59O1xuXG4vKlxuICogU2FtZSBhcyBEYXRhVmFsdWUuaXNJbnN0YW5jZSwgYnV0IGFsc28gYWxsb3dzIHRoZSBudWxsIHZhbHVlXG4gKi9cbkRhdGFWYWx1ZS5pc0luc3RhbmNlT3JOdWxsID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiAoKG9iaj09PW51bGwpIHx8IERhdGFWYWx1ZS5pc0luc3RhbmNlKG9iaikpO1xufTtcblxuLypcbiAqIENyZWF0ZSBhIG5ldyBEYXRhVmFsdWUgc3VidHlwZSBvZiBhIGdpdmVuIHR5cGUgZnJvbSBhIHJlYWwgdmFsdWVcbiAqL1xuRGF0YVZhbHVlLmNyZWF0ZSA9IGZ1bmN0aW9uICh0eXBlLCByZWFsVmFsdWUpIHtcbiAgICB2YXIgTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL251bWJlcl92YWx1ZS5qcycpLFxuICAgICAgICBEYXRldGltZVZhbHVlID0gcmVxdWlyZSgnLi9kYXRldGltZV92YWx1ZS5qcycpO1xuXG4gICAgaWYgKHR5cGUgPT09IERhdGFWYWx1ZS5OVU1CRVIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJWYWx1ZShyZWFsVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gRGF0YVZhbHVlLkRBVEVUSU1FKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZXRpbWVWYWx1ZShyZWFsVmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0IHRvIHBhcnNlIGFuIHVua25vd24gRGF0YVZhbHVlIHR5cGVcIik7XG59O1xuXG4vKlxuICogQ3JlYXRlIGEgbmV3IERhdGFWYWx1ZSBzdWJ0eXBlIG9mIGEgZ2l2ZW4gdHlwZSBieSBwYXJzaW5nIGEgc3RyaW5nXG4gKi9cbkRhdGFWYWx1ZS5wYXJzZSA9IGZ1bmN0aW9uICh0eXBlLCBzdHJpbmcpIHtcbiAgICB2YXIgTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL251bWJlcl92YWx1ZS5qcycpLFxuICAgICAgICBEYXRldGltZVZhbHVlID0gcmVxdWlyZSgnLi9kYXRldGltZV92YWx1ZS5qcycpO1xuXG4gICAgaWYgKHR5cGUgPT09IERhdGFWYWx1ZS5OVU1CRVIpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlclZhbHVlLnBhcnNlKHN0cmluZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBEYXRhVmFsdWUuREFURVRJTUUpIHtcbiAgICAgICAgcmV0dXJuIERhdGV0aW1lVmFsdWUucGFyc2Uoc3RyaW5nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdCB0byBwYXJzZSBhbiB1bmtub3duIERhdGFWYWx1ZSB0eXBlXCIpO1xufTtcblxuLypcbiAqIEVudW0gdmFsdWVzIGZvciBjb21wYXJpc29uIG9wZXJhdG9ycy4gIFRoZXNlIHNob3VsZCBiZSBsb3dlcmNhc2Ugc3RyaW5ncyAtLS0gdGhleSdyZSB1c2VkIGFzXG4gKiBhY3R1YWwgbWV0aG9kIG5hbWVzIGJlbG93LlxuICovXG5EYXRhVmFsdWUuTFQgPSBcImx0XCI7XG5EYXRhVmFsdWUuTEUgPSBcImxlXCI7XG5EYXRhVmFsdWUuRVEgPSBcImVxXCI7XG5EYXRhVmFsdWUuR0UgPSBcImdlXCI7XG5EYXRhVmFsdWUuR1QgPSBcImd0XCI7XG5EYXRhVmFsdWUuTkUgPSBcIm5lXCI7XG5cbnZhciBjb21wYXJhdG9yRnVuY3MgPSB7fTtcbmNvbXBhcmF0b3JGdW5jc1tEYXRhVmFsdWUuTFRdID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRoaXMuY29tcGFyZVRvKHgpICAgPCAwOyB9O1xuY29tcGFyYXRvckZ1bmNzW0RhdGFWYWx1ZS5MRV0gPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdGhpcy5jb21wYXJlVG8oeCkgIDw9IDA7IH07XG5jb21wYXJhdG9yRnVuY3NbRGF0YVZhbHVlLkVRXSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0aGlzLmNvbXBhcmVUbyh4KSA9PT0gMDsgfTtcbmNvbXBhcmF0b3JGdW5jc1tEYXRhVmFsdWUuR0VdID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRoaXMuY29tcGFyZVRvKHgpICA+PSAwOyB9O1xuY29tcGFyYXRvckZ1bmNzW0RhdGFWYWx1ZS5HVF0gPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdGhpcy5jb21wYXJlVG8oeCkgICA+IDA7IH07XG5jb21wYXJhdG9yRnVuY3NbRGF0YVZhbHVlLk5FXSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0aGlzLmNvbXBhcmVUbyh4KSAhPT0gMDsgfTtcblxuLypcbiAqIE1peCB0aGUgNSBjb21wYXJhdG9yIGZ1bmN0aW9uIGludG8gYW5vdGhlciBvYmplY3Q6XG4gKi9cbkRhdGFWYWx1ZS5taXhpbkNvbXBhcmF0b3JzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIG9ialtEYXRhVmFsdWUuTFRdID0gY29tcGFyYXRvckZ1bmNzW0RhdGFWYWx1ZS5MVF07XG4gICAgb2JqW0RhdGFWYWx1ZS5MRV0gPSBjb21wYXJhdG9yRnVuY3NbRGF0YVZhbHVlLkxFXTtcbiAgICBvYmpbRGF0YVZhbHVlLkVRXSA9IGNvbXBhcmF0b3JGdW5jc1tEYXRhVmFsdWUuRVFdO1xuICAgIG9ialtEYXRhVmFsdWUuR0VdID0gY29tcGFyYXRvckZ1bmNzW0RhdGFWYWx1ZS5HRV07XG4gICAgb2JqW0RhdGFWYWx1ZS5HVF0gPSBjb21wYXJhdG9yRnVuY3NbRGF0YVZhbHVlLkdUXTtcbiAgICBvYmpbRGF0YVZhbHVlLk5FXSA9IGNvbXBhcmF0b3JGdW5jc1tEYXRhVmFsdWUuTkVdO1xufTtcblxuLypcbiAqIFRoZSBjb21wYXJhdG9ycyBmdW5jdGlvbiByZXR1cm5zIGEgbGlzdCBvZiB0aGUgNSBjb21wYXJhdG9yXG4gKiBmdW5jdGlvbnMsIHRvIGJlIHVzZWQgbGlrZSBhbiBlbnVtIHR5cGUuXG4gKi9cbkRhdGFWYWx1ZS5jb21wYXJhdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gWyBEYXRhVmFsdWUuTFQsIERhdGFWYWx1ZS5MRSwgRGF0YVZhbHVlLkVRLCBEYXRhVmFsdWUuR0UsIERhdGFWYWx1ZS5HVCwgRGF0YVZhbHVlLk5FIF07XG59O1xuXG4vKlxuICogQ29udmVydCBhIHN0cmluZyB0byBhIGNvbXBhcmF0b3IgZW51bSBvYmplY3Q6XG4gKi9cbkRhdGFWYWx1ZS5wYXJzZUNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZihzdHJpbmcpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN3aXRjaCAoc3RyaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSBcImx0XCI6IHJldHVybiBEYXRhVmFsdWUuTFQ7XG4gICAgICAgIGNhc2UgXCJsZVwiOiByZXR1cm4gRGF0YVZhbHVlLkxFO1xuICAgICAgICBjYXNlIFwiZXFcIjogcmV0dXJuIERhdGFWYWx1ZS5FUTtcbiAgICAgICAgY2FzZSBcImdlXCI6IHJldHVybiBEYXRhVmFsdWUuR0U7XG4gICAgICAgIGNhc2UgXCJndFwiOiByZXR1cm4gRGF0YVZhbHVlLkdUO1xuICAgICAgICBjYXNlIFwibmVcIjogcmV0dXJuIERhdGFWYWx1ZS5ORTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyaW5nICsgXCIgc2hvdWxkIGJlIG9uZSBvZiAnbHQnLCAnbGUnLCAnZXEnLCAnZ2UnLCAnZ3QnLCAnbmUnLlwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZhbHVlO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyk7XG5cbnZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMuZGF0YS52YXJpYWJsZXMudmFyaWFibGUpO1xuXG52YXIgRGF0YVZhcmlhYmxlID0gbmV3IGplcm1haW5lLk1vZGVsKFwiRGF0YVZhcmlhYmxlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhc0EoXCJpZFwiKS53aGljaC5pc0EoXCJzdHJpbmdcIik7XG4gICAgdGhpcy5oYXNBKFwiY29sdW1uXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG4gICAgdGhpcy5oYXNBKFwidHlwZVwiKS53aGljaC5pc09uZU9mKERhdGFWYWx1ZS50eXBlcygpKS5hbmQuZGVmYXVsdHNUbyhEYXRhVmFsdWUuTlVNQkVSKTtcbiAgICB0aGlzLmhhc0EoXCJkYXRhXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIERhdGEgPSByZXF1aXJlKCcuL2RhdGEuanMnKTtcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBEYXRhO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcIm1pc3Npbmd2YWx1ZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFWYWx1ZS5pc0luc3RhbmNlKTtcblxuICAgIHRoaXMuaGFzQShcIm1pc3NpbmdvcFwiKS53aGljaC5pc09uZU9mKERhdGFWYWx1ZS5jb21wYXJhdG9ycygpKTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwiaWRcIiwgXCIlY29sdW1uXCIsIFwiJXR5cGVcIik7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMuZGF0YS52YXJpYWJsZXMudmFyaWFibGUsIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZhcmlhYmxlO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgRGF0YXRpcHNWYXJpYWJsZSA9IHJlcXVpcmUoJy4vZGF0YXRpcHNfdmFyaWFibGUuanMnKSxcbiAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyksXG4gICAgRGF0YUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vZGF0YV9mb3JtYXR0ZXIuanMnKSxcbiAgICBSR0JDb2xvciA9IHJlcXVpcmUoJy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMucGxvdC5kYXRhdGlwcyk7XG5cbnZhciBEYXRhdGlwcyA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkRhdGF0aXBzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhc01hbnkoXCJ2YXJpYWJsZXNcIikuZWFjaE9mV2hpY2gudmFsaWRhdGVXaXRoKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgICByZXR1cm4gdmFyaWFibGUgaW5zdGFuY2VvZiBEYXRhdGlwc1ZhcmlhYmxlO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImZvcm1hdFN0cmluZ1wiKS53aGljaC5pc0EoXCJzdHJpbmdcIik7XG4gICAgdGhpcy5oYXNBKFwiYmdjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChiZ2NvbG9yKSB7XG4gICAgICAgIHJldHVybiBiZ2NvbG9yIGluc3RhbmNlb2YgUkdCQ29sb3I7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiYmdhbHBoYVwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5oYXNBKFwiYm9yZGVyXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG4gICAgdGhpcy5oYXNBKFwiYm9yZGVyY29sb3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYm9yZGVyY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGJvcmRlcmNvbG9yIGluc3RhbmNlb2YgUkdCQ29sb3I7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwicGFkXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJmb3JtYXRcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZERhdGEgPSBbXSxcbiAgICAgICAgICAgIHJlcGxhY2VtZW50UGF0dGVybnMgPSBbXSxcbiAgICAgICAgICAgIG91dHB1dCA9IHRoaXMuZm9ybWF0U3RyaW5nKCksXG4gICAgICAgICAgICBpLCBsID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm9ybWF0dGVkRGF0YS5wdXNoKHRoaXMudmFyaWFibGVzKCkuYXQoaSkuZm9ybWF0dGVyKCkuZm9ybWF0KGRhdGFbaV0pKTtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50UGF0dGVybnMucHVzaChuZXcgUmVnRXhwKFwiXFxcXHtcIiArIGkgKyBcIlxcXFx9XCIsIFwiZ1wiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShyZXBsYWNlbWVudFBhdHRlcm5zW2ldLCBmb3JtYXR0ZWREYXRhW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9bXFxufFxccl0vZywgXCI8YnIvPlwiKTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiY29tcHV0ZURpbWVuc2lvbnNcIiwgZnVuY3Rpb24gKGNvbnRlbnQsIGVsZW0pIHtcbiAgICAgICAgdmFyIHBhZGRpbmdXaWR0aCAgPSBwYXJzZUludChlbGVtLmNzcyhcInBhZGRpbmctbGVmdFwiKSwgMTApICsgcGFyc2VJbnQoZWxlbS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpLCAxMCksXG4gICAgICAgICAgICBwYWRkaW5nSGVpZ2h0ID0gcGFyc2VJbnQoZWxlbS5jc3MoXCJwYWRkaW5nLXRvcFwiKSwgMTApICArIHBhcnNlSW50KGVsZW0uY3NzKFwicGFkZGluZy1ib3R0b21cIiksIDEwKSxcbiAgICAgICAgICAgIGJvcmRlciAgICAgICAgPSAyICogdGhpcy5ib3JkZXIoKTtcblxuICAgICAgICBlbGVtLmh0bWwoY29udGVudCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwid2lkdGhcIiAgOiBlbGVtLndpZHRoKCkgICsgYm9yZGVyICsgcGFkZGluZ1dpZHRoLFxuICAgICAgICAgICAgXCJoZWlnaHRcIiA6IGVsZW0uaGVpZ2h0KCkgKyBib3JkZXIgKyBwYWRkaW5nSGVpZ2h0XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJjb21wdXRlT3JpZW50YXRpb25cIiwgZnVuY3Rpb24gKGRhdGEsIGdyYXBoV2lkdGgsIGdyYXBoSGVpZ2h0KSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zICAgID0gZGF0YS5kaW1lbnNpb25zLFxuICAgICAgICAgICAgcGl4ZWxwICAgICAgICA9IGRhdGEucGl4ZWxwLFxuICAgICAgICAgICAgZGF0YXRpcFdpZHRoICA9IGRpbWVuc2lvbnMud2lkdGgsXG4gICAgICAgICAgICBkYXRhdGlwSGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgICAgICBiYXNlWCAgICAgICAgID0gcGl4ZWxwWzBdLFxuICAgICAgICAgICAgYmFzZVkgICAgICAgICA9IHBpeGVscFsxXSxcbiAgICAgICAgICAgIG9mZnNldCAgICAgICAgPSAyMCxcbiAgICAgICAgICAgIG9mZnNldFdpZHRoICAgPSBkYXRhdGlwV2lkdGggICsgb2Zmc2V0LFxuICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0ICA9IGRhdGF0aXBIZWlnaHQgKyBvZmZzZXQ7XG5cbiAgICAgICAgYmFzZVkgPSBncmFwaEhlaWdodCAtIGJhc2VZOyAvLyByZW1vdmUgdGhpcyBsaW5lIHdoZW4gYmFzZVkgaXMgdGFrZW4gZnJvbSB0aGUgbG93ZXIgbGVmdCBjb3JuZXIgYmVpbmcgdGhlIG9yaWdpblxuXG4gICAgICAgIGlmICggLy8gY2VudGVyXG4gICAgICAgICAgICBiYXNlWCAgICAgICAtIG9mZnNldFdpZHRoICA+PSAwICYmXG4gICAgICAgICAgICAgICAgZ3JhcGhXaWR0aCAgLSBiYXNlWCAgICAgICAgPj0gb2Zmc2V0V2lkdGggJiZcbiAgICAgICAgICAgICAgICBiYXNlWSAgICAgICAtIG9mZnNldEhlaWdodCA+PSAwICYmXG4gICAgICAgICAgICAgICAgZ3JhcGhIZWlnaHQgLSBiYXNlWSAgICAgICAgPj0gb2Zmc2V0SGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIFtEYXRhdGlwcy5VUCwgRGF0YXRpcHMuRE9XTiwgRGF0YXRpcHMuUklHSFQsIERhdGF0aXBzLkxFRlRdO1xuICAgICAgICB9IGVsc2UgaWYgKCAvLyB0b3BcbiAgICAgICAgICAgIGJhc2VYICAgICAgIC0gb2Zmc2V0V2lkdGggID49IDAgJiZcbiAgICAgICAgICAgICAgICBncmFwaFdpZHRoICAtIGJhc2VYICAgICAgICA+PSBvZmZzZXRXaWR0aCAmJlxuICAgICAgICAgICAgICAgIGJhc2VZICAgICAgICAgICAgICAgICAgICAgID49IGdyYXBoSGVpZ2h0IC0gb2Zmc2V0SGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgZ3JhcGhIZWlnaHQgICAgICAgICAgICAgICAgPj0gYmFzZVlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gW0RhdGF0aXBzLkRPV04sIERhdGF0aXBzLlJJR0hULCBEYXRhdGlwcy5MRUZULCBEYXRhdGlwcy5VUF07XG4gICAgICAgIH0gZWxzZSBpZiAoIC8vIGJvdHRvbVxuICAgICAgICAgICAgYmFzZVggICAgICAtIG9mZnNldFdpZHRoID49IDAgJiZcbiAgICAgICAgICAgICAgICBncmFwaFdpZHRoIC0gYmFzZVggICAgICAgPj0gb2Zmc2V0V2lkdGggJiZcbiAgICAgICAgICAgICAgICBvZmZzZXRIZWlnaHQgICAgICAgICAgICAgPj0gYmFzZVkgJiZcbiAgICAgICAgICAgICAgICBiYXNlWSAgICAgICAgICAgICAgICAgICAgPj0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBbRGF0YXRpcHMuVVAsIERhdGF0aXBzLlJJR0hULCBEYXRhdGlwcy5MRUZULCBEYXRhdGlwcy5ET1dOXTtcbiAgICAgICAgfSBlbHNlIGlmICggLy8gbGVmdFxuICAgICAgICAgICAgYmFzZVggICAgICAgICAgICAgICAgICAgICAgPj0gMCAmJlxuICAgICAgICAgICAgICAgIG9mZnNldFdpZHRoICAgICAgICAgICAgICAgID49IGJhc2VYICYmXG4gICAgICAgICAgICAgICAgYmFzZVkgICAgICAgLSBvZmZzZXRIZWlnaHQgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGdyYXBoSGVpZ2h0IC0gYmFzZVkgICAgICAgID49IG9mZnNldEhlaWdodFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBbRGF0YXRpcHMuUklHSFQsIERhdGF0aXBzLlVQLCBEYXRhdGlwcy5ET1dOLCBEYXRhdGlwcy5MRUZUXTtcbiAgICAgICAgfSBlbHNlIGlmICggLy8gcmlnaHRcbiAgICAgICAgICAgIGdyYXBoV2lkdGggICAgICAgICAgICAgICAgID49IGJhc2VYICYmXG4gICAgICAgICAgICAgICAgb2Zmc2V0V2lkdGggICAgICAgICAgICAgICAgPj0gZ3JhcGhXaWR0aCAtIGJhc2VYICYmXG4gICAgICAgICAgICAgICAgYmFzZVkgICAgICAgLSBvZmZzZXRIZWlnaHQgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGdyYXBoSGVpZ2h0IC0gYmFzZVkgICAgICAgID49IG9mZnNldEhlaWdodFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBbRGF0YXRpcHMuTEVGVCwgRGF0YXRpcHMuVVAsIERhdGF0aXBzLkRPV04sIERhdGF0aXBzLlJJR0hUXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGJhc2VYIDwgZ3JhcGhXaWR0aCAvIDIpIHsgLy8gbGVmdCBzaWRlIG9mIGdyYXBoXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VZID4gZ3JhcGhIZWlnaHQgLyAyKSB7IC8vIHRvcC1sZWZ0IGNvcm5lciBvZiBncmFwaFxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVggLSBkYXRhdGlwV2lkdGgvMiA8IChncmFwaEhlaWdodCAtIGJhc2VZKSAtIGRhdGF0aXBIZWlnaHQvMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgaG9yaXpvbnRhbCBzaWRlIHRoYW4gdGhlIHZlcnRpY2FsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuUklHSFQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5ET1dOKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgaXMgbG9zdCBvZmYgdGhlIHZlcnRpY2FsIHNpZGUgdGhhbiB0aGUgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLkRPV04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5SSUdIVCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VYIC0gb2Zmc2V0V2lkdGggPCAoZ3JhcGhIZWlnaHQgLSBiYXNlWSkgLSBvZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgaXMgbG9zdCBvZmYgdGhlIGhvcml6b250YWwgc2lkZSB0aGFuIHRoZSB2ZXJ0aWNhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLlVQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuTEVGVCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGlzIGxvc3Qgb2ZmIHRoZSB2ZXJ0aWNhbCBzaWRlIHRoYW4gdGhlIGhvcml6b250YWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5MRUZUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuVVApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gYm90dG9tLWxlZnQgY29ybmVyIG9mIGdyYXBoXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlWCAtIGRhdGF0aXBXaWR0aC8yIDwgYmFzZVkgLSBkYXRhdGlwSGVpZ2h0LzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgaXMgbG9zdCBvZmYgdGhlIGhvcml6b250YWwgc2lkZSB0aGFuIHRoZSB2ZXJ0aWNhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLlJJR0hUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuVVApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgdmVydGljYWwgc2lkZSB0aGFuIHRoZSBob3Jpem9udGFsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuVVApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5SSUdIVCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VYIC0gb2Zmc2V0V2lkdGggPCBiYXNlWSAtIG9mZnNldEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgaG9yaXpvbnRhbCBzaWRlIHRoYW4gdGhlIHZlcnRpY2FsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuRE9XTik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLkxFRlQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgdmVydGljYWwgc2lkZSB0aGFuIHRoZSBob3Jpem9udGFsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuTEVGVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLkRPV04pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcmlnaHQgc2lkZSBvZiBncmFwaFxuICAgICAgICAgICAgICAgIGlmIChiYXNlWSA+IGdyYXBoSGVpZ2h0IC8gMikgeyAvLyB0b3AtcmlnaHQgY29ybmVyIG9mIGdyYXBoXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZ3JhcGhXaWR0aCAtIGJhc2VYKSAtIGRhdGF0aXBXaWR0aC8yIDwgKGdyYXBoSGVpZ2h0IC0gYmFzZVkpIC0gZGF0YXRpcEhlaWdodC8yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGlzIGxvc3Qgb2ZmIHRoZSBob3Jpem9udGFsIHNpZGUgdGhhbiB0aGUgdmVydGljYWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5MRUZUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuRE9XTik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGlzIGxvc3Qgb2ZmIHRoZSB2ZXJ0aWNhbCBzaWRlIHRoYW4gdGhlIGhvcml6b250YWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5ET1dOKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuTEVGVCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChncmFwaFdpZHRoIC0gYmFzZVgpIC0gb2Zmc2V0V2lkdGggPCAoZ3JhcGhIZWlnaHQgLSBiYXNlWSkgLSBvZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgaXMgbG9zdCBvZmYgdGhlIGhvcml6b250YWwgc2lkZSB0aGFuIHRoZSB2ZXJ0aWNhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLlVQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuUklHSFQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgdmVydGljYWwgc2lkZSB0aGFuIHRoZSBob3Jpem9udGFsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuUklHSFQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5VUCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBib3R0b20tcmlnaHQgY29ybmVyIG9mIGdyYXBoXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZ3JhcGhXaWR0aCAtIGJhc2VYKSAtIGRhdGF0aXBXaWR0aC8yIDwgYmFzZVkgLSBkYXRhdGlwSGVpZ2h0LzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgaXMgbG9zdCBvZmYgdGhlIGhvcml6b250YWwgc2lkZSB0aGFuIHRoZSB2ZXJ0aWNhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLkxFRlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5VUCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGlzIGxvc3Qgb2ZmIHRoZSB2ZXJ0aWNhbCBzaWRlIHRoYW4gdGhlIGhvcml6b250YWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMucHVzaChEYXRhdGlwcy5VUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLkxFRlQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZ3JhcGhXaWR0aCAtIGJhc2VYKSAtIG9mZnNldFdpZHRoIDwgYmFzZVkgLSBvZmZzZXRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBpcyBsb3N0IG9mZiB0aGUgaG9yaXpvbnRhbCBzaWRlIHRoYW4gdGhlIHZlcnRpY2FsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuRE9XTik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLlJJR0hUKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgaXMgbG9zdCBvZmYgdGhlIHZlcnRpY2FsIHNpZGUgdGhhbiB0aGUgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKERhdGF0aXBzLlJJR0hUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLnB1c2goRGF0YXRpcHMuRE9XTik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJlZmVyZW5jZXM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJub3JtYWxpemVcIiwgZnVuY3Rpb24gKHBsb3QpIHtcbiAgICAgICAgdmFyIGRhdGF0aXBzVmFyaWFibGVzID0gdGhpcy52YXJpYWJsZXMoKSxcbiAgICAgICAgICAgIHBsb3RWYXJpYWJsZXMgICAgID0gcGxvdC52YXJpYWJsZSgpLFxuICAgICAgICAgICAgdmFyaWFibGUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBjcmVhdGVzIG1pc3NpbmcgdmFyaWFibGVzIGZvciB0aGUgZGF0YXRpcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgaWYgKGRhdGF0aXBzVmFyaWFibGVzLnNpemUoKSA8IHBsb3RWYXJpYWJsZXMuc2l6ZSgpKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBkYXRhdGlwc1ZhcmlhYmxlcy5zaXplKCk7IGkgPCBwbG90VmFyaWFibGVzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YXRpcHNWYXJpYWJsZXMuYWRkKG5ldyBEYXRhdGlwc1ZhcmlhYmxlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0cyB1cCBmb3JtYXR0ZXJzIGZvciBkYXRhdGlwcyB2YXJpYWJsZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhdGlwc1ZhcmlhYmxlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgdmFyaWFibGUgPSBkYXRhdGlwc1ZhcmlhYmxlcy5hdChpKTtcbiAgICAgICAgICAgIHR5cGUgPSBwbG90VmFyaWFibGVzLmF0KGkpLnR5cGUoKTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZS5mb3JtYXRTdHJpbmcoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IERhdGFWYWx1ZS5OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUuZm9ybWF0U3RyaW5nKGRlZmF1bHRWYWx1ZXNbXCJmb3JtYXRTdHJpbmctbnVtYmVyXCJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZS5mb3JtYXRTdHJpbmcoZGVmYXVsdFZhbHVlc1tcImZvcm1hdFN0cmluZy1kYXRldGltZVwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyaWFibGUuZm9ybWF0dGVyKERhdGFGb3JtYXR0ZXIuY3JlYXRlKHR5cGUsIHZhcmlhYmxlLmZvcm1hdFN0cmluZygpKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLnBsb3QuZGF0YXRpcHMsIGF0dHJpYnV0ZXMpO1xufSk7XG5cbkRhdGF0aXBzLlVQICAgID0gXCJ1XCI7XG5EYXRhdGlwcy5ET1dOICA9IFwiZFwiO1xuRGF0YXRpcHMuTEVGVCAgPSBcImxcIjtcbkRhdGF0aXBzLlJJR0hUID0gXCJyXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YXRpcHM7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMucGxvdC5kYXRhdGlwcy52YXJpYWJsZSksXG4gICAgRGF0YUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vZGF0YV9mb3JtYXR0ZXIuanMnKTtcblxudmFyIERhdGF0aXBzVmFyaWFibGUgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJEYXRhdGlwc1ZhcmlhYmxlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhc0EoXCJmb3JtYXRTdHJpbmdcIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuICAgIHRoaXMuaGFzQShcImZvcm1hdHRlclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFGb3JtYXR0ZXIuaXNJbnN0YW5jZSk7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMucGxvdC5kYXRhdGlwcy52YXJpYWJsZSwgYXR0cmlidXRlcyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhdGlwc1ZhcmlhYmxlO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgc3ByaW50ZiA9IHJlcXVpcmUoJ3NwcmludGYnKTtcblxudmFyIERhdGV0aW1lRm9ybWF0dGVyID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHZhciB0ZXN0U3RyaW5nO1xuICAgIGlmICh0eXBlb2YoZm9ybWF0KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXRTdHJpbmcgPSBmb3JtYXQ7XG4gICAgdGVzdFN0cmluZyA9IERhdGV0aW1lRm9ybWF0dGVyLmZvcm1hdEludGVybmFsbHkoZm9ybWF0LCBuZXcgRGF0ZSgwKSk7XG4gICAgdGhpcy5sZW5ndGggPSB0ZXN0U3RyaW5nLmxlbmd0aDtcbn07XG5cbkRhdGV0aW1lRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gRGF0ZXRpbWVGb3JtYXR0ZXIuZm9ybWF0SW50ZXJuYWxseSh0aGlzLmZvcm1hdFN0cmluZywgdmFsdWUudmFsdWUpO1xufTtcblxuRGF0ZXRpbWVGb3JtYXR0ZXIucHJvdG90eXBlLmdldE1heExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5EYXRldGltZUZvcm1hdHRlci5wcm90b3R5cGUuZ2V0Rm9ybWF0U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdFN0cmluZztcbn07XG5cbkRhdGV0aW1lRm9ybWF0dGVyLmZvcm1hdEludGVybmFsbHkgPSBmdW5jdGlvbiAoZm9ybWF0U3RyaW5nLCBkYXRlKSB7XG4gICAgdmFyIGRheU5hbWVzID0ge1xuICAgICAgICBcInNob3J0TmFtZXNcIjogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgICAgICBcImxvbmdOYW1lc1wiOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXVxuICAgIH0sXG4gICAgICAgIG1vbnRoTmFtZXMgPSB7XG4gICAgICAgICAgICBcInNob3J0TmFtZXNcIjogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdLFxuICAgICAgICAgICAgXCJsb25nTmFtZXNcIjogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl1cbiAgICAgICAgfSxcbiAgICAgICAgc3RhdGUgPSAwLFxuICAgICAgICBjLFxuICAgICAgICBpLFxuICAgICAgICB0LFxuICAgICAgICBvdXRwdXQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGZvcm1hdFN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjID0gZm9ybWF0U3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoYyA9PT0gXCIlXCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSBcIllcIjpcbiAgICAgICAgICAgICAgICAvLyBmb3VyIGRpZ2l0IHllYXJcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgICAgIC8vIHR3byBkaWdpdCB5ZWFyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLnN1YnN0cigyLCAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgLy8gMi1kaWdpdCBtb250aCBudW1iZXIgd2l0aCBsZWFkaW5nIHplcm9cbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gc3ByaW50ZihcIiUwMnNcIiwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAvLyBtb250aCBudW1iZXIgd2l0aG91dCBsZWFkaW5nIHplcm9cbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTlwiOlxuICAgICAgICAgICAgICAgIC8vIG1vbnRoIG5hbWUsIHNwZWxsZWQgb3V0XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IG1vbnRoTmFtZXMubG9uZ05hbWVzW2RhdGUuZ2V0VVRDTW9udGgoKV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICAgICAgICAgIC8vIG1vbnRoIG5hbWUsIDMgbGV0dGVyIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBtb250aE5hbWVzLnNob3J0TmFtZXNbZGF0ZS5nZXRVVENNb250aCgpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICAgICAgLy8gdHdvLWRpZ2l0IGRheSBvZiBtb250aCB3aXRoIGxlYWRpbmcgemVyb1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzcHJpbnRmKFwiJTAyc1wiLCBkYXRlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICAgICAgLy8gZGF5IG9mIG1vbnRoIHdpdGhvdXQgbGVhZGluZyB6ZXJvXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgbmFtZSwgc3BlbGxlZCBvdXRcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZGF5TmFtZXMubG9uZ05hbWVzW2RhdGUuZ2V0VVRDRGF5KCldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IG5hbWUsIDMtbGV0dGVyIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBkYXlOYW1lcy5zaG9ydE5hbWVzW2RhdGUuZ2V0VVRDRGF5KCldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAvLyBob3VyIG9mIGRheSwgMjQgaG91ciBjbG9ja1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzcHJpbnRmKFwiJTAyc1wiLCBkYXRlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgICAgIC8vIGhvdXIgb2YgZGF5LCAxMiBob3VyIGNsb2NrXG4gICAgICAgICAgICAgICAgdCA9IGRhdGUuZ2V0VVRDSG91cnMoKSAlIDEyO1xuICAgICAgICAgICAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBcIjEyXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaVwiOlxuICAgICAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gc3ByaW50ZihcIiUwMnNcIiwgZGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gc3ByaW50ZihcIiUwMnNcIiwgZGF0ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgIC8vIGRlY2lzZWNvbmRzICgxMHRocyBvZiBhIHNlY29uZClcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gc3ByaW50ZihcIiUwM3NcIiwgZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKS50b1N0cmluZygpKS5zdWJzdHIoMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgICAgIC8vIGNlbnRpc2Vjb25kcyAoMTAwdGhzIG9mIGEgc2Vjb25kKVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzcHJpbnRmKFwiJTAzc1wiLCBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCkpLnN1YnN0cigwLCAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgICAgICAgLy8gbWlsbGlzZWNvbmRzICgxMDAwdGhzIG9mIGEgc2Vjb25kKVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzcHJpbnRmKFwiJTAzc1wiLCBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBcIjpcbiAgICAgICAgICAgICAgICAvLyBBTSBvciBQTVxuICAgICAgICAgICAgICAgIHQgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHQgPCAxMikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gXCJBTVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBcIlBNXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBcIjpcbiAgICAgICAgICAgICAgICAvLyBhbSBvciBwbVxuICAgICAgICAgICAgICAgIHQgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHQgPCAxMikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gXCJhbVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBcInBtXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgICAgICAvLyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICAgICAgICAgIC8vICVcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gXCIlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2hhcmFjdGVyIGNvZGUgZm9yIGRhdGV0aW1lIGZvcm1hdHRpbmcgc3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0ZXRpbWVGb3JtYXR0ZXI7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBEYXRldGltZVZhbHVlID0gcmVxdWlyZSgnLi9kYXRldGltZV92YWx1ZS5qcycpLFxuICAgIEVudW0gPSByZXF1aXJlKCcuLi9tYXRoL2VudW0uanMnKTtcblxudmFyIERhdGV0aW1lVW5pdCA9IHJlcXVpcmUoJy4vZGF0ZXRpbWVfdW5pdC5qcycpO1xuXG52YXIgRGF0ZXRpbWVNZWFzdXJlID0gZnVuY3Rpb24gKG1lYXN1cmUsIHVuaXQpIHtcbiAgICBpZiAodHlwZW9mKG1lYXN1cmUpICE9PSBcIm51bWJlclwiIHx8IERhdGV0aW1lTWVhc3VyZS5pc1VuaXQodW5pdCkgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW1wcm9wZXIgaW5wdXQgZm9yIERhdGV0aW1lIE1lYXN1cmUncyBjb25zdHJ1Y3RvclwiKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0ZXRpbWUgTWVhc3VyZSdzIGNvbnRydWN0b3IgcmVxdWlyZXMgZXhhY3RseSB0d28gYXJndW1lbnRzXCIpO1xuICAgIH1cbiAgICB0aGlzLm1lYXN1cmUgPSBtZWFzdXJlO1xuICAgIHRoaXMudW5pdCAgICA9IHVuaXQ7XG59O1xuXG5EYXRldGltZU1lYXN1cmUuaXNVbml0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICByZXR1cm4gRGF0ZXRpbWVVbml0LmlzSW5zdGFuY2UodW5pdCk7XG59O1xuXG5EYXRldGltZU1lYXN1cmUucHJvdG90eXBlLm5lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZXRpbWVNZWFzdXJlKC10aGlzLm1lYXN1cmUsIHRoaXMudW5pdCk7XG59O1xuXG5EYXRldGltZU1lYXN1cmUucHJvdG90eXBlLmdldFJlYWxWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmFjdG9yO1xuICAgIHN3aXRjaCAodGhpcy51bml0KSB7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuTUlMTElTRUNPTkQ6XG4gICAgICAgIGZhY3RvciA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0ZXRpbWVVbml0LlNFQ09ORDpcbiAgICAgICAgZmFjdG9yID0gMTAwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuTUlOVVRFOlxuICAgICAgICBmYWN0b3IgPSA2MDAwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuSE9VUjpcbiAgICAgICAgZmFjdG9yID0gMzYwMDAwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuREFZOlxuICAgICAgICBmYWN0b3IgPSA4NjQwMDAwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuV0VFSzpcbiAgICAgICAgZmFjdG9yID0gNjA0ODAwMDAwO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5NT05USDpcbiAgICAgICAgZmFjdG9yID0gMjU5MjAwMDAwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuWUVBUjpcbiAgICAgICAgZmFjdG9yID0gMzE1MzYwMDAwMDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZWFzdXJlICogZmFjdG9yO1xufTtcblxuRGF0ZXRpbWVNZWFzdXJlLnBhcnNlID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgcmUsIG1lYXN1cmUsIHVuaXQ7XG5cbiAgICBpZiAodHlwZW9mKHMpICE9PSBcInN0cmluZ1wiIHx8IHMubWF0Y2goL1xccyotPygoWzAtOV0rXFwuP1swLTldKil8KFswLTldKlxcLj9bMC05XSspKVxccyoobXN8c3xtfEh8RHxXfE18WSl7MX1cXHMqJC8pID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkltcHJvcGVyIGlucHV0IGZvciBEYXRldGltZSBNZWFzdXJlJ3MgcGFyc2UgbWV0aG9kXCIpO1xuICAgIH1cblxuICAgIHJlICAgICAgPSAvbXN8c3xtfEh8RHxXfE18WS87XG4gICAgbWVhc3VyZSA9IHBhcnNlRmxvYXQocy5yZXBsYWNlKHJlLCBcIlwiKSk7XG4gICAgdW5pdCAgICA9IHMubWF0Y2gocmUpOyAvLyByZXR1cm5zIGFuIGFycmF5XG5cbiAgICB1bml0ID0gRGF0ZXRpbWVVbml0LnBhcnNlKHVuaXRbMF0pO1xuXG4gICAgcmV0dXJuIG5ldyBEYXRldGltZU1lYXN1cmUobWVhc3VyZSwgdW5pdCk7XG59O1xuXG5EYXRldGltZU1lYXN1cmUuZmluZFRpY2ttYXJrV2l0aE1pbGxpc2Vjb25kU3BhY2luZyA9IGZ1bmN0aW9uICgvKm51bWJlcihtaWxsaXNlY29uZHMpKi92YWx1ZSwgLypudW1iZXIobWlsbGlzZWNvbmRzKSovYWxpZ25tZW50LCAvKm51bWJlcihtaWxsaXNlY29uZHMpKi9zcGFjaW5nKSB7XG4gICAgdmFyIG9mZnNldCA9IHZhbHVlIC0gYWxpZ25tZW50LFxuICAgICAgICBkICAgICAgPSBNYXRoLmZsb29yKCBvZmZzZXQgLyBzcGFjaW5nICk7XG4gICAgaWYgKG9mZnNldCAlIHNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgKytkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGV0aW1lVmFsdWUoYWxpZ25tZW50ICsgZCAqIHNwYWNpbmcpO1xufTtcblxuRGF0ZXRpbWVNZWFzdXJlLmZpbmRUaWNrbWFya1dpdGhNb250aFNwYWNpbmcgPSBmdW5jdGlvbiAoLypEYXRldGltZVZhbHVlKi92YWx1ZSwgLypEYXRldGltZVZhbHVlKi9hbGlnbm1lbnQsIC8qbnVtYmVyKG1vbnRocykqL21vbnRoU3BhY2luZykge1xuICAgIHZhciB2YWx1ZUQgPSB2YWx1ZS52YWx1ZSwgICAgICAgLy9OT1RFOiBcIi52YWx1ZVwiIHByb3BlcnR5IG9mIERhdGV0aW1lVmFsdWUgaXMgYSBqYXZhc2NyaXB0IERhdGUgb2JqZWN0XG4gICAgICAgIGFsaWduRCA9IGFsaWdubWVudC52YWx1ZSwgICAvL05PVEU6IFwiLnZhbHVlXCIgcHJvcGVydHkgb2YgRGF0ZXRpbWVWYWx1ZSBpcyBhIGphdmFzY3JpcHQgRGF0ZSBvYmplY3RcbiAgICAgICAgbW9udGhPZmZzZXQgPSAxMiAqICh2YWx1ZUQuZ2V0VVRDRnVsbFllYXIoKSAtIGFsaWduRC5nZXRVVENGdWxsWWVhcigpKSArICh2YWx1ZUQuZ2V0VVRDTW9udGgoKSAtIGFsaWduRC5nZXRVVENNb250aCgpKSxcbiAgICAgICAgZCA9IE1hdGguZmxvb3IoIG1vbnRoT2Zmc2V0IC8gbW9udGhTcGFjaW5nICk7XG5cbiAgICBpZiAobW9udGhPZmZzZXQgJSBtb250aFNwYWNpbmcgIT09IDApIHsgKytkOyB9XG4gICAgZWxzZSBpZiAodmFsdWVELmdldFVUQ0RhdGUoKSA+IGFsaWduRC5nZXRVVENEYXRlKCkpIHsgKytkOyB9XG4gICAgZWxzZSBpZiAodmFsdWVELmdldFVUQ0RhdGUoKSA9PT0gYWxpZ25ELmdldFVUQ0RhdGUoKSAmJiB2YWx1ZUQuZ2V0VVRDSG91cnMoKSA+IGFsaWduRC5nZXRVVENIb3VycygpKSB7ICsrZDsgfVxuICAgIGVsc2UgaWYgKHZhbHVlRC5nZXRVVENEYXRlKCkgPT09IGFsaWduRC5nZXRVVENEYXRlKCkgJiYgdmFsdWVELmdldFVUQ0hvdXJzKCkgPT09IGFsaWduRC5nZXRVVENIb3VycygpICYmIHZhbHVlRC5nZXRVVENNaW51dGVzKCkgPiBhbGlnbkQuZ2V0VVRDTWludXRlcygpKSB7ICsrZDsgfVxuICAgIGVsc2UgaWYgKHZhbHVlRC5nZXRVVENEYXRlKCkgPT09IGFsaWduRC5nZXRVVENEYXRlKCkgJiYgdmFsdWVELmdldFVUQ0hvdXJzKCkgPT09IGFsaWduRC5nZXRVVENIb3VycygpICYmIHZhbHVlRC5nZXRVVENNaW51dGVzKCkgPT09IGFsaWduRC5nZXRVVENNaW51dGVzKCkgJiYgdmFsdWVELmdldFVUQ1NlY29uZHMoKSA+IGFsaWduRC5nZXRVVENTZWNvbmRzKCkpIHsgKytkOyB9XG4gICAgZWxzZSBpZiAodmFsdWVELmdldFVUQ0RhdGUoKSA9PT0gYWxpZ25ELmdldFVUQ0RhdGUoKSAmJiB2YWx1ZUQuZ2V0VVRDSG91cnMoKSA9PT0gYWxpZ25ELmdldFVUQ0hvdXJzKCkgJiYgdmFsdWVELmdldFVUQ01pbnV0ZXMoKSA9PT0gYWxpZ25ELmdldFVUQ01pbnV0ZXMoKSAmJiB2YWx1ZUQuZ2V0VVRDU2Vjb25kcygpID09PSBhbGlnbkQuZ2V0VVRDU2Vjb25kcygpICYmIHZhbHVlRC5nZXRVVENNaWxsaXNlY29uZHMoKSA+IGFsaWduRC5nZXRVVENNaWxsaXNlY29uZHMoKSkgeyArK2Q7IH1cblxuICAgIHJldHVybiBhbGlnbm1lbnQuYWRkKCBEYXRldGltZU1lYXN1cmUucGFyc2UoKGQgKiBtb250aFNwYWNpbmcpICsgXCJNXCIpICk7XG59O1xuXG5cbi8qKlxuICogQ29uc2lkZXIgdGhlIHJlZ3VsYXIgbGF0dGljZSBvZiBwb2ludHMgb24gdGhlIERhdGV0aW1lIGxpbmUgc2VwYXJhdGVkIGZyb20gZWFjaCBvdGhlclxuICogYnkgYHRoaXNgIERhdGV0aW1lTWVhc3VyZSwgYW5kIGFsaWduZWQgYXQgdGhlIERhdGV0aW1lVmFsdWUgYGFsaWdubWVudGAuICBUaGlzIGZ1bmN0aW9uXG4gKiByZXR1cm4gdGhlIHNtYWxsZXN0IERhdGV0aW1lVmFsdWUgaW4gdGhhdCBsYXR0aWNlIHdoaWNoIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICogYHZhbHVlYC5cbiAqIFxuICogcmV0dXJuOiBhIERhdGV0aW1lVmFsdWVcbiAqL1xuRGF0ZXRpbWVNZWFzdXJlLnByb3RvdHlwZS5maXJzdFNwYWNpbmdMb2NhdGlvbkF0T3JBZnRlciA9IGZ1bmN0aW9uICgvKkRhdGV0aW1lVmFsdWUqL3ZhbHVlLCAvKkRhdGV0aW1lVmFsdWUqL2FsaWdubWVudCkgIHtcbiAgICBzd2l0Y2ggKHRoaXMudW5pdCkge1xuICAgIGNhc2UgRGF0ZXRpbWVVbml0Lk1PTlRIOlxuICAgICAgICByZXR1cm4gRGF0ZXRpbWVNZWFzdXJlLmZpbmRUaWNrbWFya1dpdGhNb250aFNwYWNpbmcodmFsdWUsIGFsaWdubWVudCwgdGhpcy5tZWFzdXJlKTtcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5ZRUFSOlxuICAgICAgICByZXR1cm4gRGF0ZXRpbWVNZWFzdXJlLmZpbmRUaWNrbWFya1dpdGhNb250aFNwYWNpbmcodmFsdWUsIGFsaWdubWVudCwgdGhpcy5tZWFzdXJlICogMTIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBEYXRldGltZU1lYXN1cmUuZmluZFRpY2ttYXJrV2l0aE1pbGxpc2Vjb25kU3BhY2luZyh2YWx1ZS5nZXRSZWFsVmFsdWUoKSwgYWxpZ25tZW50LmdldFJlYWxWYWx1ZSgpLCB0aGlzLmdldFJlYWxWYWx1ZSgpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMganVzdCBsaWtlIGBmaXJzdFNwYWNpbmdMb2NhdGlvbkF0T3JBZnRlcmAgYWJvdmUsIGJ1dCByZXR1cm5zIHRoZVxuICogZ3JlYXRlc3QgRGF0ZXRpbWVWYWx1ZSBpbiB0aGUgbGF0dGljZSB0aGF0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICogXG4gKiByZXR1cm46IGEgRGF0ZXRpbWVWYWx1ZVxuICovXG5EYXRldGltZU1lYXN1cmUucHJvdG90eXBlLmxhc3RTcGFjaW5nTG9jYXRpb25BdE9yQmVmb3JlID0gZnVuY3Rpb24gKC8qRGF0ZXRpbWVWYWx1ZSovdmFsdWUsIC8qRGF0ZXRpbWVWYWx1ZSovYWxpZ25tZW50KSAge1xuICAgIHZhciB4ID0gdGhpcy5maXJzdFNwYWNpbmdMb2NhdGlvbkF0T3JBZnRlcih2YWx1ZSwgYWxpZ25tZW50KTtcbiAgICBpZiAoeC5lcSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIHZhciB5ID0geC5hZGQodGhpcy5uZWdhdGl2ZSgpKTtcbiAgICByZXR1cm4geTtcbn07XG5cbkRhdGV0aW1lTWVhc3VyZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVhc3VyZS50b1N0cmluZygpICsgdGhpcy51bml0LnRvU3RyaW5nKCk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRGF0ZXRpbWVNZWFzdXJlO1xuIiwidmFyIEVudW0gPSByZXF1aXJlKCcuLi9tYXRoL2VudW0uanMnKTtcblxudmFyIERhdGV0aW1lVW5pdCA9IG5ldyBFbnVtKFwiRGF0ZXRpbWVVbml0XCIpO1xuXG5EYXRldGltZVVuaXQuTUlMTElTRUNPTkQgPSBuZXcgRGF0ZXRpbWVVbml0KFwibXNcIik7XG5EYXRldGltZVVuaXQuU0VDT05EICAgICAgPSBuZXcgRGF0ZXRpbWVVbml0KFwic1wiKTtcbkRhdGV0aW1lVW5pdC5NSU5VVEUgICAgICA9IG5ldyBEYXRldGltZVVuaXQoXCJtXCIpO1xuRGF0ZXRpbWVVbml0LkhPVVIgICAgICAgID0gbmV3IERhdGV0aW1lVW5pdChcIkhcIik7XG5EYXRldGltZVVuaXQuREFZICAgICAgICAgPSBuZXcgRGF0ZXRpbWVVbml0KFwiRFwiKTtcbkRhdGV0aW1lVW5pdC5XRUVLICAgICAgICA9IG5ldyBEYXRldGltZVVuaXQoXCJXXCIpO1xuRGF0ZXRpbWVVbml0Lk1PTlRIICAgICAgID0gbmV3IERhdGV0aW1lVW5pdChcIk1cIik7XG5EYXRldGltZVVuaXQuWUVBUiAgICAgICAgPSBuZXcgRGF0ZXRpbWVVbml0KFwiWVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRldGltZVVuaXQ7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBEYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKSxcbiAgICBEYXRldGltZVVuaXQgPSByZXF1aXJlKCcuL2RhdGV0aW1lX3VuaXQuanMnKSxcbiAgICBzcHJpbnRmID0gcmVxdWlyZSgnc3ByaW50ZicpO1xuXG52YXIgRGF0ZXRpbWVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YodmFsdWUpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGV0aW1lVmFsdWUgcmVxdWlyZXMgaXRzIHBhcmFtZXRlciB0byBiZSBhIG51bWJlclwiKTtcbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbn07XG5cbkRhdGV0aW1lVmFsdWUucHJvdG90eXBlLmdldFJlYWxWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5nZXRUaW1lKCk7XG59O1xuXG5EYXRldGltZVZhbHVlLnByb3RvdHlwZS50eXBlID0gRGF0YVZhbHVlLkRBVEVUSU1FO1xuXG5EYXRldGltZVZhbHVlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZXRpbWVWYWx1ZSh0aGlzLmdldFJlYWxWYWx1ZSgpKTtcbn07XG5cbkRhdGV0aW1lVmFsdWUucGFyc2UgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgdmFyIFkgPSAwLFxuICAgICAgICBNID0gMCxcbiAgICAgICAgRCA9IDEsXG4gICAgICAgIEggPSAwLFxuICAgICAgICBtID0gMCxcbiAgICAgICAgcyA9IDAsXG4gICAgICAgIG1zID0gMDtcbiAgICBpZiAodHlwZW9mKHN0cmluZykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1tcXC5cXC1cXDpcXHNdL2csIFwiXCIpO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgWSA9IHBhcnNlSW50KHN0cmluZywgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgIFkgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDAsNCksIDEwKTtcbiAgICAgICAgICAgIE0gPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDQsNiksIDEwKSAtIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICAgICAgWSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMCw0KSwgMTApO1xuICAgICAgICAgICAgTSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoNCw2KSwgMTApIC0gMTtcbiAgICAgICAgICAgIEQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDYsOCksIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcubGVuZ3RoID09PSAxMCkge1xuICAgICAgICAgICAgWSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMCw0KSwgMTApO1xuICAgICAgICAgICAgTSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoNCw2KSwgMTApIC0gMTtcbiAgICAgICAgICAgIEQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDYsOCksIDEwKTtcbiAgICAgICAgICAgIEggPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDgsMTApLCAxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgICAgIFkgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDAsNCksIDEwKTtcbiAgICAgICAgICAgIE0gPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDQsNiksIDEwKSAtIDE7XG4gICAgICAgICAgICBEID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZyg2LDgpLCAxMCk7XG4gICAgICAgICAgICBIID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZyg4LDEwKSwgMTApO1xuICAgICAgICAgICAgbSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMTAsMTIpLCAxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMTQpIHtcbiAgICAgICAgICAgIFkgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDAsNCksIDEwKTtcbiAgICAgICAgICAgIE0gPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDQsNiksIDEwKSAtIDE7XG4gICAgICAgICAgICBEID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZyg2LDgpLCAxMCk7XG4gICAgICAgICAgICBIID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZyg4LDEwKSwgMTApO1xuICAgICAgICAgICAgbSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHJpbmcoMTAsMTIpLCAxMCk7XG4gICAgICAgICAgICBzID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZygxMiwxNCksIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcubGVuZ3RoID09PSAxNSB8fCBzdHJpbmcubGVuZ3RoID09PSAxNiB8fCBzdHJpbmcubGVuZ3RoID09PSAxNykge1xuICAgICAgICAgICAgWSAgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDAsNCksIDEwKTtcbiAgICAgICAgICAgIE0gID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZyg0LDYpLCAxMCkgLSAxO1xuICAgICAgICAgICAgRCAgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDYsOCksIDEwKTtcbiAgICAgICAgICAgIEggID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cmluZyg4LDEwKSwgMTApO1xuICAgICAgICAgICAgbSAgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDEwLDEyKSwgMTApO1xuICAgICAgICAgICAgcyAgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDEyLDE0KSwgMTApO1xuICAgICAgICAgICAgbXMgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyaW5nKDE0LDE3KSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZyA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZXMgdGhlIGNhc2Ugb2YgXCIwXCIsIHdoaWNoIHBhcnNlciBzaG91bGQgY29udmVydCB0byB0aGUgVW5peCBlcG9jaFxuICAgICAgICAgICAgWSA9IDE5NzA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3QgaW5wdXQgZm9ybWF0IGZvciBEYXRldGltZSBWYWx1ZSdzIHBhcnNlIG1ldGhvZDpcIiArIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRldGltZSBWYWx1ZSdzIHBhcnNlIG1ldGhvZCByZXF1aXJlcyBpdHMgcGFyYW1ldGVyIHRvIGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGV0aW1lVmFsdWUoRGF0ZS5VVEMoWSwgTSwgRCwgSCwgbSwgcywgbXMpKTtcbn07XG5cblxuRGF0ZXRpbWVWYWx1ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFksIE0sIEQsIEgsIG0sIHMsIG1zO1xuXG4gICAgWSAgPSBzcHJpbnRmKFwiJTA0c1wiLCB0aGlzLnZhbHVlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKSk7XG4gICAgTSAgPSBzcHJpbnRmKFwiJTAyc1wiLCAodGhpcy52YWx1ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKSk7XG4gICAgRCAgPSBzcHJpbnRmKFwiJTAyc1wiLCB0aGlzLnZhbHVlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpKTtcbiAgICBIICA9IHNwcmludGYoXCIlMDJzXCIsIHRoaXMudmFsdWUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpKTtcbiAgICBtICA9IHNwcmludGYoXCIlMDJzXCIsIHRoaXMudmFsdWUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkpO1xuICAgIHMgID0gc3ByaW50ZihcIiUwMnNcIiwgdGhpcy52YWx1ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKSk7XG4gICAgbXMgPSBcIi5cIiArIHNwcmludGYoXCIlMDNzXCIsIHRoaXMudmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKSk7XG5cbiAgICBpZiAobXMgPT09IFwiLjAwMFwiKSB7XG4gICAgICAgIG1zID0gXCJcIjtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIFkgKyBNICsgRCArIEggKyBtICsgcyArIG1zO1xufTtcblxuXG5EYXRldGltZVZhbHVlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAoeCkge1xuICAgIGlmICh0aGlzLmdldFJlYWxWYWx1ZSgpIDwgeC5nZXRSZWFsVmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmICh0aGlzLmdldFJlYWxWYWx1ZSgpID4geC5nZXRSZWFsVmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG5EYXRldGltZVZhbHVlLnByb3RvdHlwZS5hZGRSZWFsVmFsdWUgPSBmdW5jdGlvbiAoIHJlYWxWYWx1ZUluY3IgKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRldGltZVZhbHVlKHRoaXMudmFsdWUuZ2V0VGltZSgpICsgcmVhbFZhbHVlSW5jcik7XG59O1xuXG5EYXRldGltZVZhbHVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoIC8qRGF0YU1lYXN1cmUqLyBtZWFzdXJlKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZXRpbWVWYWx1ZSh0aGlzLmdldFJlYWxWYWx1ZSgpKTtcbiAgICBzd2l0Y2ggKG1lYXN1cmUudW5pdCkge1xuICAgIGNhc2UgRGF0ZXRpbWVVbml0Lk1JTExJU0VDT05EOlxuICAgICAgICBkYXRlLnZhbHVlLnNldFVUQ01pbGxpc2Vjb25kcyhkYXRlLnZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpICsgbWVhc3VyZS5tZWFzdXJlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuU0VDT05EOlxuICAgICAgICBkYXRlLnZhbHVlLnNldFVUQ1NlY29uZHMoZGF0ZS52YWx1ZS5nZXRVVENTZWNvbmRzKCkgKyBtZWFzdXJlLm1lYXN1cmUpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5NSU5VVEU6XG4gICAgICAgIGRhdGUudmFsdWUuc2V0VVRDTWludXRlcyhkYXRlLnZhbHVlLmdldFVUQ01pbnV0ZXMoKSArIG1lYXN1cmUubWVhc3VyZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0ZXRpbWVVbml0LkhPVVI6XG4gICAgICAgIGRhdGUudmFsdWUuc2V0VVRDSG91cnMoZGF0ZS52YWx1ZS5nZXRVVENIb3VycygpICsgbWVhc3VyZS5tZWFzdXJlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuREFZOlxuICAgICAgICBkYXRlLnZhbHVlLnNldFVUQ0RhdGUoZGF0ZS52YWx1ZS5nZXRVVENEYXRlKCkgKyBtZWFzdXJlLm1lYXN1cmUpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERhdGV0aW1lVW5pdC5XRUVLOlxuICAgICAgICBkYXRlLnZhbHVlLnNldFVUQ0RhdGUoZGF0ZS52YWx1ZS5nZXRVVENEYXRlKCkgKyBtZWFzdXJlLm1lYXN1cmUgKiA3KTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuTU9OVEg6XG4gICAgICAgIGRhdGUudmFsdWUuc2V0VVRDTW9udGgoZGF0ZS52YWx1ZS5nZXRVVENNb250aCgpICsgbWVhc3VyZS5tZWFzdXJlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRldGltZVVuaXQuWUVBUjpcbiAgICAgICAgZGF0ZS52YWx1ZS5zZXRVVENGdWxsWWVhcihkYXRlLnZhbHVlLmdldFVUQ0Z1bGxZZWFyKCkgKyBtZWFzdXJlLm1lYXN1cmUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59O1xuXG5EYXRhVmFsdWUubWl4aW5Db21wYXJhdG9ycyhEYXRldGltZVZhbHVlLnByb3RvdHlwZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0ZXRpbWVWYWx1ZTtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxuLyoqXG4gKiBFdmVudEVtaXR0ZXIgaXMgYSBKZXJtYWluZSBtb2RlbCB0aGF0IHN1cHBvcnRzIGJhc2ljIGV2ZW50IGVtaXR0aW5nIC9cbiAqIGhhbmRsaW5nIGZvciBKZXJtYWluZSBvYmplY3RzLlxuICpcbiAqIEV2ZW50cyBhcmUgcmVwcmVzZW50ZWQgYXMgcGxhaW4gb2xkIEphdmFTY3JpcHQgb2JqZWN0cyB3aXRoIGF0IGxlYXN0XG4gKiB0aGUgZm9sbG93aW5nIHR3byBwcm9wZXJ0aWVzOlxuICpcbiAqICAgKip0eXBlKipcbiAqXG4gKiAgID4gYSBzdHJpbmcgZ2l2aW5nIHRoZSB0eXBlIG9mIHRoZSBldmVudDsgdGhpcyBjYW4gYmUgYW55XG4gKiAgICAgYXJiaXRyYXJ5IHN0cmluZy4gIFRoZSBldmVudCB0eXBlIGlzIG5vdCByZXN0cmljdGVkIHRvIGJlXG4gKiAgICAgZnJvbSBzb21lIHByZWRldGVybWluZWQgbGlzdDsgYXBwbGljYXRpb25zIGFyZSBmcmVlIHRvXG4gKiAgICAgdXNlIHdoYXRldmVyIHN0cmluZ3MgdGhleSB3YW50IGZvciB0aGVpciBldmVudCB0eXBlcy5cbiAqXG4gKiAgICoqdGFyZ2V0KipcbiAqXG4gKiAgID4gYSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdCB0aGF0IGVtaXR0ZWQgdGhlIGV2ZW50XG4gKlxuICogRXZlbnQgb2JqZWN0cyBtYXkgYWxzbyBjb250YWluIGFyYml0cmFyeSBvdGhlciBwcm9wZXJ0aWVzIHRoYXQgYXJlIHNwZWNpZmljIHRvXG4gKiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZS5cbiAqXG4gKiBBbnkgSmVybWFpbmUgbW9kZWwgY2FuIGRlY2xhcmUgaXRzZWxmIHRvIGJlIGFuIGV2ZW50IGVtaXR0ZXIgYnkgc2F5aW5nXG4gKiBcInRoaXMuaXNBKEV2ZW50RW1pdHRlcilcIiBpbiBpdHMgbW9kZWwgZGVjbGFyYXRpb24uXG4gKlxuICogVGhpcyBhZGRzIHRocmVlIG1ldGhvZHMgdG8gdGhlIG1vZGVsOlxuICogIFxuICogICAqKmFkZExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXJGdW5jdGlvbikqKlxuICpcbiAqICAgPiBSZWdpc3RlcnMgbGlzdGVuZXJGdW5jdGlvbiBhcyBhIGxpc3RlbmVyIGZvciBldmVudHMgb2YgdHlwZVxuICogICAgIGV2ZW50VHlwZSAoYSBzdHJpbmcpLiAgbGlzdGVuZXJGdW5jdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvblxuICogICAgIHRoYXQgYWNjZXB0cyBhIHNpbmdsZSBhcmd1bWVudCB3aGljaCB3aWxsIGJlIGEgcmVmZXJlbmNlIHRvIGFuXG4gKiAgICAgZXZlbnQgb2JqZWN0IGFzIGRlc2NyaWJlZCBhYm92ZS4gIFdoZW4gdGhlIG9iamVjdCBlbWl0cyB0aGVcbiAqICAgICBldmVudCwgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBpbiB0aGUgY29udGV4dFxuICogICAgIHdoZXJlIGl0cyBcInRoaXNcIiBrZXl3b3JkIHJlZmVycyB0byB0aGUgb2JqZWN0IHRoYXQgZW1pdHRlZCB0aGVcbiAqICAgICBldmVudCAodGhlIGV2ZW50IHRhcmdldCkuICBJZiBsaXN0ZW5lckZ1bmN0aW9uIGlzIGFscmVhZHlcbiAqICAgICByZWdpc3RlcmVkIGFzIGEgbGlzdGVuZXIgZm9yIGV2ZW50VHlwZSwgdGhpcyBmdW5jdGlvbiBkb2VzXG4gKiAgICAgbm90aGluZyAtLS0gZWFjaCBsaXN0ZW5lciBmdW5jdGlvbiBjYW4gYmUgcmVnaXN0ZXJlZCBvbmx5IG9uY2UuXG4gKlxuICogICAqKnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXJGdW5jdGlvbikqKlxuICpcbiAqICAgPiBSZW1vdmVzIHRoZSBnaXZlbiBsaXN0ZW5lckZ1bmN0aW9uIGZyb20gdGhlIGxpc3Qgb2YgbGlzdGVuZXJzXG4gKiAgICAgZm9yIHRoaXMgb2JqZWN0IGZvciBldmVudHMgb2YgdHlwZSBldmVudFR5cGUuXG4gKlxuICogICAqKmVtaXQoZXZlbnQpKipcbiAqXG4gKiAgID4gQ2F1c2VzIHRoZSBvYmplY3QgdG8gZW1pdCB0aGUgZ2l2ZW4gZXZlbnQuICBUaGUgYXJndW1lbnQgY2FuIGJlXG4gKiAgICAgZWl0aGVyIGEgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGl0IGlzIGFzc3VtZWQgdG8gYmUgYW4gZXZlbnQgdHlwZVxuICogICAgIGFuZCBpcyBjb252ZXJ0ZWQgdG8gYW4gZXZlbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuICd0eXBlJ1xuICogICAgIHByb3BlcnR5LCBvciBhbiBldmVudCBvYmplY3Qgd2l0aCBhICd0eXBlJyBwcm9wZXJ0eSBhbmQgYW55XG4gKiAgICAgb3RoZXIgZGVzaXJlZCBwcm9wZXJ0aWVzLiAgVGhlIGVtaXQoKSBtZXRob2QgYXV0b21hdGljYWxseSBhZGRzXG4gKiAgICAgYSAndGFyZ2V0JyBwcm9wZXJ0eSB0byB0aGUgZXZlbnQgb2JqZWN0LCB3aG9zZSB2YWx1ZSBpcyBhXG4gKiAgICAgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3QgZW1pdHRpbmcgdGhlIGV2ZW50LlxuICpcbiAqIEluIG1vc3QgY2FzZXMgdGhlIGVtaXQoKSBtZXRob2QgaXMgb25seSBjYWxsZWQgZnJvbSB3aXRoaW4gdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBhbiBFdmVudEVtaXR0ZXIgb2JqZWN0LCBhbmQgY29kZSBleHRlcm5hbCB0byB0aGVcbiAqIG9iamVjdCdzIG1vZGVsIHdpbGwgdXNlIGl0cyBhZGRMaXN0ZW5lcigpIGFuZCByZW1vdmVMaXN0ZW5lcigpIG1ldGhvZHNcbiAqIHRvIHByb2Nlc3MgZXZlbnRzIHRoYXQgdGhlIG9iamVjdCBlbWl0cy4gIEFsbCB0aHJlZSBvZiB0aGVzZSBtZXRob2RzXG4gKiBhcmUgcHVibGljIG1ldGhvZHMsIHRob3VnaCwgc28gaXQncyBhbHNvIHBvc3NpYmxlIGZvciBjb2RlIG91dHNpZGUgb2ZcbiAqIGFuIG9iamVjdCdzIGltcGxlbWVudGF0aW9uIHRvIGNhdXNlIGl0IHRvIGVtaXQgYW4gZXZlbnQsIG9yIGZvciB0aGVcbiAqIG9iamVjdCdzIG93biBjb2RlIHRvIGxpc3RlbiBmb3IgYW5kIHByb2Nlc3MgaXRzIG93biBldmVudHMuXG4gKlxuICogVHdvIHNwZWNpYWwgdHlwZXMgb2YgZXZlbnRzIGFyZSBhbHdheXMgcHJlc2VudCBmb3IgZXZlcnkgRXZlbnRFbWl0dGVyXG4gKiBvYmplY3Q6IHRoZSBcImxpc3RlbmVyQWRkZWRcIiBhbmQgXCJsaXN0ZW5lclJlbW92ZWRcIiBldmVudHMuICBUaGVzZVxuICogZXZlbnRzIG1ha2UgaXQgcG9zc2libGUgdG8gbW9uaXRvciB0aGUgYWRkaXRpb24gb3IgcmVtb3ZhbCBvZiBldmVudFxuICogbGlzdGVuZXJzLiAgVGhlIFwibGlzdGVuZXJBZGRlZFwiIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbmV2ZXIgYSBuZXdcbiAqIGxpc3RlbmVyIGZ1bmN0aW9uIGlzIGFkZGVkLCBhbmQgdGhlIFwibGlzdGVuZXJSZW1vdmVkXCIgZXZlbnQgaXMgZW1pdHRlZFxuICogd2hlbmV2ZXIgYSBsaXN0ZW5lciBpcyByZW1vdmVkLiAgRWFjaCBvZiB0aGVzZSBldmVudHMgY29udGFpbiB0aGVcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgKip0YXJnZXRUeXBlKipcbiAqXG4gKiAgID4gdGhlIGV2ZW50IHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBsaXN0ZW5lclxuICogICAgIGJlaW5nIGFkZGVkIG9yIHJlbW92ZWRcbiAqXG4gKiAgICoqbGlzdGVuZXIqKlxuICpcbiAqICAgPiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gYmVpbmcgYWRkZWQgb3IgcmVtb3ZlZFxuICpcbiAqIEBjbGFzcyBFdmVudEVtaXR0ZXJcbiAqIEBmb3IgRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIFBlcnNvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgdGhpcy5pc0EoRXZlbnRFbWl0dGVyKTtcbiAqICAgICAgICAgdGhpcy5oYXNBKFwibmFtZVwiKS53aGljaC5pc0EoXCJzdHJpbmdcIik7XG4gKiAgICAgICAgIHRoaXMucmVzcG9uZHNUbyhcInNheVwiLCBmdW5jdGlvbihzb21ldGhpbmcpIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMubmFtZSgpICsgJyBzYXlzICcgKyBzb21ldGhpbmcpO1xuICogICAgICAgICAgICAgdGhpcy5lbWl0KHt0eXBlIDogXCJzYXlcIiwgbWVzc2FnZSA6IHNvbWV0aGluZ30pO1xuICogICAgICAgICB9KTtcbiAqICAgICB9KTtcbiAqICAgICB2YXIgcGVyc29uID0gbmV3IFBlcnNvbigpLm5hbWUoXCJNYXJrXCIpO1xuICpcbiAqICAgICB2YXIgc2F5TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCkge1xuICogICAgICAgICBjb25zb2xlLmxvZyhldmVudC50YXJnZXQubmFtZSgpICsgJyBzYWlkICcgKyBldmVudC5tZXNzYWdlKTtcbiAqICAgICB9O1xuICpcbiAqICAgICBwZXJzb24uc2F5KCdIZWxsbycpO1xuICogICAgIHBlcnNvbi5hZGRMaXN0ZW5lcihcInNheVwiLCBzYXlMaXN0ZW5lcik7XG4gKiAgICAgcGVyc29uLnNheSgnQWxyaWdodCcpO1xuICogICAgIHBlcnNvbi5yZW1vdmVMaXN0ZW5lcihcInNheVwiLCBzYXlMaXN0ZW5lcik7XG4gKiAgICAgcGVyc29uLnNheSgnR29vZGJ5ZScpO1xuICpcbiAqXG4gKiAgICAgT1VUUFVUOlxuICpcbiAqICAgICAgICAgTWFyayBzYXlzIEhlbGxvXG4gKiAgICAgICAgIE1hcmsgc2F5cyBBbHJpZ2h0XG4gKiAgICAgICAgIE1hcmsgc2FpZCBBbHJpZ2h0XG4gKiAgICAgICAgIE1hcmsgc2FpZCBHb29kYnllXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSBuZXcgamVybWFpbmUuTW9kZWwoZnVuY3Rpb24gKCkge1xuICAgIC8vIGxpc3RlbmVycyBpcyBhIHBsYWluIG9sZCBKUyBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgZXZlbnRzXG4gICAgLy8gdHlwZXMgKHN0cmluZ3MpOyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGVhY2gga2V5IGlzIHRoZVxuICAgIC8vIGxpc3Qgb2YgcmVnaXN0ZXJlZCBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIHRoYXQgZXZlbnQgdHlwZS5cbiAgICB0aGlzLmhhc0EoXCJsaXN0ZW5lcnNcIikud2hpY2guZGVmYXVsdHNUbyggZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlbXB0eSBvYmplY3QgYXMgdGhlXG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWUsIHNvIHdlIGdldCBhIG5ldyBsaXN0ZW5lcnMgb2JqZWN0XG4gICAgICAgIC8vIGNyZWF0ZWQgZm9yIGVhY2ggRXZlbnRFbWl0dGVyIGluc3RhbmNlLlxuICAgICAgICByZXR1cm4ge307XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gZm9yIGV2ZW50cyBvZiBhIHNwZWNpZmljIHR5cGVcbiAgICAgKiBlbWl0dGVkIGJ5IHRoaXMgb2JqZWN0LlxuICAgICAqIFxuICAgICAqIEBtZXRob2QgYWRkTGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIHRoZSB0eXBlIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgYSBsaXN0ZW5lciBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBsaXN0ZW5lclxuICAgICAqICAgICAgICAgd2FzIGFjdHVhbGx5IGFkZGVkIChhIGxpc3RlbmVyIGlzIG5vdCBhZGRlZCBpZiBpdFxuICAgICAqICAgICAgICAgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciB0aGUgZXZlbnRUeXBlKVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImFkZExpc3RlbmVyXCIsIGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycygpLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBpZiAobGlzdGVuZXJzW2V2ZW50VHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGk9MDsgaTxsaXN0ZW5lcnNbZXZlbnRUeXBlXS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tldmVudFR5cGVdW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRUeXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5lbWl0KHsgdHlwZSAgICAgICA6IFwibGlzdGVuZXJBZGRlZFwiLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRUeXBlIDogZXZlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciAgIDogbGlzdGVuZXJ9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24gZm9yIGV2ZW50cyBvZiBhIHNwZWNpZmljIHR5cGVcbiAgICAgKiBlbWl0dGVkIGJ5IHRoaXMgb2JqZWN0LlxuICAgICAqIFxuICAgICAqIEBtZXRob2QgcmVtb3ZlTGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIHRoZSB0eXBlIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBsaXN0ZW5lclxuICAgICAqICAgICAgICAgd2FzIGFjdHVhbGx5IHJlbW92ZWQuXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwicmVtb3ZlTGlzdGVuZXJcIiwgZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKCksXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnNbZXZlbnRUeXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxsaXN0ZW5lcnNbZXZlbnRUeXBlXS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbZXZlbnRUeXBlXVtpXSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50VHlwZV1baV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoeyB0eXBlICAgICAgIDogXCJsaXN0ZW5lclJlbW92ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VHlwZSA6IGV2ZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgICA6IGxpc3RlbmVyfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgb2JqZWN0cyBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQuICBJZiB0aGUgXCJldmVudFwiXG4gICAgICogYXJndW1lbnQgaXMgYSBzdHJpbmcsIGl0IGlzIGNvbnZlcnRlZCB0byBhbiBPYmplY3QgaGF2aW5nXG4gICAgICogdGhhdCBzdHJpbmcgYXMgdGhlIHZhbHVlIG9mIGl0cyBcInR5cGVcIiBhdHRyaWJ1dGU7IG90aGVyd2lzZVxuICAgICAqIHRoZSBcImV2ZW50XCIgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGV2ZW50IE9iamVjdCBoYXZpbmcgYVxuICAgICAqIFwidHlwZVwiIGF0dHJpYnV0ZSBhbmQgYW55IG90aGVyIGF0dHJpYnV0ZXMgYXBwcm9yaWF0ZSBmb3JcbiAgICAgKiB0aGF0IGV2ZW50IHR5cGUuICBJbiBlaXRoZXIgY2FzZSwgYWxsIChpZiB0aGVyZSBhcmUgYW55KSBvZlxuICAgICAqIHRoZSBjdXJyZW50IGxpc3RlbmVycyBvbiB0aGlzIG9iamVjdCBmb3IgZXZlbnRzIG9mIHRoZVxuICAgICAqIGdpdmVuIHR5cGUgd2lsbCBiZSBpbnZva2VkLCBiZWluZyBwYXNzZWQgYW4gZXZlbnQgb2JqZWN0LlxuICAgICAqIFxuICAgICAqIEBtZXRob2QgZW1pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gZXZlbnQgZWl0aGVyIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBldmVudCB0eXBlLCBvciBhbiBldmVudFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHdpdGggYSAndHlwZScgYXR0cmlidXRlLlxuICAgICAqIEByZXR1cm4gKG5vdGhpbmcpXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZW1pdFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBudWxscyA9IFtdO1xuXG4gICAgICAgIGlmICh0eXBlb2YoZXZlbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBldmVudCA9IHsgdHlwZSA6IGV2ZW50IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFldmVudC50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBvYmplY3QgbWlzc2luZyAndHlwZScgcHJvcGVydHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycygpW2V2ZW50LnR5cGVdO1xuXG4gICAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAvLyBubyBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudCB0eXBlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsIGFsbCB0aGUgbGlzdGVuZXJzIGZvciB0aGlzIGV2ZW50IHR5cGUsIGV4Y2VwdCBmb3JcbiAgICAgICAgLy8gbnVsbHMsIHdoaWNoIHdlIGtlZXAgdHJhY2sgb2ZcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbnVsbHMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBhbnkgbnVsbHMgZnJvbSB0aGUgbGlzdGVuZXJzIGxpc3Q7IHdvcmsgZnJvbSB0aGUgZW5kXG4gICAgICAgIC8vIG9mIHRoZSBsaXN0IGJhY2t3YXJkcyBzbyB0aGF0IHJlbW92aW5nIGFuIGl0ZW0gZG9lc24ndCBjaGFuZ2VcbiAgICAgICAgLy8gdGhlIGluZGV4IG9mIG90aGVyIGl0ZW1zIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgaWYgKG51bGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaT1udWxscy5sZW5ndGgtMTsgaT49MDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShudWxsc1tpXSwxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgRmlsdGVyT3B0aW9uID0gcmVxdWlyZSgnLi9maWx0ZXJfb3B0aW9uLmpzJyk7XG5cbnZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMucGxvdC5maWx0ZXIpO1xuXG52YXIgRmlsdGVyID0gbmV3IGplcm1haW5lLk1vZGVsKFwiRmlsdGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhc01hbnkoXCJvcHRpb25zXCIpLmVhY2hPZldoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gb3B0aW9uIGluc3RhbmNlb2YgRmlsdGVyT3B0aW9uO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcInR5cGVcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKHR5cGUpID09PSBcInN0cmluZ1wiO1xuICAgIH0pO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLnBsb3QuZmlsdGVyLCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcjtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90LmZpbHRlci5vcHRpb24pO1xuXG52YXIgRmlsdGVyT3B0aW9uID0gbmV3IGplcm1haW5lLk1vZGVsKFwiRmlsdGVyT3B0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhc0EoXCJuYW1lXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZihuYW1lKSA9PT0gXCJzdHJpbmdcIjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJ2YWx1ZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIjtcbiAgICB9KTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5wbG90LmZpbHRlci5vcHRpb24sIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyT3B0aW9uO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgQXhpcyA9IHJlcXVpcmUoJy4vYXhpcy5qcycpLFxuICAgIEJhY2tncm91bmQgPSByZXF1aXJlKCcuL2JhY2tncm91bmQuanMnKSxcbiAgICBEYXRhID0gcmVxdWlyZSgnLi9kYXRhLmpzJyksXG4gICAgTGVnZW5kID0gcmVxdWlyZSgnLi9sZWdlbmQuanMnKSxcbiAgICBQbG90ID0gcmVxdWlyZSgnLi9wbG90LmpzJyksXG4gICAgUGxvdGFyZWEgPSByZXF1aXJlKCcuL3Bsb3RhcmVhLmpzJyksXG4gICAgVGl0bGUgPSByZXF1aXJlKCcuL3RpdGxlLmpzJyksXG4gICAgV2luZG93ID0gcmVxdWlyZSgnLi93aW5kb3cuanMnKSxcbiAgICBCb3ggPSByZXF1aXJlKCcuLi9tYXRoL2JveC5qcycpLFxuICAgIERhdGFQbG90ID0gcmVxdWlyZSgnLi4vY29yZS9kYXRhX3Bsb3QuanMnKSxcbiAgICBBeGlzQmluZGluZyA9IHJlcXVpcmUoJy4uL2NvcmUvYXhpc19iaW5kaW5nLmpzJyksXG4gICAgdmFyYWlibGVfaWRfcmVnZXggPSAvXihbXlxcLl0rKVxcLiguKykkLztcblxuXG4vKipcbiAqIFRoZSBHcmFwaCBKZXJtYWluZSBtb2RlbCBjb250cm9scyB0aGUgcHJvcGVydGllcyBmb3IgYW4gaW5kaXZpZHVhbCBHcmFwaC5cbiAqXG4gKiBAY2xhc3MgR3JhcGhcbiAqIEBmb3IgR3JhcGhcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzKTtcblxudmFyIEdyYXBoID0gbmV3IGplcm1haW5lLk1vZGVsKFwiR3JhcGhcIiwgZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENoaWxkIG1vZGVsIHdoaWNoIGNvbnRyb2xzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBHcmFwaCdzIFdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aW5kb3dcbiAgICAgKiBAdHlwZSB7V2luZG93fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJ3aW5kb3dcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodykge1xuICAgICAgICByZXR1cm4gdyBpbnN0YW5jZW9mIFdpbmRvdztcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDaGlsZCBtb2RlbCB3aGljaCBjb250cm9scyB0aGUgcHJvcGVydGllcyBvZiB0aGUgR3JhcGgncyBQbG90YXJlYS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwbG90YXJlYVxuICAgICAqIEB0eXBlIHtQbG90YXJlYX1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwicGxvdGFyZWFcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAocGxvdGFyZWEpIHtcbiAgICAgICAgcmV0dXJuIHBsb3RhcmVhIGluc3RhbmNlb2YgUGxvdGFyZWE7XG4gICAgfSk7XG5cblxuICAgIC8qKlxuICAgICAqIENoaWxkIG1vZGVsIHdoaWNoIGNvbnRyb2xzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBHcmFwaCdzIExlZ2VuZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsZWdlbmRcbiAgICAgKiBAdHlwZSB7TGVnZW5kfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJsZWdlbmRcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAobGVnZW5kKSB7XG4gICAgICAgIHJldHVybiBsZWdlbmQgaW5zdGFuY2VvZiBMZWdlbmQ7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ2hpbGQgbW9kZWwgd2hpY2ggY29udHJvbHMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIEdyYXBoJ3MgQmFja2dyb3VuZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBiYWNrZ3JvdW5kXG4gICAgICogQHR5cGUge0JhY2tncm91bmR9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImJhY2tncm91bmRcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYmFja2dyb3VuZCkge1xuICAgICAgICByZXR1cm4gYmFja2dyb3VuZCBpbnN0YW5jZW9mIEJhY2tncm91bmQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGlsZCBtb2RlbCB3aGljaCBjb250cm9scyB0aGUgcHJvcGVydGllcyBvZiB0aGUgR3JhcGgncyBUaXRsZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aXRsZVxuICAgICAqIEB0eXBlIHtUaXRsZX1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwidGl0bGVcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIHRpdGxlIGluc3RhbmNlb2YgVGl0bGU7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSmVybWFpbmUgQXR0cl9MaXN0IG9mIHRoZSBHcmFwaCdzIEF4ZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYXhlc1xuICAgICAqIEB0eXBlIHtBeGlzfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc01hbnkoXCJheGVzXCIpLmVhY2hPZldoaWNoLnZhbGlkYXRlV2l0aChmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICByZXR1cm4gYXhpcyBpbnN0YW5jZW9mIEF4aXM7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSmVybWlhbmUgQXR0cl9MaXN0IG9mIHRoZSBHcmFwaCdzIFBsb3RzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBsb3RzXG4gICAgICogQHR5cGUge1Bsb3R9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzTWFueShcInBsb3RzXCIpLmVhY2hPZldoaWNoLnZhbGlkYXRlV2l0aChmdW5jdGlvbiAocGxvdCkge1xuICAgICAgICByZXR1cm4gcGxvdCBpbnN0YW5jZW9mIFBsb3Q7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSmVybWlhbmUgQXR0cl9MaXN0IG9mIHRoZSBHcmFwaCdzIERhdGEgc2V0cy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAgICogQHR5cGUge0RhdGF9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzTWFueShcImRhdGFcIikuZWFjaE9mV2hpY2gudmFsaWRhdGVXaXRoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgRGF0YTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgY29tcHV0ZWQgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgR3JhcGgncyB3aW5kb3dCb3guXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd2luZG93Qm94XG4gICAgICogQHR5cGUge31cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwid2luZG93Qm94XCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgQm94O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgY29tcHV0ZWQgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgR3JhcGgncyBwYWRkaW5nQm94LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBhZGRpbmdCb3hcbiAgICAgKiBAdHlwZSB7fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJwYWRkaW5nQm94XCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgQm94O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgY29tcHV0ZWQgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgR3JhcGgncyBwbG90Qm94LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBsb3RCb3hcbiAgICAgKiBAdHlwZSB7fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJwbG90Qm94XCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgQm94O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRhaW5pbmcgTXVsdGlncmFwaCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBtdWx0aWdyYXBoXG4gICAgICogQHR5cGUge31cbiAgICAgKiBAYXV0aG9yIG1icFxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcIm11bHRpZ3JhcGhcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIC8vYXZvaWQgdXNpbmcgaW5zdGFuY2VvZiwgc28gd2UgZG9uJ3QgaGF2ZSB0byByZXF1aXJlKCdtdWx0aWdyYXBoLmpzJykgYWJvdmUhISFcbiAgICAgICAgLy9yZXR1cm4gdmFsIGluc3RhbmNlb2YgTXVsdGlncmFwaDtcbiAgICAgICAgLy9KdXN0IGNoZWNrIGZvciBidXN5U3Bpbm5lckxldmVsIGZ1bmN0aW9uLCBzaW5jZSB0aGF0J3MgdGhlIHBhcnQgb2YgdGhlXG4gICAgICAgIC8vbXVsdGlncmFwaCB0aGF0IHdlIHVzZSAoZHVjayB0eXBpbmcpLlxuICAgICAgICByZXR1cm4gKHR5cGVvZih2YWwuYnVzeVNwaW5uZXJMZXZlbCkgPT0gXCJmdW5jdGlvblwiKTtcbiAgICB9KTtcblxuICAgIHRoaXMuaGFzQShcIngwXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJ5MFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICB0aGlzLmhhc0EoXCJmaWx0ZXJcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuICgodHlwZW9mKGZpbHRlcikgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgKCh0eXBlb2YoZmlsdGVyLnJlc2V0KSA9PT0gJ2Z1bmN0aW9uJykgJiYgKHR5cGVvZihmaWx0ZXIuZmlsdGVyKSA9PT0gJ2Z1bmN0aW9uJykpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuaXNCdWlsdFdpdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndpbmRvdyggbmV3IFdpbmRvdygpICk7XG4gICAgICAgIHRoaXMucGxvdGFyZWEoIG5ldyBQbG90YXJlYSgpICk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCggbmV3IEJhY2tncm91bmQoKSApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwicG9zdFBhcnNlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIGhhbmRsZUFqYXhFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmFjdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5tdWx0aWdyYXBoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubXVsdGlncmFwaCgpLmJ1c3lTcGlubmVyTGV2ZWwoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmFjdGlvbiA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5tdWx0aWdyYXBoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubXVsdGlncmFwaCgpLmJ1c3lTcGlubmVyTGV2ZWwoLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGk9MDsgaTx0aGlzLmRhdGEoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhKCkuYXQoaSkuYWRkTGlzdGVuZXIoXCJhamF4RXZlbnRcIiwgaGFuZGxlQWpheEV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEdyYXBoJ3MgZ2VvbWV0cnkuIERldGVybWluZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIEdyYXBoJ3MgYHdpbmRvd0JveGAsXG4gICAgICogYHBhZGRpbmdCb3hgIGFuZCBgcGxvdEJveGA7IGNhbGxzIGl0cyBBeGVzJyBhbmQgTGVnZW5kJ3MgaW1wbGVtZW50YXRpb25zIG9mXG4gICAgICogYGluaXRpYWxpemVHZW9tZXRyeWAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVHZW9tZXRyeVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gd2lkdGggV2lkdGggb2YgdGhlIG11bHRpZ3JhcGgncyBkaXZcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGhlaWdodCBIZWlnaHQgb2YgdGhlIG11bHRpZ3JhcGgncyBkaXZcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhpY3NDb250ZXh0XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImluaXRpYWxpemVHZW9tZXRyeVwiLCBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIHZhciB3ICAgICAgICAgICAgICA9IHRoaXMud2luZG93KCksXG4gICAgICAgICAgICB3aW5kb3dCb3JkZXIgICA9IHcuYm9yZGVyKCksXG4gICAgICAgICAgICB3aW5kb3dNYXJnaW4gICA9IHcubWFyZ2luKCksXG4gICAgICAgICAgICB3aW5kb3dQYWRkaW5nICA9IHcucGFkZGluZygpLFxuICAgICAgICAgICAgcGxvdGFyZWEgICAgICAgPSB0aGlzLnBsb3RhcmVhKCksXG4gICAgICAgICAgICBwbG90YXJlYUJvcmRlciA9IHBsb3RhcmVhLmJvcmRlcigpLFxuICAgICAgICAgICAgcGxvdGFyZWFNYXJnaW4gPSBwbG90YXJlYS5tYXJnaW4oKSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgdGhpcy53aW5kb3dCb3goIG5ldyBCb3god2lkdGgsIGhlaWdodCkgKTtcbiAgICAgICAgdGhpcy5wYWRkaW5nQm94KCBuZXcgQm94KFxuICAgICAgICAgICAgKCB3aWR0aCAtXG4gICAgICAgICAgICAgICggd2luZG93TWFyZ2luLmxlZnQoKSAgKyB3aW5kb3dCb3JkZXIgKyB3aW5kb3dQYWRkaW5nLmxlZnQoKSApIC1cbiAgICAgICAgICAgICAgKCB3aW5kb3dNYXJnaW4ucmlnaHQoKSArIHdpbmRvd0JvcmRlciArIHdpbmRvd1BhZGRpbmcucmlnaHQoKSApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKCBoZWlnaHQgLVxuICAgICAgICAgICAgICAoIHdpbmRvd01hcmdpbi50b3AoKSAgICArIHdpbmRvd0JvcmRlciArIHdpbmRvd1BhZGRpbmcudG9wKCkgKSAtXG4gICAgICAgICAgICAgICggd2luZG93TWFyZ2luLmJvdHRvbSgpICsgd2luZG93Qm9yZGVyICsgd2luZG93UGFkZGluZy5ib3R0b20oKSApXG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wbG90Qm94KCBuZXcgQm94KFxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIHRoaXMucGFkZGluZ0JveCgpLndpZHRoKCkgLVxuICAgICAgICAgICAgICAgICAgICAoIHBsb3RhcmVhTWFyZ2luLmxlZnQoKSArIHBsb3RhcmVhTWFyZ2luLnJpZ2h0KCkgKyAoMiAqIHBsb3RhcmVhQm9yZGVyKSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nQm94KCkuaGVpZ2h0KCkgLVxuICAgICAgICAgICAgICAgICAgICAoIHBsb3RhcmVhTWFyZ2luLnRvcCgpICsgcGxvdGFyZWFNYXJnaW4uYm90dG9tKCkgKyAoMiAqIHBsb3RhcmVhQm9yZGVyKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5heGVzKCkuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYXhlcygpLmF0KGkpLmluaXRpYWxpemVHZW9tZXRyeSh0aGlzLCBncmFwaGljc0NvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZ2VuZCgpLmluaXRpYWxpemVHZW9tZXRyeSh0aGlzLCBncmFwaGljc0NvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpdGxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGl0bGUoKS5pbml0aWFsaXplR2VvbWV0cnkoZ3JhcGhpY3NDb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueDAoIHdpbmRvd01hcmdpbi5sZWZ0KCkgICArIHdpbmRvd0JvcmRlciArIHdpbmRvd1BhZGRpbmcubGVmdCgpICAgKyBwbG90YXJlYU1hcmdpbi5sZWZ0KCkgICArIHBsb3RhcmVhQm9yZGVyICk7XG4gICAgICAgIHRoaXMueTAoIHdpbmRvd01hcmdpbi5ib3R0b20oKSArIHdpbmRvd0JvcmRlciArIHdpbmRvd1BhZGRpbmcuYm90dG9tKCkgKyBwbG90YXJlYU1hcmdpbi5ib3R0b20oKSArIHBsb3RhcmVhQm9yZGVyICk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252aWVuY2UgZnVuY3Rpb24gZm9yIHJlZ2lzdGVyaW5nIGNhbGxiYWNrIGZ1bmN0aW9ucyBvbiB0aGUgR3JhcGgncyBgRGF0YWAgbW9kZWxzLiBBZGRzXG4gICAgICogYGRhdGFSZWFkeWAgZXZlbnQgbGlzdGVuZXJzIHRvIGVhY2ggb2YgdGhlIEdyYXBoJ3MgYERhdGFgIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJDb21tb25EYXRhQ2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZWdpc3RlckNvbW1vbkRhdGFDYWxsYmFja1wiLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGEoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhKCkuYXQoaSkuYWRkTGlzdGVuZXIoXCJkYXRhUmVhZHlcIiwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcGF1c2VBbGxEYXRhXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInBhdXNlQWxsRGF0YVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICAvLyBwYXVzZSBhbGwgdGhpcyBncmFwaCdzIGRhdGEgc291cmNlczpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YSgpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEoKS5hdChpKS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVzdW1lQWxsRGF0YVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJyZXN1bWVBbGxEYXRhXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIC8vIHJlc3VtZSBhbGwgdGhpcyBncmFwaCdzIGRhdGEgc291cmNlczpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YSgpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEoKS5hdChpKS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBmaW5kTmVhcmVzdEF4aXNcbiAgICAgKiBAcGFyYW0ge30geFxuICAgICAqIEBwYXJhbSB7fSB5XG4gICAgICogQHBhcmFtIHt9IG9yaWVudGF0aW9uXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImZpbmROZWFyZXN0QXhpc1wiLCBmdW5jdGlvbiAoeCwgeSwgb3JpZW50YXRpb24pIHtcbiAgICAgICAgdmFyIGZvdW5kQXhpcyA9IG51bGwsXG4gICAgICAgICAgICBtaW5kaXN0ID0gOTk5OSxcbiAgICAgICAgICAgIGF4ZXMgPSB0aGlzLmF4ZXMoKSxcbiAgICAgICAgICAgIG5heGVzID0gdGhpcy5heGVzKCkuc2l6ZSgpLFxuICAgICAgICAgICAgYXhpcyxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBkO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmF4ZXM7ICsraSkge1xuICAgICAgICAgICAgYXhpcyA9IGF4ZXMuYXQoaSk7XG4gICAgICAgICAgICBpZiAoIWF4aXMudmlzaWJsZSgpKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBpZiAoKG9yaWVudGF0aW9uID09PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgKG9yaWVudGF0aW9uID09PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgIChheGlzLm9yaWVudGF0aW9uKCkgPT09IG9yaWVudGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIGQgPSBheGlzLmRpc3RhbmNlVG9Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRBeGlzID09PSBudWxsIHx8IGQgPCBtaW5kaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQXhpcyA9IGF4aXM7XG4gICAgICAgICAgICAgICAgICAgIG1pbmRpc3QgPSBkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmRBeGlzO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiYXhpc0J5SWRcIiwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIC8vIHJldHVybiBhIHBvaW50ZXIgdG8gdGhlIGF4aXMgZm9yIHRoaXMgZ3JhcGggdGhhdCBoYXMgdGhlIGdpdmVuIGlkLCBpZiBhbnlcbiAgICAgICAgdmFyIGF4ZXMgPSB0aGlzLmF4ZXMoKSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBheGVzLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYXhlcy5hdChpKS5pZCgpID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBheGVzLmF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG5cblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImRhdGFCeUlkXCIsIGZ1bmN0aW9uKGlkKSB7IC8vICdpZCcgaXMgYSBzdHJpbmcgaWQgb2YgYSBkYXRhIG9iamVjdFxuICAgICAgICAvLyBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGRhdGEgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gZ3JhcGggaGF2aW5nIHRoZSBnaXZlbiBpZFxuICAgICAgICB2YXIgZGF0YXMgPSB0aGlzLmRhdGEoKSxcbiAgICAgICAgICAgIGRhdGE7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhcy5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGFzLmF0KGkpO1xuICAgICAgICAgICAgaWYgKGRhdGEuaWQoKSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwidmFyaWFibGVCeUlkXCIsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAvLyByZXR1cm4gYSBwb2ludGVyIHRvIHRoZSB2YXJpYWJsZSBmb3IgdGhpcyBncmFwaCB0aGF0IGhhcyB0aGUgZ2l2ZW4gaWQsIGlmIGFueVxuICAgICAgICB2YXIgZGF0YXMsXG4gICAgICAgICAgICByZSA9IC9eKFteXFwuXSspXFwuKC4rKSQvLFxuICAgICAgICAgICAgbSA9IGlkLm1hdGNoKHJlKSxcbiAgICAgICAgICAgIGRhdGFfaWQsXG4gICAgICAgICAgICB2YXJfaWQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgY29sdW1ucyxcbiAgICAgICAgICAgIGksIGo7XG5cbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGRhdGFfaWQgPSBtWzFdO1xuICAgICAgICAgICAgdmFyX2lkID0gbVsyXTtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGFCeUlkKGRhdGFfaWQpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuY29sdW1uSWRUb0RhdGFWYXJpYWJsZSh2YXJfaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YXMgPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhcy5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBkYXRhcy5hdChpKS5jb2x1bW5zKCk7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnMuc2l6ZSgpOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbnMuYXQoaikuaWQoKSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLmF0KGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwibm9ybWFsaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIEhPUklaT05UQUwgPSBBeGlzLkhPUklaT05UQUwsXG4gICAgICAgICAgICBWRVJUSUNBTCAgID0gQXhpcy5WRVJUSUNBTCxcbiAgICAgICAgICAgIGF4ZXMgID0gdGhpcy5heGVzKCksXG4gICAgICAgICAgICBwbG90cyA9IHRoaXMucGxvdHMoKSxcbiAgICAgICAgICAgIGksIGosXG4gICAgICAgICAgICBoYXhpc0NvdW50ID0gMCxcbiAgICAgICAgICAgIHZheGlzQ291bnQgPSAwLFxuICAgICAgICAgICAgYXhpcyxcbiAgICAgICAgICAgIGF4aXNpZCxcbiAgICAgICAgICAgIHBsb3Q7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbm9ybWFsaXplcyB0aGUgZGF0YSBzZWN0aW9uc1xuICAgICAgICAvL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhKCkuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSgpLmF0KGkpLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSGFuZGxlcyBtaXNzaW5nIGhvcml6b250YWxheGlzIGFuZCB2ZXJ0aWNhbCBheGlzIHRhZ3NcbiAgICAgICAgLy9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF4ZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChheGVzLmF0KGkpLm9yaWVudGF0aW9uKCkgPT09IEhPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICBoYXhpc0NvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF4ZXMuYXQoaSkub3JpZW50YXRpb24oKSA9PT0gVkVSVElDQUwpIHtcbiAgICAgICAgICAgICAgICB2YXhpc0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGF4aXNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgYXhlcy5hZGQobmV3IEF4aXMoSE9SSVpPTlRBTCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YXhpc0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBheGVzLmFkZChuZXcgQXhpcyhWRVJUSUNBTCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSGFuZGxlcyBtaXNzaW5nIGlkJ3MgZm9yIGF4ZXNcbiAgICAgICAgLy9cbiAgICAgICAgaGF4aXNDb3VudCA9IDA7XG4gICAgICAgIHZheGlzQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXhlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgYXhpcyA9IGF4ZXMuYXQoaSk7XG4gICAgICAgICAgICBpZiAoYXhpcy5vcmllbnRhdGlvbigpID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgYXhpc2lkID0gXCJ4XCI7XG4gICAgICAgICAgICAgICAgaWYgKGhheGlzQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNpZCArPSBoYXhpc0NvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXhpc0NvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF4aXMub3JpZW50YXRpb24oKSA9PT0gVkVSVElDQUwpIHtcbiAgICAgICAgICAgICAgICBheGlzaWQgPSBcInlcIjtcbiAgICAgICAgICAgICAgICBpZiAodmF4aXNDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpc2lkICs9IHZheGlzQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZheGlzQ291bnQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF4aXMuaWQoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYXhpcy5pZChheGlzaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbm9ybWFsaXplcyB0aGUgcmVzdCBvZiB0aGUgYXhpcyBwcm9wZXJ0aWVzXG4gICAgICAgIC8vXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBheGVzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICBheGVzLmF0KGkpLm5vcm1hbGl6ZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGhhbmRsZXMgbWlzc2luZyBwbG90IHRhZ3NcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHBsb3RzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgcGxvdHMuYWRkKG5ldyBEYXRhUGxvdCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIG5vcm1hbGl6ZXMgdGhlIHBsb3RzXG4gICAgICAgIC8vXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwbG90cy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgcGxvdHMuYXQoaSkubm9ybWFsaXplKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbm9ybWFsaXplcyB0aGUgbGVnZW5kXG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZ2VuZCgpLm5vcm1hbGl6ZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGV4ZWN1dGUgdGhlIHNldERhdGFSYW5nZSBtZXRob2QgZm9yIGVhY2ggYXhpcyBiaW5kaW5nLCB0byBzeW5jIHVwIGFsbCBheGVzXG4gICAgICAgIC8vIHRoYXQgcGFydGljaXBhdGUgaW4gdGhlIGJpbmRpbmcgKHRoaXMgdGFrZXMgY2FyZSBvZiBzZXR0aW5nIGRhdGFNaW4vZGF0YU1heFxuICAgICAgICAvLyBmb3IgYW55IGF4ZXMgdGhhdCBkb24ndCBoYXZlIHRoZW0gYWxyZWFkeSBidXQgd2hpY2ggYXJlIGJvdW5kIHRvIGF4ZXMgdGhhdFxuICAgICAgICAvLyBkbyBoYXZlIHRoZW0pXG4gICAgICAgIC8vIFxuICAgICAgICBBeGlzQmluZGluZy5zeW5jQWxsQmluZGluZ3MoKTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBhcnJhbmdlIHRvIHNldCBtaXNzaW5nIGF4aXMgbWluL21heCB2YWx1ZXMgd2hlbiBkYXRhIGlzIHJlYWR5LCBpZiBuZWNlc3NhcnlcbiAgICAgICAgLy8gXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBheGVzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBheGlzLi4uXG4gICAgICAgICAgICBheGlzID0gYXhlcy5hdChpKTtcbiAgICAgICAgICAgIGlmICghYXhpcy5oYXNEYXRhTWluKCkgfHwgIWF4aXMuaGFzRGF0YU1heCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBheGlzIGlzIG1pc2luZyBlaXRoZXIgYSBkYXRhTWluKCkgb3IgZGF0YU1heCgpIHZhbHVlLi4uXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBsb3RzLnNpemUoKTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgYSBEYXRhUGxvdCB0aGF0IHJlZmVyZW5jZXMgdGhpcyBheGlzLi4uXG4gICAgICAgICAgICAgICAgICAgIHBsb3QgPSBwbG90cy5hdChqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsb3QgaW5zdGFuY2VvZiBEYXRhUGxvdCAmJiAocGxvdC5ob3Jpem9udGFsYXhpcygpID09PSBheGlzIHx8IHBsb3QudmVydGljYWxheGlzKCkgPT09IGF4aXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIHRoZW4gcmVnaXN0ZXIgYSBkYXRhUmVhZHkgbGlzdGVuZXIgZm9yIHRoaXMgcGxvdCdzIGRhdGEgc2VjdGlvbiB3aGljaCBzZXRzIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlzc2luZyBib3VuZChzKSBvbiB0aGUgYXhpcyBvbmNlIHRoZSBkYXRhIGlzIHJlYWR5LiAgRG8gdGhpcyBpbnNpZGUgYSBjbG9zdXJlIHNvIHRoYXQgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiByZWZlciB0byBhIHBvaW50ZXIgdG8gb3VyIGR5bmFtaWNhbGx5LWRlZmluZWQgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSBpbnNpZGUgaXRzZWxmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gZGUtcmVnaXN0ZXIgaXQgb25jZSBpdCBpcyBjYWxsZWQ7IHRoaXMgaXMgZG9uZSB2aWEgdGhlIHRoZSBsb2NhbCB2YXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXhpc0JvdW5kc1NldHRlci4gIFRoZSBjbG9zdXJlIGFsc28gc2VydmVzIHRvIGNhcHR1cmUgdGhlIGN1cnJlbnQgdmFsdWVzLCB2aWEgYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIGF4aXMgcG9pbnRlciwgYSBwb2ludGVyIHRvIHRoZSBkYXRhIG9iamVjdCwgYW5kIGEgYm9vbGVhbiAoaXNIb3Jpem9udGFsKSB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGUgYXhpcyBpcyB0aGUgcGxvdCdzIGhvcml6b250YWwgb3IgdmVydGljYWwgYXhpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoYXhpcywgZGF0YSwgaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNCb3VuZHNTZXR0ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IGlzSG9yaXpvbnRhbCA/IDAgOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzID0gZGF0YS5nZXRCb3VuZHMoY29sdW1uTnVtYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IGF4aXMuZGF0YU1pbigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gYXhpcy5kYXRhTWF4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXhpcy5oYXNEYXRhTWluKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IGJvdW5kc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWF4aXMuaGFzRGF0YU1heCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBib3VuZHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzLmhhc0RhdGFNaW4oKSB8fCAhYXhpcy5oYXNEYXRhTWF4KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuc2V0RGF0YVJhbmdlKG1pbiwgbWF4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJlbW92ZUxpc3RlbmVyKCdkYXRhUmVhZHknLCBheGlzQm91bmRzU2V0dGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYWRkTGlzdGVuZXIoJ2RhdGFSZWFkeScsIGF4aXNCb3VuZHNTZXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShheGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwbG90LmRhdGEoKSwgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwbG90Lmhvcml6b250YWxheGlzKCkgPT09IGF4aXMgICAgLy8gaXNIb3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gZm9yIChqPTA7IGogPCB0aGlzLnBsb3RzKCkuc2l6ZSgpOyArK2opLi4uXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG5cbiAgICB9KTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcywgYXR0cmlidXRlcyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMuaG9yaXpvbnRhbGF4aXMuZ3JpZCk7XG5cbnZhciBHcmlkID0gbmV3IGplcm1haW5lLk1vZGVsKFwiR3JpZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXNBKFwiY29sb3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yIGluc3RhbmNlb2YgUkdCQ29sb3I7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwidmlzaWJsZVwiKS53aGljaC5pc0EoXCJib29sZWFuXCIpO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzLmdyaWQsIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZDtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5sZWdlbmQuaWNvbik7XG5cbnZhciBJY29uID0gbmV3IGplcm1haW5lLk1vZGVsKFwiSWNvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXNBKFwiaGVpZ2h0XCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG4gICAgdGhpcy5oYXNBKFwid2lkdGhcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJib3JkZXJcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5sZWdlbmQuaWNvbiwgYXR0cmlidXRlcyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJY29uO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9tYXRoL3BvaW50LmpzJyk7XG5cbnZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMuYmFja2dyb3VuZC5pbWcpO1xuXG52YXIgSW1nID0gbmV3IGplcm1haW5lLk1vZGVsKFwiSW1nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhc0EoXCJzcmNcIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuICAgIHRoaXMuaGFzQShcImFuY2hvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIGFuY2hvciBpbnN0YW5jZW9mIFBvaW50O1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImJhc2VcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICByZXR1cm4gYmFzZSBpbnN0YW5jZW9mIFBvaW50O1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcInBvc2l0aW9uXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbiBpbnN0YW5jZW9mIFBvaW50O1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImZyYW1lXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgIHJldHVybiBmcmFtZSA9PT0gSW1nLlBBRERJTkcgfHwgZnJhbWUgPT09IEltZy5QTE9UO1xuICAgIH0pO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJzcmNcIik7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMuYmFja2dyb3VuZC5pbWcsIGF0dHJpYnV0ZXMpO1xufSk7XG5cbkltZy5QQURESU5HID0gXCJwYWRkaW5nXCI7XG5JbWcuUExPVCAgICA9IFwicGxvdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltZztcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpLFxuICAgIERhdGFGb3JtYXR0ZXIgPSByZXF1aXJlKCcuL2RhdGFfZm9ybWF0dGVyLmpzJyksXG4gICAgRGF0YU1lYXN1cmUgPSByZXF1aXJlKCcuL2RhdGFfbWVhc3VyZS5qcycpLFxuICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vbWF0aC9wb2ludC5qcycpLFxuICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMuaG9yaXpvbnRhbGF4aXMubGFiZWxzLmxhYmVsKTtcblxudmFyIExhYmVsZXIgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJMYWJlbGVyXCIsIGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZU9yRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZih2YWx1ZU9yRnVuY3Rpb24pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZU9yRnVuY3Rpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZU9yRnVuY3Rpb247XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5oYXNBKFwiYXhpc1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHZhciBBeGlzID0gcmVxdWlyZSgnLi9heGlzLmpzJyk7XG4gICAgICAgIHJldHVybiBheGlzIGluc3RhbmNlb2YgQXhpcztcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJmb3JtYXR0ZXJcIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhRm9ybWF0dGVyLmlzSW5zdGFuY2UpO1xuICAgIHRoaXMuaGFzQShcImZvbnRcIikud2hpY2guaXNBKFwic3RyaW5nXCIpLmFuZC53aGljaC5kZWZhdWx0c1RvKFwiXCIpO1xuICAgIHRoaXMuaGFzQShcInN0YXJ0XCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YVZhbHVlLmlzSW5zdGFuY2UpO1xuICAgIHRoaXMuaGFzQShcImFuZ2xlXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJwb3NpdGlvblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJhbmNob3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBhbmNob3IgaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJzcGFjaW5nXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YU1lYXN1cmUuaXNJbnN0YW5jZSk7XG4gICAgdGhpcy5oYXNBKFwiZGVuc2l0eWZhY3RvclwiKS53aGljaC5pc0EoXCJudW1iZXJcIikuYW5kLndoaWNoLmRlZmF1bHRzVG8oMS4wKTtcblxuICAgIHRoaXMuaGFzQShcImNvbG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvciBpbnN0YW5jZW9mIFJHQkNvbG9yO1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNBKFwidmlzaWJsZVwiKS53aGljaC5pc0EoXCJib29sZWFuXCIpLmFuZC53aGljaC5kZWZhdWx0c1RvKHRydWUpO1xuXG4gICAgdGhpcy5pc0J1aWx0V2l0aChcImF4aXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFiZWxzRGVmYXVsdHMgPSBkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzLmxhYmVscztcbiAgICAgICAgaWYgKHRoaXMuYXhpcygpLnR5cGUoKSA9PT0gRGF0YVZhbHVlLkRBVEVUSU1FKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCBnZXRWYWx1ZShsYWJlbHNEZWZhdWx0c1snc3RhcnQtZGF0ZXRpbWUnXSkgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoIGdldFZhbHVlKGxhYmVsc0RlZmF1bHRzWydzdGFydC1udW1iZXInXSkgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaW5pdGlhbGl6ZUdlb21ldHJ5XCIsIGZ1bmN0aW9uIChncmFwaCkge1xuICAgICAgICB2YXIgYXhpcyAgICA9IHRoaXMuYXhpcygpLFxuICAgICAgICAgICAgcGxvdEJveCA9IGdyYXBoLnBsb3RCb3goKSxcbiAgICAgICAgICAgIGxhYmVsRGVmYXVsdHMgPSBkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzLmxhYmVscy5sYWJlbCxcbiAgICAgICAgICAgIEF4aXMgPSByZXF1aXJlKCcuL2F4aXMuanMnKTtcblxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChheGlzLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGlmIChheGlzLnBlcnBPZmZzZXQoKSA+IHBsb3RCb3guaGVpZ2h0KCkvMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCBnZXRWYWx1ZShsYWJlbERlZmF1bHRzW1wicG9zaXRpb24taG9yaXpvbnRhbC10b3BcIl0pICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiggZ2V0VmFsdWUobGFiZWxEZWZhdWx0c1tcInBvc2l0aW9uLWhvcml6b250YWwtYm90dG9tXCJdKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMucGVycE9mZnNldCgpID4gcGxvdEJveC53aWR0aCgpLzIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiggZ2V0VmFsdWUobGFiZWxEZWZhdWx0c1tcInBvc2l0aW9uLXZlcnRpY2FsLXJpZ2h0XCJdKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24oIGdldFZhbHVlKGxhYmVsRGVmYXVsdHNbXCJwb3NpdGlvbi12ZXJ0aWNhbC1sZWZ0XCJdKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuY2hvcigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChheGlzLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGlmIChheGlzLnBlcnBPZmZzZXQoKSA+IHBsb3RCb3guaGVpZ2h0KCkvMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvciggZ2V0VmFsdWUobGFiZWxEZWZhdWx0c1tcImFuY2hvci1ob3Jpem9udGFsLXRvcFwiXSkgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvciggZ2V0VmFsdWUobGFiZWxEZWZhdWx0c1tcImFuY2hvci1ob3Jpem9udGFsLWJvdHRvbVwiXSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChheGlzLnBlcnBPZmZzZXQoKSA+IHBsb3RCb3gud2lkdGgoKS8yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yKCBnZXRWYWx1ZShsYWJlbERlZmF1bHRzW1wiYW5jaG9yLXZlcnRpY2FsLXJpZ2h0XCJdKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yKCBnZXRWYWx1ZShsYWJlbERlZmF1bHRzW1wiYW5jaG9yLXZlcnRpY2FsLWxlZnRcIl0pICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJpc0VxdWFsRXhjZXB0Rm9yU3BhY2luZ1wiLCBmdW5jdGlvbiAobGFiZWxlcikge1xuICAgICAgICAvLyByZXR1cm4gdHJ1ZSBpZmYgdGhlIGdpdmVuIGxhYmVsZXIgYW5kIHRoaXMgbGFiZWxlciBhcmUgZXF1YWwgaW4gZXZlcnkgd2F5XG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlaXIgc3BhY2luZyB2YWx1ZXNcbiAgICAgICAgcmV0dXJuICgodGhpcy5heGlzKCkgICAgICAgICAgICAgICAgICAgICAgICAgPT09ICAgbGFiZWxlci5heGlzKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmZvcm1hdHRlcigpLmdldEZvcm1hdFN0cmluZygpICA9PT0gICBsYWJlbGVyLmZvcm1hdHRlcigpLmdldEZvcm1hdFN0cmluZygpICAgICApICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuc3RhcnQoKSAgICAgICAgICAgICAgICAgICAgICAgIC5lcSggIGxhYmVsZXIuc3RhcnQoKSAgICAgICAgICAgICAgICAgICAgICAgICApICkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5hbmdsZSgpICAgICAgICAgICAgICAgICAgICAgICAgPT09ICAgbGFiZWxlci5hbmdsZSgpICAgICAgICAgICAgICAgICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnBvc2l0aW9uKCkgICAgICAgICAgICAgICAgICAgICAuZXEoICBsYWJlbGVyLnBvc2l0aW9uKCkgICAgICAgICAgICAgICAgICAgICAgKSApICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuYW5jaG9yKCkgICAgICAgICAgICAgICAgICAgICAgIC5lcSggIGxhYmVsZXIuYW5jaG9yKCkgICAgICAgICAgICAgICAgICAgICAgICApICkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5kZW5zaXR5ZmFjdG9yKCkgICAgICAgICAgICAgICAgPT09ICAgbGFiZWxlci5kZW5zaXR5ZmFjdG9yKCkgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgKTtcbiAgICB9KTtcblxuXG4gICAgdGhpcy5oYXNBKFwiaXRlcmF0b3JOZXh0VmFsdWVcIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhVmFsdWUuaXNJbnN0YW5jZU9yTnVsbCkuYW5kLndoaWNoLmRlZmF1bHRzVG8obnVsbCk7XG4gICAgdGhpcy5oYXNBKFwiaXRlcmF0b3JNaW5WYWx1ZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFWYWx1ZS5pc0luc3RhbmNlKTtcbiAgICB0aGlzLmhhc0EoXCJpdGVyYXRvck1heFZhbHVlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YVZhbHVlLmlzSW5zdGFuY2UpO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwicHJlcGFyZVwiLCBmdW5jdGlvbiAobWluRGF0YVZhbHVlLCBtYXhEYXRhVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRvck1pblZhbHVlKG1pbkRhdGFWYWx1ZSk7XG4gICAgICAgIHRoaXMuaXRlcmF0b3JNYXhWYWx1ZShtYXhEYXRhVmFsdWUpO1xuICAgICAgICB0aGlzLml0ZXJhdG9yTmV4dFZhbHVlKCB0aGlzLnNwYWNpbmcoKS5maXJzdFNwYWNpbmdMb2NhdGlvbkF0T3JBZnRlcihtaW5EYXRhVmFsdWUsIHRoaXMuc3RhcnQoKSkgKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImhhc05leHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLml0ZXJhdG9yTmV4dFZhbHVlKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlKHRoaXMuaXRlcmF0b3JNYXhWYWx1ZSgpKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcInBlZWtOZXh0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlICAgID0gdGhpcy5pdGVyYXRvck5leHRWYWx1ZSgpLFxuICAgICAgICAgICAgbWF4VmFsdWUgPSB0aGlzLml0ZXJhdG9yTWF4VmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuZ3QobWF4VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcIm5leHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLml0ZXJhdG9yTmV4dFZhbHVlKCksXG4gICAgICAgICAgICBtYXhWYWx1ZSA9IHRoaXMuaXRlcmF0b3JNYXhWYWx1ZSgpO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4VmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5ndChtYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVyYXRvck5leHRWYWx1ZSggdmFsdWUuYWRkKCB0aGlzLnNwYWNpbmcoKSApICk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcImdldExhYmVsRGVuc2l0eVwiLCBmdW5jdGlvbiAoZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIHZhciBheGlzICAgICAgICAgICAgICAgICAgICAgID0gdGhpcy5heGlzKCksXG4gICAgICAgICAgICBwaXhlbFNwYWNpbmcgICAgICAgICAgICAgID0gdGhpcy5zcGFjaW5nKCkuZ2V0UmVhbFZhbHVlKCkgKiBheGlzLmF4aXNUb0RhdGFSYXRpbygpLFxuICAgICAgICAgICAgbWluUmVhbFZhbHVlICAgICAgICAgICAgICA9IGF4aXMuZGF0YU1pbigpLmdldFJlYWxWYWx1ZSgpLFxuICAgICAgICAgICAgbWF4UmVhbFZhbHVlICAgICAgICAgICAgICA9IGF4aXMuZGF0YU1heCgpLmdldFJlYWxWYWx1ZSgpLFxuICAgICAgICAgICAgcmVwcmVzZW50YXRpdmVSZWFsVmFsdWUgICA9IG1pblJlYWxWYWx1ZSArIDAuNTEyMzQ1NjcgKiAobWF4UmVhbFZhbHVlIC0gbWluUmVhbFZhbHVlKSxcbiAgICAgICAgICAgIHJlcHJlc2VudGF0aXZlVmFsdWUgICAgICAgPSBEYXRhVmFsdWUuY3JlYXRlKGF4aXMudHlwZSgpLCByZXByZXNlbnRhdGl2ZVJlYWxWYWx1ZSApLFxuICAgICAgICAgICAgcmVwcmVzZW50YXRpdmVWYWx1ZVN0cmluZyA9IHRoaXMuZm9ybWF0dGVyKCkuZm9ybWF0KHJlcHJlc2VudGF0aXZlVmFsdWUpLFxuICAgICAgICAgICAgQXhpcyAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vYXhpcy5qcycpO1xuXG4gICAgICAgIC8vIGxlbmd0aCBvZiB0aGUgZm9ybWF0dGVkIGF4aXMgcmVwcmVzZW50YXRpdmUgdmFsdWUsIGluIHBpeGVsc1xuICAgICAgICB2YXIgcGl4ZWxGb3JtYXR0ZWRWYWx1ZSA9IChcbiAgICAgICAgICAgIChheGlzLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuSE9SSVpPTlRBTCkgP1xuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVN0cmluZ1dpZHRoKGdyYXBoaWNzQ29udGV4dCwgcmVwcmVzZW50YXRpdmVWYWx1ZVN0cmluZykgOlxuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVN0cmluZ0hlaWdodChncmFwaGljc0NvbnRleHQsIHJlcHJlc2VudGF0aXZlVmFsdWVTdHJpbmcpXG4gICAgICAgICk7XG4gICAgICAgIC8vIHJldHVybiB0aGUgcmF0aW8gLS0gdGhlIGZyYWN0aW9uIG9mIHRoZSBzcGFjaW5nIHRha2VuIHVwIGJ5IHRoZSBmb3JtYXR0ZWQgc3RyaW5nXG4gICAgICAgIHJldHVybiBwaXhlbEZvcm1hdHRlZFZhbHVlIC8gKCBwaXhlbFNwYWNpbmcgKiB0aGlzLmRlbnNpdHlmYWN0b3IoKSApO1xuICAgIH0pO1xuXG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJtZWFzdXJlU3RyaW5nV2lkdGhcIiwgZnVuY3Rpb24gKGdyYXBoaWNzQ29udGV4dCwgc3RyaW5nKSB7XG4gICAgICAgIC8vIEdyYXBoaWNzIGRyaXZlcnMgc2hvdWxkIHJlcGxhY2UgdGhpcyBtZXRob2Qgd2l0aCBhbiBhY3R1YWwgaW1wbGVtZW50YXRpb247IHRoaXNcbiAgICAgICAgLy8gaXMganVzdCBhIHBsYWNlaG9sZGVyLiAgVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCByZXR1cm4gdGhlIHdpZHRoLCBpbiBwaXhlbHMsXG4gICAgICAgIC8vIG9mIHRoZSBnaXZlbiBzdHJpbmcuICBPZiBjb3Vyc2UgdGhpcyBpcyBkZXBlbmRlbnQgb24gZm9udCBjaG9pY2UsIHNpemUsIGV0YyxcbiAgICAgICAgLy8gYnV0IHdlIGdsb3NzIG92ZXIgdGhhdCBhdCB0aGUgbW9tZW50LiAgSnVzdCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgLy8gdXNpbmcgc29tZSByZWFzb25hYmxlIGRlZmF1bHQgZm9udCBmb3Igbm93LiAgTGF0ZXIgb24sIHdlJ2xsIG1vZGlmeSB0aGlzXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIHVzZSBmb250IGluZm9ybWF0aW9uLlxuICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aCozMDtcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJtZWFzdXJlU3RyaW5nSGVpZ2h0XCIsIGZ1bmN0aW9uIChncmFwaGljc0NvbnRleHQsIHN0cmluZykge1xuICAgICAgICAvLyBzZWUgY29tbWVudCBmb3IgbWVhc3VyZVN0cmluZ1dpZHRoKCkgYWJvdmVcbiAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGgqMzA7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwicmVuZGVyTGFiZWxcIiwgZnVuY3Rpb24gKGdyYXBoaWNzQ29udGV4dCwgdmFsdWUpIHtcbiAgICAgICAgLy8gR3JhcGhpY3MgZHJpdmVycyBzaG91bGQgcmVwbGFjZSB0aGlzIG1ldGhvZCB3aXRoIGFuIGFjdHVhbCBpbXBsZW1lbnRhdGlvbjsgdGhpc1xuICAgICAgICAvLyBpcyBqdXN0IGEgcGxhY2Vob2xkZXIuICBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGRyYXcgdGhlIHN0cmluZyBmb3IgdGhlIGdpdmVuXG4gICAgICAgIC8vIHZhbHVlLCBmb3JtYXR0ZWQgYnkgdGhlIGxhYmVsZXIncyBEYXRhRm9ybWF0dGVyLCBpbiB0aGUgbG9jYXRpb24gYWxvbmcgdGhlIGF4aXNcbiAgICAgICAgLy8gZGV0ZXJtaW5lZCBieSB0aGUgdmFsdWUgaXRzZWxmLCBhbmQgdGhlIGxhYmVsZXIncyBwb3NpdGlvbiwgYW5jaG9yLCBhbmQgYW5nbGVcbiAgICAgICAgLy8gYXR0cmlidXRlcy5cbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcIm5vcm1hbGl6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZhdWx0TnVtYmVyRm9ybWF0ICAgPSBcIiUuMWZcIixcbiAgICAgICAgICAgIGRlZmF1bHREYXRldGltZUZvcm1hdCA9IFwiJVktJU0tJUQgJUg6JWlcIixcbiAgICAgICAgICAgIGxhYmVsZXJGb3JtYXQsXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5heGlzKCkudHlwZSgpO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIERldGVybWluZXMgZGVmYXVsdCB2YWx1ZXMgb2YgbGFiZWxlciBhdHRyaWJ1dGVzIGJhc2VkIG9uIGF4aXMgdHlwZVxuICAgICAgICAvL1xuICAgICAgICBpZiAodHlwZSA9PT0gRGF0YVZhbHVlLkRBVEVUSU1FKSB7XG4gICAgICAgICAgICBsYWJlbGVyRm9ybWF0ID0gZGVmYXVsdERhdGV0aW1lRm9ybWF0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFiZWxlckZvcm1hdCA9IGRlZmF1bHROdW1iZXJGb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBJbnNlcnRzIGxhYmVsZXIgZGVmYXVsdHNcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0dGVyKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZXIoRGF0YUZvcm1hdHRlci5jcmVhdGUodHlwZSwgbGFiZWxlckZvcm1hdCkpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcy5sYWJlbHMubGFiZWwsIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGFiZWxlcjtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vbWF0aC9wb2ludC5qcycpLFxuICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICBJY29uID0gcmVxdWlyZSgnLi9pY29uLmpzJyksXG4gICAgUGxvdCA9IHJlcXVpcmUoJy4vcGxvdC5qcycpLFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICB2YWxpZGF0aW9uRnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC92YWxpZGF0aW9uRnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMubGVnZW5kKTtcblxuLyoqXG4gKiBMZWdlbmQgaXMgYSBKZXJtYWluZSBtb2RlbCB0aGF0IHN1cHBvcnRzIHRoZSByZW5kZXJpbmcgb2YgTXVsdGlncmFwaCBMZWdlbmRzLlxuICogXG4gKiBUaGUgbWV0aG9kcyBmb3IgdGhpcyBvYmplY3QgdGFrZSBhIHBhcmFtZXRlciBjYWxsZWQgYGdyYXBoaWNzQ29udGV4dGAsIHdoaWNoIGlzIGFcbiAqIGRyaXZlci1zcGVjaWZpYyBvYmplY3QgdGhhdCBzdG9yZXMgd2hhdGV2ZXIgc3RhdGUvY29uZmlndXJhdGlvbiBpcyBuZWVkZWQgYnkgdGhlXG4gKiBkcml2ZXIuICBFYWNoIGRyaXZlciBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgaXRzIG93biBncmFwaGljc0NvbnRleHQgb2JqZWN0IGFuZFxuICogcGFzc2luZyBpdCB0byB0aGVzZSBtZXRob2RzLCB3aGljaCBpbiB0dXJuIHBhc3MgdGhhdCBvYmplY3Qgb24gdG8gdGhlIGRyaXZlci1zcGVjaWZpY1xuICogbWV0aG9kcyB0aGF0IHRoZXkgY2FsbC5cbiAqIFxuICogQGNsYXNzIExlZ2VuZFxuICogQGZvciBMZWdlbmRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHJlcXVpcmVzIFBvaW50LFJHQkNvbG9yLFBsb3QsSWNvblxuICovXG52YXIgTGVnZW5kID0gbmV3IGplcm1haW5lLk1vZGVsKFwiTGVnZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgbGVnZW5kIHdpbGwgYmUgcmVuZGVyZWQ7IGEgdmFsdWUgb2YgYHRydWVgIG1lYW5zIHRoZSBMZWdlbmQgd2lsbFxuICAgICAqIGJlIGRyYXduIHdoaWxlIGBmYWxzZWAgbWVhbnMgdGhhdCBpdCB3aWxsIG5vdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInZpc2libGVcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZpc2libGUgPT09IFwiYm9vbGVhblwiIHx8IHZpc2libGUgPT09IG51bGw7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggZ2l2ZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBiYXNlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBMZWdlbmQncyBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBiYXNlXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJiYXNlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGJhc2UgaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB3aGljaCBnaXZlcyB0aGUgbG9jYXRpb24gb2YgdGhlIExlZ2VuZCdzIGFuY2hvciBwb2ludCB0byBiZSBhdHRhY2hlZCB0byB0aGUgYmFzZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBhbmNob3JcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQW4oXCJhbmNob3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBhbmNob3IgaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEEgY29vcmRpbmF0ZSBwYWlyIG9mIHBpeGVsIG9mZnNldHMgZm9yIHRoZSBiYXNlIHBvaW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJwb3NpdGlvblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB3aGljaCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGxlZ2VuZCBpcyBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIHRoZSBwbG90IGFyZWEgb3IgdGhlIHBhZGRpbmdcbiAgICAgKiBib3guIEEgdmFsdWUgb2YgYHBsb3RgIG1lYW5zIHRoZSBMZWdlbmQgd2lsbCBiZSBkcmF3biByZWxhdGl2ZSB0byB0aGUgcGxvdCBhcmVhIHdoaWxlIGBwYWRkaW5nYCBtZWFuc1xuICAgICAqIHRoYXQgaXQgd2lsbCB0aGUgcGFkZGluZyBib3guXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZnJhbWVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJmcmFtZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICByZXR1cm4gZnJhbWUgPT09IFwicGxvdFwiIHx8IGZyYW1lID09PSBcInBhZGRpbmdcIjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB3aGljaCBkZXRlcm1pbmVzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBMZWdlbmQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29sb3JcbiAgICAgKiBAdHlwZSB7UkdCQ29sb3J9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImNvbG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvciBpbnN0YW5jZW9mIFJHQkNvbG9yO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGRldGVybWluZXMgdGhlIGJvcmRlcmNvbG9yIG9mIHRoZSBMZWdlbmQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm9yZGVyY29sb3JcbiAgICAgKiBAdHlwZSB7UkdCQ29sb3J9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImJvcmRlcmNvbG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGJvcmRlcmNvbG9yKSB7XG4gICAgICAgIHJldHVybiBib3JkZXJjb2xvciBpbnN0YW5jZW9mIFJHQkNvbG9yO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGRldGVybWluZXMgdGhlIG9wYWNpdHkgb2YgdGhlIExlZ2VuZDsgZGVwZW5kaW5nIG9uIHdoZXJlIHRoZSBMZWdlbmQgaXMgcG9zaXRpb25lZCBpdFxuICAgICAqIG1heSBvYnNjdXJlIHBhcnRzIG9mIHRoZSBwbG90IGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3BhY2l0eVxuICAgICAqIEB0eXBlIHtGbG9hdH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwib3BhY2l0eVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChvcGFjaXR5KSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uRnVuY3Rpb25zLnZhbGlkYXRlTnVtYmVyUmFuZ2Uob3BhY2l0eSwgMC4wLCAxLjApO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHdoaWNoIGRldGVybWluZXMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgYm9yZGVyIGRyYXduIGFyb3VuZCB0aGUgTGVnZW5kOyBhIHZhbHVlIG9mIGAwYCB0dXJuc1xuICAgICAqIHRoZSBib3JkZXIgb2ZmLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvcmRlclxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJib3JkZXJcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB3aGljaCBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2Ygcm93cyB0byBiZSB1c2VkIGZvciBQbG90IGVudHJpZXMgaW4gdGhlIExlZ2VuZC4gSWYgbGVmdFxuICAgICAqIHVuc3BlY2lmaWVkIHRoZW4gcm93cyB3aWxsIGJlIGluc2VydGVkIHRvIGFjY291bnQgZm9yIGVhY2ggUGxvdCBlbnRyeS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByb3dzXG4gICAgICogQHR5cGUge0ludGVnZXJ9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInJvd3NcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKS5hbmQuaXNHcmVhdGVyVGhhbigwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB3aGljaCBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgY29sdW1ucyB0byBiZSB1c2VkIGZvciBQbG90IGVudHJpZXMgaW4gdGhlIExlZ2VuZC4gSWYgcm93c1xuICAgICAqIGlzIHNldCB3aGlsZSBjb2x1bW5zIGlzIGxlZnQgdW5zcGVjaWZpZWQgdGhlbiBjb2x1bW5zIHdpbGwgYmUgaW5zZXJ0ZWQgdG8gYWNjb3VudCBmb3IgZWFjaCBQbG90XG4gICAgICogZW50cnkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29sdW1uc1xuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJjb2x1bW5zXCIpLndoaWNoLmlzQShcImludGVnZXJcIikuYW5kLmlzR3JlYXRlclRoYW4oMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb3JuZXJzIG9mIHRoZSBsZWdlbmQgYm94IGFyZSByb3VuZGVkIHdoZW4gZHJhd24uIEEgdmFsdWUgb2ZcbiAgICAgKiBgMGAgbWVhbnMgdGhhdCB0aGUgY29ybmVycyB3aWxsIGJlIGRyYXduIHNxdWFyZSB3aGlsZSB2YWx1ZXMgZ3JlYXRlciB0aGFuIGAwYCBtZWFuIHRoYXQgdGhlIGNvcm5lcnNcbiAgICAgKiBhcmUgcm91bmRlZCBvZmYgd2l0aCBjaXJjbGVzIHdob3NlIHJhZGl1cyBpbiBwaXhlbHMgaXMgdGhpcyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb3JuZXJyYWRpdXNcbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiY29ybmVycmFkaXVzXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgcGl4ZWwgd2lkdGggb2YgdGhlIHBhZGRpbmcgYmV0d2VlbiB0aGUgTGVnZW5kIGJvcmRlciBhbmQgaXRzIGVudHJpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGFkZGluZ1xuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJwYWRkaW5nXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBBIG9wdGlvbmFsIHN1Yi1tb2RlbCB3aGljaCBkZXRlcm1pbmVzIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBJY29ucyBmb3IgdGhlIFBsb3QgZW50cmllcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpY29uXG4gICAgICogQHR5cGUge0ljb259XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQW4oXCJpY29uXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGljb24pIHtcbiAgICAgICAgcmV0dXJuIGljb24gaW5zdGFuY2VvZiBJY29uO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pc0J1aWx0V2l0aChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWNvbiggbmV3IEljb24oKSApO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUG9pbnRlcnMgdG8gUGxvdCBtb2RlbHMgdGhhdCBoYXZlIGVudHJpZXMgaW4gdGhlIExlZ2VuZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwbG90c1xuICAgICAqIEB0eXBlIHtQbG90fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc01hbnkoXCJwbG90c1wiKS5lYWNoT2ZXaGljaC52YWxpZGF0ZVdpdGgoZnVuY3Rpb24gKHBsb3QpIHtcbiAgICAgICAgcmV0dXJuIHBsb3QgaW5zdGFuY2VvZiBQbG90O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgdmFsdWUgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIHBpeGVscyBiZXR3ZWVuIGFuIGVudHJpZXMgaWNvbiBhbmQgaXRzIGJvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpY29uT2Zmc2V0XG4gICAgICogQHR5cGUge0ludGVnZXJ9XG4gICAgICogQGRlZmF1bHQgNVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZpbmFsXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImljb25PZmZzZXRcIikud2hpY2guaXNBbihcImludGVnZXJcIikuYW5kLmRlZmF1bHRzVG8oNSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB2YWx1ZSB3aGljaCBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gYW4gZW50cmllcyBsYWJlbCBhbmQgaXRzIGljb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGFiZWxPZmZzZXRcbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKiBAZGVmYXVsdCA1XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZmluYWxcbiAgICAgKiBAdHlwZSB7fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJsYWJlbE9mZnNldFwiKS53aGljaC5pc0FuKFwiaW50ZWdlclwiKS5hbmQuZGVmYXVsdHNUbyg1KTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHZhbHVlIHdoaWNoIGRldGVybWluZXMgdGhlIG51bWJlciBvZiBwaXhlbHMgYmV0d2VlbiB0aGUgcmlnaHQgZW5kIG9mIGFuIGVudHJpZXMgbGFiZWwgYW5kXG4gICAgICogaXRzIGJvcmRlclxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxhYmVsRW5kaW5nXG4gICAgICogQHR5cGUge0ludGVnZXJ9XG4gICAgICogQGRlZmF1bHQgMTVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmaW5hbFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJsYWJlbEVuZGluZ1wiKS53aGljaC5pc0FuKFwiaW50ZWdlclwiKS5kZWZhdWx0c1RvKDE1KTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVkIHZhbHVlIG9mIHRoZSB3aWR0aCBvZiB0aGUgTGVnZW5kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdpZHRoXG4gICAgICogQHR5cGUge0Zsb2F0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZpbmFsXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcIndpZHRoXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVkIHZhbHVlIG9mIHRoZSBoZWlnaHQgb2YgdGhlIExlZ2VuZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSB7RmxvYXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZmluYWxcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiaGVpZ2h0XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVkIGB4YCB2YWx1ZSBvZiB0aGUgTGVnZW5kJ3MgbG93ZXIgbGVmdCBjb3JuZXIgcmVsYXRpdmUgdG8gaXRzIGZyYW1lLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHhcbiAgICAgKiBAdHlwZSB7RmxvYXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZmluYWxcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwieFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlZCBgeWAgdmFsdWUgb2YgdGhlIExlZ2VuZCdzIGxvd2VyIGxlZnQgY29ybmVyIHJlbGF0aXZlIHRvIGl0cyBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB5XG4gICAgICogQHR5cGUge0Zsb2F0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZpbmFsXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInlcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZWQgd2lkdGggb2YgYW4gaW5kaXZpZHVhbCBwbG90IGVudHJ5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJsb2NrV2lkdGhcbiAgICAgKiBAdHlwZSB7RmxvYXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZmluYWxcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYmxvY2tXaWR0aFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlZCBoZWlnaHQgb2YgYW4gaW5kaXZpZHVhbCBwbG90IGVudHJ5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJsb2NrSGVpZ2h0XG4gICAgICogQHR5cGUge0Zsb2F0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZpbmFsXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImJsb2NrSGVpZ2h0XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVkIHdpZHRoIG9mIHRoZSBsb25nZXN0IGxhYmVsIG9mIGFsbCBwbG90IGVudHJpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbWF4TGFiZWxXaWR0aFxuICAgICAqIEB0eXBlIHtGbG9hdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmaW5hbFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJtYXhMYWJlbFdpZHRoXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gdmFsdWUgb2YgdGhlIEljb24ncyBoZWlnaHQgYW5kIHRoZSBjb21wdXRlZCBoZWlnaHQgb2YgdGhlIHRhbGxlc3QgbGFiZWwgb2YgYWxsIHBsb3QgZW50cmllcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBtYXhMYWJlbEhlaWdodFxuICAgICAqIEB0eXBlIHtGbG9hdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmaW5hbFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJtYXhMYWJlbEhlaWdodFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJkZXRlcm1pbmVWaXNpYmlsaXR5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnZpc2libGUoKSkge1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgaWYgKHRoaXMucGxvdHMoKS5zaXplKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIExlZ2VuZCdzIGdlb21ldHJ5LiBEZXRlcm1pbmVzIHZhbHVlcyBmb3IgdGhlIGludGVybmFsIGF0dHJpYnV0ZXMgYG1heExhYmVsV2lkdGhgLFxuICAgICAqIGBtYXhMYWJlbEhlaWdodGAsIGBibG9ja1dpZHRoYCwgYGJsb2NrSGVpZ2h0YCwgYHdpZHRoYCwgYGhlaWdodGAsIGB4YCBhbmQgYHlgOyB0aGVzZSB2YWx1ZXNcbiAgICAgKiBkZXRlcm1pbmUgdGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgYW5kIGl0cyB2YXJpb3VzIGludGVybmFsIGNvbXBvbmVudHMsIGFuZCBuZWVkXG4gICAgICogdG8gYmUgcmVjb21wdXRlZCB3aGVuZXZlciB0aGUgZ2VvbWV0cnkgb2YgdGhlIGNvbnRhaW5pbmcgZ3JhcGggY2hhbmdlczsgIHRoaXMgbWV0aG9kIGlzXG4gICAgICogY2FsbGVkIGJ5IEdyYXBoLmluaXRpYWxpemVHZW9tZXRyeSgpLlxuICAgICAqIFxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZUdlb21ldHJ5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoIEplcm1haW5lIEdyYXBoIG1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoaWNzQ29udGV4dCBkcml2ZXItc3BlY2lmaWMgZ3JhcGhpY3MgY29udGV4dCBvYmplY3RcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICogQHRvZG8gRmluZCBvdXQgd2hldGhlciBvciBub3QgcGFkZGluZyBuZWVkcyB0byBiZSB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24uXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaW5pdGlhbGl6ZUdlb21ldHJ5XCIsIGZ1bmN0aW9uIChncmFwaCwgZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgIHZhciBhbmNob3IgICAgID0gdGhpcy5hbmNob3IoKSxcbiAgICAgICAgICAgIGJhc2UgICAgICAgPSB0aGlzLmJhc2UoKSxcbiAgICAgICAgICAgIHBvc2l0aW9uICAgPSB0aGlzLnBvc2l0aW9uKCksXG4gICAgICAgICAgICBpY29uT2Zmc2V0ID0gdGhpcy5pY29uT2Zmc2V0KCksXG4gICAgICAgICAgICB3aWR0aHMgID0gW10sXG4gICAgICAgICAgICBoZWlnaHRzID0gW10sXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGV0ZXJtaW5lVmlzaWJpbGl0eSgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wbG90cygpLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHRoaXMucGxvdHMoKS5hdChpKS5sZWdlbmQoKS5sYWJlbCgpO1xuICAgICAgICAgICAgaWYgKGxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsYWJlbC5pbml0aWFsaXplR2VvbWV0cnkoZ3JhcGhpY3NDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB3aWR0aHMucHVzaChsYWJlbC5vcmlnV2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0cy5wdXNoKGxhYmVsLm9yaWdIZWlnaHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aWR0aHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgLSBhO1xuICAgICAgICB9KTtcbiAgICAgICAgaGVpZ2h0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYiAtIGE7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heExhYmVsV2lkdGgod2lkdGhzWzBdKTtcbiAgICAgICAgdGhpcy5tYXhMYWJlbEhlaWdodChNYXRoLm1heChoZWlnaHRzWzBdLCB0aGlzLmljb24oKS5oZWlnaHQoKSkpO1xuXG4gICAgICAgIHRoaXMuYmxvY2tXaWR0aChpY29uT2Zmc2V0ICsgdGhpcy5pY29uKCkud2lkdGgoKSArIHRoaXMubGFiZWxPZmZzZXQoKSArIHRoaXMubWF4TGFiZWxXaWR0aCgpICsgdGhpcy5sYWJlbEVuZGluZygpKTtcbiAgICAgICAgdGhpcy5ibG9ja0hlaWdodChpY29uT2Zmc2V0ICsgdGhpcy5tYXhMYWJlbEhlaWdodCgpKTtcblxuICAgICAgICAvLyBUT0RPOiBmaW5kIG91dCB3aGV0aGVyIG9yIG5vdCBwYWRkaW5nIG5lZWRzIHRvIGJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvblxuICAgICAgICB0aGlzLndpZHRoKCgyICogdGhpcy5ib3JkZXIoKSkgKyAodGhpcy5jb2x1bW5zKCkgKiB0aGlzLmJsb2NrV2lkdGgoKSkpO1xuICAgICAgICB0aGlzLmhlaWdodCgoMiAqIHRoaXMuYm9yZGVyKCkpICsgKHRoaXMucm93cygpICogdGhpcy5ibG9ja0hlaWdodCgpKSArIGljb25PZmZzZXQpO1xuXG4gICAgICAgIGlmICh0aGlzLmZyYW1lKCkgPT09IFwicGFkZGluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLngoKChiYXNlLngoKSArIDEpICogZ3JhcGgucGFkZGluZ0JveCgpLndpZHRoKCkvMikgIC0gKChhbmNob3IueCgpICsgMSkgKiB0aGlzLndpZHRoKCkvMikgICsgcG9zaXRpb24ueCgpKTtcbiAgICAgICAgICAgIHRoaXMueSgoKGJhc2UueSgpICsgMSkgKiBncmFwaC5wYWRkaW5nQm94KCkuaGVpZ2h0KCkvMikgLSAoKGFuY2hvci55KCkgKyAxKSAqIHRoaXMuaGVpZ2h0KCkvMikgKyBwb3NpdGlvbi55KCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54KCgoYmFzZS54KCkgKyAxKSAqIGdyYXBoLnBsb3RCb3goKS53aWR0aCgpLzIpICAgICAtICgoYW5jaG9yLngoKSArIDEpICogdGhpcy53aWR0aCgpLzIpICArIHBvc2l0aW9uLngoKSk7XG4gICAgICAgICAgICB0aGlzLnkoKChiYXNlLnkoKSArIDEpICogZ3JhcGgucGxvdEJveCgpLmhlaWdodCgpLzIpICAgIC0gKChhbmNob3IueSgpICsgMSkgKiB0aGlzLmhlaWdodCgpLzIpICsgcG9zaXRpb24ueSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgbGVnZW5kOyBjYWxscyB2YXJpb3VzIGRyaXZlci1zcGVjaWZpYyBncmFwaGljcyBmdW5jdGlvbnMgdG8gZG8gdGhlXG4gICAgICogYWN0dWFsIGRyYXdpbmcgb2YgdGhlIHZhcmlvdXMgcGFydHMgb2YgdGhlIGxlZ2VuZCAoYmFja2dyb3VuZCwgYm9yZGVycywgaWNvbnMsXG4gICAgICogdGV4dCkuXG4gICAgICogXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoaWNzQ29udGV4dCBkcml2ZXItc3BlY2lmaWMgZ3JhcGhpY3MgY29udGV4dCBvYmplY3RcbiAgICAgKiBcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uIChncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgdmFyIHBsb3RzID0gdGhpcy5wbG90cygpLFxuICAgICAgICAgICAgaWNvbiAgPSB0aGlzLmljb24oKSxcbiAgICAgICAgICAgIGJsb2NreCwgYmxvY2t5LFxuICAgICAgICAgICAgaWNvbngsIGljb255LFxuICAgICAgICAgICAgbGFiZWx4LCBsYWJlbHksXG4gICAgICAgICAgICBwbG90Q291bnQgPSAwLFxuICAgICAgICAgICAgciwgYztcblxuICAgICAgICBpZiAodGhpcy5kZXRlcm1pbmVWaXNpYmlsaXR5KCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBlcmZvcm0gYW55IG5lY2Nlc2FyeSBzZXR1cFxuICAgICAgICB0aGlzLmJlZ2luKGdyYXBoaWNzQ29udGV4dCk7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgbGVnZW5kIGJveFxuICAgICAgICB0aGlzLnJlbmRlckxlZ2VuZChncmFwaGljc0NvbnRleHQpO1xuXG4gICAgICAgIGZvciAociA9IDA7IHIgPCB0aGlzLnJvd3MoKTsgcisrKSB7XG4gICAgICAgICAgICBpZiAocGxvdENvdW50ID49IHBsb3RzLnNpemUoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2t5ID0gdGhpcy5ib3JkZXIoKSArICgodGhpcy5yb3dzKCkgLSByIC0gMSkgKiB0aGlzLmJsb2NrSGVpZ2h0KCkpO1xuICAgICAgICAgICAgaWNvbnkgID0gYmxvY2t5ICsgdGhpcy5pY29uT2Zmc2V0KCk7XG4gICAgICAgICAgICBsYWJlbHkgPSBpY29ueTtcbiAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCB0aGlzLmNvbHVtbnMoKTsgYysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsb3RDb3VudCA+PSBwbG90cy5zaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJsb2NreCA9IHRoaXMuYm9yZGVyKCkgKyAoYyAqIHRoaXMuYmxvY2tXaWR0aCgpKTtcbiAgICAgICAgICAgICAgICBpY29ueCAgPSBibG9ja3ggKyB0aGlzLmljb25PZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBsYWJlbHggPSBpY29ueCArIGljb24ud2lkdGgoKSArIHRoaXMubGFiZWxPZmZzZXQoKTtcblxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhlIGljb25cbiAgICAgICAgICAgICAgICBwbG90cy5hdChwbG90Q291bnQpLnJlbmRlcmVyKCkucmVuZGVyTGVnZW5kSWNvbihncmFwaGljc0NvbnRleHQsIGljb254LCBpY29ueSwgaWNvbiwgdGhpcy5vcGFjaXR5KCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhlIGljb24gYm9yZGVyXG4gICAgICAgICAgICAgICAgaWYgKGljb24uYm9yZGVyKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGljb24ucmVuZGVyQm9yZGVyKGdyYXBoaWNzQ29udGV4dCwgaWNvbngsIGljb255LCB0aGlzLm9wYWNpdHkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSB0ZXh0XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbChwbG90cy5hdChwbG90Q291bnQpLmxlZ2VuZCgpLmxhYmVsKCksIGdyYXBoaWNzQ29udGV4dCwgbGFiZWx4LCBsYWJlbHkpO1xuXG4gICAgICAgICAgICAgICAgcGxvdENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmVmb3JtIGFueSBuZWNjZXNhcnkgc3RlcHMgYXQgdGhlIGVuZCBvZiByZW5kZXJpbmdcbiAgICAgICAgdGhpcy5lbmQoZ3JhcGhpY3NDb250ZXh0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcIm5vcm1hbGl6ZVwiLCBmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgICAgICAgdmFyIGxlZ2VuZFBsb3RzID0gdGhpcy5wbG90cygpLFxuICAgICAgICAgICAgZ3JhcGhQbG90cyAgPSBncmFwaC5wbG90cygpLFxuICAgICAgICAgICAgY29sdW1ucyA9IHRoaXMuY29sdW1ucyxcbiAgICAgICAgICAgIHJvd3MgICAgPSB0aGlzLnJvd3MsXG4gICAgICAgICAgICBpLCBqLFxuICAgICAgICAgICAgZmxhZztcblxuICAgICAgICAvL1xuICAgICAgICAvLyBzdG9yZXMgcG9pbnRlcnMgdG8gcGxvdHMgd2l0aCBsZWdlbmRzIGluIHRoZSBMZWdlbmQgb2JqZWN0XG4gICAgICAgIC8vXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBncmFwaFBsb3RzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBkb2Vzbid0IGFkZCBhIHBsb3QgaWYgaXQgZG9lc24ndCBoYXZlIGEgdmlzaWJsZSBsZWdlbmRcbiAgICAgICAgICAgIGlmICghZ3JhcGhQbG90cy5hdChpKS5sZWdlbmQoKSB8fCBncmFwaFBsb3RzLmF0KGkpLmxlZ2VuZCgpLnZpc2libGUoKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb2Vzbid0IGFkZCBhIHBsb3QgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBhZGRlZFxuICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlZ2VuZFBsb3RzLnNpemUoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyYXBoUGxvdHMuYXQoaSkgPT09IGxlZ2VuZFBsb3RzLmF0KGopKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWdlbmRQbG90cy5hZGQoZ3JhcGhQbG90cy5hdChpKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcGxvdHMgaW4gdGhlIGxlZ2VuZCBkZWZhdWx0IHRvIDEgcm93IGFuZCBjb2x1bW4gaWYgdGhleSBhcmVuJ3Qgc3BlY2lmaWVkXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChsZWdlbmRQbG90cy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93cygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByb3dzKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaWYgbmVpdGhlciByb3dzIG5vciBjb2xzIGlzIHNwZWNpZmllZCwgZGVmYXVsdCB0byAxIGNvbFxuICAgICAgICAvL1xuICAgICAgICBpZiAocm93cygpID09PSB1bmRlZmluZWQgJiYgY29sdW1ucygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbHVtbnMoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBpZiBvbmx5IG9uZSBvZiByb3dzL2NvbHMgaXMgc3BlY2lmaWVkLCBjb21wdXRlIHRoZSBvdGhlclxuICAgICAgICAvL1xuICAgICAgICBpZiAoY29sdW1ucygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbHVtbnMocGFyc2VJbnQobGVnZW5kUGxvdHMuc2l6ZSgpIC8gcm93cygpICsgKCAobGVnZW5kUGxvdHMuc2l6ZSgpICUgcm93cygpKSA+IDAgPyAxIDogMCApLCAxMCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHJvd3MoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByb3dzKHBhcnNlSW50KGxlZ2VuZFBsb3RzLnNpemUoKSAvIGNvbHVtbnMoKSArICggKGxlZ2VuZFBsb3RzLnNpemUoKSAlIGNvbHVtbnMoKSkgPiAwID8gMSA6IDAgKSwgMTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLmxlZ2VuZCwgYXR0cmlidXRlcyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWdlbmQ7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbi8qKlxuICogVGhlIE1peGluIG1vZGVsIHByb3ZpZGVzIGEgY29udmVuaWVudCB3YXkgZm9yIEplcm1haW5lXG4gKiBhcHBsaWNhdGlvbnMgdG8gXCJtaXggaW5cIiBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHkgdG8gYSBtb2RlbCxcbiAqIGZyb20gb3V0c2lkZSB0aGUgbW9kZWwncyBpbml0aWFsIGRlZmluaXRpb24uXG4gKiBcbiAqIFRoZSBhYmlsaXR5IHRvIGFkZCBmZWF0dXJlcyAobWV0aG9kcyBhbmQvb3IgYXR0cmlidXRlcykgdG8gYVxuICogSmVybWFpbmUgbW9kZWwgb3V0c2lkZSBpdHMgaW5pdGlhbCBkZWZpbml0aW9uIGFscmVhZHkgZXhpc3RzIGluXG4gKiBKZXJtYWluZSAtLSB0aGlzIE1peGluIG1vZGVsIGRvZXMgbm90IGFjdHVhbGx5IGFkZCBuZXdcbiAqIGZ1bmN0aW9uYWxpdHkgdG8gSmVybWFpbmU7IGl0IGp1c3QgcHJvdmlkZXMgYSBjb252ZW5pZW50XG4gKiBwYXR0ZXJuIGZvciBncm91cGluZyBhZGRpdGlvbmFsIGZlYXR1cmVzIHRvZ2V0aGVyIGFuZCBhcHBseWluZ1xuICogdGhlbSB0byBhIG1vZGVsIGFzIGEgZ3JvdXAuXG4gKiBcbiAqIFRoZSBNaXhpbiBtb2RlbCBtYWludGFpbnMgYW4gaW50ZXJuYWwgbGlzdCBvZiBmdW5jdGlvbnMsIGNhbGxlZFxuICogbWl4aW4gZnVuY3Rpb25zLCBhbmQgcHJvdmlkZXMgYW4gYWRkKCkgbWV0aG9kIGZvciBhZGRpbmcgYVxuICogZnVuY3Rpb24gdG8gdGhhdCBsaXN0LlxuICogXG4gKiBUaGUgYXBwbHkoKSBtZXRob2QgY2FsbHMgYWxsIG9mIHRoZSBtaXhpbmZ1bmN0aW9ucyB0aGF0IGhhdmUgYmVlblxuICogYWRkZWQgdG8gdGhlIGxpc3QsIHBhc3NpbmcgZWFjaCBvbmUgdGhlIHNhbWUgYXJndW1lbnRzXG4gKiB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBhcHBseSgpIGZ1bmN0aW9uIGl0c2VsZi5cbiAqIFxuICogVGhhdCdzIGl0LiAgVGhhdCdzIGFsbCB0aGUgTWl4aW4gY2xhc3MgZG9lcy4gIEl0J3MgdXAgdG8geW91IHRvXG4gKiBwdXQgd2hhdGV2ZXIgamVybWFpbmUtbW9kZWwtZXh0ZW5kaW5nIGNvZGUgeW91IHdhbnQgaW4gdGhlXG4gKiBtaXhpbiBmdW5jdGlvbnMgeW91IGFkZCB0byB0aGUgTWl4aW47IHRoZSBNaXhpbiBzaW1wbHkgc2VydmVzXG4gKiBhcyBhIHBsYWNlIHRvIGhvbGQgdGhlbSBhbGwsIGFuZCBhIGNvbnZlbmllbnQgd2F5IHRvIGV4ZWN1dGVcbiAqIHRoZW0gYWxsIGF0IG9uY2UuXG4gKlxuICogQGNsYXNzIE1peGluXG4gKiBAZm9yIE1peGluXG4gKiBAYXV0aG9yIG1icFxuICovXG52YXIgTWl4aW4gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJNaXhpblwiLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJuYWwgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYmUgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBtaXhpbmZ1bmNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7fVxuICAgICAqIEBhdXRob3IgbWJwXG4gICAgICovXG4gICAgdGhpcy5oYXNNYW55KFwibWl4aW5mdW5jc1wiKTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHZhbHVlIGZvciB0cmFja2luZyB3aGV0aGVyIGFwcGx5KCkgaGFzIGJlZW4gY2FsbGVkXG4gICAgICogZm9yIHRoaXMgTWl4aW4uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYXBwbGllZFxuICAgICAqIEB0eXBlIHt9XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYXV0aG9yIG1icFxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImFwcGxpZWRcIikud2hpY2guaXNBKFwiYm9vbGVhblwiKS5kZWZhdWx0c1RvKGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmdW5jdGlvbiB0byB0aGlzIE1peGluJ3MgbWl4aW4gbGlzdC4gIERvZXMgbm90IGNoZWNrXG4gICAgICogdG8gc2VlIGlmIHRoZSBmdW5jdGlvbiBpcyBhbHJlYWR5IG9uIHRoZSBsaXN0IC0tIGp1c3QgYmxpbmRseVxuICAgICAqIGFwcGVuZHMgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0ge30gZnVuY1xuICAgICAqIEBhdXRob3IgbWJwXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiYWRkXCIsIGZ1bmN0aW9uIChtaXhpbmZ1bmMpIHtcbiAgICAgICAgdGhpcy5taXhpbmZ1bmNzKCkuYWRkKG1peGluZnVuYyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGVhY2ggb2YgdGhpcyBNaXhpbidzIG1peGluIGZ1bmN0aW9ucy4gIEFueVxuICAgICAqIGFyZ3VtZW50cyBwYXNzZWQgdG8gYXBwbHkoKSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRvIGVhY2hcbiAgICAgKiBtaXhpbiBmdW5jdGlvbiBjYWxsZWQuXG4gICAgICogXG4gICAgICogYXBwbHkoKSBjaGVja3MgdG8gc2VlIHdoZXRoZXIgaXQgaGFzIGV2ZXIgYmVlbiBjYWxsZWRcbiAgICAgKiBiZWZvcmUgZm9yIHRoaXMgTWl4aW4sIGFuZCBvbmx5IGV4ZWN1dGVzIHRoZSBtaXhpblxuICAgICAqIGZ1bmN0aW9ucyBpZiB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIHRvIGFwcGx5KCk7IGNhbGxzIHRvXG4gICAgICogYXBwbHkoKSBhZnRlciB0aGUgZmlyc3Qgb25lIHdpbGwgaGF2ZSBubyBlZmZlY3QuICAoVGhpcyBpc1xuICAgICAqIHRydWUgZXZlbiBpZiBhZGRpdGlvbmFsIG1peGluIGZ1bmN0aW9ucyBhcmUgYWRkZWQgYWZ0ZXJcbiAgICAgKiBhcHBseSgpIGlzIGNhbGxlZDsgdGhlIE1peGluIG1haW50YWlucyBhIHNpbmdsZSBpbnRlcm5hbFxuICAgICAqIEJvb2xlYW4gdmFsdWUgdGhhdCB0cmFja3Mgd2hldGhlciBhcHBseSgpIGhhcyBiZWVuIGNhbGxlZC4pXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFwcGx5XG4gICAgICogQGF1dGhvciBtYnBcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJhcHBseVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghIHRoaXMuYXBwbGllZCgpKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPHRoaXMubWl4aW5mdW5jcygpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taXhpbmZ1bmNzKCkuYXQoaSkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGxpZWQodHJ1ZSk7XG4gICAgfSk7XG5cblxuICAgIC8qKlxuICAgICAqIEp1c3QgbGlrZSBhcHBseSgpLCBidXQgZm9yY2VzIHRoZSBtaXhpbiBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkXG4gICAgICogcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGFwcGx5KCkgd2FzIHByZXZpb3VzbHkgY2FsbGVkIGZvciB0aGlzXG4gICAgICogTWl4aW4uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlYXBwbHlcbiAgICAgKiBAYXV0aG9yIG1icFxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInJlYXBwbHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFwcGxpZWQoZmFsc2UpO1xuICAgICAgICB0aGlzLmFwcGx5LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcbiAgICB9KTtcblxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNaXhpbjtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG52YXIgTXVsdGlncmFwaDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIGlmICh0eXBlb2YoTXVsdGlncmFwaCkgIT09IFwidW5kZWZpbmVkXCIpIHsgcmV0dXJuIE11bHRpZ3JhcGg7IH1cblxuICAgIHZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBNdWx0aWdyYXBoIEplcm1haW5lIG1vZGVsIGlzIHRoZSByb290IGNsYXNzIGZvciB0aGUganMtbXVsdGlncmFwaCBwcm9qZWN0LlxuICAgICAqXG4gICAgICogQGNsYXNzIE11bHRpZ3JhcGhcbiAgICAgKiBAZm9yIE11bHRpZ3JhcGhcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBNdWx0aWdyYXBoID0gbmV3IGplcm1haW5lLk1vZGVsKFwiTXVsdGlncmFwaFwiLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEplcm1pYW5lIEF0dHJfTGlzdCBvZiBhbGwgdGhlIGdyYXBocyBpbiBhIE11bHRpZ3JhcGguXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBncmFwaHNcbiAgICAgICAgICogQHR5cGUge0dyYXBofVxuICAgICAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc01hbnkoXCJncmFwaHNcIikuZWFjaE9mV2hpY2gudmFsaWRhdGVXaXRoKGZ1bmN0aW9uIChncmFwaCkge1xuICAgICAgICAgICAgdmFyIEdyYXBoID0gcmVxdWlyZSgnLi9ncmFwaC5qcycpO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXBoIGluc3RhbmNlb2YgR3JhcGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGl2IHRoZSBtdWx0aWdyYXBoIGlzIHJlbmRlcmVkIGluLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgZGl2XG4gICAgICAgICAqIEB0eXBlIHtIVE1MIEVsZW1lbnR9XG4gICAgICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQShcImRpdlwiKTsgLy8gdGhlIGFjdHVhbCBkaXYgZWxlbWVudFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXJsIGZvciB0aGUgbXVnbCBmaWxlIHRoaXMgZ3JhcGggd2FzIGNyZWF0ZWQgZnJvbSwgaWYgYW55XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBtdWdsXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBhdXRob3IgbWJwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0EoXCJtdWdsXCIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBKYXZhU2NyaXB0IGFycmF5IG9mIGFqYXggdGhyb3R0bGVzOyBlYWNoIGVudHJ5IGluIHRoaXMgYXJyYXkgaXMgYW5cbiAgICAgICAgICogb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiAgICByZWdleCAgICAgICAgOiByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIFVSTHNcbiAgICAgICAgICogICAgYWpheHRocm90dGxlIDogaW5zdGFuY2Ugb2YgJC5hamF4dGhyb3R0bGVcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhamF4dGhyb3R0bGVzXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQGF1dGhvciBtYnBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQShcImFqYXh0aHJvdHRsZXNcIik7XG5cbiAgICAgICAgdGhpcy5pc0J1aWx0V2l0aChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuYWpheHRocm90dGxlcyhbXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcImFkZEFqYXhUaHJvdHRsZVwiLCBmdW5jdGlvbiAocGF0dGVybiwgcmVxdWVzdHMsIHBlcmlvZCwgY29uY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5hamF4dGhyb3R0bGVzKCkucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVnZXggICAgICAgIDogcGF0dGVybiA/IG5ldyBSZWdFeHAocGF0dGVybikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgYWpheHRocm90dGxlIDogJC5hamF4dGhyb3R0bGUoe1xuICAgICAgICAgICAgICAgICAgICBudW1SZXF1ZXN0c1BlclRpbWVQZXJpb2QgOiBwYXJzZUludChyZXF1ZXN0cywxMCksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVQZXJpb2QgICAgICAgICAgICAgICA6IHBhcnNlSW50KHBlcmlvZCwgMTApLFxuICAgICAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW50ICAgICAgICAgICAgOiBwYXJzZUludChjb25jdXJyZW50LCAxMClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcImdldEFqYXhUaHJvdHRsZVwiLCBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3R0bGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAkLmVhY2godGhpcy5hamF4dGhyb3R0bGVzKCksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZWdleCB8fCB0aGlzLnJlZ2V4LnRlc3QodXJsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZSA9IHRoaXMuYWpheHRocm90dGxlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhyb3R0bGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gdHJhbnNmb3JtcyBhIGdpdmVuIFVSTCBzbyB0aGF0IGl0XG4gICAgICAgICAqIGlzIHJlbGF0aXZlIHRvIHRoZSBzYW1lIGJhc2UgYXMgdGhlIFVSTCBmcm9tIHdoaWNoIHRoZSBNVUdMXG4gICAgICAgICAqIGZpbGUgd2FzIGxvYWRlZC4gIElmIHRoaXMgZ3JhcGggd2FzIG5vdCBjcmVhdGVkIGZyb20gYSBNVUdMXG4gICAgICAgICAqIGZpbGUgKGVpdGhlciBpdCBjYW1lIGZyb20gYSBNVUdMIHN0cmluZywgb3Igd2FzIGNyZWF0ZWQgcHJvZ3JhbW1hdGljYWxseSksXG4gICAgICAgICAqIHRoZSBVUkwgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgICAgICAgKiBcbiAgICAgICAgICogSWYgdGhlIFVSTCB0byBiZSByZWJhc2VkIGlzIGFic29sdXRlIChjb250YWlucyAnOi8vJylcbiAgICAgICAgICogb3Igcm9vdC1yZWxhdGl2ZSAoc3RhcnRzIHdpdGggYSAnLycpLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBPdGhlcmlzZSwgdGhlIGdpdmVuIFVSTCBpcyByZWxhdGl2ZSwgYW5kIHdoaGF0IGlzIHJldHVybmVkIGlzIGFcbiAgICAgICAgICogbmV3IFVSTCBvYnRhaW5lZCBieSBpbnRlcnByZXRpbmcgaXQgcmVsYXRpdmUgdG8gdGhlIFVSTFxuICAgICAgICAgKiBmcm9tIHdoaWNoIHRoZSBNVUdMIHdhcyBsb2FkZWQuIFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNwb25kc1RvKFwicmViYXNlVXJsXCIsIGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgdmFyIGJhc2V1cmwgPSB0aGlzLm11Z2woKTtcbiAgICAgICAgICAgIGlmICghIGJhc2V1cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9eXFwvLy50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cmwgaXMgcm9vdC1yZWxhdGl2ZSAoc3RhcnRzIHdpdGggYSAnLycpOyByZXR1cm4gaXQgdW5tb2RpZmllZFxuICAgICAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLzpcXC9cXC8vLnRlc3QodXJsKSkge1xuICAgICAgICAgICAgICAgIC8vIHVybCBjb250YWlucyAnOi8vJywgc28gYXNzdW1lIGl0J3MgYSBmdWxsIHVybCwgcmV0dXJuIGl0IHVubW9kaWZpZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udmVydCBiYXNldXJsIHRvIGEgcmVhbCBiYXNlIHBhdGgsIGJ5IGVsaW1pbmF0aW5nIGFueSB1cmwgYXJncyBhbmRcbiAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpbmFsICcvJ1xuICAgICAgICAgICAgaWYgKCEvXlxcLy8udGVzdChiYXNldXJsKSAgJiYgIS86XFwvXFwvLy50ZXN0KGJhc2V1cmwpICYmICEvXlxcLlxcLy8udGVzdChiYXNldXJsKSkge1xuICAgICAgICAgICAgICAgIC8vIGZpcnN0IG1ha2Ugc3VyZSB0aGF0IGlmIGJhc2V1cmwgaXMgcmVsYXRpdmUsIGl0IHN0YXJ0cyB3aXRoICcuLydcbiAgICAgICAgICAgICAgICBiYXNldXJsID0gJy4vJyArIGJhc2V1cmw7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZXVybCA9IGJhc2V1cmwucmVwbGFjZSgvXFw/LiokLywgJycpOyAvLyByZW1vdmUgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgJz8nXG4gICAgICAgICAgICBiYXNldXJsID0gYmFzZXVybC5yZXBsYWNlKC9cXC9bXlxcL10qJC8sICcvJyk7IC8vIHJlbW92ZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBsYXN0ICcvJ1xuICAgICAgICAgICAgcmV0dXJuIGJhc2V1cmwgKyB1cmw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYnVzeSBzcGlubmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBidXN5U3Bpbm5lclxuICAgICAgICAgKiBAdHlwZSB7SFRNTCBFbGVtZW50fVxuICAgICAgICAgKiBAYXV0aG9yIG1icFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNBKFwiYnVzeVNwaW5uZXJcIik7IC8vIHRoZSBidXN5X3NwaW5uZXIgZGl2XG5cbiAgICAgICAgdGhpcy5yZXNwb25kc1RvKFwiYnVzeVNwaW5uZXJMZXZlbFwiLCBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1c3lTcGlubmVyKCkpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMuYnVzeVNwaW5uZXIoKSkuYnVzeV9zcGlubmVyKCdsZXZlbCcsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIE11bHRpZ3JhcGgncyBnZW9tZXRyeSBieSBjYWxsaW5nIHRoZSBgaW5pdGlhbGl6ZUdlb21ldHJ5YCBmdW5jdGlvbiBvZlxuICAgICAgICAgKiBlYWNoIG9mIGl0cyBncmFwaCBjaGlsZHJlbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBpbml0aWFsaXplR2VvbWV0cnlcbiAgICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSB3aWR0aCBXaWR0aCBvZiB0aGUgbXVsdGlncmFwaCdzIGRpdi5cbiAgICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSBtdWx0aWdyYXBoJ3MgZGl2LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhpY3NDb250ZXh0XG4gICAgICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcImluaXRpYWxpemVHZW9tZXRyeVwiLCBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgZ3JhcGhpY3NDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmdyYXBocygpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaHMoKS5hdChpKS5pbml0aWFsaXplR2VvbWV0cnkod2lkdGgsIGhlaWdodCwgZ3JhcGhpY3NDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZpZW5jZSBmdW5jdGlvbiBmb3IgcmVnaXN0ZXJpbmcgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBkYXRhIGJlY29taW5nIHJlYWR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyQ29tbW9uRGF0YUNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIHJlZ2lzdGVyZWQuXG4gICAgICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcInJlZ2lzdGVyQ29tbW9uRGF0YUNhbGxiYWNrXCIsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5ncmFwaHMoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhzKCkuYXQoaSkucmVnaXN0ZXJDb21tb25EYXRhQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJub3JtYWxpemVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5ncmFwaHMoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhzKCkuYXQoaSkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgY2FudmFzIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBicm93c2VySGFzQ2FudmFzU3VwcG9ydFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICBNdWx0aWdyYXBoLmJyb3dzZXJIYXNDYW52YXNTdXBwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXYXJuaW5nOiB0aGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdsb2JhbCB2YXJpYWJsZXMgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGBcbiAgICAgICAgLy8gLS0tIGl0IGRvZXMgbm90IHJlbHkgb24gdGhlc2UgdmFyaWFibGVzIGJlaW5nIHBhc3NlZCBpbiBhcyBpcyB0aGVcbiAgICAgICAgLy8gY2FzZSB3aXRoICckJyBhYm92ZS5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoISF3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQpICYmXG4gICAgICAgICAgICAgICAgKCEhd2luZG93LkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkgJiZcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhKGVsZW0uZ2V0Q29udGV4dCAmJiBlbGVtLmdldENvbnRleHQoJzJkJykpO1xuICAgICAgICAgICAgICAgIH0oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpKVxuICAgICAgICAgICAgKTtcbiAgICB9O1xuICAgIFxuICAgIE11bHRpZ3JhcGguYnJvd3Nlckhhc1NWR1N1cHBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdhcm5pbmc6IHRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgZ2xvYmFsIHZhcmlhYmxlIGBkb2N1bWVudGBcbiAgICAgICAgLy8gLS0tIGl0IGRvZXMgbm90IHJlbHkgb24gdGhpcyB2YXJpYWJsZSBiZWluZyBwYXNzZWQgaW4gYXMgaXMgdGhlXG4gICAgICAgIC8vIGNhc2Ugd2l0aCAnJCcgYWJvdmUuXG4gICAgICAgIHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJlxuICAgICAgICAgICAgISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgXCJzdmdcIikuY3JlYXRlU1ZHUmVjdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE11bHRpZ3JhcGggYWNjb3JkaW5nIHRvIHNwZWNpZmllZCBvcHRpb25zLiBSZXR1cm5zIGFcbiAgICAgKiBqUXVlcnkgYHByb21pc2VgIHdoaWNoIGludGVyYWN0cyB3aXRoIHRoZSBtdWx0aWdyYXBoIHRocm91Z2ggaXRzXG4gICAgICogYGRvbmVgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVHcmFwaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MIEVsZW1lbnR8alF1ZXJ5IE9iamVjdH0gb3B0aW9ucy5kaXYgKFJFUVVJUkVEKVxuICAgICAqICAgICAgVGhlIERPTSBlbGVtZW50IGRpdiBpbnRvIHdoaWNoIHRoZSBtdWx0aWdyYXBoIHNob3VsZCBiZVxuICAgICAqICAgICAgcGxhY2VkOyB0aGlzIHZhbHVlIG1heSBiZSBlaXRoZXIgKGEpIGEgc3RyaW5nIHdoaWNoIGlzIHRha2VuXG4gICAgICogICAgICB0byBiZSB0aGUgaWQgYXR0cmlidXRlIG9mIGEgZGl2IGluIHRoZSBwYWdlLCAoYikgYSByZWZlcmVuY2VcbiAgICAgKiAgICAgIHRvIHRoZSBkaXYgRE9NIGVsZW1lbnQgaXRzZWxmLCBvciAoYykgYSBqUXVlcnkgb2JqZWN0XG4gICAgICogICAgICBjb3JyZXNwb25kaW5nIHRvIHRoZSBkaXYgRE9NIGVsZW1lbnQuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtVUkl9IG9wdGlvbnMubXVnbCAoUkVRVUlSRUQsIHVubGVzcyBtdWdsU3RyaW5nIGlzIHByZXNlbnQpXG4gICAgICogICAgICAgdGhlIFVSTCBmcm9tIHdoaWNoIHRoZSBNVUdMXG4gICAgICogICAgICAgZmlsZSBmb3IgdGhlIE11bHRpZ3JhcGggY2FuIGJlIGxvYWRlZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLm11Z2xTdHJpbmcgKFJFUVVJUkVELCB1bmxlc3MgbXVnbCBpcyBwcmVzZW50KVxuICAgICAqICAgICAgIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIE1VR0wgWE1MIGZvciB0aGUgZ3JhcGhcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5kcml2ZXIgKE9QVElPTkFMKSBJbmRpY2F0ZXMgd2hpY2hcbiAgICAgKiAgICAgICBncmFwaGljcyBkcml2ZXIgdG8gdXNlOyBzaG91bGQgYmUgb25lIG9mIHRoZSBzdHJpbmdzXG4gICAgICogICAgICAgXCJjYW52YXNcIiwgXCJyYXBoYWVsXCIsIG9yIFwiYXV0b1wiLiAgVGhlIGRlZmF1bHQgKHdoaWNoIGlzXG4gICAgICogICAgICAgdXNlZCBpZiB0aGUgJ2RyaXZlcicgdGFnIGlzIGFic2VudCkgaXMgXCJhdXRvXCIsIHdoaWNoXG4gICAgICogICAgICAgY2F1c2VzIE11bHRpZ3JhcGggdG8gY2hlY2sgdGhlIGZlYXR1cmVzIG9mIHRoZSBicm93c2VyXG4gICAgICogICAgICAgaXQgaXMgcnVubmluZyBpbiBhbmQgY2hvb3NlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGRyaXZlci5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmVycm9yIChPUFRJT05BTCkgQSBmdW5jdGlvbiBmb3JcbiAgICAgKiAgICAgICBkaXNwbGF5aW5nIGVycm9yIG1lc3NhZ2VzIHRvIHRoZSB1c2VyLiAgTXVsdGlncmFwaCB3aWxsXG4gICAgICogICAgICAgY2FsbCB0aGlzIGZ1bmN0aW9uIGlmIGFuZCB3aGVuIGl0IGVuY291bnRlcnMgYW4gZXJyb3IuICBUaGVcbiAgICAgKiAgICAgICBmdW5jdGlvbiBzaG91bGQgcmVjZWl2ZSBhIHNpbmdsZSBhcmd1bWVudCB3aGljaCBpcyBhblxuICAgICAqICAgICAgIGluc3RhbmNlIG9mIHRoZSBKYXZhU2NyaXB0IEVycm9yIG9iamVjdC4gIFRoZSBkZWZhdWx0IGlzIHRvXG4gICAgICogICAgICAgdXNlIE11bHRpZ3JhcGgncyBvd24gaW50ZXJuYWwgbWVjaGFuaXNtIGZvciBkaXNwbGF5aW5nIHVzZXJcbiAgICAgKiAgICAgICBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMud2FybmluZyAoT1BUSU9OQUwpIEEgZnVuY3Rpb24gZm9yXG4gICAgICogICAgICAgZGlzcGxheWluZyB3YXJuaW5nIG1lc3NhZ2VzIHRvIHRoZSB1c2VyLiAgTXVsdGlncmFwaCB3aWxsXG4gICAgICogICAgICAgY2FsbCB0aGlzIGZ1bmN0aW9uIGlmIGFuZCB3aGVuIGl0IG5lZWRzIHRvIGRpc3BsYXkgYVxuICAgICAqICAgICAgIHdhcm5pbmcgbWVzc2FnZS4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZWNlaXZlIGEgc2luZ2xlXG4gICAgICogICAgICAgYXJndW1lbnQgd2hpY2ggaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIEphdmFTY3JpcHQgRXJyb3JcbiAgICAgKiAgICAgICBvYmplY3QuICBUaGUgZGVmYXVsdCBpcyB0byB1c2UgTXVsdGlncmFwaCdzIG93biBpbnRlcm5hbFxuICAgICAqICAgICAgIG1lY2hhbmlzbSBmb3IgZGlzcGxheWluZyB1c2VyIG1lc3NhZ2VzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IGpRdWVyeSBwcm9taXNlIHdoaWNoIHByb3ZpZGVzIGludGVyYWN0aW9uIHdpdGhcbiAgICAgKiAgICAgdGhlIGdyYXBoIHRocm91Z2ggaXRzIGBkb25lYCBmdW5jdGlvbi5cbiAgICAgKiBAYXV0aG9yIG1icFxuICAgICAqL1xuICAgIE11bHRpZ3JhcGguY3JlYXRlR3JhcGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZGl2ID0gb3B0aW9ucy5kaXYsXG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlcixcbiAgICAgICAgICAgIGRlZmF1bHRNZXNzYWdlSGFuZGxlcjtcblxuICAgICAgICAvLyAvLyBpZiBkcml2ZXIgd2Fzbid0IHNwZWNpZmllZCwgY2hvb3NlIHRoZSBiZXN0IGJhc2VkIG9uIGJyb3dzZXIgY2FwYWJpbGl0eVxuICAgICAgICAvLyBpZiAoIW9wdGlvbnMuZHJpdmVyKSB7XG4gICAgICAgIC8vICAgICBpZiAobnMuYnJvd3Nlckhhc0NhbnZhc1N1cHBvcnQoKSkge1xuICAgICAgICAvLyAgICAgICAgIG9wdGlvbnMuZHJpdmVyID0gXCJjYW52YXNcIjtcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICAgICAgb3B0aW9ucy5kcml2ZXIgPSBcInJhcGhhZWxcIjtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBGb3JjZSBjYW52YXMgZHJpdmVyIGZyb20gbm93IG9uOlxuICAgICAgICBvcHRpb25zLmRyaXZlciA9IFwiY2FudmFzXCI7XG5cbiAgICAgICAgLy8gaWYgZGl2IGlzIGEgc3RyaW5nLCBhc3N1bWUgaXQncyBhbiBpZCwgYW5kIGNvbnZlcnQgaXQgdG8gdGhlIGRpdiBlbGVtZW50IGl0c2VsZlxuICAgICAgICBpZiAodHlwZW9mKGRpdikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRpdiA9ICQoXCIjXCIgKyBkaXYpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yY2UgdGhlIGRpdiB0byBoYXZlIHRoZSBzcGVjaWZpYyB3aWR0aCBvciBoZWlnaHQgZ2l2ZW4gaW4gdGhlIG9wdGlvbnMsIGlmIGFueS5cbiAgICAgICAgLy8gSSdtIGFkZGluZyB0aGlzIGNvZGUgdG8gcmVzb2x2ZSBhIHByb2JsZW0gd2l0aCB0aGUgZGl2IHNpemUgc29tZXRpbWVzIG5vdCBiZWluZ1xuICAgICAgICAvLyBhdmFpbGFibGUgd2hlbiBzcmMvZ3JhcGhpY3MvY2FudmFzL211bHRpZ3JhcGguanM6Y3JlYXRlQ2FudmFzR3JhcGhGcm9tU3RyaW5nKClcbiAgICAgICAgLy8gaXMgdXNlZDsgc2VlIHRoZSBub3RlcyBpbiB0aGF0IGZpbGUuXG4gICAgICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy53aWR0aCA+IDApIHtcbiAgICAgICAgICAgICQoZGl2KS53aWR0aChvcHRpb25zLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICQoZGl2KS5oZWlnaHQob3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTk9URTogZWFjaCBvZiB0aGUgTXVsdGlncmFwaC5jcmVhdGV7RFJJVkVSfUdyYXBoIGZ1bmN0aW9ucyBiZWxvdyB0YWtlcyBhblxuICAgICAgICAvLyBcIm9wdGlvbnNcIiBvYmplY3QgYXJndW1lbnQganVzdCBsaWtlIE11bHRpZ3JhcGguY3JlYXRlR3JhcGggZG9lcy4gIEluIGdlbmVyYWwgdGhpc1xuICAgICAgICAvLyBcIm9wdGlvbnNcIiBvYmplY3QgaXMgdGhlIHNhbWUgYXMgdGhlIG9uZSBwYXNzZWQgdG8gdGhpcyBNdWx0aWdyYXBoLmNyZWF0ZUdyYXBoXG4gICAgICAgIC8vIGZ1bmN0aW9uLCBidXQgaXQgZGlmZmVycyBpbiBvbmUgd2F5OiBJbnN0ZWFkIG9mIGNvbnRhaW5pbmcgc2VwYXJhdGUgXCJlcnJvclwiIGFuZFxuICAgICAgICAvLyBcIndhcm5pbmdcIiBwcm9wZXJ0aWVzIHdoaWNoIGFyZSBvcHRpb25hbCwgdGhlIFwib3B0aW9uc1wiIG9iamVjdCBwYXNzZWQgdG8gdGhlXG4gICAgICAgIC8vIE11bHRpZ3JhcGguY3JlYXRle0RSSVZFUn1HcmFwaCBmdW5jdGlvbnMgcmVxdWlyZXMgYSBzaW5nbGUgKG5vbi1vcHRpb25hbCEpXG4gICAgICAgIC8vIFwibWVzc2FnZUhhbmRsZXJcIiBwcm9wZXJ0eSwgd2hpY2ggaW4gdHVybiBjb250YWlucyBcImVycm9yXCIgYW5kIFwid2FybmluZ1wiIHByb3BlcnRpZXNcbiAgICAgICAgLy8gd2hpY2ggYXJlIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgZXJyb3JzIGFuZCB3YXJuaW5ncywgcmVzcGVjdGl2ZWx5LiAgQm90aCB0aGVcbiAgICAgICAgLy8gXCJlcnJvclwiIGFuZCBhIFwid2FybmluZ1wiIHByb3BlcnRpZXMgbXVzdCBiZSBwcmVzZW50IGluIHRoZSBcIm1lc3NhZ2VIYW5kbGVyXCIgb2JqZWN0XG4gICAgICAgIC8vIGFuZCBtdXN0IHBvaW50IHRvIHZhbGlkIGZ1bmN0aW9ucy5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFRoZSByYXRpb25hbGUgYmVoaW5kIHRoaXMgaXMgdG8gYWxsb3cgY29udmVuaWVuY2UgZm9yIGNhbGxlcnMgb2YgdGhlIG1vcmUgXCJwdWJsaWNcIlxuICAgICAgICAvLyBNdWx0aWdyYXBoLmNyZWF0ZUdyYXBoIGZ1bmN0aW9uLCBzbyB0aGF0IHRoZXkgZG9uJ3QgaGF2ZSB0byBzcGVjaWZ5IGFuIGVycm9yIG9yXG4gICAgICAgIC8vIHdhcm5pbmcgaGFuZGxlciBmdW5jdGlvbiB1bmxlc3MgdGhleSB3YW50IHRvIHVzZSBjdXN0b20gb25lcy4gIFRoZSBpbnRlcm5hbFxuICAgICAgICAvLyBNdWx0aWdyYXBoLmNyZWF0ZXtEUklWRVJ9R3JhcGggZnVuY3Rpb25zLCBob3dldmVyLCBhbHdheXMgbmVlZCBhY2Nlc3MgdG8gZXJyb3IgYW5kXG4gICAgICAgIC8vIHdhcm5pbmcgZnVuY3Rpb25zLCBhbmQgb2Z0ZW4gbmVlZCB0byBwYXNzIGJvdGggb2YgdGhlbSBvbiB0byBvdGhlciBmdW5jdGlvbnMsIHNvXG4gICAgICAgIC8vIHRoZXkncmUgZW5jYXBzdWxhdGVkIHRvZ2V0aGVyIGludG8gYSBzaW5nbGUgbWVzc2FnZUhhbmRsZXIgb2JqZWN0IHRvIG1ha2UgdGhpc1xuICAgICAgICAvLyBlYXNpZXIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEJ1aWxkIHRoZSBtZXNzYWdlSGFuZGxlciBvYmplY3Q6XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyID0ge307XG4gICAgICAgIGlmICh0eXBlb2Yob3B0aW9ucy5lcnJvcikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIuZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yob3B0aW9ucy53YXJuaW5nKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlci53YXJuaW5nID0gb3B0aW9ucy53YXJuaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEgbWVzc2FnZUhhbmRsZXIuZXJyb3IgIHx8ICEgbWVzc2FnZUhhbmRsZXIud2FybmluZykge1xuICAgICAgICAgICAgZGVmYXVsdE1lc3NhZ2VIYW5kbGVyID0gTXVsdGlncmFwaC5jcmVhdGVEZWZhdWx0TWVzc2FnZUhhbmRsZXJzKGRpdik7XG4gICAgICAgICAgICBpZiAoISBtZXNzYWdlSGFuZGxlci5lcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLmVycm9yID0gZGVmYXVsdE1lc3NhZ2VIYW5kbGVyLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEgbWVzc2FnZUhhbmRsZXIud2FybmluZykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLndhcm5pbmcgPSBkZWZhdWx0TWVzc2FnZUhhbmRsZXIud2FybmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLm1lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubXVnbFN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBkZWxlZ2F0ZSB0byB0aGUgZHJpdmVyLXNwZWNpZmljIGNyZWF0ZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZHJpdmVyID09PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpZ3JhcGguY3JlYXRlQ2FudmFzR3JhcGhGcm9tU3RyaW5nKG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmRyaXZlciA9PT0gXCJyYXBoYWVsXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlncmFwaC5jcmVhdGVSYXBoYWVsR3JhcGhGcm9tU3RyaW5nKG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2VIYW5sZGVyLmVycm9yKG5ldyBFcnJvcihcImludmFsaWQgZ3JhcGhpYyBkcml2ZXIgJ1wiICsgb3B0aW9ucy5kcml2ZXIgKyBcIicgc3BlY2lmaWVkIHRvIE11bHRpZ3JhcGguY3JlYXRlR3JhcGhcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWxlZ2F0ZSB0byB0aGUgZHJpdmVyLXNwZWNpZmljIGNyZWF0ZSBmdW5jdGlvblxuICAgICAgICBpZiAob3B0aW9ucy5kcml2ZXIgPT09IFwiY2FudmFzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBNdWx0aWdyYXBoLmNyZWF0ZUNhbnZhc0dyYXBoKG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZHJpdmVyID09PSBcInJhcGhhZWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIE11bHRpZ3JhcGguY3JlYXRlUmFwaGFlbEdyYXBoKG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlSGFubGRlci5lcnJvcihuZXcgRXJyb3IoXCJpbnZhbGlkIGdyYXBoaWMgZHJpdmVyICdcIiArIG9wdGlvbnMuZHJpdmVyICsgXCInIHNwZWNpZmllZCB0byBNdWx0aWdyYXBoLmNyZWF0ZUdyYXBoXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYHdpbmRvdy5tdWx0aWdyYXBoLmNyZWF0ZWAgaXMgYW4gYWxpYXMgZm9yIGB3aW5kb3cubXVsdGlncmFwaC5jb3JlLk11bHRpZ3JhcGguY3JlYXRlR3JhcGhgLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB3aW5kb3cubXVsdGlncmFwaC5jcmVhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SFRNTCBFbGVtZW50fGpRdWVyeSBPYmplY3R9IG9wdGlvbnMuZGl2IChSRVFVSVJFRClcbiAgICAgKiAgICAgIFRoZSBET00gZWxlbWVudCBkaXYgaW50byB3aGljaCB0aGUgbXVsdGlncmFwaCBzaG91bGQgYmVcbiAgICAgKiAgICAgIHBsYWNlZDsgdGhpcyB2YWx1ZSBtYXkgYmUgZWl0aGVyIChhKSBhIHN0cmluZyB3aGljaCBpcyB0YWtlblxuICAgICAqICAgICAgdG8gYmUgdGhlIGlkIGF0dHJpYnV0ZSBvZiBhIGRpdiBpbiB0aGUgcGFnZSwgKGIpIGEgcmVmZXJlbmNlXG4gICAgICogICAgICB0byB0aGUgZGl2IERPTSBlbGVtZW50IGl0c2VsZiwgb3IgKGMpIGEgalF1ZXJ5IG9iamVjdFxuICAgICAqICAgICAgY29ycmVzcG9uZGluZyB0byB0aGUgZGl2IERPTSBlbGVtZW50LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7VVJJfSBvcHRpb25zLm11Z2wgKFJFUVVJUkVEKSB0aGUgVVJMIGZyb20gd2hpY2ggdGhlIE1VR0xcbiAgICAgKiAgICAgICBmaWxlIGZvciB0aGUgTXVsdGlncmFwaCBjYW4gYmUgbG9hZGVkXG4gICAgICogXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZHJpdmVyIChPUFRJT05BTCkgSW5kaWNhdGVzIHdoaWNoXG4gICAgICogICAgICAgZ3JhcGhpY3MgZHJpdmVyIHRvIHVzZTsgc2hvdWxkIGJlIG9uZSBvZiB0aGUgc3RyaW5nc1xuICAgICAqICAgICAgIFwiY2FudmFzXCIsIFwicmFwaGFlbFwiLCBvciBcImF1dG9cIi4gIFRoZSBkZWZhdWx0ICh3aGljaCBpc1xuICAgICAqICAgICAgIHVzZWQgaWYgdGhlICdkcml2ZXInIHRhZyBpcyBhYnNlbnQpIGlzIFwiYXV0b1wiLCB3aGljaFxuICAgICAqICAgICAgIGNhdXNlcyBNdWx0aWdyYXBoIHRvIGNoZWNrIHRoZSBmZWF0dXJlcyBvZiB0aGUgYnJvd3NlclxuICAgICAqICAgICAgIGl0IGlzIHJ1bm5pbmcgaW4gYW5kIGNob29zZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBkcml2ZXIuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5lcnJvciAoT1BUSU9OQUwpIEEgZnVuY3Rpb24gZm9yXG4gICAgICogICAgICAgZGlzcGxheWluZyBlcnJvciBtZXNzYWdlcyB0byB0aGUgdXNlci4gIE11bHRpZ3JhcGggd2lsbFxuICAgICAqICAgICAgIGNhbGwgdGhpcyBmdW5jdGlvbiBpZiBhbmQgd2hlbiBpdCBlbmNvdW50ZXJzIGFuIGVycm9yLiAgVGhlXG4gICAgICogICAgICAgZnVuY3Rpb24gc2hvdWxkIHJlY2VpdmUgYSBzaW5nbGUgYXJndW1lbnQgd2hpY2ggaXMgYW5cbiAgICAgKiAgICAgICBpbnN0YW5jZSBvZiB0aGUgSmF2YVNjcmlwIEVycm9yIG9iamVjdC4gIFRoZSBkZWZhdWx0IGlzIHRvXG4gICAgICogICAgICAgdXNlIE11bHRpZ3JhcGgncyBvd24gaW50ZXJuYWwgbWVjaGFuaXNtIGZvciBkaXNwbGF5aW5nIHVzZXJcbiAgICAgKiAgICAgICBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMud2FybmluZyAoT1BUSU9OQUwpIEEgZnVuY3Rpb24gZm9yXG4gICAgICogICAgICAgZGlzcGxheWluZyB3YXJuaW5nIG1lc3NhZ2VzIHRvIHRoZSB1c2VyLiAgTXVsdGlncmFwaCB3aWxsXG4gICAgICogICAgICAgY2FsbCB0aGlzIGZ1bmN0aW9uIGlmIGFuZCB3aGVuIGl0IG5lZWRzIHRvIGRpc3BsYXkgYVxuICAgICAqICAgICAgIHdhcm5pbmcgbWVzc2FnZS4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZWNlaXZlIGEgc2luZ2xlXG4gICAgICogICAgICAgYXJndW1lbnQgd2hpY2ggaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIEphdmFTY3JpcHQgRXJyb3JcbiAgICAgKiAgICAgICBvYmplY3QuICBUaGUgZGVmYXVsdCBpcyB0byB1c2UgTXVsdGlncmFwaCdzIG93biBpbnRlcm5hbFxuICAgICAqICAgICAgIG1lY2hhbmlzbSBmb3IgZGlzcGxheWluZyB1c2VyIG1lc3NhZ2VzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IGpRdWVyeSBwcm9taXNlIHdoaWNoIHByb3ZpZGVzIGludGVyYWN0aW9uIHdpdGhcbiAgICAgKiAgICAgdGhlIGdyYXBoIHRocm91Z2ggaXRzIGBkb25lYCBmdW5jdGlvbi5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIE11bHRpZ3JhcGguY3JlYXRlID0gTXVsdGlncmFwaC5jcmVhdGVHcmFwaDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgZGVmYXVsdCBlcnJvciBhbmQgd2FybmluZyBmdW5jdGlvbnMgZm9yIG11bHRpZ3JhcGguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZURlZmF1bHRNZXNzYWdlSGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge0hUTUwgRWxlbWVudH0gZGl2XG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGtleWVkIGJ5IGBlcnJvcmAgYW5kIGB3YXJuaW5nYCB3aGljaCByZXNwZWN0aXZlbHkgcG9pbnQgdG9cbiAgICAgKiAgICAgdGhlIGdlbmVyYXRlZCBkZWZhdWx0IGVycm9yIGFuZCB3YXJuaW5nIGZ1bmN0aW9ucy5cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgTXVsdGlncmFwaC5jcmVhdGVEZWZhdWx0TWVzc2FnZUhhbmRsZXJzID0gZnVuY3Rpb24gKGRpdikge1xuXG4gICAgICAgICQoZGl2KS5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG4gICAgICAgICQoZGl2KS5lcnJvckRpc3BsYXkoe30pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvciA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tUcmFjZSA9IChlLnN0YWNrICYmIHR5cGVvZihlLnN0YWNrKSA9PT0gXCJzdHJpbmdcIikgPyBlLnN0YWNrLnJlcGxhY2UoL1xcbi9nLCBcIjwvbGk+PGxpPlwiKSA6IGUubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAkKGRpdikuZXJyb3JEaXNwbGF5KFwiZGlzcGxheUVycm9yXCIsIHN0YWNrVHJhY2UsIGUubWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICBmb250Q29sb3IgICAgICAgOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA6ICcjZmYwMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yQ29sb3IgIDogJyNmZjAwMDAnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB3YXJuaW5nIDogZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgICAgICAvLyB3IGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcsIG9yIGEgV2FybmluZyBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlICAgID0gXCJXYXJuaW5nOiBcIiArICgodHlwZW9mKHcpID09PSBcInN0cmluZ1wiKSA/IHcgOiB3Lm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICBzdGFja1RyYWNlID0gKHR5cGVvZih3KSAhPT0gXCJzdHJpbmdcIiAmJiB3LnN0YWNrICYmIHR5cGVvZih3LnN0YWNrKSA9PT0gXCJzdHJpbmdcIikgPyB3LnN0YWNrLnJlcGxhY2UoL1xcbi9nLCBcIjwvbGk+PGxpPlwiKSA6IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgJChkaXYpLmVycm9yRGlzcGxheShcImRpc3BsYXlFcnJvclwiLCBzdGFja1RyYWNlLCBtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRDb2xvciAgICAgICA6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yIDogJyNlMDZhMWInLFxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JDb2xvciAgOiAnI2UwNmExYidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gZGVmaW5lIGVtcHR5IG9iamVjdCBmb3IgaG9sZGluZyBkYXRhIGFkcGF0ZXJzXG4gICAgTXVsdGlncmFwaC5fZGF0YUFkYXB0ZXJzID0ge307XG5cbiAgICBNdWx0aWdyYXBoLmluc3RhbGxEYXRhQWRhcHRlciA9IGZ1bmN0aW9uKG5hbWUsIGFkYXB0ZXIpIHtcbiAgICAgICAgTXVsdGlncmFwaC5fZGF0YUFkYXB0ZXJzW25hbWVdID0gYWRhcHRlcjtcbiAgICB9O1xuXG4gICAgTXVsdGlncmFwaC5nZXREYXRhQWRhcHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIE11bHRpZ3JhcGguX2RhdGFBZGFwdGVyc1tuYW1lXTtcbiAgICB9O1xuXG4gICAgLy8gc28gdGhhdCBkYXRhIGFkcGF0ZXJzLCBvciBvdGhlciBKUyBjb2RlIGludGVyYWN0aW5nIHdpdGggTXVsdGlncmFwaCxcbiAgICAvLyBtYXkgaGF2ZSBhY2Nlc3MgdG8gc3ByaW50ZjpcbiAgICBNdWx0aWdyYXBoLnNwcmludGYgPSByZXF1aXJlKCdzcHJpbnRmJyk7XG5cbiAgICByZXR1cm4gTXVsdGlncmFwaDtcbn07XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBzcHJpbnRmID0gcmVxdWlyZSgnc3ByaW50ZicpO1xuXG52YXIgTnVtYmVyRm9ybWF0dGVyID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHZhciB0ZXN0U3RyaW5nO1xuICAgIGlmICh0eXBlb2YoZm9ybWF0KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXRTdHJpbmcgPSBmb3JtYXQ7XG4gICAgdGVzdFN0cmluZyA9IHNwcmludGYoZm9ybWF0LCAwKTtcbiAgICB0aGlzLmxlbmd0aCA9IHRlc3RTdHJpbmcubGVuZ3RoO1xufTtcblxuTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gc3ByaW50Zih0aGlzLmZvcm1hdFN0cmluZywgdmFsdWUuZ2V0UmVhbFZhbHVlKCkpO1xufTtcblxuTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS5nZXRNYXhMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS5nZXRGb3JtYXRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0U3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJGb3JtYXR0ZXI7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbk51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9udW1iZXJfdmFsdWUuanMnKTtcblxuLy8gRnVkZ2UgZmFjdG9yIGZvciBmbG9hdGluZyBwb2ludCBjb21wYXJpc29uczpcbnZhciBlcHNpbG9uID0gMUUtMTI7XG5cbnZhciBOdW1iZXJNZWFzdXJlID0gZnVuY3Rpb24gKG1lYXN1cmUpIHtcbiAgICB0aGlzLm1lYXN1cmUgPSBtZWFzdXJlO1xufTtcblxuTnVtYmVyTWVhc3VyZS5wcm90b3R5cGUuZ2V0UmVhbFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1lYXN1cmU7XG59O1xuXG5OdW1iZXJNZWFzdXJlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tZWFzdXJlLnRvU3RyaW5nKCk7XG59O1xuXG5OdW1iZXJNZWFzdXJlLnByb3RvdHlwZS5maXJzdFNwYWNpbmdMb2NhdGlvbkF0T3JBZnRlciA9IGZ1bmN0aW9uICh2YWx1ZSwgYWxpZ25tZW50KSAge1xuICAgIHZhciBmLFxuICAgICAgICBuLFxuICAgICAgICBtLFxuICAgICAgICBhID0gYWxpZ25tZW50LnZhbHVlLFxuICAgICAgICB2ID0gdmFsdWUudmFsdWUsXG4gICAgICAgIHMgPSBNYXRoLmFicyh0aGlzLm1lYXN1cmUpO1xuICAgIGYgPSAodiAtIGEpIC8gcztcbiAgICBuID0gTWF0aC5mbG9vcihmKTtcbiAgICBtID0gbiArIDE7XG4gICAgLy9pZiAoKE1hdGguYWJzKG4gLSBmKSA8IGVwc2lsb24pIHx8IChNYXRoLmFicyhtIC0gZikgPCBlcHNpbG9uKSkge1xuICAgIC8vTk9URTogYnkgZGVmaW5pdGlvbiBvZiBuPWZsb29yKGYpLCB3ZSBrbm93IGYgPj0gbiwgc28gTWF0aC5hYnMobiAtIGYpIGlzIHRoZSBzYW1lIGFzIChmIC0gbilcbiAgICAvL0Fsc28gYnkgZGVmaW5pdGlvbiwgZmxvb3IoZikrMSA+PSBmLCBzbyBNYXRoLmFicyhtIC0gZikgaXMgdGhlIHNhbWUgYXMgKG0gLSBmKVxuICAgIGlmICgoZiAtIG4gPCBlcHNpbG9uKSB8fCAobSAtIGYgPCBlcHNpbG9uKSkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlclZhbHVlKHYpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE51bWJlclZhbHVlKGEgKyBzICogbSk7XG59O1xuXG4vLyBDb25zaWRlciBhIGxhdHRpY2Ugb2YgdmFsdWVzIHNwYWNlZCBgc2AgYXBhcnQsIGFsaWduZWQgd2l0aCBgYWBcbi8vICAgIGkuZS4gYWxsIHZhbHVlcyBhICsgeipzLCB3aGVyZSB6IGlzIGFueSBpbnRlZ2VyXG4vLyBSZXR1cm4gdGhlIGxhcmdlc3QgdmFsdWUgaW4gdGhpcyBsYXR0aWNlIHRoYXQgaXMgPD0gYHZgXG5mdW5jdGlvbiBsYXN0U3BhY2luZ0xvY2F0aW9uQXRPckJlZm9yZShzLCB2LCBhKSB7XG4gICAgdmFyIG4sIG4sIGY7XG4gICAgdiA9IHYgLSBhO1xuICAgIGlmICh2ID49IDApIHtcbiAgICAgICAgZiA9IHYgLyBzO1xuICAgICAgICBuID0gTWF0aC5mbG9vcihmKTtcbiAgICAgICAgaWYgKGYgLSBuIDwgZXBzaWxvbikgeyByZXR1cm4gdjsgfVxuICAgICAgICByZXR1cm4gYSArIG4qcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBmID0gLXYgLyBzO1xuICAgICAgICBuID0gTWF0aC5jZWlsKGYpO1xuICAgICAgICBpZiAobiAtIGYgPCBlcHNpbG9uKSB7IHJldHVybiB2OyB9XG4gICAgICAgIHJldHVybiBhIC0gbipzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGp1c3QgbGlrZSBgZmlyc3RTcGFjaW5nTG9jYXRpb25BdE9yQWZ0ZXJgIGFib3ZlLCBidXQgcmV0dXJucyB0aGVcbiAqIGdyZWF0ZXN0IE51bWJlclZhbHVlIGluIHRoZSBsYXR0aWNlIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gKiBcbiAqIHJldHVybjogYSBOdW1iZXJWYWx1ZVxuICovXG5OdW1iZXJNZWFzdXJlLnByb3RvdHlwZS5sYXN0U3BhY2luZ0xvY2F0aW9uQXRPckJlZm9yZSA9IGZ1bmN0aW9uICgvKk51bWJlclZhbHVlKi92YWx1ZSwgLypOdW1iZXJWYWx1ZSovYWxpZ25tZW50KSAge1xuICAgIHJldHVybiBuZXcgTnVtYmVyVmFsdWUobGFzdFNwYWNpbmdMb2NhdGlvbkF0T3JCZWZvcmUodGhpcy5tZWFzdXJlLCB2YWx1ZS52YWx1ZSwgYWxpZ25tZW50LnZhbHVlKSk7XG59O1xuXG4vLyAgICB2YXIgZixcbi8vICAgICAgICBuLFxuLy8gICAgICAgIG0sXG4vLyAgICAgICAgYSA9IGFsaWdubWVudC52YWx1ZSxcbi8vICAgICAgICB2ID0gdmFsdWUudmFsdWUsXG4vLyAgICAgICAgcyA9IE1hdGguYWJzKHRoaXMubWVhc3VyZSk7XG4vLyAgICBmID0gKHYgLSBhKSAvIHM7XG4vLyAgICBpZiAoZiA+IDApIHtcbi8vICAgICAgICBuID0gTWF0aC5mbG9vcihmKTtcbi8vICAgIH0gZWxzZSB7XG4vLyAgICAgICAgbiA9IE1hdGguY2VpbChmKTtcbi8vICAgIH1cbi8vICAgIG0gPSBuICsgMTtcbi8vICAgIGlmICgoZiAtIG4gPCBlcHNpbG9uKSB8fCAobSAtIGYgPCBlcHNpbG9uKSkge1xuLy8gICAgICAgIGNvbnNvbGUubG9nKCdhdCAxJyk7XG4vLyAgICAgICAgY29uc29sZS5sb2coZik7XG4vLyAgICAgICAgY29uc29sZS5sb2coZi1uKTtcbi8vICAgICAgICBjb25zb2xlLmxvZyhtLWYpO1xuLy8gICAgICAgIGNvbnNvbGUubG9nKGVwc2lsb24pO1xuLy8gICAgICAgIHJldHVybiBuZXcgTnVtYmVyVmFsdWUodik7XG4vLyAgICB9XG4vLyAgICBjb25zb2xlLmxvZygnYXQgMicpO1xuLy8gICAgcmV0dXJuIG5ldyBOdW1iZXJWYWx1ZShhICsgcyAqIG4pO1xuLy99O1xuXG5OdW1iZXJNZWFzdXJlLnBhcnNlID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gbmV3IE51bWJlck1lYXN1cmUocGFyc2VGbG9hdChzKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlck1lYXN1cmU7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbkRhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpO1xuXG52YXIgTnVtYmVyVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59O1xuXG5OdW1iZXJWYWx1ZS5wcm90b3R5cGUuZ2V0UmVhbFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuTnVtYmVyVmFsdWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKCk7XG59O1xuXG5OdW1iZXJWYWx1ZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA8IHgudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZSA+IHgudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxuTnVtYmVyVmFsdWUucHJvdG90eXBlLmFkZFJlYWxWYWx1ZSA9IGZ1bmN0aW9uICggcmVhbFZhbHVlSW5jciApIHtcbiAgICByZXR1cm4gbmV3IE51bWJlclZhbHVlKHRoaXMudmFsdWUgKyByZWFsVmFsdWVJbmNyKTtcbn07XG5cbk51bWJlclZhbHVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoLypEYXRhTWVhc3VyZSovIG1lYXN1cmUpIHtcbiAgICAvLyBOT1RFOiBkZWxpYmVyYXRlbHkgYWNjZXNzaW5nIHRoZSAnbWVhc3VyZScgcHJvcGVydHkgb2YgYSBOdW1iZXJNZWFzdXJlIGhlcmUsIHJhdGhlclxuICAgIC8vIHRoYW4gY2FsbGluZyBpdHMgZ2V0UmVhbFZhbHVlKCkgbWV0aG9kLCBmb3IgY29udmVuaWVuY2UgYW5kIGVmZmljaWVuY3k6XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJWYWx1ZSh0aGlzLnZhbHVlICsgbWVhc3VyZS5tZWFzdXJlKTtcbn07XG5cbk51bWJlclZhbHVlLnByb3RvdHlwZS50eXBlID0gRGF0YVZhbHVlLk5VTUJFUjtcblxuTnVtYmVyVmFsdWUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJWYWx1ZSh0aGlzLnZhbHVlKTtcbn07XG5cbk51bWJlclZhbHVlLnBhcnNlID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gbmV3IE51bWJlclZhbHVlKHBhcnNlRmxvYXQocykpO1xufTtcblxuRGF0YVZhbHVlLm1peGluQ29tcGFyYXRvcnMoTnVtYmVyVmFsdWUucHJvdG90eXBlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJWYWx1ZTtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxuRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyk7XG5cbnZhciB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMuaG9yaXpvbnRhbGF4aXMucGFuKTtcblxudmFyIFBhbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlBhblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXNBKFwiYWxsb3dlZFwiKS53aGljaC5pc0EoXCJib29sZWFuXCIpO1xuICAgIHRoaXMuaGFzQShcIm1pblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFWYWx1ZS5pc0luc3RhbmNlT3JOdWxsKTtcbiAgICB0aGlzLmhhc0EoXCJtYXhcIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhVmFsdWUuaXNJbnN0YW5jZU9yTnVsbCk7XG5cbiAgICAvL05PVEU6IHRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIERhdGFWYWx1ZSBhbmQgRGF0YU1lYXN1cmUgZm9yIHRoZSB6b29tICYgcGFuIG1vZGVsXG4gICAgLy8gICAgICBhdHRyaWJ1dGVzIG1pZ2h0IHNlZW0gY29uZnVzaW5nLCBzbyBoZXJlJ3MgYSB0YWJsZSB0byBjbGFyaWZ5IGl0OlxuICAgIC8vXG4gICAgLy8gICAgICAgICAgICAgIEJvb2xlYW4gICAgICBEYXRhVmFsdWUgICAgICBEYXRhTWVhc3VyZVxuICAgIC8vICAgICAgICAgICAgICAtLS0tLS0tICAgICAgLS0tLS0tLS0tICAgICAgLS0tLS0tLS0tLS1cbiAgICAvLyAgem9vbTogICAgICAgYWxsb3dlZCAgICAgIGFuY2hvciAgICAgICAgIG1pbixtYXhcbiAgICAvLyAgIHBhbjogICAgICAgYWxsb3dlZCAgICAgIG1pbixtYXhcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcy5wYW4sIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFuO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgQXJyYXlEYXRhID0gcmVxdWlyZSgnLi9hcnJheV9kYXRhLmpzJyksXG4gICAgRGF0YU1lYXN1cmUgPSByZXF1aXJlKCcuL2RhdGFfbWVhc3VyZS5qcycpLFxuICAgIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4vZGF0YV92YWx1ZS5qcycpO1xuXG52YXIgUGVyaW9kaWNBcnJheURhdGEgPSBuZXcgamVybWFpbmUuTW9kZWwoZnVuY3Rpb24gKCkge1xuICAgIHZhciBQZXJpb2RpY0FycmF5RGF0YSA9IHRoaXMsXG4gICAgICAgIGVtcHR5SXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBcIm5leHRcIiAgICA6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgICAgXCJoYXNOZXh0XCIgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICB9O1xuXG4gICAgdGhpcy5pc0EoQXJyYXlEYXRhKTtcbiAgICB0aGlzLmhhc0EoXCJwZXJpb2RcIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhTWVhc3VyZS5pc0luc3RhbmNlKTtcbiAgICAvL3RoaXMuaGFzQShcImNvbHVtbjBSZWxhdGl2ZVJlYWxWYWx1ZXNcIikud2hpY2guZGVmYXVsdHNUbyhudWxsKTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwiY29sdW1uc1wiLCBcInN0cmluZ0FycmF5XCIsIFwicGVyaW9kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMuYWRkTGlzdGVuZXIoXCJsaXN0ZW5lckFkZGVkXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmFycmF5KCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0VHlwZSA9PT0gXCJkYXRhUmVhZHlcIikge1xuICAgICAgICAgICAgICAgIGV2ZW50Lmxpc3RlbmVyKGRhdGFbMF1bMF0sIGRhdGFbZGF0YS5sZW5ndGgtMV1bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qXG4gICAgIHRoaXMucmVzcG9uZHNUbyhcImluaXRpYWxpemVDb2x1bW4wUmVsYXRpdmVSZWFsVmFsdWVzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5KCksXG4gICAgIGNvbHVtbjBSZWxhdGl2ZVJlYWxWYWx1ZXMgPSBbXSxcbiAgICAgaTtcbiAgICAgZm9yIChpPTA7IGk8YXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgY29sdW1uMFJlbGF0aXZlUmVhbFZhbHVlc1tpXSA9IGFycmF5W2ldWzBdIC0gYXJyYXlbMF1bMF07XG4gICAgIH1cbiAgICAgdGhpcy5jb2x1bW4wUmVsYXRpdmVSZWFsVmFsdWVzKGNvbHVtbjBSZWxhdGl2ZVJlYWxWYWx1ZXMpO1xuICAgICB9KTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZ2V0SXRlcmF0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZyBhcnJheX0gY29sdW1uSURzXG4gICAgICogQHBhcmFtIHtEYXRhVmFsdWV9IG1pblxuICAgICAqIEBwYXJhbSB7RGF0YVZhbHVlfSBtYXhcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGJ1ZmZlclxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJnZXRJdGVyYXRvclwiLCBmdW5jdGlvbiAoY29sdW1uSWRzLCBtaW4sIG1heCwgYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQZXJpb2RpY0FycmF5RGF0YS5nZXRBcnJheURhdGFJdGVyYXRvcih0aGlzLCBjb2x1bW5JZHMsIG1pbiwgbWF4LCBidWZmZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBnZXRBcnJheURhdGFJdGVyYXRvclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5RGF0YX0gYXJyYXlEYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmcgYXJyYXl9IGNvbHVtbklEc1xuICAgICAqIEBwYXJhbSB7RGF0YVZhbHVlfSBtaW5cbiAgICAgKiBAcGFyYW0ge0RhdGFWYWx1ZX0gbWF4XG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBidWZmZXJcbiAgICAgKiBAcmV0dXJuIGl0ZXJcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgUGVyaW9kaWNBcnJheURhdGEuZ2V0QXJyYXlEYXRhSXRlcmF0b3IgPSBmdW5jdGlvbiAocGVyaW9kaWNBcnJheURhdGEsIGNvbHVtbklkcywgbWluLCBtYXgsIGJ1ZmZlcikge1xuICAgICAgICB2YXIgaXRlciA9IHt9LFxuICAgICAgICAgICAgYXJyYXlTbGljZSA9IFtdLFxuICAgICAgICAgICAgY3VyciA9IDAsXG4gICAgICAgICAgICBpLCBqLFxuICAgICAgICAgICAgY3VycmVudEluZGV4LFxuICAgICAgICAgICAgY29sdW1uSW5kaWNlcyxcbiAgICAgICAgICAgIGFycmF5ID0gcGVyaW9kaWNBcnJheURhdGEuYXJyYXkoKTtcblxuICAgICAgICBidWZmZXIgPSBidWZmZXIgfHwgMDtcblxuICAgICAgICAvLyBjb2x1bW5JZHMgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoY29sdW1uSWRzKSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheURhdGE6IGdldEl0ZXJhdG9yIG1ldGhvZCByZXF1aXJlcyB0aGF0IHRoZSBmaXJzdCBwYXJhbWV0ZXIgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nc1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5JZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGNvbHVtbklkc1tpXSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlEYXRhOiBnZXRJdGVyYXRvciBtZXRob2QgcmVxdWlyZXMgdGhhdCB0aGUgZmlyc3QgcGFyYW1ldGVyIGJlIGFuIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9taW4sbWF4IGFyZ3VtZW50cyBzaG91bGQgYmUgZGF0YSB2YWx1ZXNcbiAgICAgICAgaWYgKCFEYXRhVmFsdWUuaXNJbnN0YW5jZShtaW4pIHx8ICFEYXRhVmFsdWUuaXNJbnN0YW5jZShtYXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheURhdGE6IGdldEl0ZXJhdG9yIG1ldGhvZCByZXF1aXJlcyB0aGUgc2Vjb25kIGFuZCB0aGlyZCBhcmd1bWVudCB0byBiZSBudW1iZXIgdmFsdWVzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9idWZmZXIgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGludGVnZXJcbiAgICAgICAgaWYgKHR5cGVvZihidWZmZXIpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheURhdGE6IGdldEl0ZXJhdG9yIG1ldGhvZCByZXF1aXJlcyBsYXN0IGFyZ3VtZW50IHRvIGJlIGFuIGludGVnZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vIGRhdGEsIHJldHVybiBhbiBlbXB0eSBpdGVyYXRvclxuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlJdGVyYXRvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAvLyBwb3B1bGF0ZSB0aGUgY29sdW1uMFJlbGF0aXZlUmVhbFZhbHVlcyBhcnJheSBpZiBpdCBoYXNuJ3QgeWV0IGJlZW4gcG9wdWxhdGVkXG4gICAgICAgICBpZiAodGhpcy5jb2x1bW4wUmVsYXRpdmVSZWFsVmFsdWVzKCkgPT09IG51bGwpIHtcbiAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbHVtbjBSZWxhdGl2ZVJlYWxWYWx1ZXMoKTtcbiAgICAgICAgIH1cbiAgICAgICAgICovXG5cbiAgICAgICAgLy8gTGV0IGBiYXNlVmFsdWVgIGJlIHRoZSBsb2NhdGlvbiBvZiB0aGUgZmlyc3QgZGF0YSBwb2ludCBpbiB0aGUgYXJyYXlcbiAgICAgICAgdmFyIGJhc2VWYWx1ZSA9IGFycmF5WzBdWzBdO1xuXG4gICAgICAgIC8vIEluIHRoZSByZWd1bGFyIGxhdHRpY2Ugb2Ygc3BhY2luZyBgcGVyaW9kYCBhbGlnbmVkIHdpdGggYmFzZVZhbHVlLFxuICAgICAgICAvLyBmaW5kIHRoZSBsYXN0IHBvaW50IHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBtaW5gLiAgQ2FsbCB0aGlzIHBvaW50IGBiYC5cbiAgICAgICAgdmFyIGIgPSBwZXJpb2RpY0FycmF5RGF0YS5wZXJpb2QoKS5sYXN0U3BhY2luZ0xvY2F0aW9uQXRPckJlZm9yZShtaW4sIGJhc2VWYWx1ZSk7XG5cbiAgICAgICAgLy8gTGV0IGBvZmZzZXRSZWFsVmFsdWVgIGJlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYiBhbmQgYmFzZVZhbHVlLCBhcyBhIHJlYWwgdmFsdWU6XG4gICAgICAgIHZhciBvZmZzZXRSZWFsVmFsdWUgPSBiLmdldFJlYWxWYWx1ZSgpIC0gYmFzZVZhbHVlLmdldFJlYWxWYWx1ZSgpO1xuXG4gICAgICAgIC8vIExldCBgYmFzZU1pbmAgYmUgYG1pbmAgc2hpZnRlZCAnYmFja3dhcmQnIGJ5IG9mZnNldFJlYWxWYWx1ZTsgdGhpcyBpcyBgbWluYFxuICAgICAgICAvLyByZWxhdGl2ZSB0byB0aGUgc2FtZSBwZXJpb2QgY3ljbGUgYXMgYmFzZVZhbHVlOlxuICAgICAgICB2YXIgYmFzZU1pbiA9IERhdGFWYWx1ZS5jcmVhdGUobWluLnR5cGUsIG1pbi5nZXRSZWFsVmFsdWUoKSAtIG9mZnNldFJlYWxWYWx1ZSk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHJvdyBpbiB0aGUgYXJyYXkgd2hvc2UgY29sdW1uMCB2YWx1ZSBpcyA+PSBiYXNlTWluO1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBkYXRhIHBvaW50IHdlIHN0YXJ0IHdpdGhcbiAgICAgICAgZm9yIChjdXJyZW50SW5kZXggPSAwOyBjdXJyZW50SW5kZXggPCBhcnJheS5sZW5ndGg7ICsrY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlbY3VycmVudEluZGV4XVswXS5nZShiYXNlTWluKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vVE9ETyBsYXRlcjogYmFjayB1cCAnYnVmZmVyJyBzdGVwc1xuICAgICAgICAvL1xuXG4gICAgICAgIC8vIHNldCB0aGUgY3VycmVudCB2YWx1ZSB0byBiZSB0aGUgY29sdW1uMCB2YWx1ZSBhdCB0aGlzIGZpcnN0IGluZGV4LCBzaGlmdGVkXG4gICAgICAgIC8vICdmb3J3YXJkJyBieSBvZmZzZXRSZWFsVmFsdWVcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IERhdGFWYWx1ZS5jcmVhdGUoYXJyYXlbY3VycmVudEluZGV4XVswXS50eXBlLCBhcnJheVtjdXJyZW50SW5kZXhdWzBdLmdldFJlYWxWYWx1ZSgpICsgb2Zmc2V0UmVhbFZhbHVlKTtcblxuICAgICAgICBjb2x1bW5JbmRpY2VzID0gW107XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5JZHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrID0gcGVyaW9kaWNBcnJheURhdGEuY29sdW1uSWRUb0NvbHVtbk51bWJlcihjb2x1bW5JZHNbal0pO1xuICAgICAgICAgICAgY29sdW1uSW5kaWNlcy5wdXNoKCBrICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvamVjdGlvbiA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBpLCB4O1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uSW5kaWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uSW5kaWNlc1tpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbi5wdXNoKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0aW9uLnB1c2goYXJyYXlbY3VycmVudEluZGV4XVtjb2x1bW5JbmRpY2VzW2ldXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYiA9IGIuYWRkKHBlcmlvZGljQXJyYXlEYXRhLnBlcmlvZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UmVhbFZhbHVlID0gYi5nZXRSZWFsVmFsdWUoKSAtIGJhc2VWYWx1ZS5nZXRSZWFsVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gRGF0YVZhbHVlLmNyZWF0ZShhcnJheVtjdXJyZW50SW5kZXhdWzBdLnR5cGUsIGFycmF5W2N1cnJlbnRJbmRleF1bMF0uZ2V0UmVhbFZhbHVlKCkgKyBvZmZzZXRSZWFsVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUuZ3QobWF4KSkge1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE86IGFjdHVhbGx5IG5lZWQgdG8gZmlndXJlIG91dCBob3cgdG8gbW92ZSBmb3J3YXJkIGBidWZmZXJgIHN0ZXBzLCBidXQgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyBza2lwIHRoYXQgcGFydC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc05leHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjdXJyZW50SW5kZXggPj0gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgIH07XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUGVyaW9kaWNBcnJheURhdGE7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBQbG90TGVnZW5kID0gcmVxdWlyZSgnLi9wbG90X2xlZ2VuZC5qcycpLFxuICAgIEF4aXMgPSByZXF1aXJlKCcuL2F4aXMuanMnKSxcbiAgICBSZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXIuanMnKTtcblxudmFyIFBsb3QgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJQbG90XCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhhc0EoXCJsZWdlbmRcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAobGVnZW5kKSB7XG4gICAgICAgIHJldHVybiBsZWdlbmQgaW5zdGFuY2VvZiBQbG90TGVnZW5kO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImhvcml6b250YWxheGlzXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIGF4aXMgaW5zdGFuY2VvZiBBeGlzO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcInZlcnRpY2FsYXhpc1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHJldHVybiBheGlzIGluc3RhbmNlb2YgQXhpcztcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJyZW5kZXJlclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgICAgICByZXR1cm4gcmVuZGVyZXIgaW5zdGFuY2VvZiBSZW5kZXJlcjtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJ2aXNpYmxlXCIpLndoaWNoLmlzQShcImJvb2xlYW5cIikuYW5kLmRlZmF1bHRzVG8odHJ1ZSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJub3JtYWxpemVcIiwgZnVuY3Rpb24oZ3JhcGgpIHtcbiAgICAgICAgdmFyIGdyYXBoQXhlcyA9IGdyYXBoLmF4ZXMoKSxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZSxcbiAgICAgICAgICAgIG51bWJlck9mVmFyaWFibGVzLFxuICAgICAgICAgICAgZmluZE5leHRWYXJpYWJsZUF0T3JBZnRlcixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBEYXRhUGxvdCA9IHJlcXVpcmUoJy4uL2NvcmUvZGF0YV9wbG90LmpzJyk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSGFuZGxlcyBtaXNzaW5nIHZhcmlhYmxlc1xuICAgICAgICAvL1xuICAgICAgICBmaW5kTmV4dFZhcmlhYmxlQXRPckFmdGVyID0gZnVuY3Rpb24gKHBsb3QsIGRhdGEsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcEZsYWcgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZUluUGxvdEZsYWcsXG4gICAgICAgICAgICAgICAgaSA9IGluZGV4LFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgdmFyaWFibGU7XG5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGluZGV4ICYmIG92ZXJsYXBGbGFnID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgTm9ybWFsaXplcjogVGhlcmUgZG9lcyBub3QgZXhpc3QgYW4gdW51c2VkIHZhcmlhYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpID09PSBkYXRhLmNvbHVtbnMoKS5zaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXJpYWJsZUluUGxvdEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IGRhdGEuY29sdW1ucygpLmF0KGkpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBsb3QudmFyaWFibGUoKS5zaXplKCk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxvdC52YXJpYWJsZSgpLmF0KGopID09PSB2YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVJblBsb3RGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlSW5QbG90RmxhZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhhbmRsZXMgbWlzc2luZyBob3Jpem9udGFsYXhpcyB0YWdzXG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0aGlzLmhvcml6b250YWxheGlzKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdyYXBoQXhlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChncmFwaEF4ZXMuYXQoaSkub3JpZW50YXRpb24oKSA9PT0gQXhpcy5IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9yaXpvbnRhbGF4aXMoZ3JhcGhBeGVzLmF0KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSGFuZGxlcyBtaXNzaW5nIHZlcnRpY2FsYXhpcyB0YWdzXG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsYXhpcygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBncmFwaEF4ZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JhcGhBeGVzLmF0KGkpLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuVkVSVElDQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbGF4aXMoZ3JhcGhBeGVzLmF0KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSGFuZGxlcyBtaXNzaW5nIHJlbmRlcmVyIHRhZ3NcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXF1aXJlKCcuL3JlbmRlcmVycy9hbGxfcmVuZGVyZXJzLmpzJyk7XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSBSZW5kZXJlci5UeXBlLnBhcnNlKFwibGluZVwiKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIoUmVuZGVyZXIuY3JlYXRlKHJlbmRlcmVyVHlwZSkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlcigpLnBsb3QodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBudW1iZXJPZlZhcmlhYmxlcyA9IHRoaXMucmVuZGVyZXIoKS5udW1iZXJPZlZhcmlhYmxlcygpO1xuXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRGF0YVBsb3QpIHtcbiAgICAgICAgICAgIHZhciBwbG90RGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgICAgICBwbG90VmFyaWFibGVzID0gdGhpcy52YXJpYWJsZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocGxvdERhdGEoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGxvdERhdGEoZ3JhcGguZGF0YSgpLmF0KDApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBsb3RWYXJpYWJsZXMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGxvdFZhcmlhYmxlcy5hZGQoZmluZE5leHRWYXJpYWJsZUF0T3JBZnRlcih0aGlzLCBwbG90RGF0YSgpLCAwKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwbG90VmFyaWFibGVzLmF0KDApID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGxvdFZhcmlhYmxlcy5yZXBsYWNlKDAsIGZpbmROZXh0VmFyaWFibGVBdE9yQWZ0ZXIodGhpcywgcGxvdERhdGEoKSwgMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAocGxvdFZhcmlhYmxlcy5zaXplKCkgPCBudW1iZXJPZlZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIHBsb3RWYXJpYWJsZXMuYWRkKGZpbmROZXh0VmFyaWFibGVBdE9yQWZ0ZXIodGhpcywgcGxvdERhdGEoKSwgMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAxLiBnZXQgdmFyaWFibGVzIGZyb20gYSBkYXRhIHNlY3Rpb24sIHNvbWUgd2lsbCBiZSB1c2VkLCBvdGhlcnMgd29uJ3QgYmUuXG4gICAgICAgICAgICAvLyAyLiBjaGVjayBpZiBob3Jpem9udGFsIGF4aXMgbmVlZHMgYSB2YXJpYWJsZVxuICAgICAgICAgICAgLy8gICAgICAgaWYgaXQgZG9lcyAtIGZpbmQgZmlyc3QgdW51c2VkIHZhcmlhYmxlLCBzdGFydGluZyBhdCBwb3NpdGlvbiAwXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgIC0gaWYgbm8gdW51c2VkIHZhcmlhYmxlcyBleGlzdCAtIHRocm93IGVycm9yXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgIC0gQ09OVElOVUVcbiAgICAgICAgICAgIC8vICAgICAgIGlmIGl0IGRvZXMgbm90IC0gQ09OVElOVUVcbiAgICAgICAgICAgIC8vIDMuIGNoZWNrIGlmIHZlcnRpY2FsIGF4aXMgbmVlZHMgdmFyaWFibGUocylcbiAgICAgICAgICAgIC8vICAgICAgIGlmIGl0IGRvZXMgLSBmaW5kIGZpcnN0IHVudXNlZCB2YXJpYWJsZSwgc3RhcnRpbmcgYXQgdGhlIHBvc2l0aW9uIG9mXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgdGhlIHggdmFyaWFibGVcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgLSBpZiBubyB1bnVzZWQgdmFyaWFibGVzIGV4aXN0IC0gdGhyb3cgZXJyb3JcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgLSBjaGVjayBpZiB2ZXJ0aWNhbCBheGlzIG5lZWRzIGFub3RoZXIgdmFyaWFibGVcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgaWYgaXQgZG9lcyAtIFJlcGVhdCBzdGVwIDNcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YXRpcHMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YXRpcHMoKS5ub3JtYWxpemUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbG90O1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgVGV4dCA9IHJlcXVpcmUoJy4vdGV4dC5qcycpLFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90LmxlZ2VuZCk7XG5cbnZhciBQbG90TGVnZW5kID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUGxvdExlZ2VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXNBKFwidmlzaWJsZVwiKS53aGljaC5pc0EoXCJib29sZWFuXCIpO1xuICAgIHRoaXMuaGFzQShcImxhYmVsXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBsYWJlbCBpbnN0YW5jZW9mIFRleHQ7XG4gICAgfSk7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMucGxvdC5sZWdlbmQsIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGxvdExlZ2VuZDtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICBJbnNldHMgPSByZXF1aXJlKCcuLi9tYXRoL2luc2V0cy5qcycpLFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90YXJlYSk7XG5cbnZhciBQbG90YXJlYSA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlBsb3RhcmVhXCIsIGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuaGFzQShcIm1hcmdpblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICAgICAgcmV0dXJuIG1hcmdpbiBpbnN0YW5jZW9mIEluc2V0cztcbiAgICB9KTtcblxuICAgIHRoaXMuaGFzQShcImJvcmRlclwiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuXG4gICAgdGhpcy5oYXNBKFwiY29sb3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yID09PSBudWxsIHx8IGNvbG9yIGluc3RhbmNlb2YgUkdCQ29sb3I7XG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc0EoXCJib3JkZXJjb2xvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChib3JkZXJjb2xvcikge1xuICAgICAgICByZXR1cm4gYm9yZGVyY29sb3IgaW5zdGFuY2VvZiBSR0JDb2xvcjtcbiAgICB9KTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5wbG90YXJlYSwgYXR0cmlidXRlcyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbG90YXJlYTtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIFdhcm5pbmcgPSByZXF1aXJlKCcuL3dhcm5pbmcuanMnKSxcbiAgICBFbnVtID0gcmVxdWlyZSgnLi4vbWF0aC9lbnVtLmpzJyksXG4gICAgcmVuZGVyZXJMaXN0LFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90LnJlbmRlcmVyKSxcbiAgICBUeXBlID0gbmV3IEVudW0oXCJSZW5kZXJlclR5cGVcIiksXG4gICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi9tYXRoL3JnYl9jb2xvci5qcycpO1xuXG52YXIgUmVuZGVyZXIgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJSZW5kZXJlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXNBKFwidHlwZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKFR5cGUuaXNJbnN0YW5jZSk7XG4gICAgdGhpcy5oYXNBKFwicGxvdFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChwbG90KSB7XG4gICAgICAgIHZhciBQbG90ID0gcmVxdWlyZSgnLi9wbG90LmpzJyk7XG4gICAgICAgIHJldHVybiBwbG90IGluc3RhbmNlb2YgUGxvdDtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJudW1iZXJPZlZhcmlhYmxlc1wiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICB0aGlzLmhhc0EoXCJmaWx0ZXJcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuICgodHlwZW9mKGZpbHRlcikgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgKCh0eXBlb2YoZmlsdGVyLnJlc2V0KSA9PT0gJ2Z1bmN0aW9uJykgJiYgKHR5cGVvZihmaWx0ZXIuZmlsdGVyKSA9PT0gJ2Z1bmN0aW9uJykpKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcInNldFVwTWlzc2luZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEEgY2FsbCB0byB0aGlzIG1ldGhvZCByZXN1bHRzIGluIHRoZSBhZGRpdGlvbiAob3IgcmVwbGFjZW1lbnQpIG9mIGEgbWV0aG9kIGNhbGxlZCBcImlzTWlzc2luZygpXCJcbiAgICAgICAgLy8gdGhhdCBjYW4gYmUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgYSB2YWx1ZSBtZWV0cyB0aGUgXCJtaXNzaW5nXCIgY3JpdGVyaWEgb2Ygb25lIG9mIHRoaXMgcmVuZGVyZXInc1xuICAgICAgICAvLyBwbG90J3MgZGF0YSBjb2x1bW5zLiAgVGhlIHBvaW50IG9mIGhhdmluZyB0aGlzIFwic2V0VXBNaXNzaW5nKClcIiBtZXRob2QgY3JlYXRlIHRoZSBcImlzTWlzc2luZygpXCJcbiAgICAgICAgLy8gbWV0aG9kLCByYXRoZXIgdGhhbiBqdXN0IGNvZGluZyB0aGUgXCJpc01pc3NpbmcoKVwiIG1ldGhvZCBkaXJlY3RseSBoZXJlLCBpcyBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlXG4gICAgICAgIC8vIGEgcG9pbnRlciB0byB0aGUgcGxvdCdzIGRhdGEgb2JqZWN0IHZpYSBhIGNsb3N1cmUsIGZvciBmYXN0ZXIgYWNjZXNzLCByYXRoZXIgdGhhbiBjb2RpbmdcbiAgICAgICAgLy8gdGhpcy5wbG90KCkuZGF0YSgpIGluIFwiaXNNaXNzaW5nKClcIiwgd2hpY2ggYWRkcyB0aGUgb3ZlcmhlYWQgb2YgMiBnZXR0ZXIgY2FsbHMgdG8gZWFjaCBpbnZvY2F0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGF3a3dhcmQuICBXaGF0IHdlIHJlYWxseSB3YW50IGlzIGZvciB0aGlzIHN0dWZmIHRvIGhhcHBlbiBhdXRvbWF0aWNhbGx5IHdoZW5cbiAgICAgICAgLy8gdGhlIHJlbmRlcmVyJ3MgXCJwbG90XCIgYXR0cmlidXRlIGlzIHNldC4gIENhbiBKZXJtYWluZSBiZSBtb2RpZmllZCB0byBhbGxvdyB1cyB0byB3cml0ZVxuICAgICAgICAvLyBhIGN1c3RvbSBzZXR0ZXIsIHNvIHRoYXQgd2UgY2FuIGV4ZWN1dGUgdGhpcyBjb2RlIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVuZGVyJ3MgXCJwbG90XCJcbiAgICAgICAgLy8gYXR0cmlidXRlIGlzIHNldCA/Pz9cbiAgICAgICAgdmFyIHBsb3QgPSB0aGlzLnBsb3QoKSxcbiAgICAgICAgICAgIGRhdGE7XG4gICAgICAgIGlmICghcGxvdCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nOiByZW5kZXJlci5zZXRVcE1pc3NpbmcoKSBjYWxsZWQgZm9yIHJlbmRlcmVyIHRoYXQgaGFzIG5vIHBsb3QgcmVmXCIpO1xuICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgcmVhbGx5IGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvciBDb25zdGFudFBsb3QsIGNyZWF0ZSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIGZhbHNlLCBzaW5jZSBpdCBoYXMgbm8gZGF0YVxuICAgICAgICB2YXIgQ29uc3RhbnRQbG90ID0gcmVxdWlyZSgnLi9jb25zdGFudF9wbG90LmpzJyk7XG4gICAgICAgIGlmIChwbG90IGluc3RhbmNlb2YgQ29uc3RhbnRQbG90KSB7XG4gICAgICAgICAgICB0aGlzLmlzTWlzc2luZyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKCFwbG90LmRhdGEoKSkge1xuICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgZXZlbnR1YWxseSB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nOiByZW5kZXJlci5zZXRVcE1pc3NpbmcoKSBjYWxsZWQgZm9yIHJlbmRlcmVyIHdob3NlIHBsb3QgaGFzIG5vIGRhdGEgcmVmXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBwbG90LmRhdGEoKTtcbiAgICAgICAgdGhpcy5pc01pc3NpbmcgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmlzTWlzc2luZyhwW2ldLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwidHlwZVwiKTtcblxuICAgIHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHModGhpcywgZGVmYXVsdFZhbHVlcy5wbG90LnJlbmRlcmVyLCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMucmVzcG9uZHNUbyhcInRyYW5zZm9ybVBvaW50XCIsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICBoYXhpcyA9IHRoaXMucGxvdCgpLmhvcml6b250YWxheGlzKCksXG4gICAgICAgICAgICB2YXhpcyA9IHRoaXMucGxvdCgpLnZlcnRpY2FsYXhpcygpLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBvdXRwdXRbMF0gPSBoYXhpcy5kYXRhVmFsdWVUb0F4aXNWYWx1ZShpbnB1dFswXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBpbnB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gdmF4aXMuZGF0YVZhbHVlVG9BeGlzVmFsdWUoaW5wdXRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG5cbiAgICB2YXIgZXF1YWxPclVuZGVmaW5lZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoKGE9PT1iKSB8fCAoKGE9PT11bmRlZmluZWQpICYmIChiPT09dW5kZWZpbmVkKSkpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJzZXRPcHRpb25cIiwgZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgcmVuZGVyZXJPcHQsXG4gICAgICAgICAgICByZW5kZXJlck9wdHMsXG4gICAgICAgICAgICBpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uc01ldGFkYXRhW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0IHRvIHNldCB1bmtub3duIHJlbmRlcmVyIG9wdGlvbiAnXCIrbmFtZStcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXJPcHRzID0gdGhpcy5vcHRpb25zKClbbmFtZV0oKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlbmRlcmVyT3B0cy5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgaWYgKGVxdWFsT3JVbmRlZmluZWQocmVuZGVyZXJPcHRzLmF0KGkpLm1pbigpLCBtaW4pICYmXG4gICAgICAgICAgICAgICAgZXF1YWxPclVuZGVmaW5lZChyZW5kZXJlck9wdHMuYXQoaSkubWF4KCksIG1heCkpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlck9wdHMuYXQoaSkudmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnZXQgdGhpcyBmYXIsIGl0IG1lYW5zIHdlIGRpZG4ndCBmaW5kIGFuIGV4aXN0aW5nIG9wdGlvbiBpbiB0aGUgbGlzdCB3aXRoIG1hdGNoaW5nIG1pbi9tYXhcbiAgICAgICAgLy8gc2V0dGluZ3MsIHNvIHdlIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGFwcGVuZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0OlxuICAgICAgICByZW5kZXJlck9wdCA9IG5ldyAodGhpcy5vcHRpb25zTWV0YWRhdGFbbmFtZV0udHlwZSkoKTtcbiAgICAgICAgcmVuZGVyZXJPcHQudmFsdWUodmFsdWUpO1xuICAgICAgICByZW5kZXJlck9wdC5taW4obWluKTtcbiAgICAgICAgcmVuZGVyZXJPcHQubWF4KG1heCk7XG4gICAgICAgIHJlbmRlcmVyT3B0cy5hZGQocmVuZGVyZXJPcHQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwic2V0T3B0aW9uRnJvbVN0cmluZ1wiLCBmdW5jdGlvbiAobmFtZSwgc3RyaW5nVmFsdWUsIHN0cmluZ01pbiwgc3RyaW5nTWF4KSB7XG4gICAgICAgIHZhciBwbG90ID0gdGhpcy5wbG90KCksXG4gICAgICAgICAgICB0eXBlID0gdGhpcy50eXBlKCksXG4gICAgICAgICAgICBEYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBUd28gYmxvY2tzIG9mIGNvZGUgYmVsb3cgcHJvdmlkZXMgc3VwcG9ydCBmb3IgdGhlIGRlcHJlY2F0ZWQgXCJkb3RzaXplXCIgYW5kIFwiZG90Y29sb3JcIlxuICAgICAgICAvLyBvcHRpb25zLCB3aGljaCBoYXZlIGJlZW4gcmVwbGFjZWQgYnkgXCJwb2ludHNpemVcIiBhbmQgXCJwb2ludGNvbG9yXCIuICBEZWxldGUgdGhlc2UgYmxvY2tzXG4gICAgICAgIC8vIHdoZW4gcmVtb3Zpbmcgc3VwcG9ydCBmb3IgdGhpcy5cbiAgICAgICAgLy8gXG5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIEZpcnN0IGJsb2NrIGluIHN1cHBvcnQgb2YgZGVwcmVjYXRlZCBkb3RzaXplL2RvdGNvbG9yIG9wdGlvbnM6XG4gICAgICAgIC8vXG4gICAgICAgIHZhciB3YXJuaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJkb3RzaXplXCIpIHtcbiAgICAgICAgICAgIG5hbWUgPSBcInBvaW50c2l6ZVwiO1xuICAgICAgICAgICAgd2FybmluZyA9IG5ldyBXYXJuaW5nKCdkZXByZWNhdGVkIFwiZG90c2l6ZVwiIG9wdGlvbiB1c2VkIGZvciBcIicgKyB0eXBlICsgJ1wiIHJlbmRlcmVyOyB1c2UgXCJwb2ludHNpemVcIiBpbnN0ZWFkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJkb3Rjb2xvclwiKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJwb2ludGNvbG9yXCI7XG4gICAgICAgICAgICB3YXJuaW5nID0gbmV3IFdhcm5pbmcoJ2RlcHJlY2F0ZWQgXCJkb3Rjb2xvclwiIG9wdGlvbiB1c2VkIGZvciBcIicgKyB0eXBlICsgJ1wiIHJlbmRlcmVyOyB1c2UgXCJwb2ludGNvbG9yXCIgaW5zdGVhZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFxuICAgICAgICAvLyBFbmQgb2YgZmlyc3QgYmxvY2sgaW4gc3VwcG9ydCBvZiBkZXByZWNhdGVkIGRvdHNpemUvZG90Y29sb3Igb3B0aW9uc1xuICAgICAgICAvL1xuXG4gICAgICAgIHZhciByZW5kZXJlck9wdDtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNNZXRhZGF0YVtuYW1lXSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyByZW5kZXJlciBoYXMgbm8gb3B0aW9uIG5hbWVkIFwibmFtZVwiLCBiYWlsIG91dCBpbW1lZGlhdGVseS4gIFRoaXMgc2hvdWxkIGV2ZW50dWFsbHlcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yLCBidXQgZm9yIG5vdyB3ZSBqdXN0IHF1aWV0bHkgaWdub3JlIGl0LCB0byBlbGltaW5hdGUgZXJyb3IgY29uZGl0aW9ucyBjb21pbmdcbiAgICAgICAgICAgIC8vIGZyb20gdW5pbXBsZW1lbnRlZCBvcHRpb25zLlxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIldBUk5JTkc6IHJlbmRlcmVyIGhhcyBubyBvcHRpb24gbmFtZWQgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYXJuaW5nKCdcIicgKyB0eXBlICsgJ1wiJyArICcgcmVuZGVyZXIgaGFzIG5vIG9wdGlvbiBuYW1lZCBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXJPcHQgPSBuZXcgKHRoaXMub3B0aW9uc01ldGFkYXRhW25hbWVdLnR5cGUpKCk7XG4gICAgICAgIHJlbmRlcmVyT3B0LnBhcnNlVmFsdWUoc3RyaW5nVmFsdWUsIHRoaXMpO1xuICAgICAgICBpZiAocGxvdCAmJiBwbG90LnZlcnRpY2FsYXhpcygpKSB7XG4gICAgICAgICAgICBpZiAoc3RyaW5nTWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlck9wdC5taW4oIERhdGFWYWx1ZS5wYXJzZSggcGxvdC52ZXJ0aWNhbGF4aXMoKS50eXBlKCksIHN0cmluZ01pbiApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpbmdNYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyT3B0Lm1heCggRGF0YVZhbHVlLnBhcnNlKCBwbG90LnZlcnRpY2FsYXhpcygpLnR5cGUoKSwgc3RyaW5nTWF4ICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKG5hbWUsIHJlbmRlcmVyT3B0LnZhbHVlKCksIHJlbmRlcmVyT3B0Lm1pbigpLCByZW5kZXJlck9wdC5tYXgoKSk7XG5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFNlY29uZCBibG9jayBpbiBzdXBwb3J0IG9mIGRlcHJlY2F0ZWQgZG90c2l6ZS9kb3Rjb2xvciBvcHRpb25zOlxuICAgICAgICAvL1xuICAgICAgICBpZiAod2FybmluZykge1xuICAgICAgICAgICAgdGhyb3cgd2FybmluZztcbiAgICAgICAgfVxuICAgICAgICAvLyBcbiAgICAgICAgLy8gRW5kIG9mIHNlY29uZCBibG9jayBpbiBzdXBwb3J0IG9mIGRlcHJlY2F0ZWQgZG90c2l6ZS9kb3Rjb2xvciBvcHRpb25zOlxuICAgICAgICAvL1xuICAgIH0pO1xuXG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJnZXRPcHRpb25WYWx1ZVwiLCBmdW5jdGlvbiAob3B0aW9uTmFtZSwgLypvcHRpb25hbDoqL3ZhbHVlKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbkxpc3Q7XG5cbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucygpO1xuICAgICAgICBpZiAodHlwZW9mKG9wdGlvbnNbb3B0aW9uTmFtZV0pICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBvcHRpb24gXCInK29wdGlvbk5hbWUrJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uTGlzdCA9IG9wdGlvbnNbb3B0aW9uTmFtZV0oKTtcbiAgICAgICAgaWYgKCFvcHRpb25MaXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gb3B0aW9uIFwiJytvcHRpb25OYW1lKydcIicpO1xuICAgICAgICB9XG4gICAgICAgIC8vTk9URTogb3B0aW9ucyBhcmUgc3RvcmVkIGluIHJldmVyc2Ugb3JkZXI7IGRlZmF1bHQgb25lIGlzIGFsd2F5cyBpbiB0aGUgJzAnIHBvc2l0aW9uLlxuICAgICAgICAvLyAgU2VhcmNoIHRocm91Z2ggdGhlbSBzdGFydGluZyBhdCB0aGUgRU5EIG9mIHRoZSBsaXN0LCBnb2luZyBiYWNrd2FyZHMhXG4gICAgICAgIGZvciAoaSA9IG9wdGlvbkxpc3Quc2l6ZSgpLTE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uTGlzdC5hdChpKTtcbiAgICAgICAgICAgIGlmICgoKG9wdGlvbi5taW4oKT09PXVuZGVmaW5lZCkgfHwgKHZhbHVlPT09dW5kZWZpbmVkKSB8fCBvcHRpb24ubWluKCkubGUodmFsdWUpKSAmJlxuICAgICAgICAgICAgICAgICgob3B0aW9uLm1heCgpPT09dW5kZWZpbmVkKSB8fCAodmFsdWU9PT11bmRlZmluZWQpIHx8IG9wdGlvbi5tYXgoKS5ndCh2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0pO1xuXG4gICAgLy8gbWV0aG9kIG11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzczpcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJiZWdpblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgfSk7XG4gICAgLy8gbWV0aG9kIG11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzczpcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJkYXRhUG9pbnRcIiwgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgfSk7XG4gICAgLy8gbWV0aG9kIG11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzczpcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgIH0pO1xuXG59KTtcblxuLypcbiAqIFByaXZhdGUgbGlzdCBvZiBrbm93biByZW5kZXJlcnMuICBUaGlzIGxpc3QgaXMgcG9wdWxhdGVkIGZyb20gd2l0aGluIGluZGl2aWR1YWxcbiAqIHJlbmRlcmVyIHN1Ym1vZGVsIGltcGxlbWVudGF0aW9ucyBieSBjYWxscyB0byBSZW5kZXJlci5hZGRUeXBlLlxuICovXG5yZW5kZXJlckxpc3QgPSBbXTtcblxuLypcbiAqIEFkZCBhIHJlbmRlcmVyIHN1Ym1vZGVsIHRvIHRoZSBsaXN0IG9mIGtub3duIHJlbmRlcnMuICByZW5kZXJlck9iaiBzaG91bGQgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOlxuICogICAgJ3R5cGUnICA6IHRoZSB0eXBlIG9mIHRoZSByZW5kZXJlciAtLSBhIHN0cmluZywgd2hpY2ggaXMgdGhlIHZhbHVlIGV4cGVjdGVkXG4gKiAgICAgICAgICAgICAgZm9yIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiB0aGUgbXVnbCA8cmVuZGVyZXI+IHRhZy5cbiAqICAgICdtb2RlbCcgOiB0aGUgcmVuZGVyZXIgc3VibW9kZWxcbiAqL1xuUmVuZGVyZXIuYWRkVHlwZSA9IGZ1bmN0aW9uIChyZW5kZXJlck9iaikge1xuICAgIHJlbmRlcmVyTGlzdC5wdXNoKHJlbmRlcmVyT2JqKTtcbn07XG5cbi8qXG4gKiBGYWN0b3J5IG1ldGhvZDogY3JlYXRlIGFuIGluc3RhbmNlIG9mIGEgcmVuZGVyZXIgc3VibW9kZWwgYmFzZWQgb24gaXRzIHR5cGUgKGEgc3RyaW5nKS5cbiAqL1xuUmVuZGVyZXIuY3JlYXRlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgcmVuZGVyZXI7XG4gICAgZm9yIChpID0gMDsgaSA8IHJlbmRlcmVyTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAocmVuZGVyZXJMaXN0W2ldLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyID0gbmV3IChyZW5kZXJlckxpc3RbaV0ubW9kZWwpKCk7XG4gICAgICAgICAgICByZW5kZXJlci50eXBlKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlJlbmRlcmVyLmNyZWF0ZTogJ1wiICsgdHlwZSArIFwiJyBpcyBub3QgYSBrbm93biByZW5kZXJlciB0eXBlXCIpO1xuICAgIC8vICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVyLmNyZWF0ZTogYXR0ZW1wdCB0byBjcmVhdGUgYSByZW5kZXJlciBvZiB1bmtub3duIHR5cGUnKTtcbn07XG5cblJlbmRlcmVyLmRlY2xhcmVPcHRpb25zID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBPcHRpb25zTW9kZWxOYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIGksXG4gICAgICAgIE9wdGlvbnNNb2RlbCxcbiAgICAgICAgb3B0aW9uc01ldGFkYXRhLFxuICAgICAgICBkZWNsYXJlT3B0aW9uID0gZnVuY3Rpb24ob3B0aW9uTmFtZSwgb3B0aW9uVHlwZSkge1xuICAgICAgICAgICAgLy8gTk9URTogdGhpcyBjYWxsIHRvIGhhc01hbnkoKSBoYXMgdG8gYmUgaW4gYSBmdW5jdGlvbiBoZXJlLCByYXRoZXIgdGhhbiBqdXN0XG4gICAgICAgICAgICAvLyBiZWluZyB3cml0dGVuIGlubGluZSB3aGVyZSBpdCBpcyB1c2VkIGJlbG93LCBiZWNhdXNlIHdlIG5lZWQgYSBjbG9zdXJlIHRvXG4gICAgICAgICAgICAvLyBjYXB0dXJlIHZhbHVlIG9mIG9wdGlvbnNbaV0udHlwZSBhcyBvcHRpb25UeXBlLCBmb3IgdXNlIGluIHRoZSB2YWxpZGF0aW9uXG4gICAgICAgICAgICAvLyBmdW5jdGlvbi4gIE90aGVyd2lzZSwgdGhlIHZhbGlkYXRvciBjYXB0dXJlcyB0aGUgJ29wdGlvbnMnIGFycmF5IGFuZCB0aGVcbiAgICAgICAgICAgIC8vIGxvY2FsIGxvb3AgdmFyaWFibGUgaSBpbnN0ZWFkLCBhbmQgZXZhbHVhdGVzIG9wdGlvbnNbaV0udHlwZSB3aGVuIHZhbGlkYXRpb25cbiAgICAgICAgICAgIC8vIGlzIHBlcmZvcm1lZCFcbiAgICAgICAgICAgIE9wdGlvbnNNb2RlbC5oYXNNYW55KG9wdGlvbk5hbWUpLmVhY2hPZldoaWNoLnZhbGlkYXRlV2l0aChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2IGluc3RhbmNlb2Ygb3B0aW9uVHlwZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgT3B0aW9uc01vZGVsICAgID0gbmV3IGplcm1haW5lLk1vZGVsKE9wdGlvbnNNb2RlbE5hbWUsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICBvcHRpb25zTWV0YWRhdGEgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWNsYXJlT3B0aW9uKG9wdGlvbnNbaV0ubmFtZSwgb3B0aW9uc1tpXS50eXBlKTtcbiAgICAgICAgb3B0aW9uc01ldGFkYXRhW29wdGlvbnNbaV0ubmFtZV0gPSB7XG4gICAgICAgICAgICBcInR5cGVcIiAgICA6IG9wdGlvbnNbaV0udHlwZSxcbiAgICAgICAgICAgIFwiZGVmYXVsdFwiIDogb3B0aW9uc1tpXVtcImRlZmF1bHRcIl1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyZXIuaGFzQShcIm9wdGlvbnNcIikuaXNJbW11dGFibGUoKS5kZWZhdWx0c1RvKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBPcHRpb25zTW9kZWwoKTsgfSk7XG4gICAgcmVuZGVyZXIucHJvdG90eXBlLm9wdGlvbnNNZXRhZGF0YSA9IG9wdGlvbnNNZXRhZGF0YTtcblxuICAgIHJlbmRlcmVyLmlzQnVpbHRXaXRoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcG9wdWxhdGUgb3B0aW9ucyB3aXRoIGRlZmF1bHQgdmFsdWVzIHN0b3JlZCBpbiBvcHRpb25zIG1ldGFkYXRhICh3aGljaCB3YXMgcG9wdWxhdGVkIGJ5IGRlY2xhcmVPcHRpb25zKTpcbiAgICAgICAgdmFyIG9wdGlvbnNNZXRhZGF0YSA9IHRoaXMub3B0aW9uc01ldGFkYXRhLFxuICAgICAgICAgICAgb3B0LCByb3B0O1xuICAgICAgICBmb3IgKG9wdCBpbiBvcHRpb25zTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zTWV0YWRhdGEuaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgICAgICAgICAgIHJvcHQgPSBuZXcgKG9wdGlvbnNNZXRhZGF0YVtvcHRdLnR5cGUpKG9wdGlvbnNNZXRhZGF0YVtvcHRdW1wiZGVmYXVsdFwiXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zKClbb3B0XSgpLmFkZCggcm9wdCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn07XG5cblxuUmVuZGVyZXIuT3B0aW9uID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUmVuZGVyZXIuT3B0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyk7XG4gICAgdGhpcy5oYXNBKFwibWluXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoRGF0YVZhbHVlLmlzSW5zdGFuY2UpO1xuICAgIHRoaXMuaGFzQShcIm1heFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFWYWx1ZS5pc0luc3RhbmNlKTtcbn0pO1xuXG5cblJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUmVuZGVyZXIuUkdCQ29sb3JPcHRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFJlbmRlcmVyLk9wdGlvbik7XG4gICAgdGhpcy5oYXNBKFwidmFsdWVcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdiBpbnN0YW5jZW9mIFJHQkNvbG9yIHx8IHYgPT09IG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInZhbHVlXCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInNlcmlhbGl6ZVZhbHVlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKS5nZXRIZXhTdHJpbmcoKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJwYXJzZVZhbHVlXCIsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgdGhpcy52YWx1ZSggUkdCQ29sb3IucGFyc2Uoc3RyaW5nKSApO1xuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInZhbHVlRXFcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlKCkuZXEodmFsdWUpO1xuICAgIH0pO1xuXG59KTtcblxuUmVuZGVyZXIuTnVtYmVyT3B0aW9uID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUmVuZGVyZXIuTnVtYmVyT3B0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzQShSZW5kZXJlci5PcHRpb24pO1xuICAgIHRoaXMuaGFzQShcInZhbHVlXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwidmFsdWVcIik7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwic2VyaWFsaXplVmFsdWVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSgpLnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwicGFyc2VWYWx1ZVwiLCBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHRoaXMudmFsdWUoIHBhcnNlRmxvYXQoc3RyaW5nKSApO1xuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInZhbHVlRXFcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSgpPT09dmFsdWUpO1xuICAgIH0pO1xufSk7XG5cblJlbmRlcmVyLkRhdGFWYWx1ZU9wdGlvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlJlbmRlcmVyLkRhdGFWYWx1ZU9wdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIuT3B0aW9uKTtcbiAgICB0aGlzLmhhc0EoXCJ2YWx1ZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyk7XG4gICAgICAgIHJldHVybiBEYXRhVmFsdWUuaXNJbnN0YW5jZSh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInZhbHVlXCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInNlcmlhbGl6ZVZhbHVlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJ2YWx1ZUVxXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSgpLmVxKHZhbHVlKTtcbiAgICB9KTtcbn0pO1xuXG5SZW5kZXJlci5WZXJ0aWNhbERhdGFWYWx1ZU9wdGlvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlJlbmRlcmVyLkRhdGFWYWx1ZU9wdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIuRGF0YVZhbHVlT3B0aW9uKTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwidmFsdWVcIik7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwicGFyc2VWYWx1ZVwiLCBmdW5jdGlvbiAoc3RyaW5nLCByZW5kZXJlcikge1xuICAgICAgICB2YXIgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyk7XG4gICAgICAgIHRoaXMudmFsdWUoIERhdGFWYWx1ZS5wYXJzZShyZW5kZXJlci5wbG90KCkudmVydGljYWxheGlzKCkudHlwZSgpLCBzdHJpbmcpICk7XG4gICAgfSk7XG4gICAgXG59KTtcblxuUmVuZGVyZXIuSG9yaXpvbnRhbERhdGFWYWx1ZU9wdGlvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlJlbmRlcmVyLkRhdGFWYWx1ZU9wdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIuRGF0YVZhbHVlT3B0aW9uKTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwidmFsdWVcIik7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwicGFyc2VWYWx1ZVwiLCBmdW5jdGlvbiAoc3RyaW5nLCByZW5kZXJlcikge1xuICAgICAgICB2YXIgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyk7XG4gICAgICAgIHRoaXMudmFsdWUoIERhdGFWYWx1ZS5wYXJzZShyZW5kZXJlci5wbG90KCkuaG9yaXpvbnRhbGF4aXMoKS50eXBlKCksIHN0cmluZykgKTtcbiAgICB9KTtcbiAgICBcbn0pO1xuXG5SZW5kZXJlci5EYXRhTWVhc3VyZU9wdGlvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlJlbmRlcmVyLkRhdGFNZWFzdXJlT3B0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzQShSZW5kZXJlci5PcHRpb24pO1xuICAgIHRoaXMuaGFzQShcInZhbHVlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBEYXRhTWVhc3VyZSA9IHJlcXVpcmUoJy4vZGF0YV9tZWFzdXJlLmpzJyk7XG4gICAgICAgIHJldHVybiBEYXRhTWVhc3VyZS5pc0luc3RhbmNlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwidmFsdWVcIik7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwic2VyaWFsaXplVmFsdWVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInZhbHVlRXFcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlKCkuZXEodmFsdWUpO1xuICAgIH0pO1xufSk7XG5cblJlbmRlcmVyLlZlcnRpY2FsRGF0YU1lYXN1cmVPcHRpb24gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJSZW5kZXJlci5EYXRhTWVhc3VyZU9wdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIuRGF0YU1lYXN1cmVPcHRpb24pO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInBhcnNlVmFsdWVcIiwgZnVuY3Rpb24gKHN0cmluZywgcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi9kYXRhX21lYXN1cmUuanMnKTtcbiAgICAgICAgdGhpcy52YWx1ZSggRGF0YU1lYXN1cmUucGFyc2UocmVuZGVyZXIucGxvdCgpLnZlcnRpY2FsYXhpcygpLnR5cGUoKSwgc3RyaW5nKSApO1xuICAgIH0pO1xuICAgIFxufSk7XG5cblJlbmRlcmVyLkhvcml6b250YWxEYXRhTWVhc3VyZU9wdGlvbiA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlJlbmRlcmVyLkRhdGFNZWFzdXJlT3B0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzQShSZW5kZXJlci5EYXRhTWVhc3VyZU9wdGlvbik7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInZhbHVlXCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInBhcnNlVmFsdWVcIiwgZnVuY3Rpb24gKHN0cmluZywgcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi9kYXRhX21lYXN1cmUuanMnKTtcbiAgICAgICAgdGhpcy52YWx1ZSggRGF0YU1lYXN1cmUucGFyc2UocmVuZGVyZXIucGxvdCgpLmhvcml6b250YWxheGlzKCkudHlwZSgpLCBzdHJpbmcpICk7XG4gICAgfSk7XG4gICAgXG59KTtcblxuUmVuZGVyZXIuVHlwZSA9IFR5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG4iLCJyZXF1aXJlKCcuL2JhbmRfcmVuZGVyZXIuanMnKTtcbnJlcXVpcmUoJy4vYmFyX3JlbmRlcmVyLmpzJyk7XG5yZXF1aXJlKCcuL2ZpbGxfcmVuZGVyZXIuanMnKTtcbnJlcXVpcmUoJy4vcG9pbnRsaW5lX3JlbmRlcmVyLmpzJyk7XG5yZXF1aXJlKCcuL3JhbmdlYmFyX3JlbmRlcmVyLmpzJyk7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbi8vIFRoZSBCYW5kIHJlbmRlcmVyIGlzIGEgMi12YXJpYWJsZSByZW5kZXJlciB3aGljaCBmaWxscyB0aGUgcmVnaW9uXG4vLyBiZXR3ZWVuIHR3byBkYXRhIGxpbmVzIHdpdGggYSBzb2xpZCBjb2xvciwgYW5kIGRyYXdzIGEgbGluZSBzZWdtZW50XG4vLyBiZXR3ZWVuIGNvbnNlY3V0aXZlIGRhdGEgcG9pbnRzIGluIGVhY2ggbGluZS5cbi8vIFxuLy8gSXQgaXMgdmVyeSBzaW1pbGFyIHRvIHRoZSBmaWxsIHJlbmRlcmVyIGV4Y2VwdCB0aGF0IHRoZSBmaWxsZWQgcmVnaW9uXG4vLyBleHRlbmRzIGJldHdlZW4gdGhlIHR3byAodmVydGljYWwgYXhpcykgZGF0YSB2YWx1ZXMgYXQgZWFjaCBkYXRhIHBvaW50LCBpbnN0ZWFkXG4vLyBvZiBiZXR3ZWVuIGEgc2luZ2xlICh2ZXJ0aWNhbCBheGlzKSB2YWx1ZSBhbmQgYSBob3Jpem9udGFsIGJhc2UgbGluZS5cbi8vIFxuLy8gVGhlIGxpbmUgc2VnZW1lbnRzIHNob3VsZCBvY2NsdWRlIHRoZSBzb2xpZCBmaWxsLlxuLy8gXG4vLyBUaGlzIHJlbmRlcmVyIGFjY2VwdHMgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGxpbmVjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAweDAwMDAwMCAoYmxhY2spXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIENvbG9yIHVzZWQgZm9yIGxpbmUgc2VnbWVudHMuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZXdpZHRoXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAxXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFdpZHRoLCBpbiBwaXhlbHMsIG9mIGxpbmUgc2VnbWVudHMuICBBXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIG9mIDAgbWVhbnMgZG8gbm90IGRyYXcgbGluZSBzZWdtZW50cy5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBsaW5lMWNvbG9yXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIFJHQkNvbG9yXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIG5vbmUgKGxpbmVjb2xvciBpcyB1c2VkKVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBDb2xvciB1c2VkIGZvciBsaW5lIHNlZ21lbnRzIGNvbm5lY3RpbmcgdGhlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBvZiB2YXJpYWJsZSAxLiAgIElmIGJvdGggbGluZWNvbG9yIGFuZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lMWNvbG9yIGFyZSBzcGVjaWZpZWQsIGxpbmUxY29sb3IgaXMgdXNlZC5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBsaW5lMXdpZHRoXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAtMSAobGluZXdpZHRoIGlzIHVzZWQpXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFdpZHRoLCBpbiBwaXhlbHMsIG9mIGxpbmUgc2VnbWVudHMgY29ubmVjdGluZyB0aGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIG9mIHZhcmlhYmxlIDEuICBBIHZhbHVlIG9mIDAgbWVhbnMgZG8gbm90XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXcgbGluZSBzZWdtZW50cy4gICBJZiBib3RoIGxpbmV3aWR0aCBhbmRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTF3aWR0aCBhcmUgc3BlY2lmaWVkLCBsaW5lMXdpZHRoIGlzIHVzZWQuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZTJjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICBub25lIChsaW5lY29sb3IgaXMgdXNlZClcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgQ29sb3IgdXNlZCBmb3IgbGluZSBzZWdtZW50cyBjb25uZWN0aW5nIHRoZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgb2YgdmFyaWFibGUgMi4gICBJZiBib3RoIGxpbmVjb2xvciBhbmRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTJjb2xvciBhcmUgc3BlY2lmaWVkLCBsaW5lMmNvbG9yIGlzIHVzZWQuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZTJ3aWR0aFxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgLTEgKGxpbmV3aWR0aCBpcyB1c2VkKVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBXaWR0aCwgaW4gcGl4ZWxzLCBvZiBsaW5lIHNlZ21lbnRzIGNvbm5lY3RpbmcgdGhlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBvZiB2YXJpYWJsZSAyLiAgQSB2YWx1ZSBvZiAwIG1lYW5zIGRvIG5vdFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3IGxpbmUgc2VnbWVudHMuICAgSWYgYm90aCBsaW5ld2lkdGggYW5kXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUyd2lkdGggYXJlIHNwZWNpZmllZCwgbGluZTJ3aWR0aCBpcyB1c2VkLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGZpbGxjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAweDgwODA4MCAoZGFyayBncmF5KVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBDb2xvciB1c2VkIGZvciB0aGUgZmlsbCBhcmVhLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGZpbGxvcGFjaXR5XG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAxXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIE9wYWNpdHkgdXNlZCBmb3IgdGhlIGZpbGwgYXJlYS5cbi8vXG5cbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyLmpzJyksXG4gICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpO1xuXG52YXIgQmFuZFJlbmRlcmVyID0gbmV3IGplcm1haW5lLk1vZGVsKFwiQmFuZFJlbmRlcmVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzQShSZW5kZXJlcik7XG4gICAgdGhpcy5oYXNBKFwibnVtYmVyT2ZWYXJpYWJsZXNcIikud2hpY2guZGVmYXVsdHNUbygzKTtcbn0pO1xuXG5CYW5kUmVuZGVyZXIuR1JBWSA9IHBhcnNlSW50KFwiODBcIiwgMTYpIC8gMjU1O1xuXG5SZW5kZXJlci5kZWNsYXJlT3B0aW9ucyhCYW5kUmVuZGVyZXIsIFwiQmFuZFJlbmRlcmVyT3B0aW9uc1wiLCBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwibGluZWNvbG9yXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuUkdCQ29sb3JPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbmV3IFJHQkNvbG9yKDAsMCwwKVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwibGluZXdpZHRoXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IDFcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImxpbmUxY29sb3JcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5SR0JDb2xvck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBudWxsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJsaW5lMXdpZHRoXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IC0xXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJsaW5lMmNvbG9yXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuUkdCQ29sb3JPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbnVsbFxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwibGluZTJ3aWR0aFwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAtMVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwiZmlsbGNvbG9yXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuUkdCQ29sb3JPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbmV3IFJHQkNvbG9yKEJhbmRSZW5kZXJlci5HUkFZLEJhbmRSZW5kZXJlci5HUkFZLEJhbmRSZW5kZXJlci5HUkFZKVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwiZmlsbG9wYWNpdHlcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5OdW1iZXJPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogMS4wXG4gICAgfVxuXSk7XG5cblJlbmRlcmVyLkJBTkQgPSBuZXcgUmVuZGVyZXIuVHlwZShcImJhbmRcIik7XG5cblJlbmRlcmVyLmFkZFR5cGUoe1widHlwZVwiICA6IFJlbmRlcmVyLlR5cGUucGFyc2UoXCJiYW5kXCIpLFxuICAgICAgICAgICAgICAgICAgXCJtb2RlbFwiIDogQmFuZFJlbmRlcmVyfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFuZFJlbmRlcmVyO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG4vLyBUaGUgQmFyIHJlbmRlcmVyIGlzIGEgMS12YXJpYWJsZSByZW5kZXJlciB3aGljaCBkcmF3cyBhIGJhciBhdCBlYWNoXG4vLyBub24tbWlzc2luZyBkYXRhIHBvaW50IHdpdGggYW4gb3V0bGluZSBhcm91bmQgdGhlIGJhciBhbmQgYSBzb2xpZFxuLy8gZmlsbCBiZXR3ZWVuIHRoZSBiYXIgYW5kIHRoZSBob3Jpem9udGFsIGF4aXMuXG4vLyBcbi8vIFRoaXMgcmVuZGVyZXIgYWNjZXB0cyB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgYmFyd2lkdGhcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgRGF0YU1lYXN1cmVcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgPz8/XG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFdpZHRoLCBpbiByZWxhdGl2ZSB0ZXJtcyB0byB0aGUgdHlwZSBvZiB0aGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcyB0aGUgcGxvdCBpcyBvbiwgb2YgdGhlIGJhcnMuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBiYXJvZmZzZXRcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgbnVtYmVyXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDBcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgVGhlIG9mZnNldCwgaW4gcGl4ZWxzLCBvZiB0aGUgbGVmdCBlZGdlIG9mXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggYmFyIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgZGF0YSB2YWx1ZS5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGJhcmJhc2Vcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgRGF0YVZhbHVlXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIG51bGxcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgVGhlIGxvY2F0aW9uLCByZWxhdGl2ZSB0byB0aGUgcGxvdCdzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsIGF4aXMsIG9mIHRoZSBib3R0b20gb2YgdGhlIGJhcjsgaWZcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgbm8gYmFyYmFzZSBpcyBzcGVjaWZpZWQsIHRoZSBiYXJzIHdpbGxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kIGRvd24gdG8gdGhlIGJvdHRvbSBvZiB0aGUgcGxvdCBhcmVhLlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZWNvbG9yXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIFJHQkNvbG9yXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDB4MDAwMDAwIChibGFjaylcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgVGhlIGNvbG9yIHRvIGJlIHVzZWQgZm9yIHRoZSBvdXRsaW5lIGFyb3VuZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIGJhci5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBmaWxsY29sb3Jcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgUkdCQ29sb3Jcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMHgwMDAwMDAgKGJsYWNrKVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBUaGUgY29sb3IgdG8gYmUgdXNlZCBmb3IgdGhlIGZpbGwgaW5zaWRlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggYmFyOyBpZiBiYXJiYXNlIGlzIHNwZWNpZmllZCwgdGhpc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciBpcyB1c2VkIG9ubHkgZm9yIGJhcnMgdGhhdCBleHRlbmRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvdmUgdGhlIGJhc2UuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgZmlsbG9wYWNpdHlcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgbnVtYmVyXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDFcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgT3BhY2l0eSB1c2VkIGZvciB0aGUgZmlsbCBpbnNpZGUgZWFjaCBiYXIuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgaGlkZWxpbmVzXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAyXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIEJhcnMgd2hpY2ggYXJlIGxlc3Mgd2lkZSwgaW4gcGl4ZWxzLCB0aGFuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgbnVtYmVyIGRvIG5vdCByZW5kZXIgdGhlaXIgb3V0bGluZXMuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIuanMnKSxcbiAgICBSR0JDb2xvciA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgRGF0YU1lYXN1cmUgPSByZXF1aXJlKCcuLi9kYXRhX21lYXN1cmUuanMnKSxcbiAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgZGVmYXVsdFZhbHVlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICBhdHRyaWJ1dGVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzKGRlZmF1bHRWYWx1ZXMucGxvdC5yZW5kZXJlcik7XG5cbnZhciBCYXJSZW5kZXJlciA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkJhclJlbmRlcmVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzQShSZW5kZXJlcik7XG4gICAgdGhpcy5oYXNBKFwibnVtYmVyT2ZWYXJpYWJsZXNcIikud2hpY2guZGVmYXVsdHNUbygyKTtcbn0pO1xuXG5SZW5kZXJlci5kZWNsYXJlT3B0aW9ucyhCYXJSZW5kZXJlciwgXCJCYXJSZW5kZXJlck9wdGlvbnNcIiwgW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImJhcndpZHRoXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuSG9yaXpvbnRhbERhdGFNZWFzdXJlT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG5ldyBEYXRhTWVhc3VyZS5wYXJzZShcIm51bWJlclwiLCAwKVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwiYmFyb2Zmc2V0XCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IDBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImJhcmJhc2VcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5WZXJ0aWNhbERhdGFWYWx1ZU9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBudWxsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJmaWxsY29sb3JcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5SR0JDb2xvck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBuZXcgUkdCQ29sb3IoMCwwLDApXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJmaWxsb3BhY2l0eVwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAxLjBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImxpbmVjb2xvclwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG5ldyBSR0JDb2xvcigwLDAsMClcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImhpZGVsaW5lc1wiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAyXG4gICAgfVxuXSk7XG5cblJlbmRlcmVyLkJBUiA9IG5ldyBSZW5kZXJlci5UeXBlKFwiYmFyXCIpO1xuXG5SZW5kZXJlci5hZGRUeXBlKHtcInR5cGVcIiAgOiBSZW5kZXJlci5UeXBlLnBhcnNlKFwiYmFyXCIpLFxuICAgICAgICAgICAgICAgICAgXCJtb2RlbFwiIDogQmFyUmVuZGVyZXJ9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXJSZW5kZXJlcjtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxuLy8gVGhlIEZpbGwgcmVuZGVyZXIgaXMgYSAxLXZhcmlhYmxlIHJlbmRlcmVyIHdoaWNoIGNvbm5lY3RzIGNvbnNlY3V0aXZlXG4vLyBub24tbWlzc2luZyBkYXRhIHBvaW50cyB3aXRoIGxpbmUgc2VnbWVudHMgd2l0aCBhIHNvbGlkIGZpbGwgYmV0d2VlblxuLy8gdGhlIGxpbmVzIGFuZCB0aGUgaG9yaXpvbnRhbCBheGlzLlxuLy8gXG4vLyBUaGUgbGluZSBzZWdlbWVudHMgc2hvdWxkIG9jY2x1ZGUgdGhlIHNvbGlkIGZpbGwuXG4vLyBcbi8vIFRoaXMgcmVuZGVyZXIgYWNjZXB0cyB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZWNvbG9yXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIFJHQkNvbG9yXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDB4MDAwMDAwIChibGFjaylcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgQ29sb3IgdXNlZCBmb3IgbGluZSBzZWdtZW50c1xuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGxpbmV3aWR0aFxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBXaWR0aCwgaW4gcGl4ZWxzLCBvZiBsaW5lIHNlZ21lbnRzLiAgQVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBvZiAwIG1lYW5zIGRvIG5vdCBkcmF3IGxpbmUgc2VnbWVudHMuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgZmlsbGNvbG9yXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIFJHQkNvbG9yXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDB4ODA4MDgwIChkYXJrIGdyYXkpXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIENvbG9yIHVzZWQgZm9yIHRoZSBmaWxsIGFyZWEuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgZG93bmZpbGxjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICBudWxsXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIENvbG9yIHVzZWQgZm9yIGZpbGwgYXJlYSB0aGF0IGlzIGJlbG93IHRoZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsYmFzZSwgaWYgYSBmaWxsYmFzZSBpcyBzcGVjaWZpZWQuIElmIG5vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25maWxsY29sb3IgaXMgc3BlY2lmZWQsIGZpbGxjb2xvciB3aWxsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHVzZWQgZm9yIGFsbCBmaWxsIGFyZWFzLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGZpbGxvcGFjaXR5XG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAxXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIE9wYWNpdHkgdXNlZCBmb3IgdGhlIGZpbGwgYXJlYS5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBmaWxsYmFzZVxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBEYXRhVmFsdWVcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgbnVsbFxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBUaGUgbG9jYXRpb24gYWxvbmcgdGhlIHBsb3QncyB2ZXJ0aWNhbCBheGlzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBob3Jpem9udGFsIGxpbmUgdGhhdCBkZWZpbmVzIHRoZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gKG9yIHRvcCkgb2YgdGhlIGZpbGxlZCByZWdpb247IGlmIG5vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxiYXNlIGlzIHNwZWNpZmllZCwgdGhlIGZpbGwgd2lsbCBleHRlbmRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgZG93biB0byB0aGUgYm90dG9tIG9mIHRoZSBwbG90IGFyZWEuXG4vLyBcbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyLmpzJyksXG4gICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90LnJlbmRlcmVyKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5wbG90LnJlbmRlcmVyKTtcblxudmFyIEZpbGxSZW5kZXJlciA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkZpbGxSZW5kZXJlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIpO1xuICAgIHRoaXMuaGFzQShcIm51bWJlck9mVmFyaWFibGVzXCIpLndoaWNoLmRlZmF1bHRzVG8oMik7XG59KTtcblxuRmlsbFJlbmRlcmVyLkdSQVkgPSBwYXJzZUludChcIjgwXCIsIDE2KSAvIDI1NTtcblxuUmVuZGVyZXIuZGVjbGFyZU9wdGlvbnMoRmlsbFJlbmRlcmVyLCBcIkZpbGxSZW5kZXJlck9wdGlvbnNcIiwgW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImxpbmVjb2xvclwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG5ldyBSR0JDb2xvcigwLDAsMClcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImxpbmV3aWR0aFwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAxXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJmaWxsY29sb3JcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5SR0JDb2xvck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBuZXcgUkdCQ29sb3IoRmlsbFJlbmRlcmVyLkdSQVksRmlsbFJlbmRlcmVyLkdSQVksRmlsbFJlbmRlcmVyLkdSQVkpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJkb3duZmlsbGNvbG9yXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuUkdCQ29sb3JPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbnVsbFxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwiZmlsbG9wYWNpdHlcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5OdW1iZXJPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogMS4wXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJmaWxsYmFzZVwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLlZlcnRpY2FsRGF0YVZhbHVlT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG51bGxcbiAgICB9XG5dKTtcblxuUmVuZGVyZXIuRklMTCA9IG5ldyBSZW5kZXJlci5UeXBlKFwiZmlsbFwiKTtcblxuUmVuZGVyZXIuYWRkVHlwZSh7XCJ0eXBlXCIgIDogUmVuZGVyZXIuVHlwZS5wYXJzZShcImZpbGxcIiksXG4gICAgICAgICAgICAgICAgICBcIm1vZGVsXCIgOiBGaWxsUmVuZGVyZXJ9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxsUmVuZGVyZXI7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbi8vIFRoZSBQb2ludGxpbmUgcmVuZGVyZXIgaXMgYSAxLXZhcmlhYmxlIHJlbmRlcmVyIHdoaWNoIGRyYXdzIGEgc2hhcGVcbi8vIGF0IGVhY2ggbm9uLW1pc3NpbmcgZGF0YSBwb2ludCwgYW5kIGNvbm5lY3RzIGNvbnNlY3V0aXZlXG4vLyBub24tbWlzc2luZyBkYXRhIHBvaW50cyB3aXRoIGxpbmUgc2VnbWVudHMuICBUaGUgZHJhd2luZyBvZiBib3RoXG4vLyB0aGUgcG9pbnRzLCBhbmQgdGhlIGxpbmVzLCBpcyBvcHRpb25hbCwgc28gdGhpcyByZW5kZXJlciBjYW4gYmVcbi8vIHVzZWQgdG8gZHJhdyBqdXN0IHBvaW50cywganVzdCBsaW5lIHNlZ21lbnRzLCBvciBib3RoLlxuLy8gXG4vLyBXaGVuIGJvdGggcG9pbnRzIGFuZCBsaW5lIHNlZ21lbnRzIGFyZSBkcmF3biwgdGhlIHBvaW50cyBzaG91bGRcbi8vIGJlIGRyYXduIG9uIFwidG9wIG9mXCIgdGhlIGxpbmUgc2VnbWVudHMuXG4vLyBcbi8vIFRoaXMgcmVuZGVyZXIgYWNjZXB0cyB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZXdpZHRoXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAxXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFdpZHRoLCBpbiBwaXhlbHMsIG9mIGxpbmUgc2VnbWVudHMuICBBXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIG9mIDAgbWVhbnMgZG8gbm90IGRyYXcgbGluZSBzZWdtZW50cy5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBsaW5lY29sb3Jcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgUkdCQ29sb3Jcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMHgwMDAwMDAgKGJsYWNrKVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBDb2xvciB1c2VkIGZvciBsaW5lIHNlZ21lbnRzXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgcG9pbnRzaXplXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAwXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFRoZSByYWRpdXMgb2YgZHJhd24gcG9pbnRzLiAgQSB2YWx1ZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBvZiAwIG1lYW5zIGRvIG5vdCBkcmF3IHBvaW50cy5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBwb2ludGNvbG9yXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIFJHQkNvbG9yXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDB4MDAwMDAwIChibGFjaylcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgQ29sb3IgdXNlZCBmb3IgZHJhd2luZyBwb2ludHNcbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBwb2ludHNoYXBlXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIE9uZSBvZiB0aGUgY29uc3RhbnRzIFBvaW50bGluZVJlbmRlcmVyLkNJUkNMRSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9pbnRsaW5lUmVuZGVyZXIuU1FVQVJFLCBQb2ludGxpbmVSZW5kZXJlci5UUklBTkdMRSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9pbnRsaW5lUmVuZGVyZXIuRElBTU9ORCwgUG9pbnRsaW5lUmVuZGVyZXIuU1RBUixcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9pbnRsaW5lUmVuZGVyZXIuUExVUywgb3IgUG9pbnRsaW5lUmVuZGVyZXIuWC4gIFRoZXNlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmQgdG8gdGhlIHN0cmluZ3MgXCJjaXJjbGVcIiwgXCJzcXVhcmVcIiwgXCJ0cmlhbmdsZVwiLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpYW1vbmRcIiwgXCJzdGFyXCIsIFwicGx1c1wiLCBhbmQgXCJ4XCIgaW4gTVVHTCBmaWxlcy5cbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgUG9pbnRsaW5lUmVuZGVyZXIuQ0lSQ0xFXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFRoZSBzaGFwZSB0byB1c2UgZm9yIGRyYXdpbmcgcG9pbnRzLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGxpbmVzdHJva2Vcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgT25lIG9mIHRoZSBjb25zdGFudHMgUG9pbnRsaW5lUmVuZGVyZXIuU09MSUQsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50bGluZVJlbmRlcmVyLkRBU0hFRC4gIFRoZXNlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmQgdG8gdGhlIHN0cmluZ3MgXCJzb2xpZFwiLCBcImRhc2hlZFwiIGluIE1VR0wgZmlsZXMuXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIFBvaW50bGluZVJlbmRlcmVyLlNPTElEXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFdoZXRoZXIgdG8gZHJhdyBzb2xpZCBvciBkYXNoZWQgbGluZXNcbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBwb2ludG9wYWNpdHlcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgbnVtYmVyXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDEuMFxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBUaGUgb3BhY3RpeSBvZiB0aGUgZHJhd24gcG9pbnRzLCBpbiB0aGUgcmFuZ2UgMC0xLlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBBIHZhbHVlIG9mIDEgbWVhbnMgY29tcGxldGVseSBvcGFxdWU7IGEgdmFsdWUgb2YgMFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFucyBjb21wbGV0ZWx5IGludmlzaWJsZS5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBwb2ludG91dGxpbmV3aWR0aFxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBudW1iZXJcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMFxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBUaGUgd2lkdGgsIGluIHBpeGVscywgb2YgdGhlIG91dGxpbmUgdG8gYmUgZHJhd25cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJvdW5kIGVhY2ggcG9pbnQuICBBIHZhbHVlIG9mIDAgbWVhbnMgZHJhdyBub1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIHBvaW50b3V0bGluZWNvbG9yXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIFJHQkNvbG9yXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgIDB4MDAwMDAwIChibGFjaylcbi8vICAgICBERVNDUklQVElPTjogICAgICAgICAgVGhlIGNvbG9yIHRvIHVzZSBmb3IgdGhlIG91dGxpbmUgYXJvdW5kIGVhY2ggcG9pbnQuXG4vL1xudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIuanMnKSxcbiAgICBSR0JDb2xvciA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLnBsb3QucmVuZGVyZXIpO1xuXG52YXIgUG9pbnRsaW5lUmVuZGVyZXIgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJQb2ludGxpbmVSZW5kZXJlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0EoUmVuZGVyZXIpO1xuICAgIHRoaXMuaGFzQShcIm51bWJlck9mVmFyaWFibGVzXCIpLndoaWNoLmRlZmF1bHRzVG8oMik7XG4gICAgLy9cbiAgICAvL3RoaXMuaXNCdWlsdFdpdGgoLi4uKSAgTk8gTk8gTk8hISFcbiAgICAvL1xuICAgIC8vIERPIE5PVCBDQUxMIGlzQnVpbHRXaXRoIGZvciBhIHJlbmRlcmVyIHN1YmNsYXNzOyBSZW5kZXJlci5kZWNsYXJlT3B0aW9ucyBjYWxscyBpc0J1aWx0V2l0aCgpLCBhbmQgaXRcbiAgICAvLyB3aWxsIGJyZWFrIGlmIHlvdSBhbHNvIGNhbGwgaXQgaGVyZSEhIVxufSk7XG5cblxuUG9pbnRsaW5lUmVuZGVyZXIuQ0lSQ0xFICAgPSBcImNpcmNsZVwiO1xuUG9pbnRsaW5lUmVuZGVyZXIuU1FVQVJFICAgPSBcInNxdWFyZVwiO1xuUG9pbnRsaW5lUmVuZGVyZXIuVFJJQU5HTEUgPSBcInRyaWFuZ2xlXCI7XG5Qb2ludGxpbmVSZW5kZXJlci5ESUFNT05EICA9IFwiZGlhbW9uZFwiO1xuUG9pbnRsaW5lUmVuZGVyZXIuU1RBUiAgICAgPSBcInN0YXJcIjtcblBvaW50bGluZVJlbmRlcmVyLlBMVVMgICAgID0gXCJwbHVzXCI7XG5Qb2ludGxpbmVSZW5kZXJlci5YICAgICAgICA9IFwieFwiO1xuXG5Qb2ludGxpbmVSZW5kZXJlci5zaGFwZXMgPSBbIFxuICAgIFBvaW50bGluZVJlbmRlcmVyLkNJUkNMRSxcbiAgICBQb2ludGxpbmVSZW5kZXJlci5TUVVBUkUsXG4gICAgUG9pbnRsaW5lUmVuZGVyZXIuVFJJQU5HTEUsXG4gICAgUG9pbnRsaW5lUmVuZGVyZXIuRElBTU9ORCxcbiAgICBQb2ludGxpbmVSZW5kZXJlci5TVEFSLFxuICAgIFBvaW50bGluZVJlbmRlcmVyLlBMVVMsXG4gICAgUG9pbnRsaW5lUmVuZGVyZXIuWFxuXTtcblxuUG9pbnRsaW5lUmVuZGVyZXIuaXNTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHZhciBpO1xuICAgIGZvciAoaT0wOyBpPFBvaW50bGluZVJlbmRlcmVyLnNoYXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoUG9pbnRsaW5lUmVuZGVyZXIuc2hhcGVzW2ldID09PSBzaGFwZSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qb2ludGxpbmVSZW5kZXJlci5wYXJzZVNoYXBlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmIChzdHJpbmcudG9Mb3dlckNhc2UoKSA9PT0gUG9pbnRsaW5lUmVuZGVyZXIuQ0lSQ0xFKSAgIHsgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyLkNJUkNMRTsgICB9XG4gICAgaWYgKHN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBQb2ludGxpbmVSZW5kZXJlci5TUVVBUkUpICAgeyByZXR1cm4gUG9pbnRsaW5lUmVuZGVyZXIuU1FVQVJFOyAgIH1cbiAgICBpZiAoc3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IFBvaW50bGluZVJlbmRlcmVyLlRSSUFOR0xFKSB7IHJldHVybiBQb2ludGxpbmVSZW5kZXJlci5UUklBTkdMRTsgfVxuICAgIGlmIChzdHJpbmcudG9Mb3dlckNhc2UoKSA9PT0gUG9pbnRsaW5lUmVuZGVyZXIuRElBTU9ORCkgIHsgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyLkRJQU1PTkQ7ICB9XG4gICAgaWYgKHN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBQb2ludGxpbmVSZW5kZXJlci5TVEFSKSAgICAgeyByZXR1cm4gUG9pbnRsaW5lUmVuZGVyZXIuU1RBUjsgICAgIH1cbiAgICBpZiAoc3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IFBvaW50bGluZVJlbmRlcmVyLlBMVVMpICAgICB7IHJldHVybiBQb2ludGxpbmVSZW5kZXJlci5QTFVTOyAgICAgfVxuICAgIGlmIChzdHJpbmcudG9Mb3dlckNhc2UoKSA9PT0gUG9pbnRsaW5lUmVuZGVyZXIuWCkgICAgICAgIHsgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyLlg7ICAgICAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBwb2ludCBzaGFwZTogXCIgKyBzdHJpbmcpO1xufTtcblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gY29udmVydHMgYSBcInNoYXBlXCIgZW51bSBvYmplY3QgdG8gYSBzdHJpbmcuICBJbiByZWFsaXR5LCB0aGUgb2JqZWN0cyBBUkVcbiAqIHRoZSBzdHJpbmdzLCBzbyB3ZSBqdXN0IHJldHVybiB0aGUgb2JqZWN0LlxuICovXG5Qb2ludGxpbmVSZW5kZXJlci5zZXJpYWxpemVTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiBzaGFwZTtcbn07XG5cblBvaW50bGluZVJlbmRlcmVyLlNoYXBlT3B0aW9uID0gbmV3IGplcm1haW5lLk1vZGVsKFwiUG9pbnRsaW5lUmVuZGVyZXIuU2hhcGVPcHRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFJlbmRlcmVyLk9wdGlvbik7XG4gICAgdGhpcy5oYXNBKFwidmFsdWVcIikud2hpY2gudmFsaWRhdGVzV2l0aChQb2ludGxpbmVSZW5kZXJlci5pc1NoYXBlKTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwidmFsdWVcIik7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwic2VyaWFsaXplVmFsdWVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUG9pbnRsaW5lUmVuZGVyZXIuc2VyaWFsaXplU2hhcGUodGhpcy52YWx1ZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJwYXJzZVZhbHVlXCIsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgdGhpcy52YWx1ZSggUG9pbnRsaW5lUmVuZGVyZXIucGFyc2VTaGFwZShzdHJpbmcpICk7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwidmFsdWVFcVwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlKCk9PT12YWx1ZSk7XG4gICAgfSk7XG59KTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuUG9pbnRsaW5lUmVuZGVyZXIuU09MSUQgICA9IFwic29saWRcIjtcblBvaW50bGluZVJlbmRlcmVyLkRBU0hFRCAgPSBcImRhc2hlZFwiO1xuXG5Qb2ludGxpbmVSZW5kZXJlci5zdHJva2VzID0gWyBcbiAgICBQb2ludGxpbmVSZW5kZXJlci5TT0xJRCxcbiAgICBQb2ludGxpbmVSZW5kZXJlci5EQVNIRURcbl07XG5cblBvaW50bGluZVJlbmRlcmVyLmlzU3Ryb2tlID0gZnVuY3Rpb24gKHN0cm9rZSkge1xuICAgIHZhciBpO1xuICAgIGZvciAoaT0wOyBpPFBvaW50bGluZVJlbmRlcmVyLnN0cm9rZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKFBvaW50bGluZVJlbmRlcmVyLnN0cm9rZXNbaV0gPT09IHN0cm9rZSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qb2ludGxpbmVSZW5kZXJlci5wYXJzZVN0cm9rZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICBpZiAoc3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IFBvaW50bGluZVJlbmRlcmVyLlNPTElEKSAgIHsgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyLlNPTElEOyAgIH1cbiAgICBpZiAoc3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IFBvaW50bGluZVJlbmRlcmVyLkRBU0hFRCkgIHsgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyLkRBU0hFRDsgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBsaW5lIHN0cm9rZTogXCIgKyBzdHJpbmcpO1xufTtcblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gY29udmVydHMgYSBcInN0cm9rZVwiIGVudW0gb2JqZWN0IHRvIGEgc3RyaW5nLiAgSW4gcmVhbGl0eSwgdGhlIG9iamVjdHMgQVJFXG4gKiB0aGUgc3RyaW5ncywgc28gd2UganVzdCByZXR1cm4gdGhlIG9iamVjdC5cbiAqL1xuUG9pbnRsaW5lUmVuZGVyZXIuc2VyaWFsaXplU3Ryb2tlID0gZnVuY3Rpb24gKHN0cm9rZSkge1xuICAgIHJldHVybiBzdHJva2U7XG59O1xuXG5Qb2ludGxpbmVSZW5kZXJlci5TdHJva2VPcHRpb24gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJQb2ludGxpbmVSZW5kZXJlci5TdHJva2VPcHRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFJlbmRlcmVyLk9wdGlvbik7XG4gICAgdGhpcy5oYXNBKFwidmFsdWVcIikud2hpY2gudmFsaWRhdGVzV2l0aChQb2ludGxpbmVSZW5kZXJlci5pc1N0cm9rZSk7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInZhbHVlXCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInNlcmlhbGl6ZVZhbHVlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyLnNlcmlhbGl6ZVN0cm9rZSh0aGlzLnZhbHVlKCkpO1xuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInBhcnNlVmFsdWVcIiwgZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICB0aGlzLnZhbHVlKCBQb2ludGxpbmVSZW5kZXJlci5wYXJzZVN0cm9rZShzdHJpbmcpICk7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwidmFsdWVFcVwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlKCk9PT12YWx1ZSk7XG4gICAgfSk7XG59KTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuUmVuZGVyZXIuZGVjbGFyZU9wdGlvbnMoUG9pbnRsaW5lUmVuZGVyZXIsIFwiUG9pbnRsaW5lUmVuZGVyZXJPcHRpb25zXCIsIFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJsaW5lY29sb3JcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5SR0JDb2xvck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBuZXcgUkdCQ29sb3IoMCwwLDApXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJsaW5ld2lkdGhcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5OdW1iZXJPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogMVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwicG9pbnRzaGFwZVwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFBvaW50bGluZVJlbmRlcmVyLlNoYXBlT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IFBvaW50bGluZVJlbmRlcmVyLkNJUkNMRVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwibGluZXN0cm9rZVwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFBvaW50bGluZVJlbmRlcmVyLlN0cm9rZU9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBQb2ludGxpbmVSZW5kZXJlci5TT0xJRFxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwicG9pbnRzaXplXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IDBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcInBvaW50Y29sb3JcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5SR0JDb2xvck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiBuZXcgUkdCQ29sb3IoMCwwLDApXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJwb2ludG9wYWNpdHlcIixcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgOiBSZW5kZXJlci5OdW1iZXJPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogMS4wXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJwb2ludG91dGxpbmV3aWR0aFwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiICAgICAgICAgIDogXCJwb2ludG91dGxpbmVjb2xvclwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG5ldyBSR0JDb2xvcigwLDAsMClcbiAgICB9XG5dKTtcblxuUmVuZGVyZXIuUE9JTlRMSU5FID0gbmV3IFJlbmRlcmVyLlR5cGUoXCJwb2ludGxpbmVcIik7XG5SZW5kZXJlci5QT0lOVCAgICAgPSBuZXcgUmVuZGVyZXIuVHlwZShcInBvaW50XCIpO1xuUmVuZGVyZXIuTElORSAgICAgID0gbmV3IFJlbmRlcmVyLlR5cGUoXCJsaW5lXCIpO1xuXG5SZW5kZXJlci5hZGRUeXBlKHtcInR5cGVcIiAgOiBSZW5kZXJlci5UeXBlLnBhcnNlKFwicG9pbnRsaW5lXCIpLFxuICAgICAgICAgICAgICAgICAgXCJtb2RlbFwiIDogUG9pbnRsaW5lUmVuZGVyZXJ9KTtcblJlbmRlcmVyLmFkZFR5cGUoe1widHlwZVwiICA6IFJlbmRlcmVyLlR5cGUucGFyc2UoXCJsaW5lXCIpLFxuICAgICAgICAgICAgICAgICAgXCJtb2RlbFwiIDogUG9pbnRsaW5lUmVuZGVyZXJ9KTtcblJlbmRlcmVyLmFkZFR5cGUoe1widHlwZVwiICA6IFJlbmRlcmVyLlR5cGUucGFyc2UoXCJwb2ludFwiKSxcbiAgICAgICAgICAgICAgICAgIFwibW9kZWxcIiA6IFBvaW50bGluZVJlbmRlcmVyfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRsaW5lUmVuZGVyZXI7XG5cbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxuLy8gVGhlIFJhbmdlQmFyIHJlbmRlcmVyIGlzIGEgMi12YXJpYWJsZSByZW5kZXJlciB3aGljaCBkcmF3cyBhXG4vLyB2ZXJ0aWNhbCBiYXIgYmV0d2VlbiB0d28gZGF0YSB2YWx1ZXMsIGFuZCBvcHRpb25hbGx5IG91dGxpbmVzXG4vLyBhcm91bmQgdGhlIGJhcnMuICBJdCBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIEJhciByZW5kZXJlciBleGNlcHRcbi8vIHRoYXQgdGhlIGJhciBpcyBkcmF3biBiZXR3ZWVuIHR3byBkYXRhIHZhbHVlcywgaW5zdGVhZCBvZiBiZXR3ZWVuIGFcbi8vIHNpbmdsZSBkYXRhIHZhbHVlIGFuZCBhIGJhc2UgbGluZS5cbi8vIFxuLy8gVGhlIGxpbmUgc2VnZW1lbnRzIHNob3VsZCBvY2NsdWRlIHRoZSBzb2xpZCBmaWxsLlxuLy8gXG4vLyBUaGlzIHJlbmRlcmVyIGFjY2VwdHMgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGJhcndpZHRoXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIERhdGFNZWFzdXJlXG4vLyAgICAgREVGQVVMVCBWQUxVRTogICAgICAgID8/P1xuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBXaWR0aCwgaW4gcmVsYXRpdmUgdGVybXMgdG8gdGhlIHR5cGUgb2YgdGhlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMgdGhlIHBsb3QgaXMgb24sIG9mIHRoZSBiYXJzLlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgYmFyb2Zmc2V0XG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAwXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFRoZSBvZmZzZXQgb2YgdGhlIGxlZnQgZWRnZSBvZiBlYWNoIGJhclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIGRhdGEgdmFsdWUsIGFzIGFcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb24gKDAtMSkgb2YgdGhlIGJhcndpZHRoLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGZpbGxjb2xvclxuLy8gICAgIERBVEEgVFlQRTogICAgICAgICAgICBSR0JDb2xvclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAweDgwODA4MCAoZGFyayBncmF5KVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBDb2xvciB1c2VkIGZvciBmaWxsaW5nIHRoZSBiYXJzLlxuLy8gXG4vLyAgICAgT1BUSU9OIE5BTUU6ICAgICAgICAgIGZpbGxvcGFjaXR5XG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAxXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIE9wYWNpdHkgdXNlZCBmb3IgdGhlIGZpbGwgYXJlYS5cbi8vIFxuLy8gICAgIE9QVElPTiBOQU1FOiAgICAgICAgICBsaW5lY29sb3Jcbi8vICAgICBEQVRBIFRZUEU6ICAgICAgICAgICAgUkdCQ29sb3Jcbi8vICAgICBERUZBVUxUIFZBTFVFOiAgICAgICAgMHgwMDAwMDAgKGJsYWNrKVxuLy8gICAgIERFU0NSSVBUSU9OOiAgICAgICAgICBDb2xvciB1c2VkIGZvciBvdXRsaW5lcyBhcm91bmQgdGhlIGJhcnMuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgbGluZXdpZHRoXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAwXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIFdpZHRoLCBpbiBwaXhlbHMsIG9mIG91dGxpbmVzIGFyb3VuZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYmFycy4gIEEgdmFsdWUgb2YgMCAod2hpY2ggaXMgdGhlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQpIG1lYW5zIGRvbid0IGRyYXcgb3V0bGluZXMuXG4vLyBcbi8vICAgICBPUFRJT04gTkFNRTogICAgICAgICAgaGlkZWxpbmVzXG4vLyAgICAgREFUQSBUWVBFOiAgICAgICAgICAgIG51bWJlclxuLy8gICAgIERFRkFVTFQgVkFMVUU6ICAgICAgICAyXG4vLyAgICAgREVTQ1JJUFRJT046ICAgICAgICAgIEJhcnMgd2hpY2ggYXJlIGxlc3Mgd2lkZSwgaW4gcGl4ZWxzLCB0aGFuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgbnVtYmVyIGRvIG5vdCByZW5kZXIgdGhlaXIgb3V0bGluZXMuXG4vLyBcbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyLmpzJyksXG4gICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi4vZGF0YV9tZWFzdXJlLmpzJyksXG4gICAgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLnBsb3QucmVuZGVyZXIpO1xuXG52YXIgUmFuZ2VCYXJSZW5kZXJlciA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIlJhbmdlQmFyUmVuZGVyZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBKFJlbmRlcmVyKTtcbiAgICB0aGlzLmhhc0EoXCJudW1iZXJPZlZhcmlhYmxlc1wiKS53aGljaC5kZWZhdWx0c1RvKDMpO1xufSk7XG5cblJlbmRlcmVyLmRlY2xhcmVPcHRpb25zKFJhbmdlQmFyUmVuZGVyZXIsIFwiUmFuZ2VCYXJSZW5kZXJlck9wdGlvbnNcIiwgW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImJhcndpZHRoXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuSG9yaXpvbnRhbERhdGFNZWFzdXJlT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IG5ldyBEYXRhTWVhc3VyZS5wYXJzZShcIm51bWJlclwiLCAwKVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwiYmFyb2Zmc2V0XCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IDBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImZpbGxjb2xvclwiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLlJHQkNvbG9yT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IFJHQkNvbG9yLnBhcnNlKFwiMHg4MDgwODBcIilcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImZpbGxvcGFjaXR5XCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IDEuMFxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwibGluZWNvbG9yXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuUkdCQ29sb3JPcHRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiICAgICAgIDogbmV3IFJHQkNvbG9yKDAsMCwwKVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIiAgICAgICAgICA6IFwibGluZXdpZHRoXCIsXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgIDogUmVuZGVyZXIuTnVtYmVyT3B0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIiAgICAgICA6IDFcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCIgICAgICAgICAgOiBcImhpZGVsaW5lc1wiLFxuICAgICAgICBcInR5cGVcIiAgICAgICAgICA6IFJlbmRlcmVyLk51bWJlck9wdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCIgICAgICAgOiAyXG4gICAgfVxuXSk7XG5cblJlbmRlcmVyLlJBTkdFQkFSID0gbmV3IFJlbmRlcmVyLlR5cGUoXCJyYW5nZWJhclwiKTtcblxuUmVuZGVyZXIuYWRkVHlwZSh7XCJ0eXBlXCIgIDogUmVuZGVyZXIuVHlwZS5wYXJzZShcInJhbmdlYmFyXCIpLFxuICAgICAgICAgICAgICAgICAgXCJtb2RlbFwiIDogUmFuZ2VCYXJSZW5kZXJlcn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlQmFyUmVuZGVyZXI7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbi8qKlxuICogVGV4dCBpcyBhIEplcm1haW5lIG1vZGVsIHRoYXQgc3VwcG9ydHMgc3RvcmluZyBhbmQgZGV0ZXJtaW5pbmcgbWV0cmljcyBvZlxuICogc3RyaW5ncyBpbiBkaWZmZXJlbnQgZ3JhcGhpY3MgY29udGV4dHMuXG4gKlxuICogQGNsYXNzIFRleHRcbiAqIEBmb3IgVGV4dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gc3RyaW5nIHtTdHJpbmd9IFRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBUZXh0IG1vZGVsXG4gKi9cbnZhciBUZXh0ID0gbmV3IGplcm1haW5lLk1vZGVsKFwiVGV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInN0cmluZ1wiKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBUZXh0IG1vZGVsXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc3RyaW5nXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJzdHJpbmdcIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVucm90YXRlZCB3aWR0aCBvZiB0aGUgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3JpZ1dpZHRoXG4gICAgICogQHR5cGUge2Zsb2F0fVxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcIm9yaWdXaWR0aFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5yb3RhdGVkIGhlaWdodCBvZiB0aGUgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3JpZ0hlaWdodFxuICAgICAqIEB0eXBlIHtmbG9hdH1cbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJvcmlnSGVpZ2h0XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb3RhdGVkIHdpZHRoIG9mIHRoZSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByb3RhdGVkV2lkdGhcbiAgICAgKiBAdHlwZSB7ZmxvYXR9XG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwicm90YXRlZFdpZHRoXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb3RhdGVkIGhlaWdodCBvZiB0aGUgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcm90YXRlZEhlaWdodFxuICAgICAqIEB0eXBlIHtmbG9hdH1cbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJyb3RhdGVkSGVpZ2h0XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIHRoaXMuaGFzQShcImZvbnRcIikud2hpY2guaXNBKFwic3RyaW5nXCIpLmFuZC53aGljaC5kZWZhdWx0c1RvKFwiXCIpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB1bnJvdGF0ZWQgYW5kIHJvdGF0ZWQgd2lkdGhzIGFuZCBoZWlnaHRzIGZvciB0aGUgc3RvcmVkIHN0cmluZy4gT3ZlcnJpZGRlbiBieVxuICAgICAqIGltcGxlbWVudGF0aW9ucyBpbiBncmFwaGljcyBkcml2ZXJzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbml0aWFsaXplR2VvbWV0cnlcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoaWNzQ29udGV4dFxuICAgICAqICAgQHBhcmFtIHtGbG9hdH0gZ3JhcGhpY3NDb250ZXh0LmFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaW5pdGlhbGl6ZUdlb21ldHJ5XCIsIGZ1bmN0aW9uIChncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgdmFyIG9yaWdXaWR0aCxcbiAgICAgICAgICAgIG9yaWdIZWlnaHQsXG4gICAgICAgICAgICByb3RhdGVkV2lkdGgsXG4gICAgICAgICAgICByb3RhdGVkSGVpZ2h0O1xuXG4gICAgICAgIG9yaWdXaWR0aCAgPSB0aGlzLm1lYXN1cmVTdHJpbmdXaWR0aChncmFwaGljc0NvbnRleHQpO1xuICAgICAgICBvcmlnSGVpZ2h0ID0gdGhpcy5tZWFzdXJlU3RyaW5nSGVpZ2h0KGdyYXBoaWNzQ29udGV4dCk7XG4gICAgICAgIHJvdGF0ZWRXaWR0aCA9IG9yaWdXaWR0aDtcbiAgICAgICAgcm90YXRlZEhlaWdodCA9IG9yaWdIZWlnaHQ7XG5cbiAgICAgICAgaWYgKGdyYXBoaWNzQ29udGV4dCAmJiBncmFwaGljc0NvbnRleHQuYW5nbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gZ3JhcGhpY3NDb250ZXh0LmFuZ2xlLzE4MCAqIE1hdGguUEk7XG4gICAgICAgICAgICByb3RhdGVkV2lkdGggPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpICogb3JpZ1dpZHRoICsgTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKSAqIG9yaWdIZWlnaHQ7XG4gICAgICAgICAgICByb3RhdGVkSGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKSAqIG9yaWdXaWR0aCArIE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSkgKiBvcmlnSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcmlnV2lkdGgob3JpZ1dpZHRoKTtcbiAgICAgICAgdGhpcy5vcmlnSGVpZ2h0KG9yaWdIZWlnaHQpO1xuICAgICAgICB0aGlzLnJvdGF0ZWRXaWR0aChyb3RhdGVkV2lkdGgpO1xuICAgICAgICB0aGlzLnJvdGF0ZWRIZWlnaHQocm90YXRlZEhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHVucm90YXRlZCB3aWR0aCBmb3IgdGhlIHN0b3JlZCBzdHJpbmcuIE92ZXJyaWRkZW4gYnkgaW1wbGVtZW50YXRpb25zIGluIGdyYXBoaWNzXG4gICAgICogZHJpdmVycy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbWVhc3VyZVN0cmluZ1dpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtGbG9hdH0gVW5yb3RhdGVkIHdpZHRoIG9mIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhpY3NDb250ZXh0XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwibWVhc3VyZVN0cmluZ1dpZHRoXCIsIGZ1bmN0aW9uIChncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgLy8gR3JhcGhpY3MgZHJpdmVycyBzaG91bGQgcmVwbGFjZSB0aGlzIG1ldGhvZCB3aXRoIGFuIGFjdHVhbCBpbXBsZW1lbnRhdGlvbjsgdGhpc1xuICAgICAgICAvLyBpcyBqdXN0IGEgcGxhY2Vob2xkZXIuICBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIHJldHVybiB0aGUgd2lkdGgsIGluIHBpeGVscyxcbiAgICAgICAgLy8gb2YgdGhlIGdpdmVuIHN0cmluZy4gIE9mIGNvdXJzZSB0aGlzIGlzIGRlcGVuZGVudCBvbiBmb250IGNob2ljZSwgc2l6ZSwgZXRjLFxuICAgICAgICAvLyBidXQgd2UgZ2xvc3Mgb3ZlciB0aGF0IGF0IHRoZSBtb21lbnQuICBKdXN0IHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHN0cmluZ1xuICAgICAgICAvLyB1c2luZyBzb21lIHJlYXNvbmFibGUgZGVmYXVsdCBmb250IGZvciBub3cuICBMYXRlciBvbiwgd2UnbGwgbW9kaWZ5IHRoaXNcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gdXNlIGZvbnQgaW5mb3JtYXRpb24uXG4gICAgICAgIHZhciBsaW5lcyxcbiAgICAgICAgICAgIG1heExlbmd0aCA9IDEsXG4gICAgICAgICAgICB0ZXN0TGVuZ3RoLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBpZiAodGhpcy5zdHJpbmcoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZWFzdXJlU3RyaW5nV2lkdGggcmVxdWlyZXMgdGhlIHN0cmluZyBhdHRyIHRvIGJlIHNldC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IHRoaXMuc3RyaW5nKCkuc3BsaXQoL1xcbi8pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlc3RMZW5ndGggPSBsaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGVzdExlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1heExlbmd0aCA9IHRlc3RMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBtYXhMZW5ndGggKiAxNTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdW5yb3RhdGVkIGhlaWdodCBmb3IgdGhlIHN0b3JlZCBzdHJpbmcuIE92ZXJyaWRkZW4gYnkgaW1wbGVtZW50YXRpb25zIGluIGdyYXBoaWNzXG4gICAgICogZHJpdmVycy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbWVhc3VyZVN0cmluZ0hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7RmxvYXR9IFVucm90YXRlZCBoZWlnaHQgb2Ygc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGljc0NvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJtZWFzdXJlU3RyaW5nSGVpZ2h0XCIsIGZ1bmN0aW9uIChncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgLy8gR3JhcGhpY3MgZHJpdmVycyBzaG91bGQgcmVwbGFjZSB0aGlzIG1ldGhvZCB3aXRoIGFuIGFjdHVhbCBpbXBsZW1lbnRhdGlvbjsgdGhpc1xuICAgICAgICAvLyBpcyBqdXN0IGEgcGxhY2Vob2xkZXIuICBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIHJldHVybiB0aGUgaGVpZ2h0LCBpbiBwaXhlbHMsXG4gICAgICAgIC8vIG9mIHRoZSBnaXZlbiBzdHJpbmcuICBPZiBjb3Vyc2UgdGhpcyBpcyBkZXBlbmRlbnQgb24gZm9udCBjaG9pY2UsIHNpemUsIGV0YyxcbiAgICAgICAgLy8gYnV0IHdlIGdsb3NzIG92ZXIgdGhhdCBhdCB0aGUgbW9tZW50LiAgSnVzdCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgc3RyaW5nXG4gICAgICAgIC8vIHVzaW5nIHNvbWUgcmVhc29uYWJsZSBkZWZhdWx0IGZvbnQgZm9yIG5vdy4gIExhdGVyIG9uLCB3ZSdsbCBtb2RpZnkgdGhpc1xuICAgICAgICAvLyBmdW5jdGlvbiB0byB1c2UgZm9udCBpbmZvcm1hdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuc3RyaW5nKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWVhc3VyZVN0cmluZ0hlaWdodCByZXF1aXJlcyB0aGUgc3RyaW5nIGF0dHIgdG8gYmUgc2V0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3bGluZUNvdW50ID0gdGhpcy5zdHJpbmcoKS5tYXRjaCgvXFxuL2cpO1xuICAgICAgICByZXR1cm4gKG5ld2xpbmVDb3VudCAhPT0gbnVsbCA/IChuZXdsaW5lQ291bnQubGVuZ3RoICsgMSkgOiAxKSAqIDEyO1xuICAgIH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dDtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIFRleHQgPSByZXF1aXJlKCcuL3RleHQuanMnKSxcbiAgICBSR0JDb2xvciA9IHJlcXVpcmUoJy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCcuLi9tYXRoL3BvaW50LmpzJyksXG4gICAgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgIGRlZmF1bHRWYWx1ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCksXG4gICAgYXR0cmlidXRlcyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyhkZWZhdWx0VmFsdWVzLnRpdGxlKTtcblxuLyoqXG4gKiBUaXRsZSBpcyBhIEplcm1pYW5lIG1vZGVsIHRoYXQgY29udHJvbHMgR3JhcGggVGl0bGVzLlxuICpcbiAqIEBjbGFzcyBUaXRsZVxuICogQGZvciBUaXRsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoXG4gKiBAYXV0aG9yIGpyZnJpbW1lXG4gKi9cbnZhciBUaXRsZSA9IG5ldyBqZXJtYWluZS5Nb2RlbChcIkdyYXBoVGl0bGVcIiwgZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFBvaW50ZXIgdG8gdGhlIFRpdGxlJ3MgcGFyZW50IEdyYXBoIEplcm1haW5lIG1vZGVsLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGdyYXBoXG4gICAgICogQHR5cGUge0dyYXBofVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJncmFwaFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChncmFwaCkge1xuICAgICAgICB2YXIgR3JhcGggPSByZXF1aXJlKCcuL2dyYXBoLmpzJyk7XG4gICAgICAgIHJldHVybiBncmFwaCBpbnN0YW5jZW9mIEdyYXBoO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IG9mIHRoZSB0aXRsZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0ZXh0XG4gICAgICogQHR5cGUge1RleHR9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInRleHRcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dCBpbnN0YW5jZW9mIFRleHQ7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgVGl0bGUgaXMgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgR3JhcGhzIGBwbG90YCBvciBgcGFkZGluZ2BcbiAgICAgKiBib3guXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZnJhbWVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJmcmFtZVwiKS53aGljaC5pc0EoXCJzdHJpbmdcIik7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBib3JkZXIgdG8gYmUgZHJhd24gYXJvdW5kIHRoZSB0aXRsZSBpbiBwaXhlbDsgdXNlIGEgdmFsdWUgb2YgYDBgXG4gICAgICogdG8gbm90IGRyYXcgYSBib3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm9yZGVyXG4gICAgICogQHR5cGUge0ludGVnZXJ9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImJvcmRlclwiKS53aGljaC5pc0FuKFwiaW50ZWdlclwiKTtcbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgVGl0bGUncyByZWdpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29sb3JcbiAgICAgKiBAdHlwZSB7UkdCQ29sb3J9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImNvbG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvciBpbnN0YW5jZW9mIFJHQkNvbG9yO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENvbG9yIGZvciB0aGUgVGl0bGUncyBib3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm9yZGVyY29sb3JcbiAgICAgKiBAdHlwZSB7UkdCQ29sb3J9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImJvcmRlcmNvbG9yXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGJvcmRlcmNvbG9yKSB7XG4gICAgICAgIHJldHVybiBib3JkZXJjb2xvciBpbnN0YW5jZW9mIFJHQkNvbG9yO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE9wYWNpdHkgb2YgdGhlIFRpdGxlJ3MgcmVnaW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wYWNpdHlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJvcGFjaXR5XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHBhZGRpbmcgYmV0d2VlbiB0aGUgVGl0bGUncyB0ZXh0IGFuZCBpdHMgYm9yZGVyIGluIHBpeGVsczsgdXNlIGFcbiAgICAgKiB2YWx1ZSBvZiBgMGAgdG8gbm90IGRyYXcgdGhlIHBhZGRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGFkZGluZ1xuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJwYWRkaW5nXCIpLndoaWNoLmlzQW4oXCJpbnRlZ2VyXCIpO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgY29ybmVycyBvZiB0aGUgdGl0bGUgYXBwZWFyIHJvdW5kZWQuIElmIGNvcm5lcnJhZGl1cyBpcyAwLFxuICAgICAqIHdoaWNoIGlzIHRoZSBkZWZhdWx0LCB0aGUgY29ybmVycyBhcmUgZHJhd24gc3F1YXJlLiBJZiBjb3JuZXJyYWRpdXMgPiAwLCB0aGVuIHRoZVxuICAgICAqIGNvcm5lcnMgYXJlIHJvdW5kZWQgb2ZmIHVzaW5nIGNpcmNsZXMgd2hvc2UgcmFkaXVzIGlzIGNvcm5lcnJhZGl1cyBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29ybmVycmFkaXVzXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiY29ybmVycmFkaXVzXCIpLndoaWNoLmlzQW4oXCJpbnRlZ2VyXCIpO1xuICAgIC8qKlxuICAgICAqIEEgY29vcmRpbmF0ZSBwYWlyIHdoaWNoIGdpdmVzIHRoZSByZWxhdGl2ZSBsb2NhdGlvbiBvZiB0aGUgVGl0bGUncyBhbmNob3IgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYW5jaG9yXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJhbmNob3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBhbmNob3IgaW5zdGFuY2VvZiBQb2ludDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBIGNvb3JkaW5hdGUgcGFpciB3aGljaCBnaXZlcyB0aGUgbG9jYXRpb24gb2YgdGhlIFRpdGxlJ3MgYmFzZSBwb2ludCwgcmVsYXRpdmUgdG9cbiAgICAgKiBpdHMgR3JhcGgncyBwbG90IG9yIHBhZGRpbmcgYm94IC0gZGV0ZXJtaW5lZCBieSB0aGUgYGZyYW1lYCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYmFzZVxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiYmFzZVwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChiYXNlKSB7XG4gICAgICAgIHJldHVybiBiYXNlIGluc3RhbmNlb2YgUG9pbnQ7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQSBjb29yZGluYXRlIHBhaXIgb2YgcGl4ZWwgb2Zmc2V0cyBmb3IgdGhlIGJhc2UgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcInBvc2l0aW9uXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbiBpbnN0YW5jZW9mIFBvaW50O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoZSBmb250LXNpemUgb2YgdGhlIHRpdGxlLiBDdXJyZW50bHkgaXMgYSBjb25zdGFudC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmb250LXNpemVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKi9cbiAgICB0aGlzLmhhc0EoXCJmb250U2l6ZVwiKS53aGljaC5pc0EoXCJzdHJpbmdcIikuYW5kLmRlZmF1bHRzVG8oXCIxOHB4XCIpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgZ2VvbWV0cnkgb2YgdGhlIFRpdGxlJ3MgdGV4dC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZUdlb21ldHJ5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGljc0NvbnRleHRcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaW5pdGlhbGl6ZUdlb21ldHJ5XCIsIGZ1bmN0aW9uIChncmFwaGljc0NvbnRleHQpIHtcbiAgICAgICAgZ3JhcGhpY3NDb250ZXh0LmZvbnRTaXplID0gdGhpcy5mb250U2l6ZSgpO1xuICAgICAgICB0aGlzLnRleHQoKS5pbml0aWFsaXplR2VvbWV0cnkoZ3JhcGhpY3NDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBHcmFwaCBUaXRsZS4gT3ZlcnJpZGRlbiBieSBpbXBsZW1lbnRhdGlvbnMgaW4gZ3JhcGhpY3MgZHJpdmVycy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uICgpIHt9KTtcblxuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJ0ZXh0XCIsIFwiZ3JhcGhcIik7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMudGl0bGUsIGF0dHJpYnV0ZXMpO1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaXRsZTtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIFdhcm5pbmcgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn07XG5cbldhcm5pbmcucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzICA9IFdhcm5pbmc7XG4iLCIvLyBUaGlzIGZpbGUgdXNlcyBqUXVlcnkuICBBIHZhbGlkIGpRdWVyeSBvYmplY3QgbXVzdCBiZSBwYXNzZWQgdG8gdGhlXG4vLyBmdW5jdGlvbiByZXR1cm5lZCBieSByZXF1aXJpbmcgdGhpcyBmaWxlLlxudmFyIFdlYlNlcnZpY2VEYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkKSB7XG4gICAgaWYgKHR5cGVvZihXZWJTZXJ2aWNlRGF0YSkgIT09IFwidW5kZWZpbmVkXCIpIHsgcmV0dXJuIFdlYlNlcnZpY2VEYXRhOyB9XG5cbiAgICB2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbiAgICB2YXIgRGF0YSA9IHJlcXVpcmUoJy4vZGF0YS5qcycpLFxuICAgICAgICBEYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgRGF0YUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vZGF0YV9mb3JtYXR0ZXIuanMnKSxcbiAgICAgICAgQXJyYXlEYXRhID0gcmVxdWlyZSgnLi9hcnJheV9kYXRhLmpzJyksXG4gICAgICAgIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlID0gcmVxdWlyZSgnLi93ZWJfc2VydmljZV9kYXRhX2NhY2hlX25vZGUuanMnKSxcbiAgICAgICAgV2ViU2VydmljZURhdGFJdGVyYXRvciA9IHJlcXVpcmUoJy4vd2ViX3NlcnZpY2VfZGF0YV9pdGVyYXRvci5qcycpO1xuXG4gICAgV2ViU2VydmljZURhdGEgPSBuZXcgamVybWFpbmUuTW9kZWwoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzQShEYXRhKTtcbiAgICAgICAgdGhpcy5oYXNBKFwic2VydmljZWFkZHJlc3NcIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuICAgICAgICB0aGlzLmhhc0EoXCJzZXJ2aWNlYWRkcmVzc3BhdHRlcm5cIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuICAgICAgICB0aGlzLmhhc0EoXCJmb3JtYXRcIikud2hpY2guaXNBKFwic3RyaW5nXCIpO1xuICAgICAgICB0aGlzLmhhc0EoXCJmb3JtYXR0ZXJcIikud2hpY2gudmFsaWRhdGVzV2l0aChEYXRhRm9ybWF0dGVyLmlzSW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmhhc0EoXCJtZXNzYWdlSGFuZGxlclwiKTtcbiAgICAgICAgdGhpcy5oYXNBKFwiYWpheHRocm90dGxlXCIpO1xuICAgICAgICB0aGlzLmlzQnVpbHRXaXRoKFwiY29sdW1uc1wiLCBcInNlcnZpY2VhZGRyZXNzXCIsIFwiJW1lc3NhZ2VIYW5kbGVyXCIsIFwiJWFqYXh0aHJvdHRsZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbnMoKS5zaXplKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbjBUeXBlID0gdGhpcy5jb2x1bW5zKCkuYXQoMCkudHlwZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdCgpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtYXQoY29sdW1uMFR5cGU9PT1EYXRhVmFsdWUuTlVNQkVSID8gXCIlZlwiIDogXCIlWSVNJUQlSCVpJXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVyKERhdGFGb3JtYXR0ZXIuY3JlYXRlKGNvbHVtbjBUeXBlLCB0aGlzLmZvcm1hdCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hamF4dGhyb3R0bGUoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hamF4dGhyb3R0bGUoJCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcIl9kaXNwbGF5RXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyKCkuZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcImdldEJvdW5kc1wiLCBmdW5jdGlvbiAoY29sdW1uTnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHRoaXMga2x1ZGdlXG4gICAgICAgICAgICByZXR1cm4gWzAsIDEwXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5oYXNBKFwiYXJyYXlkYXRhXCIpLndoaWNoLmRlZmF1bHRzVG8obnVsbCkuYW5kLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGFycmF5ZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5ZGF0YSBpbnN0YW5jZW9mIEFycmF5RGF0YSB8fCBhcnJheWRhdGEgPT09IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHBvaW50ZXIgdG8gdGhlIGhlYWQgV2ViU2VydmljZURhdGFDYWNoZU5vZGUgaW4gdGhpcyBXZWJTZXJ2aWVEYXRhJ3MgY2FjaGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjYWNoZUhlYWRcbiAgICAgICAgICogQHR5cGUge251bGx8V2ViU2VydmljZURhdGFDYWNoZU5vZGV9XG4gICAgICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQShcImNhY2hlSGVhZFwiKS53aGljaC5kZWZhdWx0c1RvKG51bGwpLmFuZC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geCA9PT0gbnVsbCB8fCB4IGluc3RhbmNlb2YgV2ViU2VydmljZURhdGFDYWNoZU5vZGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHBvaW50ZXIgdG8gdGhlIHRhaWwgV2ViU2VydmljZURhdGFDYWNoZU5vZGUgaW4gdGhpcyBXZWJTZXJ2aWVEYXRhJ3MgY2FjaGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjYWNoZVRhaWxcbiAgICAgICAgICogQHR5cGUge251bGx8V2ViU2VydmljZURhdGFDYWNoZU5vZGV9XG4gICAgICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQShcImNhY2hlVGFpbFwiKS53aGljaC5kZWZhdWx0c1RvKG51bGwpLmFuZC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geCA9PT0gbnVsbCB8fCB4IGluc3RhbmNlb2YgV2ViU2VydmljZURhdGFDYWNoZU5vZGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYSBwb2ludGVyIHRvIHRoZSBmaXJzdCBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSBpbiB0aGlzIFdlYlNlcnZpZURhdGEncyBjYWNoZVxuICAgICAgICAgKiB0aGF0IGFjdHVhbGx5IGNvbnRhaW5zIGRhdGEsIGlmIGFueS4gIElmIHRoZSBjYWNoZSBkb2Vzbid0IGNvbnRhaW4gYW55IGRhdGEsIHJldHVybiBudWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGRhdGFIZWFkXG4gICAgICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgICAgICogQHJldHVybiB7bnVsbHxXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcImRhdGFIZWFkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZWFkID0gdGhpcy5jYWNoZUhlYWQoKTtcbiAgICAgICAgICAgIGlmIChoZWFkID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICBpZiAoaGVhZC5oYXNEYXRhKCkpIHsgcmV0dXJuIGhlYWQ7IH1cbiAgICAgICAgICAgIHJldHVybiBoZWFkLmRhdGFOZXh0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYSBwb2ludGVyIHRvIHRoZSBsYXN0IFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlIGluIHRoaXMgV2ViU2VydmllRGF0YSdzIGNhY2hlXG4gICAgICAgICAqIHRoYXQgYWN0dWFsbHkgY29udGFpbnMgZGF0YSwgaWYgYW55LiAgSWYgdGhlIGNhY2hlIGRvZXNuJ3QgY29udGFpbiBhbnkgZGF0YSwgcmV0dXJuIG51bGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgZGF0YVRhaWxcbiAgICAgICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAgICAgKiBAcmV0dXJuIHtudWxsfFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNwb25kc1RvKFwiZGF0YVRhaWxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRhaWwgPSB0aGlzLmNhY2hlVGFpbCgpO1xuICAgICAgICAgICAgaWYgKHRhaWwgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgICAgIGlmICh0YWlsLmhhc0RhdGEoKSkgeyByZXR1cm4gdGFpbDsgfVxuICAgICAgICAgICAgcmV0dXJuIHRhaWwuZGF0YVByZXYoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCBhIFdlYlNlcnZpY2VDYWNoZU5vZGUgaW50byB0aGlzIFdlYlNlcnZpY2UncyBjYWNoZS5cbiAgICAgICAgICogSWYgdGhpcyBub2RlJ3MgY292ZXJlZE1pbiBpcyBsZXNzIHRoYW4gdGhlIGNhY2hlIGhlYWQnc1xuICAgICAgICAgKiBjb3ZlcmVkTWluLCBpbnNlcnQgaXQgYXQgdGhlIGhlYWQ7IG90aGVyd2lzZSBpbnNlcnQgaXQgYXRcbiAgICAgICAgICogdGhlIHRhaWwuICBOb3RlIHRoYXQgbm9kZXMgYXJlIG9ubHkgaW5zZXJ0ZWQgZWl0aGVyIGF0IHRoZVxuICAgICAgICAgKiBoZWFkIG9yIGF0IHRoZSB0YWlsIG9mIHRoZSBjYWNoZSAtLS0gbm90IGluIHRoZSBtaWRkbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5zZXJ0Q2FjaGVOb2RlXG4gICAgICAgICAqIEBwYXJhbSB7V2ViU2VydmljZUNhY2hlTm9kZX0gbm9kZVxuICAgICAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJpbnNlcnRDYWNoZU5vZGVcIiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBoZWFkID0gdGhpcy5jYWNoZUhlYWQoKSxcbiAgICAgICAgICAgICAgICB0YWlsID0gdGhpcy5jYWNoZVRhaWwoKTtcbiAgICAgICAgICAgIGlmIChoZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZUhlYWQobm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVRhaWwobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNvdmVyZWRNaW4oKS5sdChoZWFkLmNvdmVyZWRNaW4oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uZXh0KGhlYWQpO1xuICAgICAgICAgICAgICAgICAgICBoZWFkLnByZXYobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVIZWFkKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucHJldih0YWlsKTtcbiAgICAgICAgICAgICAgICAgICAgdGFpbC5uZXh0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlVGFpbChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcImNvbnN0cnVjdFJlcXVlc3RVUkxcIiwgZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICAgICAgICB2YXIgc2VydmljZWFkZHJlc3MgPSB0aGlzLnNlcnZpY2VhZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyID0gdGhpcy5mb3JtYXR0ZXIoKTtcblxuICAgICAgICAgICAgaWYgKHNlcnZpY2VhZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTZXJ2aWNlRGF0YS5jb25zdHJ1Y3RSZXF1ZXN0VVJMOiB1bmRlZmluZWQgc2VydmljZSBhZGRyZXNzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU2VydmljZURhdGEuY29uc3RydWN0UmVxdWVzdFVSTDogdW5kZWZpbmVkIGZvcm1hdHRlciBmb3IgY29sdW1uIDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zZXJ2aWNlYWRkcmVzc3BhdHRlcm4oKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzZXJ2aWNlYWRkcmVzcy5pbmRleE9mKFwiJG1pblwiKSA8IDApICYmXG4gICAgICAgICAgICAgICAgICAgIChzZXJ2aWNlYWRkcmVzcy5pbmRleE9mKFwiJG1heFwiKSA8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZWFkZHJlc3NwYXR0ZXJuKHNlcnZpY2VhZGRyZXNzICsgXCIkbWluLCRtYXhcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlYWRkcmVzc3BhdHRlcm4oc2VydmljZWFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zZXJ2aWNlYWRkcmVzc3BhdHRlcm4oKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIiRtaW5cIiwgZm9ybWF0dGVyLmZvcm1hdChtaW4pKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIiRtYXhcIiwgZm9ybWF0dGVyLmZvcm1hdChtYXgpKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaGFzQShcImNvdmVyZWRNaW5cIikud2hpY2guZGVmYXVsdHNUbyhudWxsKS5hbmQudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHggPT09IG51bGwgfHwgRGF0YVZhbHVlLmlzSW5zdGFuY2UoeCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhc0EoXCJjb3ZlcmVkTWF4XCIpLndoaWNoLmRlZmF1bHRzVG8obnVsbCkuYW5kLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID09PSBudWxsIHx8IERhdGFWYWx1ZS5pc0luc3RhbmNlKHgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhdGUgcmVxdWVzdHMgbmVlZGVkIHRvIGZldGNoIGRhdGEgYmV0d2VlbiBjb3ZlcmVkTWluIGFuZCBjb3ZlcmVkTWF4LCBpZiBhbnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5zdXJlQ292ZXJlZFJhbmdlXG4gICAgICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcImluc3VyZUNvdmVyZWRSYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGVhZCA9IHRoaXMuY2FjaGVIZWFkKCksXG4gICAgICAgICAgICAgICAgdGFpbCA9IHRoaXMuY2FjaGVUYWlsKCksXG4gICAgICAgICAgICAgICAgY292ZXJlZE1pbiA9IHRoaXMuY292ZXJlZE1pbigpLFxuICAgICAgICAgICAgICAgIGNvdmVyZWRNYXggPSB0aGlzLmNvdmVyZWRNYXgoKTtcblxuICAgICAgICAgICAgaWYgKGNvdmVyZWRNaW4gPT09IG51bGwgfHwgY292ZXJlZE1heCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkID09PSBudWxsIHx8IHRhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RTaW5nbGVSYW5nZShjb3ZlcmVkTWluLCBjb3ZlcmVkTWF4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWRNaW4ubHQoaGVhZC5jb3ZlcmVkTWluKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgaGVhZCdzIG1pbiAgICAgICAgICAgICAgdGFpbCdzIG1heFxuICAgICAgICAgICAgICAgICAgICAvLyAgLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGNvdmVyZWRNaW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U2luZ2xlUmFuZ2UoY292ZXJlZE1pbiwgaGVhZC5jb3ZlcmVkTWluKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY292ZXJlZE1heC5ndCh0YWlsLmNvdmVyZWRNYXgoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBoZWFkJ3MgbWluICAgICAgICAgICAgICB0YWlsJ3MgbWF4XG4gICAgICAgICAgICAgICAgICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tfC0tLS1cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkTWF4XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFNpbmdsZVJhbmdlKHRhaWwuY292ZXJlZE1heCgpLCBjb3ZlcmVkTWF4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcInJlcXVlc3RTaW5nbGVSYW5nZVwiLCBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgICAgICAgIHZhciBub2RlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RVUkwsXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgSlF1ZXJ5WE1MUGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2VyL3htbC9qcXVlcnlfeG1sX3BhcnNlci5qcycpKCQpO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGNhY2hlIG5vZGUgdGhhdCB3aWxsIGhvbGQgdGhlIGRhdGEgaW4gdGhpcyByYW5nZVxuICAgICAgICAgICAgbm9kZSA9IG5ldyBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZShtaW4sIG1heCk7XG5cbiAgICAgICAgICAgIC8vIGluc2VydCBpdCBpbnRvIHRoZSBjYWNoZSBsaW5rZWQgbGlzdFxuICAgICAgICAgICAgdGhpcy5pbnNlcnRDYWNoZU5vZGUobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgVVJMIGZvciBmZXRjaGluZyB0aGUgZGF0YSBpbiB0aGlzIHJhbmdlXG4gICAgICAgICAgICByZXF1ZXN0VVJMID0gdGhpcy5jb25zdHJ1Y3RSZXF1ZXN0VVJMKG1pbiwgbWF4KTtcblxuICAgICAgICAgICAgLy8gaW5pdGlhdGUgdGhlIGZldGNoIHJlcXVlc3RcbiAgICAgICAgICAgIHRoaXMuZW1pdCh7dHlwZSA6ICdhamF4RXZlbnQnLCBhY3Rpb24gOiAnc3RhcnQnfSk7XG4gICAgICAgICAgICB0aGlzLmFqYXh0aHJvdHRsZSgpLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybCAgICAgIDogcmVxdWVzdFVSTCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZSA6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgIDogZnVuY3Rpb24gKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGRhdGEgY29udGFpbnMgYSA8dmFsdWVzPiB0YWcsIGV4dHJhY3QgaXRzIHRleHQgc3RyaW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmluZGV4T2YoXCI8dmFsdWVzPlwiKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKUXVlcnlYTUxQYXJzZXIuc3RyaW5nVG9KUXVlcnlYTUxPYmooZGF0YSkuZmluZChcInZhbHVlc1wiKS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJzZURhdGEodGhhdC5nZXRDb2x1bW5zKCksIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZW1pdCh7dHlwZSA6ICdhamF4RXZlbnQnLCBhY3Rpb24gOiAnc3VjY2Vzcyd9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5lbWl0KHt0eXBlIDogJ2RhdGFSZWFkeSd9KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZXJyb3IgOiBmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyb3JUaHJvd247XG4gICAgICAgICAgICAgICAgICAgIGlmIChqcVhIUi5zdGF0dXNDb2RlKCkuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlVSTCBub3QgZm91bmQ6ICdcIiArIHJlcXVlc3RVUkwgKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gdGV4dFN0YXR1cyArIFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fZGlzcGxheUVycm9yKG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vICdjb21wbGV0ZScgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYWZ0ZXIgZWl0aGVyICdzdWNjZXNzJyBvciAnZXJyb3InLCB3aGljaGV2ZXI6XG4gICAgICAgICAgICAgICAgY29tcGxldGUgOiBmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5lbWl0KHt0eXBlIDogJ2FqYXhFdmVudCcsIGFjdGlvbiA6ICdjb21wbGV0ZSd9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3BvbmRzVG8oXCJnZXRJdGVyYXRvclwiLCBmdW5jdGlvbiAoY29sdW1uSWRzLCBtaW4sIG1heCwgYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbE5vZGUsXG4gICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgICAgICAgICAgIG4sIGIsIGksIHRtcCxcbiAgICAgICAgICAgICAgICBmaW5hbE5vZGUsXG4gICAgICAgICAgICAgICAgZmluYWxJbmRleCxcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRpY2VzO1xuXG4gICAgICAgICAgICAvLyBpZiBtaW4gPiBtYXgsIHN3YXAgdGhlbVxuICAgICAgICAgICAgaWYgKG1pbi5ndChtYXgpKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gbWluO1xuICAgICAgICAgICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgICAgICAgICBtYXggPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvdmVyZWRNaW4oKSA9PT0gbnVsbCB8fCBtaW4ubHQodGhpcy5jb3ZlcmVkTWluKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3ZlcmVkTWluKG1pbi5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvdmVyZWRNYXgoKSA9PT0gbnVsbCB8fCBtYXguZ3QodGhpcy5jb3ZlcmVkTWF4KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3ZlcmVkTWF4KG1heC5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN1cmVDb3ZlcmVkUmFuZ2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YUhlYWQoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGNhY2hlIGlzIGVtcHR5LCByZXR1cm4gZW1wdHkgaXRlcmF0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgXCJuZXh0XCIgICAgOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJoYXNOZXh0XCIgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGNvbHVtbklkcyB0byBjb2x1bW5JbmRpY2VzXG4gICAgICAgICAgICBjb2x1bW5JbmRpY2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uSWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uSW5kaWNlcy5wdXNoKCB0aGlzLmNvbHVtbklkVG9Db2x1bW5OdW1iZXIoY29sdW1uSWRzW2ldKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBkYXRhIG5vZGUgY29udGFpbmluZyB0aGUgJ21pbicgdmFsdWVcbiAgICAgICAgICAgIGluaXRpYWxOb2RlID0gdGhpcy5kYXRhSGVhZCgpO1xuICAgICAgICAgICAgd2hpbGUgKChpbml0aWFsTm9kZSAhPT0gbnVsbCkgJiZcbiAgICAgICAgICAgICAgICAgICAoaW5pdGlhbE5vZGUuZGF0YU5leHQoKSAhPT0gbnVsbCkgJiZcbiAgICAgICAgICAgICAgICAgICAobWluLmd0KGluaXRpYWxOb2RlLmRhdGFNYXgoKSkpKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbE5vZGUgPSBpbml0aWFsTm9kZS5kYXRhTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaW5pdGlhbE5vZGUgPT09IG51bGwgfHwgIWluaXRpYWxOb2RlLmhhc0RhdGEoKSkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IHdpdGhpbiB0aGUgaW5pdGlhbCBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlICdtaW4nIHZhbHVlXG4gICAgICAgICAgICAgICAgd2hpbGUgKChpbml0aWFsSW5kZXggPCBpbml0aWFsTm9kZS5kYXRhKCkubGVuZ3RoLTEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgIChpbml0aWFsTm9kZS5kYXRhKClbaW5pdGlhbEluZGV4XVtjb2x1bW5JbmRpY2VzWzBdXS5sdChtaW4pKSkge1xuICAgICAgICAgICAgICAgICAgICArK2luaXRpYWxJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gYmFjayB1cCAnYnVmZmVyJyBzdGVwcywgYmVpbmcgY2FyZWZ1bCBub3QgdG8gZ28gZnVydGhlciBiYWNrIHRoYW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGhlYWQgbm9kZVxuICAgICAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuPGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAtLWluaXRpYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxJbmRleDwwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gaW5pdGlhbE5vZGUuZGF0YVByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbE5vZGUgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IGluaXRpYWxOb2RlLmRhdGEoKS5sZW5ndGgtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGRhdGEgbm9kZSBjb250YWluaW5nIHRoZSAnbWF4JyB2YWx1ZVxuICAgICAgICAgICAgICAgIGZpbmFsTm9kZSA9IGluaXRpYWxOb2RlO1xuICAgICAgICAgICAgICAgIHdoaWxlICggKG1heC5ndChmaW5hbE5vZGUuZGF0YU1heCgpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChmaW5hbE5vZGUuZGF0YU5leHQoKSAhPT0gbnVsbCkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTm9kZSA9IGZpbmFsTm9kZS5kYXRhTmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBpbmRleCB3aXRoaW4gdGhlIGZpbmFsIG5vZGUgY29ycmVzcG9uZGluZyB0byB0aGUgJ21heCcgdmFsdWVcbiAgICAgICAgICAgICAgICBmaW5hbEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxOb2RlID09PSBpbml0aWFsTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbEluZGV4ID0gaW5pdGlhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoKGZpbmFsSW5kZXggPCBmaW5hbE5vZGUuZGF0YSgpLmxlbmd0aC0xKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAoZmluYWxOb2RlLmRhdGEoKVtmaW5hbEluZGV4XVtjb2x1bW5JbmRpY2VzWzBdXS5sdChtYXgpKSkge1xuICAgICAgICAgICAgICAgICAgICArK2ZpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGdvIGZvcndhcmQgJ2J1ZmZlcicgbW9yZSBzdGVwcywgYmVpbmcgY2FyZWZ1bCBub3QgdG8gZ28gZnVydGhlciB0aGFuIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIHRhaWxcbiAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgICAgICAvL3doaWxlIChuPGJ1ZmZlciAmJiAhKGZpbmFsTm9kZT09PV90YWlsICYmIGZpbmFsSW5kZXg8ZmluYWxOb2RlLmRhdGEubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICsrZmluYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsSW5kZXggPj0gZmluYWxOb2RlLmRhdGEoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBmaW5hbE5vZGUuZGF0YU5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxOb2RlID0gYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbmRleCA9IGZpbmFsTm9kZS5kYXRhKCkubGVuZ3RoLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJTZXJ2aWNlRGF0YUl0ZXJhdG9yKGNvbHVtbkluZGljZXMsIGluaXRpYWxOb2RlLCBpbml0aWFsSW5kZXgsIGZpbmFsTm9kZSwgZmluYWxJbmRleCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaGFzQShcInBhdXNlZFwiKS53aGljaC5pc0EoXCJib29sZWFuXCIpLmFuZC5kZWZhdWx0c1RvKGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZXNwb25kc1RvKFwicGF1c2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlZCh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzcG9uZHNUbyhcInJlc3VtZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2VkKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh7dHlwZSA6ICdkYXRhUmVhZHknLFxuICAgICAgICAgICAgICAgICAgICAgICBtaW4gOiB0aGlzLmNvdmVyZWRNaW4oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgbWF4IDogdGhpcy5jb3ZlcmVkTWF4KCl9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBXZWJTZXJ2aWNlRGF0YTtcbn07XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbi8qKlxuICogQSBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSByZXByZXNlbnRzIGEgc2luZ2xlIG5vZGUgaW4gdGhlXG4gKiBkb3VibHktbGlua2VkIGxpc3QgaG9sZGluZyB0aGUgZGF0YSBmb3IgYSBXZWJTZXJ2aWNlRGF0YUNhY2hlLlxuICogVGhlIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlIGhhcyBhbiBhcnJheSBvZiBkYXRhICh3aGljaCBtYXlcbiAqIGFjdHVhbGx5IGJlIG51bGwsIGlmIHRoZSBub2RlJ3MgZGF0YSBoYXMgbm90IHlldCBiZWVuIGxvYWRlZCksXG4gKiBuZXh0IGFuZCBwcmV2IHBvaW50ZXJzIHRvIHRoZSBuZXh0IGFuZCBwcmV2aW91cyBub2RlcyBpbiB0aGVcbiAqIGxpbmtlZCBsaXN0LCBhbmQgY292ZXJlZE1pbiBhbmQgY292ZXJlZE1heCB2YWx1ZXMgdGhhdCBpbmRpY2F0ZVxuICogdGhlIG1pbiBhbmQgbWF4IHZhbHVlcyBvZiB0aGUgXCJjb3ZlcmVkXCIgcmFuZ2Ugb2YgZGF0YSBmb3IgdGhpc1xuICogbm9kZS5cbiAqIFxuICogVGhlIFwiY292ZXJlZFwiIHJhbmdlIGlzIHRoZSBpbnRlcnZhbCBvZiB0aGUgZGF0YSBudW1iZXIgbGluZSBmb3JcbiAqIHdoaWNoIHRoaXMgbm9kZSBpcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBkYXRhOyBNdWx0aWdyYXBoXG4gKiB1c2VzIHJhbmdlIHRoaXMgdG8gYXZvaWQgcmVxdWVzdGluZyB0aGUgc2FtZSBkYXRhIHR3aWNlIC0tLSBpdFxuICogbmV2ZXIgcmVxdWVzdHMgZGF0YSBmb3IgYSByYW5nZSBhbHJlYWR5IGNvdmVyZWQgYnkgYW4gZXhpc3RpbmdcbiAqIGNhY2hlIG5vZGUuXG4gKiBcbiAqIEluaXRpYWxseSwgd2hlbiB0aGUgV2ViU2VydmljZURhdGFDYWNoZU5vZGUgaXMgY3JlYXRlZCwgdGhlXG4gKiBsaW1pdHMgb2YgdGhlIGNvdmVyZWQgcmFuZ2UgYXJlIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gKiBMYXRlciBvbiwgd2hlbiB0aGUgbm9kZSdzIGRhdGEgaXMgYWN0dWFsbHkgcG9wdWxhdGVkLCB0aGVcbiAqIGxpbWl0cyBhcmUgcG90ZW50aWFsbHkgYWRqdXN0ZWQgb3V0d2FyZCwgaWYgdGhlIHJhbmdlIG9mIGRhdGFcbiAqIHJlY2VpdmVkIGlzIGxhcmdlciB0aGFuIHRoZSBpbml0aWFsbHkgc3BlY2lmaWVkIGNvdmVyZWQgcmFuZ2UuXG4gKiBTbyBpbiBhbGwgY2FzZXMsIHRoZSBjb3ZlcmVkIHJhbmdlIGluZGljYXRlcyB0aGUgcmFuZ2UgZm9yXG4gKiB3aGljaCBubyBtb3JlIGRhdGEgaXMgbmVlZGVkLCBiZWNhdXNlIGl0J3MgY292ZXJlZCBieSB0aGlzXG4gKiBub2RlLlxuICogXG4gKiBOb3RlIHRoYXQgdGhlIGNvdmVyZWQgcmFuZ2UgaXMgbmV2ZXIgYWRqdXN0ZWQgdG8gYmUgc21hbGxlci5cbiAqIFxuICogVGhlIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlIGRvZXMgbm90IGFjdHVhbGx5IGZldGNoIGFueSBkYXRhXG4gKiAtLS0gaXQgaXMgc2ltcGx5IGEgc3RvcmFnZSBjb250YWluZXIgZm9yIGZldGNoZWQgZGF0YTsgaXQncyB1cFxuICogdG8gb3RoZXIgY29kZSBvdXRzaWRlIG9mIHRoaXMgb2JqZWN0IHRvIGZldGNoIGFuZCBwb3B1bGF0ZSB0aGVcbiAqIGRhdGEuXG4gKlxuICogQGNsYXNzIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlXG4gKiBAZm9yIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RGF0YVZhbHVlfSBjb3ZlcmVkTWluXG4gKiBAcGFyYW0ge0RhdGFWYWx1ZX0gY292ZXJlZE1heFxuICovXG52YXIgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi9kYXRhX3ZhbHVlLmpzJyksXG4gICAgQXJyYXlEYXRhID0gcmVxdWlyZSgnLi9hcnJheV9kYXRhLmpzJyk7XG5cbnZhciBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSA9IG5ldyBqZXJtYWluZS5Nb2RlbChmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWN0dWFsIGRhdGEgZm9yIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAgICogQHR5cGUge0FycmF5fG51bGx9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcImRhdGFcIikud2hpY2guZGVmYXVsdHNUbyhudWxsKS5hbmQudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgdmFsaWRhdGlvbkZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpO1xuICAgICAgICAvLyBhY2NlcHQgbnVsbFxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAvLyBvbmx5IGFjY2VwdCBhcnJheXNcbiAgICAgICAgaWYgKHZhbGlkYXRpb25GdW5jdGlvbnMudHlwZU9mKGRhdGEpICE9PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiV2ViU2VydmljZURhdGFDYWNoZU5vZGUncyBkYXRhIGF0dHJpYnV0ZSBpcyBub3QgYW4gQXJyYXlcIjtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgYXJyYXkgY29udGFpbnMgYW55dGhpbmcsIGRvIGEgY3Vyc29yeSBjaGVjayB0aGF0IGl0IGxvb2tzXG4gICAgICAgIC8vIGxpa2UgYW4gYXJyYXkgb2YgRGF0YVZhbHVlIGFycmF5cyAoanVzdCBjaGVjayB0aGUgZmlyc3Qgcm93KVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RSb3cgPSBkYXRhWzBdLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkZ1bmN0aW9ucy50eXBlT2YoZmlyc3RSb3cpICE9PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIldlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlJ3MgZGF0YSBhdHRyaWJ1dGUgaXMgbm90IGFuIEFycmF5IG9mIEFycmF5c1wiO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaXJzdFJvdy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICghRGF0YVZhbHVlLmlzSW5zdGFuY2UoZmlyc3RSb3dbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiV2ViU2VydmljZURhdGFDYWNoZU5vZGUncyBkYXRhIGF0dHJpYnV0ZSBpcyBub3QgYW4gQXJyYXkgb2YgQXJyYXlzIG9mIERhdGFWYWx1ZXMgKGJhZCB2YWx1ZSBpbiBwb3NpdGlvbiBcIiArIGkgKyBcIiBvZiBmaXJzdCByb3dcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuZXh0IG5vZGUgaW4gdGhlIGNhY2hlJ3MgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBuZXh0XG4gICAgICogQHR5cGUge1dlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlfG51bGx9XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMuaGFzQShcIm5leHRcIikud2hpY2guZGVmYXVsdHNUbyhudWxsKS5hbmQudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCA9PT0gbnVsbCB8fCB4IGluc3RhbmNlb2YgV2ViU2VydmljZURhdGFDYWNoZU5vZGU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgbm9kZSBpbiB0aGUgY2FjaGUncyBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHByZXZcbiAgICAgKiBAdHlwZSB7V2ViU2VydmljZURhdGFDYWNoZU5vZGV8bnVsbH1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwicHJldlwiKS53aGljaC5kZWZhdWx0c1RvKG51bGwpLmFuZC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4ID09PSBudWxsIHx8IHggaW5zdGFuY2VvZiBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaW4gb2YgdGhlIGNvdmVyZWQgdmFsdWUgcmFuZ2VcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb3ZlcmVkTWluXG4gICAgICogQHR5cGUge0RhdGFWYWx1ZX1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiY292ZXJlZE1pblwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFWYWx1ZS5pc0luc3RhbmNlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXggb2YgdGhlIGNvdmVyZWQgdmFsdWUgcmFuZ2VcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb3ZlcmVkTWF4XG4gICAgICogQHR5cGUge0RhdGFWYWx1ZX1cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICovXG4gICAgdGhpcy5oYXNBKFwiY292ZXJlZE1heFwiKS53aGljaC52YWxpZGF0ZXNXaXRoKERhdGFWYWx1ZS5pc0luc3RhbmNlKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbmV4dCBub2RlIGluIHRoZSBjYWNoZSB0aGF0IGFjdHVhbGx5IGhhcyBkYXRhLFxuICAgICAqIG9yIG51bGwgaWYgbm9uZSBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRhdGFOZXh0XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqIEByZXR1cm4ge1dlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZGF0YU5leHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubmV4dCgpO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiAhbm9kZS5oYXNEYXRhKCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcHJldmlvdXMgbm9kZSBpbiB0aGUgY2FjaGUgdGhhdCBhY3R1YWxseSBoYXMgZGF0YSxcbiAgICAgKiBvciBudWxsIGlmIG5vbmUgZXhpc3RzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkYXRhUHJldlxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKiBAcmV0dXJuIHtXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImRhdGFQcmV2XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnByZXYoKTtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgIW5vZGUuaGFzRGF0YSgpKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wcmV2KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1pbmltdW0gKGNvbHVtbiAwKSBkYXRhIHZhbHVlIGZvciB0aGlzIG5vZGUuICBSZXR1cm5zIG51bGxcbiAgICAgKiBpZiB0aGUgbm9kZSBoYXMgbm8gZGF0YSB5ZXQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRhdGFNaW5cbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICogQHJldHVybiB7RGF0YVZhbHVlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZGF0YU1pblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhKCk7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBpZiAoZGF0YVswXSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBpZiAoZGF0YVswXS5sZW5ndGggPT09IDApIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgcmV0dXJuIGRhdGFbMF1bMF07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1heGltdW0gKGNvbHVtbiAwKSBkYXRhIHZhbHVlIGZvciB0aGlzIG5vZGUuICAgIFJldHVybnMgbnVsbFxuICAgICAqIGlmIHRoZSBub2RlIGhhcyBubyBkYXRhIHlldC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGF0YU1heFxuICAgICAqIEBhdXRob3IganJmcmltbWVcbiAgICAgKiBAcmV0dXJuIHtEYXRhVmFsdWV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJkYXRhTWF4XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSgpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgaWYgKGRhdGFbZGF0YS5sZW5ndGgtMV0gPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgaWYgKGRhdGFbZGF0YS5sZW5ndGgtMV0ubGVuZ3RoID09PSAwKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHJldHVybiBkYXRhW2RhdGEubGVuZ3RoLTFdWzBdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhpcyBub2RlIGhhcyBkYXRhOyBmYWxzZSBpZiBub3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGhhc0RhdGFcbiAgICAgKiBAYXV0aG9yIGpyZnJpbW1lXG4gICAgICogQHJldHVybiBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaGFzRGF0YVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpICE9PSBudWxsO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pc0J1aWx0V2l0aChcImNvdmVyZWRNaW5cIiwgXCJjb3ZlcmVkTWF4XCIpO1xuXG4gICAgLyoqXG4gICAgICogUG9wdWxhdGUgdGhpcyBub2RlJ3MgZGF0YSBhcnJheSBieSBwYXJzaW5nIHRoZSB2YWx1ZXNcbiAgICAgKiBjb250YWluZWQgaW4gdGhlICdkYXRhVGV4dCcgc3RyaW5nLCB3aGljaCBzaG91bGQgYmUgYVxuICAgICAqIHN0cmluZyBvZiBjb21tYS1zZXBhcmF0ZWQgdmFsdWVzIG9mIHRoZSBzYW1lIHNvcnQgZXhwZWN0ZWRcbiAgICAgKiBieSBBcnJheURhdGEgYW5kIENTVkRhdGEuICBUaGUgZmlyc3QgYXJndW1lbnQsIGBjb2x1bW5zYCxcbiAgICAgKiBzaG91bGQgYmUgYSBwbGFpbiBqYXZhc2NyaXB0IGFycmF5IG9mIERhdGFWYXJpYWJsZSBpbnN0YW5jZXMsXG4gICAgICogb2YgdGhlIHNvcnQgcmV0dXJuZWQgYnkgYERhdGEuZ2V0Q29sdW1ucygpYC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIG1ldGhvZCBleGFtaW5lcyBvdGhlciBub2RlcyBpbiB0aGUgY2FjaGUgaW4gb3JkZXJcbiAgICAgKiBpbnN1cmUgdGhhdCB2YWx1ZXMgaW5jbHVkZWQgaW4gdGhpcyBub2RlJ3MgZGF0YSBhcnJheVxuICAgICAqIGFyZSAoYSkgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlIHByZXNlbnQgaW4gdGhlXG4gICAgICogY2FjaGUgcHJpb3IgdG8gdGhpcyBub2RlLCBhbmQgKGIpIHN0cmljdGx5IGxlc3MgdGhhbiB0aGVcbiAgICAgKiBtaW5pbXVtIHZhbHVlIHByZXNlbnQgaW4gdGhlIGNhY2hlIGFmdGVyIHRoaXMgbm9kZS5cbiAgICAgKiBUaGlzIGd1YXJhbnRlZXMgdGhhdCB0aGVyZSBpcyBubyBvdmVybGFwIGJldHdlZW4gdGhlXG4gICAgICogZGF0YSBpbiB0aGlzIG5vZGUgYW5kIG90aGVyIG5vZGVzIGluIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcGFyc2VEYXRhXG4gICAgICogQHBhcmFtIHtEYXRhVmFyaWFibGUgQXR0cl9MaXN0fSBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFUZXh0XG4gICAgICogQGF1dGhvciBqcmZyaW1tZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uZHNUbyhcInBhcnNlRGF0YVwiLCBmdW5jdGlvbiAoY29sdW1ucywgZGF0YVRleHQpIHtcbiAgICAgICAgdmFyIGksIGIsXG4gICAgICAgICAgICBtYXhQcmV2VmFsdWUgPSBudWxsLFxuICAgICAgICAgICAgbWluTmV4dFZhbHVlID0gbnVsbCxcbiAgICAgICAgICAgIGFycmF5RGF0YUFycmF5LFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHJvdztcblxuICAgICAgICAvLyBzZXQgbWF4UHJldlZhbHVlIHRvIHRoZSBtYXggdmFsdWUgaW4gY29sdW1uMCBpbiB0aGUgY2FjaGUgcHJpb3IgdG8gdGhpcyBibG9jaywgaWYgYW55OlxuICAgICAgICBiID0gdGhpcy5kYXRhUHJldigpO1xuICAgICAgICBpZiAoYiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF4UHJldlZhbHVlID0gYi5kYXRhTWF4KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgbWluTmV4dFZhbHVlIHRvIHRoZSBtaW4gdmFsdWUgaW4gY29sdW1uMCBpbiB0aGUgY2FjaGUgYWZ0ZXIgdGhpcyBibG9jaywgaWYgYW55OlxuICAgICAgICBiID0gdGhpcy5kYXRhTmV4dCgpO1xuICAgICAgICBpZiAoYiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWluTmV4dFZhbHVlID0gYi5kYXRhTWluKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBjc3YgZGF0YVRleHQgc3RyaW5nIHRvIGFuIGFycmF5XG4gICAgICAgIGFycmF5RGF0YUFycmF5ID0gQXJyYXlEYXRhLnRleHRUb0RhdGFWYWx1ZXNBcnJheShjb2x1bW5zLCBkYXRhVGV4dCk7XG5cbiAgICAgICAgLy8gcG9wdWxhdGUgdGhlIGRhdGEgYXJyYXkgYnkgY29weWluZyB2YWx1ZXMgZnJvbSB0aGUgY29udmVydGVkIGFycmF5LCBza2lwcGluZyBhbnlcbiAgICAgICAgLy8gdmFsdWVzIHRoYXQgYXJlIGFscmVhZHkgd2l0aGluIHRoZSByYW5nZSBjb3ZlcmVkIGJ5IHRoZSByZXN0IG9mIHRoZSBjYWNoZVxuICAgICAgICBkYXRhID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJheURhdGFBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcm93ID0gYXJyYXlEYXRhQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAoKG1heFByZXZWYWx1ZSA9PT0gbnVsbCB8fCByb3dbMF0uZ3QobWF4UHJldlZhbHVlKSkgJiZcbiAgICAgICAgICAgICAgICAobWluTmV4dFZhbHVlID09PSBudWxsIHx8IHJvd1swXS5sdChtaW5OZXh0VmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaCggcm93ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGFueSBuZXcgdmFsdWVzLCB3ZSdyZSBkb25lXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBsb3dlciB0aGUgY292ZXJlZE1pbiB2YWx1ZSBpZiB0aGUgYWN0dWFsIGRhdGEgcmVjZWl2ZWQgaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudCBjb3ZlcmVkTWluIHZhbHVlXG4gICAgICAgIGlmIChkYXRhWzBdWzBdLmx0KHRoaXMuY292ZXJlZE1pbigpKSkge1xuICAgICAgICAgICAgdGhpcy5jb3ZlcmVkTWluKGRhdGFbMF1bMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFpc2UgdGhlIGNvdmVyZWRNYXggdmFsdWUgaWYgdGhlIGFjdHVhbCBkYXRhIHJlY2VpdmVkIGlzIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IGNvdmVyZWRNYXggdmFsdWVcbiAgICAgICAgaWYgKGRhdGFbZGF0YS5sZW5ndGgtMV1bMF0uZ3QodGhpcy5jb3ZlcmVkTWF4KCkpKSB7XG4gICAgICAgICAgICB0aGlzLmNvdmVyZWRNYXgoZGF0YVtkYXRhLmxlbmd0aC0xXVswXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb2FkIHRoZSBkYXRhXG4gICAgICAgIHRoaXMuZGF0YSggZGF0YSApO1xuICAgIH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU2VydmljZURhdGFDYWNoZU5vZGU7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbi8qKlxuICogQW4gaXRlcmF0b3IgZm9yIHN0ZXBwaW5nIHRocm91Z2ggZGF0YSB2YWx1ZXMgc3RvcmVkIGluIGEgbGlua2VkIGxpc3Qgb2ZcbiAqIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2Rlcy4gIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyA1IGFyZ3VtZW50czpcbiAqIFxuICogQGNsYXNzIFdlYlNlcnZpY2VEYXRhSXRlcmF0b3JcbiAqIEBmb3IgV2ViU2VydmljZURhdGFJdGVyYXRvclxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtBcnJheX0gY29sdW1uSW5kaWNlc1xuICogICAgIEphdmFTY3JpcHQgYXJyYXkgb2YgdGhlIGluZGljZXMgb2YgdGhlIGNvbHVtbnNcbiAqICAgICBvZiBkYXRhIHRvIHJldHVyblxuICogQHBhcmFtIHtXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZX0gaW5pdGlhbE5vZGVcbiAqICAgICBQb2ludGVyIHRvIHRoZSBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSBjb250YWluaW5nIHRoZSBmaXJzdFxuICogICAgIHZhbHVlIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBpbml0aWFsSW5kZXhcbiAqICAgICBJbmRleCwgd2l0aGluIGluaXRpYWxOb2RlLCBvZiB0aGUgZmlyc3QgdmFsdWUgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge1dlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlfSBmaW5hbE5vZGVcbiAqICAgICBQb2ludGVyIHRvIHRoZSBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSBjb250YWluaW5nIHRoZSBsYXN0XG4gKiAgICAgdmFsdWUgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZpbmFsSW5kZXhcbiAqICAgICBJbmRleCwgd2l0aGluIGZpbmFsTm9kZSwgb2YgdGhlIGxhc3QgdmFsdWUgdG8gaXRlcmF0ZSBvdmVyXG4gKi9cbnZhciBXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSA9IHJlcXVpcmUoJy4vd2ViX3NlcnZpY2VfZGF0YV9jYWNoZV9ub2RlLmpzJyksXG4gICAgVmFsaWRhdGlvbkZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpO1xuXG52YXIgV2ViU2VydmljZURhdGFJdGVyYXRvciA9IG5ldyBqZXJtYWluZS5Nb2RlbChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFdlYlNlcnZpY2VEYXRhSXRlcmF0b3IgPSB0aGlzO1xuXG4gICAgdGhpcy5oYXNBKFwiY3VycmVudE5vZGVcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2ViU2VydmljZURhdGFDYWNoZU5vZGU7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiY3VycmVudEluZGV4XCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG4gICAgdGhpcy5oYXNBKFwiY29sdW1uSW5kaWNlc1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25GdW5jdGlvbnMudHlwZU9mKHgpID09PSBcImFycmF5XCI7XG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5oYXNBKFwiaW5pdGlhbE5vZGVcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2ViU2VydmljZURhdGFDYWNoZU5vZGU7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiZmluYWxOb2RlXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYlNlcnZpY2VEYXRhQ2FjaGVOb2RlO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImluaXRpYWxJbmRleFwiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuICAgIHRoaXMuaGFzQShcImZpbmFsSW5kZXhcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcblxuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJjb2x1bW5JbmRpY2VzXCIsIFwiaW5pdGlhbE5vZGVcIiwgXCJpbml0aWFsSW5kZXhcIiwgXCJmaW5hbE5vZGVcIiwgXCJmaW5hbEluZGV4XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlKHRoaXMuaW5pdGlhbE5vZGUoKSk7XG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4KHRoaXMuaW5pdGlhbEluZGV4KCkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiaGFzTmV4dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUoKSA9PT0gbnVsbCB8fCB0aGlzLmN1cnJlbnRJbmRleCgpIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUoKSAhPT0gdGhpcy5maW5hbE5vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEluZGV4KCkgPD0gdGhpcy5maW5hbEluZGV4KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJuZXh0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFscyA9IFtdLFxuICAgICAgICAgICAgY29sdW1uSW5kaWNlcyA9IHRoaXMuY29sdW1uSW5kaWNlcygpLFxuICAgICAgICAgICAgY3VycmVudEluZGV4ID0gdGhpcy5jdXJyZW50SW5kZXgoKSxcbiAgICAgICAgICAgIGZpbmFsSW5kZXggPSB0aGlzLmZpbmFsSW5kZXgoKSxcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy5jdXJyZW50Tm9kZSgpLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IHRoaXMuZmluYWxOb2RlKCkpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBmaW5hbEluZGV4KSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxjb2x1bW5JbmRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFscy5wdXNoKGN1cnJlbnROb2RlLmRhdGEoKVtjdXJyZW50SW5kZXhdW2NvbHVtbkluZGljZXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4KCsrY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB2YWxzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8Y29sdW1uSW5kaWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhbHMucHVzaChjdXJyZW50Tm9kZS5kYXRhKClbY3VycmVudEluZGV4XVtjb2x1bW5JbmRpY2VzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCgrK2N1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID49IGN1cnJlbnROb2RlLmRhdGEoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnROb2RlKGN1cnJlbnROb2RlLmRhdGFOZXh0KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgICAgIH1cbiAgICB9KTtcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU2VydmljZURhdGFJdGVyYXRvcjtcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIEluc2V0cyA9IHJlcXVpcmUoJy4uL21hdGgvaW5zZXRzLmpzJyksXG4gICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy53aW5kb3cpO1xuXG52YXIgV2luZG93ID0gbmV3IGplcm1haW5lLk1vZGVsKFwiV2luZG93XCIsIGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuaGFzQShcIndpZHRoXCIpLndoaWNoLmlzQShcImludGVnZXJcIik7XG5cbiAgICB0aGlzLmhhc0EoXCJoZWlnaHRcIikud2hpY2guaXNBKFwiaW50ZWdlclwiKTtcblxuICAgIHRoaXMuaGFzQShcImJvcmRlclwiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpO1xuXG4gICAgdGhpcy5oYXNBKFwibWFyZ2luXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKG1hcmdpbikge1xuICAgICAgICByZXR1cm4gbWFyZ2luIGluc3RhbmNlb2YgSW5zZXRzO1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNBKFwicGFkZGluZ1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiBwYWRkaW5nIGluc3RhbmNlb2YgSW5zZXRzO1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNBKFwiYm9yZGVyY29sb3JcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYm9yZGVyY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGJvcmRlcmNvbG9yIGluc3RhbmNlb2YgUkdCQ29sb3I7XG4gICAgfSk7XG5cbiAgICB1dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzKHRoaXMsIGRlZmF1bHRWYWx1ZXMud2luZG93LCBhdHRyaWJ1dGVzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRvdztcbiIsInZhciBqZXJtYWluZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qZXJtYWluZS9zcmMvamVybWFpbmUuanMnKTtcblxudmFyIERhdGFNZWFzdXJlID0gcmVxdWlyZSgnLi9kYXRhX21lYXN1cmUuanMnKSxcbiAgICBEYXRhVmFsdWUgPSByZXF1aXJlKCcuL2RhdGFfdmFsdWUuanMnKTtcblxudmFyIHV0aWxpdHlGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICBkZWZhdWx0VmFsdWVzID0gdXRpbGl0eUZ1bmN0aW9ucy5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgIGF0dHJpYnV0ZXMgPSB1dGlsaXR5RnVuY3Rpb25zLmdldEtleXMoZGVmYXVsdFZhbHVlcy5ob3Jpem9udGFsYXhpcy56b29tKTtcblxudmFyIFpvb20gPSBuZXcgamVybWFpbmUuTW9kZWwoXCJab29tXCIsIGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuaGFzQShcImFsbG93ZWRcIikud2hpY2guaXNBKFwiYm9vbGVhblwiKTtcbiAgICB0aGlzLmhhc0EoXCJtaW5cIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAobWluKSB7XG4gICAgICAgIHJldHVybiBEYXRhTWVhc3VyZS5pc0luc3RhbmNlKG1pbik7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwibWF4XCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKG1heCkge1xuICAgICAgICByZXR1cm4gRGF0YU1lYXN1cmUuaXNJbnN0YW5jZShtYXgpO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImFuY2hvclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIERhdGFWYWx1ZS5pc0luc3RhbmNlKGFuY2hvcikgfHwgYW5jaG9yID09PSBudWxsO1xuICAgIH0pO1xuXG4gICAgdXRpbGl0eUZ1bmN0aW9ucy5pbnNlcnREZWZhdWx0cyh0aGlzLCBkZWZhdWx0VmFsdWVzLmhvcml6b250YWxheGlzLnpvb20sIGF0dHJpYnV0ZXMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gWm9vbTtcbiIsInZhciBfSU5DTFVERUQgPSBmYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkLCB3aW5kb3csIGVycm9ySGFuZGxlcikge1xuICAgIGlmICghX0lOQ0xVREVEKSB7XG4gICAgICAgIHJlcXVpcmUoJy4vZHJhZ2dhYmxlL2dyYXBoLmpzJykoJCwgd2luZG93LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICByZXF1aXJlKCcuL3RvdWNoL2dyYXBoLmpzJykoJCwgd2luZG93LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICByZXF1aXJlKCcuL3RvdWNoL211bHRpZ3JhcGguanMnKSgkLCB3aW5kb3csIGVycm9ySGFuZGxlcik7XG4gICAgICAgIHJlcXVpcmUoJy4vbW91c2UvZ3JhcGguanMnKSgkLCB3aW5kb3csIGVycm9ySGFuZGxlcik7XG4gICAgICAgIHJlcXVpcmUoJy4vbW91c2UvbXVsdGlncmFwaC5qcycpKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgcmVxdWlyZSgnLi9tdWx0aWdyYXBoLmpzJykoJCwgd2luZG93LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICByZXF1aXJlKCcuL3Jlc2l6ZS9tdWx0aWdyYXBoLmpzJykoJCwgd2luZG93LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICBfSU5DTFVERUQgPSB0cnVlO1xuICAgIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKSB7XG4gICAgdmFyIEdyYXBoID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ncmFwaC5qcycpLFxuICAgICAgICBBeGlzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzLmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKEdyYXBoLmRyYWdTdGFydGVkKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gR3JhcGg7IH1cblxuICAgIEdyYXBoLmhhc0EoXCJkcmFnU3RhcnRlZFwiKS53aGljaC5pc0EoXCJib29sZWFuXCIpO1xuICAgIEdyYXBoLmhhc0EoXCJkcmFnT3JpZW50YXRpb25cIikud2hpY2gudmFsaWRhdGVzV2l0aChBeGlzLk9yaWVudGF0aW9uLmlzSW5zdGFuY2UpO1xuICAgIEdyYXBoLmhhc0EoXCJkcmFnQXhpc1wiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhIGluc3RhbmNlb2YgQXhpcztcbiAgICB9KTtcblxuICAgIEdyYXBoLnJlc3BvbmRzVG8oXCJkb0RyYWdSZXNldFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0ZWQoZmFsc2UpO1xuICAgICAgICB0aGlzLnBhdXNlQWxsRGF0YSgpO1xuICAgIH0pO1xuXG4gICAgR3JhcGgucmVzcG9uZHNUbyhcImRvRHJhZ0RvbmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc3VtZUFsbERhdGEoKTtcbiAgICB9KTtcblxuICAgIEdyYXBoLnJlc3BvbmRzVG8oXCJkb0RyYWdcIiwgZnVuY3Rpb24gKG11bHRpZ3JhcGgsIGJ4LCBieSwgZHgsIGR5LCBzaGlmdEtleSkge1xuICAgICAgICB2YXIgZHJhZ0F4aXMgICAgICAgID0gdGhpcy5kcmFnQXhpcyxcbiAgICAgICAgICAgIGRyYWdPcmllbnRhdGlvbiA9IHRoaXMuZHJhZ09yaWVudGF0aW9uLFxuICAgICAgICAgICAgSE9SSVpPTlRBTCA9IEF4aXMuSE9SSVpPTlRBTCxcbiAgICAgICAgICAgIFZFUlRJQ0FMICAgPSBBeGlzLlZFUlRJQ0FMO1xuICAgICAgICAvLyBUT0RPOiB0aGlzIHRyeS4uLmNhdGNoIGlzIGp1c3QgdG8gcmVtaW5kIG15c2VsZiBob3cgdG8gYXBwbHksIG1ha2Ugc3VyZSB0aGlzIGlzIGNvcnJlY3QgbGF0ZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kcmFnU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT3JpZW50YXRpb24oSE9SSVpPTlRBTCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ09yaWVudGF0aW9uKFZFUlRJQ0FMKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJhZ0F4aXModGhpcy5maW5kTmVhcmVzdEF4aXMoYngsIGJ5LCBkcmFnT3JpZW50YXRpb24oKSkpO1xuICAgICAgICAgICAgICAgIGlmIChkcmFnQXhpcygpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdPcmllbnRhdGlvbiggKGRyYWdPcmllbnRhdGlvbigpID09PSBIT1JJWk9OVEFMKSA/IFZFUlRJQ0FMIDogSE9SSVpPTlRBTCApO1xuICAgICAgICAgICAgICAgICAgICBkcmFnQXhpcyggdGhpcy5maW5kTmVhcmVzdEF4aXMoYngsIGJ5LCBkcmFnT3JpZW50YXRpb24oKSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnRlZCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG8gdGhlIGFjdGlvblxuICAgICAgICAgICAgaWYgKHNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdPcmllbnRhdGlvbigpID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdBeGlzKCkuZG9ab29tKGJ4LCBkeCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0F4aXMoKS5kb1pvb20oYnksIGR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkcmFnT3JpZW50YXRpb24oKSA9PT0gSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnQXhpcygpLmRvUGFuKGJ4LCBkeCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0F4aXMoKS5kb1BhbihieSwgZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZHJhdyBldmVyeXRoaW5nXG4gICAgICAgICAgICBtdWx0aWdyYXBoLnJlZHJhdygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBHcmFwaDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKSB7XG4gICAgdmFyIEdyYXBoID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ncmFwaC5qcycpLFxuICAgICAgICBDb25zdGFudFBsb3QgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbnN0YW50X3Bsb3QuanMnKSxcbiAgICAgICAgQXhpcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpcy5qcycpO1xuXG4gICAgaWYgKHR5cGVvZihHcmFwaC5tb3VzZVdoZWVsVGltZXIpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBHcmFwaDsgfVxuXG4gICAgR3JhcGguaGFzQShcIm1vdXNlV2hlZWxUaW1lclwiKS53aGljaC5kZWZhdWx0c1RvKG51bGwpO1xuXG4gICAgR3JhcGgucmVzcG9uZHNUbyhcImRvV2hlZWxab29tXCIsIGZ1bmN0aW9uIChtdWx0aWdyYXBoLCB4LCB5LCBkZWx0YSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlQWxsRGF0YSgpO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB0aGlzLmZpbmROZWFyZXN0QXhpcyh4LCB5KTtcbiAgICAgICAgICAgIGlmIChheGlzLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGF4aXMuZG9ab29tKHgsIDQqZGVsdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBheGlzLmRvWm9vbSh5LCA0KmRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11bHRpZ3JhcGgucmVkcmF3KCk7XG5cbiAgICAgICAgICAgIC8vIHJlc3VtZSBkYXRhIGZldGNoaW5nIGFmdGVyIC41IHNlY29uZHMgb2Ygbm8gbW91c2Ugd2hlZWwgbW90aW9uOlxuICAgICAgICAgICAgdmFyIG1vdXNlV2hlZWxUaW1lciA9IHRoaXMubW91c2VXaGVlbFRpbWVyO1xuICAgICAgICAgICAgaWYgKG1vdXNlV2hlZWxUaW1lcigpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChtb3VzZVdoZWVsVGltZXIoKSk7XG4gICAgICAgICAgICAgICAgbW91c2VXaGVlbFRpbWVyKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW91c2VXaGVlbFRpbWVyKHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnJlc3VtZUFsbERhdGEoKTtcbiAgICAgICAgICAgIH0sIDUwMCkpOyBcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIEdyYXBoLmhhc0EoXCJleGlzdGluZ0RhdGF0aXBzXCIpLndoaWNoLmRlZmF1bHRzVG8oZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0pO1xuICAgIEdyYXBoLnJlc3BvbmRzVG8oXCJoYW5kbGVEYXRhdGlwc1wiLCBmdW5jdGlvbiAobG9jLCB3aWR0aCwgaGVpZ2h0LCAkdGFyZ2V0LCBkaXYpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nRGF0YXRpcHMgPSB0aGlzLmV4aXN0aW5nRGF0YXRpcHMoKSxcbiAgICAgICAgICAgIHBsb3RzICAgICAgICAgICAgPSB0aGlzLnBsb3RzKCksXG4gICAgICAgICAgICBwbG90LFxuICAgICAgICAgICAgZGF0YXRpcHNEYXRhLFxuICAgICAgICAgICAgZGF0YXRpcEluZGV4LFxuICAgICAgICAgICAgaTtcblxuICAgICAgICB2YXIgdGVtcCA9ICQoXCI8c3Bhbj48L3NwYW4+XCIpXG4gICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiICAgICAgICAgIDogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW5cIiAgICAgICAgICAgOiBcIjBweFwiLFxuICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctbGVmdFwiICAgICA6IFwiNXB4XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1yaWdodFwiICAgIDogXCI1cHhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLXRvcFwiICAgICAgOiBcIjFweFwiLFxuICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctYm90dG9tXCIgICA6IFwiMXB4XCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhkaXYpO1xuXG4gICAgICAgIC8vIGZpbmQgZmlyc3QgYXZhaWxhYmxlIGJpdCBvZiBkYXRhXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwbG90cy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgcGxvdCA9IHBsb3RzLmF0KGkpO1xuICAgICAgICAgICAgaWYgKHBsb3QgaW5zdGFuY2VvZiBDb25zdGFudFBsb3QpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGF0aXBzRGF0YSA9IHBsb3QuZ2V0RGF0YXRpcHNEYXRhKGxvYywgd2lkdGgsIGhlaWdodCwgdGhpcywgdGVtcCk7XG4gICAgICAgICAgICBpZiAoZGF0YXRpcHNEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkYXRhdGlwSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGVtcC5yZW1vdmUoKTtcblxuICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB0aGVyZSBpcyBubyBkYXRhXG4gICAgICAgIGlmIChkYXRhdGlwc0RhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVEYXRhdGlwcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmxhZyBhbGwgZGF0YXRpcHMgZm9yIHJlbW92YWxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4aXN0aW5nRGF0YXRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV4aXN0aW5nRGF0YXRpcHNbaV0uZmxhZyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZmxhZ3MgZnJvbSBkYXRhdGlwcyB0aGF0IGRvbid0IG5lZWQgdG8gYmUgcmVkcmF3blxuICAgICAgICBjaGVja0RhdGF0aXBFeGlzdGVuY2UoZGF0YXRpcHNEYXRhLCBleGlzdGluZ0RhdGF0aXBzKTtcblxuICAgICAgICB0aGlzLnJlbW92ZUZsYWdnZWREYXRhdGlwcygpO1xuXG4gICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIGRhdGF0aXAgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKGRhdGF0aXBzRGF0YS5mbGFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFycm93TGVuZ3RoID0gMTA7XG4gICAgICAgIGRhdGF0aXBzRGF0YS5hcnJvdyA9IGFycm93TGVuZ3RoO1xuXG4gICAgICAgIHZhciBkYXRhdGlwID0gcGxvdHMuYXQoZGF0YXRpcEluZGV4KS5jcmVhdGVEYXRhdGlwKGRhdGF0aXBzRGF0YSk7XG5cbiAgICAgICAgZGF0YXRpcC5hcHBlbmRUbyhkaXYpO1xuXG4gICAgICAgIGRhdGF0aXAubW91c2Vkb3duKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgJHRhcmdldC50cmlnZ2VyKFwibW91c2Vkb3duXCIsIGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGF0YXRpcHNEYXRhLmVsZW0gPSBkYXRhdGlwO1xuICAgICAgICBleGlzdGluZ0RhdGF0aXBzLnB1c2goZGF0YXRpcHNEYXRhKTtcbiAgICB9KTtcblxuICAgIHZhciBjaGVja0RhdGF0aXBFeGlzdGVuY2UgPSBmdW5jdGlvbiAoZGF0YXRpcERhdGEsIGV4aXN0aW5nRGF0YSkge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGV4aXN0aW5nRGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBkYXRhdGlwRGF0YS5jb250ZW50ICAgPT09IGV4aXN0aW5nRGF0YVtpXS5jb250ZW50ICAgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YXRpcERhdGEudHlwZSAgICAgID09PSBleGlzdGluZ0RhdGFbaV0udHlwZSAgICAgICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGF0aXBEYXRhLnBpeGVscFswXSA9PT0gZXhpc3RpbmdEYXRhW2ldLnBpeGVscFswXSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRhdGlwRGF0YS5waXhlbHBbMV0gPT09IGV4aXN0aW5nRGF0YVtpXS5waXhlbHBbMV1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nRGF0YVtpXS5mbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGF0YXRpcERhdGEuZmxhZyA9IGZhbHNlOyAvLyBkbyBub3QgcmVkcmF3XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGF0aXBEYXRhLmZsYWcgPSB0cnVlOyAvLyBuZWVkcyB0byBiZSBkcmF3blxuICAgIH07XG5cbiAgICBHcmFwaC5yZXNwb25kc1RvKFwicmVtb3ZlRGF0YXRpcHNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXhpc3RpbmdEYXRhdGlwcyA9IHRoaXMuZXhpc3RpbmdEYXRhdGlwcygpLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgaWYgKGV4aXN0aW5nRGF0YXRpcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4aXN0aW5nRGF0YXRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0RhdGF0aXBzW2ldLmVsZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleGlzdGluZ0RhdGF0aXBzID0gW107XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIEdyYXBoLnJlc3BvbmRzVG8oXCJyZW1vdmVGbGFnZ2VkRGF0YXRpcHNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXhpc3RpbmdEYXRhdGlwcyA9IHRoaXMuZXhpc3RpbmdEYXRhdGlwcygpLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgaWYgKGV4aXN0aW5nRGF0YXRpcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4aXN0aW5nRGF0YXRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhdGlwc1tpXS5mbGFnID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRGF0YXRpcHNbaV0uZWxlbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdEYXRhdGlwcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIHJldHVybiBHcmFwaDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKSB7XG5cbiAgICB2YXIgTXVsdGlncmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbXVsdGlncmFwaC5qcycpKCQpLFxuICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKTtcblxuICAgIGlmICh0eXBlb2YoTXVsdGlncmFwaC5yZWdpc3Rlck1vdXNlRXZlbnRzKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gTXVsdGlncmFwaDsgfVxuXG4gICAgTXVsdGlncmFwaC5yZXNwb25kc1RvKFwicmVnaXN0ZXJNb3VzZUV2ZW50c1wiLCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBiYXNlLFxuICAgICAgICAgICAgbW91c2VMYXN0LFxuICAgICAgICAgICAgbW91c2VJc0Rvd24gPSBmYWxzZSxcbiAgICAgICAgICAgIGRyYWdTdGFydGVkID0gZmFsc2UsXG4gICAgICAgICAgICBtdWx0aWdyYXBoID0gdGhpcyxcbiAgICAgICAgICAgICR0YXJnZXQgPSAkKHRhcmdldCk7XG5cbiAgICAgICAgdmFyIGV2ZW50TG9jYXRpb25Ub0dyYXBoQ29vcmRzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KChldmVudC5wYWdlWCAtICR0YXJnZXQub2Zmc2V0KCkubGVmdCkgLSBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLngwKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0YXJnZXQuaGVpZ2h0KCkgLSAoZXZlbnQucGFnZVkgLSAkdGFyZ2V0Lm9mZnNldCgpLnRvcCkgLSBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLnkwKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgICR0YXJnZXQubW91c2Vkb3duKGZ1bmN0aW9uIChldmVudCwgZGF0YXRpcHNFdmVudCkge1xuICAgICAgICAgICAgaWYgKGRhdGF0aXBzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZGF0YXRpcHMgbW91c2Vkb3duIGhhbmRsZXIgaXMgdHJpZ2dlcmVkIHRocm91Z2ggdGhlIGRhdGF0aXBzIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHRoZSBkZWZhdWx0IGV2ZW50IGRvZXMgbm90IGNvbnRhaW4gcGFnZVggb3IgcGFnZVkuIFNvIHRoZSBkYXRhdGlwcyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgLy8gcGFzc2VzIGl0cyBldmVudCwgd2hpY2ggZG9lcyBjb250YWluIHBhZ2VYIGFuZCBwYWdlWS5cbiAgICAgICAgICAgICAgICBldmVudCA9IGRhdGF0aXBzRXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbXVsdGlncmFwaC5ncmFwaHMoKS5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgICAgIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoaSkucmVtb3ZlRGF0YXRpcHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW91c2VMYXN0ID0gYmFzZSA9IGV2ZW50TG9jYXRpb25Ub0dyYXBoQ29vcmRzKGV2ZW50KTtcbiAgICAgICAgICAgIG1vdXNlSXNEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICR0YXJnZXQubW91c2V1cChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIG1vdXNlSXNEb3duID0gZmFsc2U7XG4gICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZ0RvbmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHRhcmdldC5tb3VzZW1vdmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRMb2MgPSBldmVudExvY2F0aW9uVG9HcmFwaENvb3JkcyhldmVudCksXG4gICAgICAgICAgICAgICAgZ3JhcGhzICAgPSBtdWx0aWdyYXBoLmdyYXBocygpO1xuICAgICAgICAgICAgaWYgKG1vdXNlSXNEb3duKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gZXZlbnRMb2MueCgpIC0gbW91c2VMYXN0LngoKSxcbiAgICAgICAgICAgICAgICAgICAgZHkgPSBldmVudExvYy55KCkgLSBtb3VzZUxhc3QueSgpO1xuICAgICAgICAgICAgICAgIGlmIChtdWx0aWdyYXBoLmdyYXBocygpLnNpemUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBocy5hdCgwKS5kb0RyYWdSZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyYXBocy5hdCgwKS5kb0RyYWcobXVsdGlncmFwaCwgYmFzZS54KCksIGJhc2UueSgpLCBkeCwgZHksIGV2ZW50LnNoaWZ0S2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gZGF0YXRpcHMgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JhcGhzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBocy5hdChpKS5oYW5kbGVEYXRhdGlwcyhldmVudExvYywgbXVsdGlncmFwaC53aWR0aCgpLCBtdWx0aWdyYXBoLmhlaWdodCgpLCAkdGFyZ2V0LCBtdWx0aWdyYXBoLmRpdigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb3VzZUxhc3QgPSBldmVudExvYztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHRhcmdldC5tb3VzZXdoZWVsKGZ1bmN0aW9uIChldmVudCwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBldmVudExvYyA9IGV2ZW50TG9jYXRpb25Ub0dyYXBoQ29vcmRzKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChtdWx0aWdyYXBoLmdyYXBocygpLnNpemUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvV2hlZWxab29tKG11bHRpZ3JhcGgsIGV2ZW50TG9jLngoKSwgZXZlbnRMb2MueSgpLCBkZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgICR0YXJnZXQubW91c2VsZWF2ZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIG1vdXNlSXNEb3duID0gZmFsc2U7XG4gICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZ0RvbmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChtdWx0aWdyYXBoLmRpdigpKS5tb3VzZWxlYXZlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGdyYXBocyA9IG11bHRpZ3JhcGguZ3JhcGhzKCksXG4gICAgICAgICAgICAgICAgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBncmFwaHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBncmFwaHMuYXQoaSkucmVtb3ZlRGF0YXRpcHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBNdWx0aWdyYXBoO1xufTtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG52YXIgX0lOQ0xVREVEID0gZmFsc2U7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKSB7XG5cbiAgICBpZiAoX0lOQ0xVREVEKSB7IHJldHVybjsgfSBlbHNlIHsgX0lOQ0xVREVEID0gdHJ1ZTsgfVxuICAgIFxuICAgIHZhciBNdWx0aWdyYXBoID0gcmVxdWlyZSgnLi4vY29yZS9tdWx0aWdyYXBoLmpzJykoJCk7XG5cbiAgICB2YXIgbWV0aG9kcyA9IHtcbiAgICAgICAgbXVsdGlncmFwaCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ211bHRpZ3JhcGgnKS5tdWx0aWdyYXBoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRvbmUgOiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZGF0YSgnbXVsdGlncmFwaCcpLm11bHRpZ3JhcGguZG9uZShmdW5jKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXQgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoJ211bHRpZ3JhcGgnKTtcbiAgICAgICAgICAgICAgICBpZiAoIShcIm11Z2xcIiBpbiBvcHRpb25zKSAmJiAhKFwibXVnbFN0cmluZ1wiIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wdGlvbnMgY29udGFpbnMgbmVpZ3RoZXIgXCJtdWdsXCIgbm9yIFwibXVnbFN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAvLyBhc3N1bWUgaXQncyBhIEpTT04gbXVnbCBvYmplY3QsIHNvIHBhc3MgaXQgb24gYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlIG9mIFwibXVnbFN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVnbFN0cmluZzogb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zLmRpdiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKCAhIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ211bHRpZ3JhcGgnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoIDogTXVsdGlncmFwaC5jcmVhdGVHcmFwaChvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLm11bHRpZ3JhcGggPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIGlmICggbWV0aG9kc1ttZXRob2RdICkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbIG1ldGhvZCBdLmFwcGx5KCB0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICkpO1xuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhIG1ldGhvZCApIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5lcnJvciggJ01ldGhvZCAnICsgIG1ldGhvZCArICcgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5Lm11bHRpZ3JhcGgnICk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSAgICBcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBJbmNsdXNpb24gb2YgdGhpcyBmaWxlIGFsbG93cyBtYXJrdXAgbGlrZSB0aGUgZm9sbG93aW5nIHRvIGJlXG4gICAgICogdXNlZCBpbiBIVE1MOlxuICAgICAqIFxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwibXVsdGlncmFwaFwiXG4gICAgICogICAgICAgIGRhdGEtc3JjPVwiTVVHTF9GSUxFXCJcbiAgICAgKiAgICAgICAgZGF0YS13aWR0aD1cIldJRFRIXCJcbiAgICAgKiAgICAgICAgZGF0YS1oZWlnaHQ9XCJIRUlHSFRcIlxuICAgICAqICAgICAgICBkYXRhLWRyaXZlcj1cIkRSSVZFUlwiPlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiBcbiAgICAgKiBUaGUgZGF0YS1kcml2ZXIgdGFnIGlzIG9wdGlvbmFsOyBpZiBub3Qgc3BlY2lmaWVkLCBpdCBjdXJyZW50bHlcbiAgICAgKiBkZWZhdWx0cyB0byBcImNhbnZhc1wiLCBidXQgdGhhdCB3aWxsIGJlIGNoYW5nZWQgaW4gdGhlIGZ1dHVyZSB0b1xuICAgICAqIG1ha2UgYSBzbWFydCBjaG9pY2UgYmFzZWQgb24gYnJvd3NlciBjYXBhYmlsaXRpZXMuXG4gICAgICogXG4gICAgICogVGhlIGRhdGEtd2lkdGggYW5kIGRhdGEtaGVpZ2h0IHRhZ3MgYXJlIGFsc28gb3B0aW9uYWw7IGlmIHRoZXlcbiAgICAgKiBhcmUgbm90IHNwZWNpZmllZCwgTXVsdGlncmFwaCB3aWxsIHVzZSB0aGUgZGl2IHNpemUgYXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBicm93c2VyICh3aGljaCBtYXkgYmUgc2V0IGJ5IGNzcyBydWxlcywgZm9yIGV4YW1wbGUpLiAgSWZcbiAgICAgKiBkYXRhLXdpZHRoIG9yIGRhdGEtaGVpZ2h0IGlzIHByZXNlbnQsIGl0IHdpbGwgb3ZlcnJpZGUgYW55IGNzc1xuICAgICAqIHdpZHRoIG9yIGhlaWdodC5cbiAgICAgKiBcbiAgICAgKi9cbiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgJChcImRpdi5tdWx0aWdyYXBoXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggID0gJCh0aGlzKS5hdHRyKFwiZGF0YS13aWR0aFwiKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSAkKHRoaXMpLmF0dHIoXCJkYXRhLWhlaWdodFwiKSxcbiAgICAgICAgICAgICAgICBzcmMgICAgPSAkKHRoaXMpLmF0dHIoXCJkYXRhLXNyY1wiKSxcbiAgICAgICAgICAgICAgICBkcml2ZXIgPSAkKHRoaXMpLmF0dHIoXCJkYXRhLWRyaXZlclwiKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zO1xuXG4gICAgICAgICAgICBpZiAod2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICQodGhpcykuY3NzKCd3aWR0aCcsIHdpZHRoICsgJ3B4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcygnaGVpZ2h0JywgaGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgLy8gZG9uJ3QgZGVmYXVsdCB0byBjYW52YXMgaGVyZSBhbnkgbW9yZTsgTXVsdGlncmFwaC5jcmVhdGVHcmFwaCBub3cgZG9lc1xuICAgICAgICAgICAgIC8vIGJyb3dzZXIgZGV0ZWN0aW9uIGFuZCB3aWxsIGRlZmF1bHQgdG8gY2FudmFzIGlmIHBvc3NpYmxlLCBvdGhlcndpc2VcbiAgICAgICAgICAgICAvLyB0byByYXBoYWVsXG4gICAgICAgICAgICAgaWYgKGRyaXZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgZHJpdmVyID0gXCJjYW52YXNcIjtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAnZGl2JyAgICA6IHRoaXMsXG4gICAgICAgICAgICAgICAgJ211Z2wnICAgOiBzcmMsXG4gICAgICAgICAgICAgICAgJ2RyaXZlcicgOiBkcml2ZXJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICQodGhpcykubXVsdGlncmFwaChvcHRpb25zKTtcbiAgICAgICAgICAgICQodGhpcykubGlnaHRib3goe1xuICAgICAgICAgICAgICAgIHNjYWxlIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwb3N0b3BlbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpZ2h0Ym94RGF0YSA9IHRoaXMuZGF0YShcImxpZ2h0Ym94XCIpO1xuICAgICAgICAgICAgICAgICAgICBsaWdodGJveERhdGEub3JpZ2luYWxEaXYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEoXCJtdWx0aWdyYXBoXCIpLm11bHRpZ3JhcGguZG9uZShmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5kaXYobGlnaHRib3hEYXRhLmNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uaW5pdGlhbGl6ZVN1cmZhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucmVzaXplU3VyZmFjZShsaWdodGJveERhdGEuY29udGVudFdpZHRoLCBsaWdodGJveERhdGEuY29udGVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLndpZHRoKGxpZ2h0Ym94RGF0YS5jb250ZW50V2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmhlaWdodChsaWdodGJveERhdGEuY29udGVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmJ1c3lTcGlubmVyKCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmJ1c3lTcGlubmVyKCQoJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6NXB4OyB0b3A6NXB4O1wiPjwvZGl2PicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbygkKG0uZGl2KCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYnVzeV9zcGlubmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0PSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWdodGJveERhdGEuY29udGVudHMubGlnaHRib3goXCJyZXNpemVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb3N0Y2xvc2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaWdodGJveERhdGEgPSB0aGlzLmRhdGEoXCJsaWdodGJveFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhKFwibXVsdGlncmFwaFwiKS5tdWx0aWdyYXBoLmRvbmUoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZGl2KGxpZ2h0Ym94RGF0YS5vcmlnaW5hbERpdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2lkdGgoJChtLmRpdigpKS53aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5oZWlnaHQoJChtLmRpdigpKS5oZWlnaHQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYnVzeVNwaW5uZXIoJCgnPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDo1cHg7IHRvcDo1cHg7XCI+PC9kaXY+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKCQobS5kaXYoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5idXN5X3NwaW5uZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG0uaW5pdGlhbGl6ZVN1cmZhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9zdHJlc2l6ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpZ2h0Ym94RGF0YSA9IHRoaXMuZGF0YShcImxpZ2h0Ym94XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEoXCJtdWx0aWdyYXBoXCIpLm11bHRpZ3JhcGguZG9uZShmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yZXNpemVTdXJmYWNlKGxpZ2h0Ym94RGF0YS5jb250ZW50V2lkdGgsIGxpZ2h0Ym94RGF0YS5jb250ZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ud2lkdGgobGlnaHRib3hEYXRhLmNvbnRlbnRXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGxpZ2h0Ym94RGF0YS5jb250ZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQsIHdpbmRvdywgZXJyb3JIYW5kbGVyKSB7XG4gICAgdmFyIE11bHRpZ3JhcGggPSByZXF1aXJlKCcuLi8uLi9jb3JlL211bHRpZ3JhcGguanMnKSgkKSxcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKE11bHRpZ3JhcGgucmVnaXN0ZXJSZXNpemVFdmVudHMpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBNdWx0aWdyYXBoOyB9XG5cbiAgICBNdWx0aWdyYXBoLnJlc3BvbmRzVG8oXCJyZWdpc3RlclJlc2l6ZUV2ZW50c1wiLCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBtdWx0aWdyYXBoID0gdGhpcztcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9ICQodGhpcy5kaXYoKSk7XG4gICAgICAgIHZhciBjID0gJCh0YXJnZXQpOyAvLyBzZWxlY3QgY2FudmFzIGluIG11bHRpZ3JhcGggZGl2XG4gICAgICAgICQod2luZG93KS5yZXNpemUocmVzcG9uZEdyYXBoKTtcblxuICAgICAgICBmdW5jdGlvbiByZXNwb25kR3JhcGgoKVxuICAgICAgICB7XG4gICAgICAgICAgICBjLmF0dHIoXCJ3aWR0aFwiLCBjb250YWluZXIud2lkdGgoKSAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGMuYXR0cihcImhlaWdodFwiLCBjb250YWluZXIuaGVpZ2h0KCkgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjLmNzcyhcIndpZHRoXCIsIGNvbnRhaW5lci53aWR0aCgpKTtcbiAgICAgICAgICAgIGMuY3NzKFwiaGVpZ2h0XCIsIGNvbnRhaW5lci5oZWlnaHQoKSk7XG4gICAgICAgICAgICBtdWx0aWdyYXBoLmluaXQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIE11bHRpZ3JhcGg7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkLCB3aW5kb3csIGVycm9ySGFuZGxlcikge1xuICAgIHZhciBHcmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZ3JhcGguanMnKSxcbiAgICAgICAgQXhpcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpcy5qcycpO1xuXG4gICAgaWYgKHR5cGVvZihHcmFwaC5kb0ZpcnN0UGluY2hab29tKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gR3JhcGg7IH1cblxuICAgIEdyYXBoLnJlc3BvbmRzVG8oXCJkb0ZpcnN0UGluY2hab29tXCIsIGZ1bmN0aW9uIChtdWx0aWdyYXBoLCBieCwgYnksIGR4LCBkeSwgdG90YWx4LCB0b3RhbHkpIHtcbiAgICAgICAgdmFyIGRyYWdBeGlzID0gdGhpcy5kcmFnQXhpcyxcbiAgICAgICAgICAgIGRyYWdPcmllbnRhdGlvbiA9IHRoaXMuZHJhZ09yaWVudGF0aW9uLFxuICAgICAgICAgICAgSE9SSVpPTlRBTCA9IEF4aXMuSE9SSVpPTlRBTCxcbiAgICAgICAgICAgIFZFUlRJQ0FMICAgPSBBeGlzLlZFUlRJQ0FMO1xuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgdHJ5Li4uY2F0Y2ggaXMganVzdCB0byByZW1pbmQgbXlzZWxmIGhvdyB0byBhcHBseSwgbWFrZSBzdXJlIHRoaXMgaXMgY29ycmVjdCBsYXRlclxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRyYWdTdGFydGVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG90YWx4ID4gdG90YWx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdPcmllbnRhdGlvbihIT1JJWk9OVEFMKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT3JpZW50YXRpb24oVkVSVElDQUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkcmFnQXhpcyh0aGlzLmZpbmROZWFyZXN0QXhpcyhieCwgYnksIGRyYWdPcmllbnRhdGlvbigpKSk7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdBeGlzKCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ09yaWVudGF0aW9uKCAoZHJhZ09yaWVudGF0aW9uKCkgPT09IEhPUklaT05UQUwpID8gVkVSVElDQUwgOiBIT1JJWk9OVEFMICk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdBeGlzKCB0aGlzLmZpbmROZWFyZXN0QXhpcyhieCwgYnksIGRyYWdPcmllbnRhdGlvbigpKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydGVkKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkbyB0aGUgYWN0aW9uXG4gICAgICAgICAgICBpZiAoZHJhZ09yaWVudGF0aW9uKCkgPT09IEhPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICBkcmFnQXhpcygpLmRvWm9vbShieCwgZHgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmFnQXhpcygpLmRvWm9vbShieSwgZHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkcmF3IGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIG11bHRpZ3JhcGgucmVkcmF3KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEdyYXBoO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCwgd2luZG93LCBlcnJvckhhbmRsZXIpIHtcbiAgICB2YXIgTXVsdGlncmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbXVsdGlncmFwaC5qcycpKCQpLFxuICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKTtcblxuICAgIGlmICh0eXBlb2YoTXVsdGlncmFwaC5yZWdpc3RlclRvdWNoRXZlbnRzKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gTXVsdGlncmFwaDsgfVxuXG4gICAgTXVsdGlncmFwaC5yZXNwb25kc1RvKFwicmVnaXN0ZXJUb3VjaEV2ZW50c1wiLCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciB0b3VjaFN0YXJ0ZWQgICAgICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICBkcmFnU3RhcnRlZCAgICAgICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICBwaW5jaFpvb21TdGFydGVkICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICBwaW5jaFpvb21EZXRlcm1pbmVkICAgID0gZmFsc2UsXG4gICAgICAgICAgICBwaW5jaFpvb21Jbml0aWFsRGVsdGFzID0ge30sXG4gICAgICAgICAgICBwaW5jaFpvb21EZXRlcm1pbmVkVGltZW91dCxcbiAgICAgICAgICAgIHByZXZpb3VzdG91Y2hhLCBwcmV2aW91c3RvdWNoYixcbiAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICBtdWx0aWdyYXBoID0gdGhpcyxcbiAgICAgICAgICAgICR0YXJnZXQgPSAkKHRhcmdldCk7XG5cbiAgICAgICAgdmFyIHRvdWNoTG9jYXRpb25Ub0dyYXBoQ29vcmRzID0gZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KCh0b3VjaC5wYWdlWCAtICR0YXJnZXQub2Zmc2V0KCkubGVmdCkgLSBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLngwKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0YXJnZXQuaGVpZ2h0KCkgLSAodG91Y2gucGFnZVkgLSAkdGFyZ2V0Lm9mZnNldCgpLnRvcCkgLSBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLnkwKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGpxdWVyeUV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGpxdWVyeUV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHRvdWNoTG9jYXRpb25Ub0dyYXBoQ29vcmRzKGUudG91Y2hlc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91c3RvdWNoYSA9IHRvdWNoTG9jYXRpb25Ub0dyYXBoQ29vcmRzKGUudG91Y2hlc1swXSk7XG5cbiAgICAgICAgICAgIC8vIG9uZSBmaW5nZXIgZHJhZ1xuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHBpbmNoIHpvb21cbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcGluY2hab29tU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGluY2hab29tRGV0ZXJtaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzdG91Y2hiID0gdG91Y2hMb2NhdGlvblRvR3JhcGhDb29yZHMoZS50b3VjaGVzWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGluY2hab29tU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBpbmNoWm9vbURldGVybWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG91Y2hTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZ0RvbmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGpxdWVyeUV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGpxdWVyeUV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIC8vIG9uZSBmaW5nZXIgZHJhZ1xuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEgJiYgZHJhZ1N0YXJ0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVEcmFnKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcGluY2ggem9vbVxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDIgJiYgcGluY2hab29tU3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZVBpbmNoWm9vbShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlVG91Y2hFbmQgPSBmdW5jdGlvbiAoanF1ZXJ5RXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0ganF1ZXJ5RXZlbnQub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gb25lIGZpbmdlciBkcmFnXG4gICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gcGluY2ggem9vbVxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBwaW5jaFpvb21TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwaW5jaFpvb21EZXRlcm1pbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBpbmNoWm9vbVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwaW5jaFpvb21EZXRlcm1pbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvdWNoU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbXVsdGlncmFwaC5ncmFwaHMoKS5hdCgwKS5kb0RyYWdEb25lKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhbmRsZVRvdWNoTGVhdmUgPSBmdW5jdGlvbiAoanF1ZXJ5RXZlbnQpIHtcbiAgICAgICAgICAgIGpxdWVyeUV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHBpbmNoWm9vbVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHBpbmNoWm9vbURldGVybWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRvdWNoU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZ0RvbmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlRHJhZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdG91Y2hMb2MgPSB0b3VjaExvY2F0aW9uVG9HcmFwaENvb3JkcyhlLnRvdWNoZXNbMF0pLFxuICAgICAgICAgICAgICAgIGR4ID0gdG91Y2hMb2MueCgpIC0gcHJldmlvdXN0b3VjaGEueCgpLFxuICAgICAgICAgICAgICAgIGR5ID0gdG91Y2hMb2MueSgpIC0gcHJldmlvdXN0b3VjaGEueSgpO1xuICAgICAgICAgICAgaWYgKG11bHRpZ3JhcGguZ3JhcGhzKCkuc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghdG91Y2hTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoMCkuZG9EcmFnUmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXVsdGlncmFwaC5ncmFwaHMoKS5hdCgwKS5kb0RyYWcobXVsdGlncmFwaCwgYmFzZS54KCksIGJhc2UueSgpLCBkeCwgZHksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvdWNoU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBwcmV2aW91c3RvdWNoYSA9IHRvdWNoTG9jO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYW5kbGVQaW5jaFpvb20gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGEgPSB0b3VjaExvY2F0aW9uVG9HcmFwaENvb3JkcyhlLnRvdWNoZXNbMF0pLFxuICAgICAgICAgICAgICAgIGIgPSB0b3VjaExvY2F0aW9uVG9HcmFwaENvb3JkcyhlLnRvdWNoZXNbMV0pLFxuICAgICAgICAgICAgICAgIGJhc2V4ID0gKGEueCgpICsgYi54KCkpIC8gMixcbiAgICAgICAgICAgICAgICBiYXNleSA9IChhLnkoKSArIGIueSgpKSAvIDIsXG4gICAgICAgICAgICAgICAgZHggPSBjYWxjdWxhdGVBYnNvbHV0ZURpc3RhbmNlKGEueCgpLCBiLngoKSkgLSBjYWxjdWxhdGVBYnNvbHV0ZURpc3RhbmNlKHByZXZpb3VzdG91Y2hhLngoKSwgcHJldmlvdXN0b3VjaGIueCgpKSxcbiAgICAgICAgICAgICAgICBkeSA9IGNhbGN1bGF0ZUFic29sdXRlRGlzdGFuY2UoYS55KCksIGIueSgpKSAtIGNhbGN1bGF0ZUFic29sdXRlRGlzdGFuY2UocHJldmlvdXN0b3VjaGEueSgpLCBwcmV2aW91c3RvdWNoYi55KCkpO1xuXG4gICAgICAgICAgICBpZiAobXVsdGlncmFwaC5ncmFwaHMoKS5zaXplKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b3VjaFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlncmFwaC5ncmFwaHMoKS5hdCgwKS5kb0RyYWdSZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGluY2hab29tRGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZyhtdWx0aWdyYXBoLCBiYXNleCwgYmFzZXksIGR4LCBkeSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG91Y2hTdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gdHdvIGZpbmdlciBzY3JvbGxcbiAgICAgICAgICAgIHZhciBjeCA9ICgoYS54KCkgLSBwcmV2aW91c3RvdWNoYS54KCkpICsgKGIueCgpIC0gcHJldmlvdXN0b3VjaGIueCgpKSkgLyAyLFxuICAgICAgICAgICAgICAgIGN5ID0gKChhLnkoKSAtIHByZXZpb3VzdG91Y2hhLnkoKSkgKyAoYi55KCkgLSBwcmV2aW91c3RvdWNoYi55KCkpKSAvIDI7XG4gICAgICAgICAgICBpZiAocGluY2hab29tRGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoMCkuZG9EcmFnKG11bHRpZ3JhcGgsIGJhc2V4LCBiYXNleSwgY3gsIGN5LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwaW5jaFpvb21EZXRlcm1pbmVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChwaW5jaFpvb21Jbml0aWFsRGVsdGFzLmJhc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLmJhc2UgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcGluY2hab29tSW5pdGlhbERlbHRhcy5iYXNlLnggPSBiYXNleDtcbiAgICAgICAgICAgICAgICAgICAgcGluY2hab29tSW5pdGlhbERlbHRhcy5iYXNlLnkgPSBiYXNleTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGlmIChwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnpvb21EZWx0YXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnpvb21EZWx0YXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImR4XCIgICAgIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZHlcIiAgICAgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0b3RhbHhcIiA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRvdGFseVwiIDogMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGluY2hab29tSW5pdGlhbERlbHRhcy5wYW5EZWx0YXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnBhbkRlbHRhcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZHhcIiA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImR5XCIgOiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGluY2hab29tSW5pdGlhbERlbHRhcy56b29tRGVsdGFzLmR4ICs9IGR4O1xuICAgICAgICAgICAgICAgIHBpbmNoWm9vbUluaXRpYWxEZWx0YXMuem9vbURlbHRhcy5keSArPSBkeTtcbiAgICAgICAgICAgICAgICBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnBhbkRlbHRhcy5keCArPSBjeDtcbiAgICAgICAgICAgICAgICBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnBhbkRlbHRhcy5keSArPSBjeTtcblxuICAgICAgICAgICAgICAgIHBpbmNoWm9vbUluaXRpYWxEZWx0YXMuem9vbURlbHRhcy50b3RhbHggKz0gTWF0aC5hYnMoZHgpO1xuICAgICAgICAgICAgICAgIHBpbmNoWm9vbUluaXRpYWxEZWx0YXMuem9vbURlbHRhcy50b3RhbHkgKz0gTWF0aC5hYnMoZHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBpbmNoWm9vbURldGVybWluZWRUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGluY2hab29tRGV0ZXJtaW5lZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNleCA9IHBpbmNoWm9vbUluaXRpYWxEZWx0YXMuYmFzZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2V5ID0gcGluY2hab29tSW5pdGlhbERlbHRhcy5iYXNlLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggPSBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnpvb21EZWx0YXMuZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnpvb21EZWx0YXMuZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSBwaW5jaFpvb21Jbml0aWFsRGVsdGFzLnBhbkRlbHRhcy5keCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeSA9IHBpbmNoWm9vbUluaXRpYWxEZWx0YXMucGFuRGVsdGFzLmR5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZ1Jlc2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZ3JhcGguZ3JhcGhzKCkuYXQoMCkuZG9GaXJzdFBpbmNoWm9vbShtdWx0aWdyYXBoLCBiYXNleCwgYmFzZXksIGR4LCBkeSwgcGluY2hab29tSW5pdGlhbERlbHRhcy56b29tRGVsdGFzLnRvdGFseCwgcGluY2hab29tSW5pdGlhbERlbHRhcy56b29tRGVsdGFzLnRvdGFseSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoLmdyYXBocygpLmF0KDApLmRvRHJhZyhtdWx0aWdyYXBoLCBiYXNleCwgYmFzZXksIGN4LCBjeSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwaW5jaFpvb21Jbml0aWFsRGVsdGFzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBwaW5jaFpvb21EZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwaW5jaFpvb21EZXRlcm1pbmVkVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaW5jaFpvb21EZXRlcm1pbmVkVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSwgNjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldmlvdXN0b3VjaGEgPSBhO1xuICAgICAgICAgICAgcHJldmlvdXN0b3VjaGIgPSBiO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNhbGN1bGF0ZUFic29sdXRlRGlzdGFuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKTtcbiAgICAgICAgfTtcblxuICAgICAgICAkdGFyZ2V0Lm9uKFwidG91Y2hzdGFydFwiLCBoYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgICAgJHRhcmdldC5vbihcInRvdWNobW92ZVwiLCBoYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAkdGFyZ2V0Lm9uKFwidG91Y2hlbmRcIiwgaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAkdGFyZ2V0Lm9uKFwidG91Y2hsZWF2ZVwiLCBoYW5kbGVUb3VjaExlYXZlKTtcblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIE11bHRpZ3JhcGg7XG59O1xuIiwidmFyIF9JTkNMVURFRCA9IGZhbHNlO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkLCB3aW5kb3cpIHtcbiAgICBpZiAoX0lOQ0xVREVEKSB7IHJldHVybjsgfVxuICAgIF9JTkNMVURFRCA9IHRydWU7XG5cbiAgICByZXF1aXJlKCcuL211bHRpZ3JhcGguanMnKSgkLCB3aW5kb3cpO1xuXG4gICAgcmVxdWlyZSgnLi9heGlzLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL2F4aXNfdGl0bGUuanMnKSgpO1xuICAgIHJlcXVpcmUoJy4vYmFja2dyb3VuZC5qcycpKCk7XG4gICAgcmVxdWlyZSgnLi9ncmFwaC5qcycpKCk7XG4gICAgcmVxdWlyZSgnLi9ncmFwaF90aXRsZS5qcycpKCk7XG4gICAgcmVxdWlyZSgnLi9pY29uLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL2ltZy5qcycpKCk7XG4gICAgcmVxdWlyZSgnLi9sYWJlbGVyLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL2xlZ2VuZC5qcycpKCk7XG4gICAgcmVxdWlyZSgnLi9wbG90YXJlYS5qcycpKCk7XG4gICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvYmFuZF9yZW5kZXJlci5qcycpKCk7XG4gICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvYmFyX3JlbmRlcmVyLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL3JlbmRlcmVycy9maWxsX3JlbmRlcmVyLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL3JlbmRlcmVycy9wb2ludGxpbmVfcmVuZGVyZXIuanMnKSgpO1xuICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3JhbmdlYmFyX3JlbmRlcmVyLmpzJykoKTtcbiAgICByZXF1aXJlKCcuL3RleHQuanMnKSgpO1xuICAgIHJlcXVpcmUoJy4vd2luZG93LmpzJykoKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBBeGlzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzLmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKEF4aXMucmVuZGVyR3JpZCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIEF4aXM7IH1cblxuICAgIEF4aXMucmVzcG9uZHNUbyhcInJlbmRlckdyaWRcIiwgZnVuY3Rpb24gKGdyYXBoLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlKCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMucHJlcGFyZVJlbmRlcihjb250ZXh0KTtcblxuICAgICAgICAvLyBkcmF3IHRoZSBncmlkIGxpbmVzXG4gICAgICAgIGlmICh0aGlzLmhhc0RhdGFNaW4oKSAmJiB0aGlzLmhhc0RhdGFNYXgoKSkgeyAvLyBza2lwIGlmIHdlIGRvbid0IHlldCBoYXZlIGRhdGEgdmFsdWVzXG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkKCkudmlzaWJsZSgpKSB7IC8vIHNraXAgaWYgZ3JpZCBsaW5lcyBhcmVuJ3QgdHVybmVkIG9uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFiZWxlcnMoKS5zaXplKCkgPiAwICYmIHRoaXMuY3VycmVudExhYmVsRGVuc2l0eSgpIDw9IDEuNSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudExhYmVsZXIgPSB0aGlzLmN1cnJlbnRMYWJlbGVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJwT2Zmc2V0ICAgICA9IHRoaXMucGVycE9mZnNldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdEJveCAgICAgICAgPSBncmFwaC5wbG90Qm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbGVyLnByZXBhcmUodGhpcy5kYXRhTWluKCksIHRoaXMuZGF0YU1heCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRMYWJlbGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBjdXJyZW50TGFiZWxlci5uZXh0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMuZGF0YVZhbHVlVG9BeGlzVmFsdWUodik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbigpID09PSBBeGlzLkhPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhhLCBwZXJwT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhhLCBwbG90Qm94LmhlaWdodCgpIC0gcGVycE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBlcnBPZmZzZXQsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBsb3RCb3gud2lkdGgoKSAtIHBlcnBPZmZzZXQsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmdyaWQoKS5jb2xvcigpLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBBeGlzLnJlc3BvbmRzVG8oXCJyZW5kZXJcIiwgZnVuY3Rpb24gKGdyYXBoLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlKCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBwYXJhbGxlbE9mZnNldCA9IHRoaXMucGFyYWxsZWxPZmZzZXQoKSxcbiAgICAgICAgICAgIHBlcnBPZmZzZXQgICAgID0gdGhpcy5wZXJwT2Zmc2V0KCksXG4gICAgICAgICAgICBwaXhlbExlbmd0aCAgICA9IHRoaXMucGl4ZWxMZW5ndGgoKSxcbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbGVyID0gdGhpcy5jdXJyZW50TGFiZWxlcigpLFxuICAgICAgICAgICAgYXhpc0lzSG9yaXpvbnRhbCA9ICh0aGlzLm9yaWVudGF0aW9uKCkgPT09IEF4aXMuSE9SSVpPTlRBTCk7XG4gICAgICAgIC8vTk9URTogYXhlcyBhcmUgZHJhd24gcmVsYXRpdmUgdG8gdGhlIGdyYXBoJ3MgcGxvdCBhcmVhIChwbG90Qm94KTsgdGhlIGNvb3JkaW5hdGVzXG4gICAgICAgIC8vICAgICAgYmVsb3cgYXJlIHJlbGF0aXZlIHRvIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvZiB0aGF0IGJveC5cblxuICAgICAgICAvL1xuICAgICAgICAvLyBSZW5kZXIgdGhlIGF4aXMgbGluZSBpdHNlbGYsIHVubGVzcyBpdHMgbGluZXdpZHRoKCkgcHJvcGVydHkgaXMgMC5cbiAgICAgICAgLy8gVE9ETzogbW9kaWZ5IHRoaXMgc28gdGhhdCBpdCBjb3JyZWN0bHkgZHJhd3MgYSBsaW5lIHdpdGggdGhlIGdpdmVuXG4gICAgICAgIC8vIGxpbmV3aWR0aCgpLiAgQXQgdGhlIG1vbWVudCwgaXQgb25seSBtYWtlcyBhIGRpc3RpbmN0aW9uIGJldHdlZW5cbiAgICAgICAgLy8gbGluZXMgb2Ygd2lkdGggMCwgd2hpY2ggYXJlbid0IGRyYXduIGF0IGFsbCwgYW5kIGxpbmVzIHdpdGggd2lkdGggPiAwLFxuICAgICAgICAvLyB3aGljaCBhcmUgZHJhd24gd2l0aCB3aWR0aCAxLlxuICAgICAgICBpZiAodGhpcy5saW5ld2lkdGgoKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoYXhpc0lzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBhcmFsbGVsT2Zmc2V0LCBwZXJwT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwYXJhbGxlbE9mZnNldCArIHBpeGVsTGVuZ3RoLCBwZXJwT2Zmc2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocGVycE9mZnNldCwgcGFyYWxsZWxPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBlcnBPZmZzZXQsIHBhcmFsbGVsT2Zmc2V0ICsgcGl4ZWxMZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcigpLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVuZGVyIHRoZSB0aWNrIG1hcmtzIGFuZCBsYWJlbHNcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHRoaXMuaGFzRGF0YU1pbigpICYmIHRoaXMuaGFzRGF0YU1heCgpKSB7IC8vIGJ1dCBza2lwIGlmIHdlIGRvbid0IHlldCBoYXZlIGRhdGEgdmFsdWVzXG4gICAgICAgICAgICBpZiAoY3VycmVudExhYmVsZXIgJiYgY3VycmVudExhYmVsZXIudmlzaWJsZSgpKSB7IC8vIGFsc28gc2tpcCBpZiB3ZSBoYXZlIG5vIGN1cnJlbnQgbGFiZWxlciwgb3JcbiAgICAgICAgICAgICAgICB2YXIgdGlja3dpZHRoID0gdGhpcy50aWNrd2lkdGgoKSwgICAgICAgICAgICAgLy8gICBpZiB3ZSBkbyBidXQgaXRzIGB2aXNpYmxlYCBwcm9wZXJ0eSBpcyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB0aWNrbWluICAgPSB0aGlzLnRpY2ttaW4oKSxcbiAgICAgICAgICAgICAgICAgICAgdGlja21heCAgID0gdGhpcy50aWNrbWF4KCksXG4gICAgICAgICAgICAgICAgICAgIHRpY2tjb2xvciA9IHRoaXMudGlja2NvbG9yKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMDAwMDAwJztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGFiZWxlci5wcmVwYXJlKHRoaXMuZGF0YU1pbigpLCB0aGlzLmRhdGFNYXgoKSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRMYWJlbGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGN1cnJlbnRMYWJlbGVyLm5leHQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSB0aGlzLmRhdGFWYWx1ZVRvQXhpc1ZhbHVlKHYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlja3dpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpY2tjb2xvciAhPT0gdW5kZWZpbmVkICYmIHRpY2tjb2xvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aWNrY29sb3IuZ2V0SGV4U3RyaW5nKCcjJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc0lzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGEsIHBlcnBPZmZzZXQrdGlja21heCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYSwgcGVycE9mZnNldCt0aWNrbWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocGVycE9mZnNldCt0aWNrbWluLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwZXJwT2Zmc2V0K3RpY2ttYXgsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpY2tjb2xvciAhPT0gdW5kZWZpbmVkICYmIHRpY2tjb2xvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYWJlbGVyLnJlbmRlckxhYmVsKGNvbnRleHQsIHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVuZGVyIHRoZSB0aXRsZVxuICAgICAgICAvL1xuICAgICAgICBpZiAodGhpcy50aXRsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnRpdGxlKCkucmVuZGVyKGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBBeGlzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEF4aXNUaXRsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpc190aXRsZS5qcycpLFxuICAgICAgICBBeGlzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzLmpzJyksXG4gICAgICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpO1xuXG4gICAgaWYgKHR5cGVvZihBeGlzVGl0bGUucmVuZGVyKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gQXhpc1RpdGxlOyB9XG5cbiAgICBBeGlzVGl0bGUucmVzcG9uZHNUbyhcInJlbmRlclwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgYXhpcyAgICAgICAgPSB0aGlzLmF4aXMoKSxcbiAgICAgICAgICAgIHRpdGxlICAgICAgID0gdGhpcy5jb250ZW50KCksXG4gICAgICAgICAgICBhbmNob3IgICAgICA9IHRoaXMuYW5jaG9yKCksXG4gICAgICAgICAgICBwZXJwT2Zmc2V0ICA9IGF4aXMucGVycE9mZnNldCgpLFxuICAgICAgICAgICAgaCAgICAgICAgICAgPSB0aXRsZS5vcmlnSGVpZ2h0KCksXG4gICAgICAgICAgICB3ICAgICAgICAgICA9IHRpdGxlLm9yaWdXaWR0aCgpLFxuICAgICAgICAgICAgcGl4ZWxBbmNob3IgPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgMC41ICogdyAqIChhbmNob3IueCgpICsgMSksXG4gICAgICAgICAgICAgICAgMC41ICogaCAqIChhbmNob3IueSgpICsgMSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzdG9yZWRCYXNlICA9ICh0aGlzLmJhc2UoKSArIDEpICogKGF4aXMucGl4ZWxMZW5ndGgoKSAvIDIpICsgYXhpcy5taW5vZmZzZXQoKSArIGF4aXMucGFyYWxsZWxPZmZzZXQoKSxcbiAgICAgICAgICAgIHBpeGVsQmFzZTtcblxuICAgICAgICBpZiAoYXhpcy5vcmllbnRhdGlvbigpID09PSBBeGlzLkhPUklaT05UQUwpIHtcbiAgICAgICAgICAgIHBpeGVsQmFzZSA9IG5ldyBQb2ludChzdG9yZWRCYXNlLCBwZXJwT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpeGVsQmFzZSA9IG5ldyBQb2ludChwZXJwT2Zmc2V0LCBzdG9yZWRCYXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAxKVwiO1xuICAgICAgICB0aXRsZS5mb250KHRoaXMuZm9udCgpKTtcbiAgICAgICAgdGl0bGUuZHJhd1RleHQoY29udGV4dCwgcGl4ZWxBbmNob3IsIHBpeGVsQmFzZSwgdGhpcy5wb3NpdGlvbigpLCB0aGlzLmFuZ2xlKCkpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBBeGlzVGl0bGU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQmFja2dyb3VuZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYmFja2dyb3VuZC5qcycpO1xuXG4gICAgaWYgKHR5cGVvZihCYWNrZ3JvdW5kLnJlbmRlcik9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIEJhY2tncm91bmQ7IH1cblxuICAgIEJhY2tncm91bmQucmVzcG9uZHNUbyhcInJlbmRlclwiLCBmdW5jdGlvbiAoZ3JhcGgsIGNvbnRleHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIG1iID0gZ3JhcGgud2luZG93KCkubWFyZ2luKCkubGVmdCgpICsgZ3JhcGgud2luZG93KCkuYm9yZGVyKCksXG4gICAgICAgICAgICBpbWcgPSB0aGlzLmltZygpO1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuY29sb3IoKS5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KG1iLCBtYiwgd2lkdGggLSAyKm1iLCBoZWlnaHQgLSAyKm1iKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoaW1nICYmIGltZy5zcmMoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbWcucmVuZGVyKGdyYXBoLCBjb250ZXh0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEJhY2tncm91bmQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgR3JhcGggPSByZXF1aXJlKCcuLi8uLi9jb3JlL2dyYXBoLmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKEdyYXBoLnJlbmRlcik9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIEdyYXBoOyB9XG5cbiAgICBHcmFwaC5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uIChjb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIHRoaXMud2luZG93KCkucmVuZGVyKGNvbnRleHQsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCgpLnJlbmRlcih0aGlzLCBjb250ZXh0LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybSgxLDAsMCwxLHRoaXMueDAoKSx0aGlzLnkwKCkpO1xuXG4gICAgICAgIHRoaXMucGxvdGFyZWEoKS5yZW5kZXIodGhpcywgY29udGV4dCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYXhlcygpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmF4ZXMoKS5hdChpKS5yZW5kZXJHcmlkKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG5cblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHRoaXMucGxvdEJveCgpLndpZHRoKCksIHRoaXMucGxvdEJveCgpLmhlaWdodCgpKTtcbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG5cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wbG90cygpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnBsb3RzKCkuYXQoaSkucmVuZGVyKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYXhlcygpLnNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmF4ZXMoKS5hdChpKS5yZW5kZXIodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxlZ2VuZCgpLnJlbmRlcihjb250ZXh0KTtcblxuICAgICAgICBpZiAodGhpcy50aXRsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnRpdGxlKCkucmVuZGVyKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gR3JhcGg7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgVGl0bGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RpdGxlLmpzJyksXG4gICAgICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpO1xuXG4gICAgaWYgKHR5cGVvZihUaXRsZS5yZW5kZXIpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBUaXRsZTsgfVxuXG4gICAgVGl0bGUucmVzcG9uZHNUbyhcInJlbmRlclwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgZ3JhcGggICAgICAgICAgID0gdGhpcy5ncmFwaCgpLFxuICAgICAgICAgICAgYm9yZGVyICAgICAgICAgID0gdGhpcy5ib3JkZXIoKSxcbiAgICAgICAgICAgIHBhZGRpbmcgICAgICAgICA9IHRoaXMucGFkZGluZygpLFxuICAgICAgICAgICAgc3RvcmVkQW5jaG9yICAgID0gdGhpcy5hbmNob3IoKSxcbiAgICAgICAgICAgIHN0b3JlZEJhc2UgICAgICA9IHRoaXMuYmFzZSgpLFxuICAgICAgICAgICAgcG9zaXRpb24gICAgICAgID0gdGhpcy5wb3NpdGlvbigpLFxuICAgICAgICAgICAgdGl0bGUgICAgICAgICAgID0gdGhpcy50ZXh0KCksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmNvbG9yKCkudG9SR0JBKHRoaXMub3BhY2l0eSgpKSxcbiAgICAgICAgICAgIHBhZGRpbmdCb3ggICAgICA9IGdyYXBoLnBhZGRpbmdCb3goKSxcbiAgICAgICAgICAgIHBsb3RCb3ggICAgICAgICA9IGdyYXBoLnBsb3RCb3goKSxcbiAgICAgICAgICAgIHBsb3RhcmVhTWFyZ2luICA9IGdyYXBoLnBsb3RhcmVhKCkubWFyZ2luKCksXG4gICAgICAgICAgICBoID0gdGl0bGUub3JpZ0hlaWdodCgpLFxuICAgICAgICAgICAgdyA9IHRpdGxlLm9yaWdXaWR0aCgpLFxuICAgICAgICAgICAgcGl4ZWxBbmNob3IgPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgKDAuNSAqIHcgKyBwYWRkaW5nICsgYm9yZGVyKSAqIChzdG9yZWRBbmNob3IueCgpICsgMSksXG4gICAgICAgICAgICAgICAgKDAuNSAqIGggKyBwYWRkaW5nICsgYm9yZGVyKSAqIChzdG9yZWRBbmNob3IueSgpICsgMSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBwaXhlbEJhc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWUoKSA9PT0gXCJwYWRkaW5nXCIpIHtcbiAgICAgICAgICAgIHBpeGVsQmFzZSA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAoc3RvcmVkQmFzZS54KCkgKyAxKSAqIChwYWRkaW5nQm94LndpZHRoKCkgLyAyKSAgLSBwbG90YXJlYU1hcmdpbi5sZWZ0KCksXG4gICAgICAgICAgICAgICAgKHN0b3JlZEJhc2UueSgpICsgMSkgKiAocGFkZGluZ0JveC5oZWlnaHQoKSAvIDIpIC0gcGxvdGFyZWFNYXJnaW4uYm90dG9tKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwaXhlbEJhc2UgPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgKHN0b3JlZEJhc2UueCgpICsgMSkgKiAocGxvdEJveC53aWR0aCgpIC8gMiksXG4gICAgICAgICAgICAgICAgKHN0b3JlZEJhc2UueSgpICsgMSkgKiAocGxvdEJveC5oZWlnaHQoKSAvIDIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIHRpdGxlLnNldFRyYW5zZm9ybShjb250ZXh0LCBwaXhlbEFuY2hvciwgcGl4ZWxCYXNlLCBwb3NpdGlvbiwgMCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCAwKTtcblxuICAgICAgICAvLyBib3JkZXJcbiAgICAgICAgaWYgKGJvcmRlciA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlcmNvbG9yKCkudG9SR0JBKCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcjtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChcbiAgICAgICAgICAgICAgICBib3JkZXIgLyAyLFxuICAgICAgICAgICAgICAgIGJvcmRlciAvIDIsXG4gICAgICAgICAgICAgICAgdyArICgyICogcGFkZGluZykgKyBib3JkZXIsXG4gICAgICAgICAgICAgICAgaCArICgyICogcGFkZGluZykgKyBib3JkZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWNrZ3JvdW5kXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KFxuICAgICAgICAgICAgYm9yZGVyLFxuICAgICAgICAgICAgYm9yZGVyLFxuICAgICAgICAgICAgdyArICgyICogcGFkZGluZyksXG4gICAgICAgICAgICBoICsgKDIgKiBwYWRkaW5nKVxuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICAvLyB0ZXh0XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICB2YXIgdGV4dFBvc2l0aW9uID0gbmV3IFBvaW50KFxuICAgICAgICAgICAgcG9zaXRpb24ueCgpICsgYm9yZGVyICsgcGFkZGluZyxcbiAgICAgICAgICAgIHBvc2l0aW9uLnkoKSArIGJvcmRlciArIHBhZGRpbmdcbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5mb250ID0gdGhpcy5mb250U2l6ZSgpICsgXCIgc2Fucy1zZXJpZlwiO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAxKVwiO1xuICAgICAgICB0aXRsZS5kcmF3VGV4dChjb250ZXh0LCBwaXhlbEFuY2hvciwgcGl4ZWxCYXNlLCB0ZXh0UG9zaXRpb24sIDApO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBUaXRsZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9pY29uLmpzJyksXG4gICAgICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpO1xuXG4gICAgaWYgKHR5cGVvZihJY29uLnJlbmRlckJvcmRlcik9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIEljb247IH1cblxuICAgIEljb24ucmVzcG9uZHNUbyhcInJlbmRlckJvcmRlclwiLCBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSkge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAxKVwiO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoeCwgeSwgdGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIEljb247XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgSW1nID0gcmVxdWlyZSgnLi4vLi4vY29yZS9pbWcuanMnKSxcbiAgICAgICAgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvdXRpbC5qcycpO1xuXG4gICAgaWYgKHR5cGVvZihJbWcucmVuZGVyKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gSW1nOyB9XG5cbiAgICBJbWcuaGFzQShcImltYWdlXCIpLndoaWNoLmRlZmF1bHRzVG8oZnVuY3Rpb24gKCkge3JldHVybiBuZXcgSW1hZ2UoKTt9KTtcbiAgICBJbWcuaGFzQShcImZldGNoZWRcIikud2hpY2guZGVmYXVsdHNUbyhmYWxzZSk7XG5cbiAgICBJbWcucmVzcG9uZHNUbyhcInJlbmRlclwiLCBmdW5jdGlvbiAoZ3JhcGgsIGNvbnRleHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hlZCgpKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJwICAgICAgPSBVdGlsLmludGVycCxcbiAgICAgICAgICAgICAgICBpbWFnZSAgICAgICA9IHRoaXMuaW1hZ2UoKSxcbiAgICAgICAgICAgICAgICBncmFwaFdpbmRvdyA9IGdyYXBoLndpbmRvdygpLFxuICAgICAgICAgICAgICAgIHBsb3RhcmVhICAgID0gZ3JhcGgucGxvdGFyZWEoKSxcbiAgICAgICAgICAgICAgICBiYXNlID0gdGhpcy5iYXNlKCksXG4gICAgICAgICAgICAgICAgYXggPSBpbnRlcnAodGhpcy5hbmNob3IoKS54KCksIC0xLCAxLCAwLCBpbWFnZS53aWR0aCksXG4gICAgICAgICAgICAgICAgYXkgPSBpbnRlcnAodGhpcy5hbmNob3IoKS55KCksIDEsIC0xLCAwLCBpbWFnZS5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gZ3JhcGhXaW5kb3cubWFyZ2luKCkubGVmdCgpICsgZ3JhcGhXaW5kb3cuYm9yZGVyKCksXG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcCAgPSBncmFwaFdpbmRvdy5tYXJnaW4oKS50b3AoKSArIGdyYXBoV2luZG93LmJvcmRlcigpLFxuICAgICAgICAgICAgICAgIHBsb3RMZWZ0ID0gcGFkZGluZ0xlZnQgKyBncmFwaFdpbmRvdy5wYWRkaW5nKCkubGVmdCgpICsgcGxvdGFyZWEubWFyZ2luKCkubGVmdCgpICsgcGxvdGFyZWEuYm9yZGVyKCksXG4gICAgICAgICAgICAgICAgcGxvdFRvcCAgPSBwYWRkaW5nVG9wICsgZ3JhcGhXaW5kb3cucGFkZGluZygpLnRvcCgpICsgcGxvdGFyZWEubWFyZ2luKCkudG9wKCkgKyBwbG90YXJlYS5ib3JkZXIoKSxcbiAgICAgICAgICAgICAgICBieCwgYnksXG4gICAgICAgICAgICAgICAgeCwgeTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lKCkgPT09IEltZy5QTE9UKSB7XG4gICAgICAgICAgICAgICAgYnggPSBwbG90TGVmdCArIGludGVycChiYXNlLngoKSwgLTEsIDEsIDAsIGdyYXBoLnBsb3RCb3goKS53aWR0aCgpKTtcbiAgICAgICAgICAgICAgICBieSA9IHBsb3RUb3AgKyBpbnRlcnAoYmFzZS55KCksIDEsIC0xLCAwLCBncmFwaC5wbG90Qm94KCkuaGVpZ2h0KCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBieCA9IHBhZGRpbmdMZWZ0ICsgaW50ZXJwKGJhc2UueCgpLCAtMSwgMSwgMCwgZ3JhcGgucGFkZGluZ0JveCgpLndpZHRoKCkpO1xuICAgICAgICAgICAgICAgIGJ5ID0gcGFkZGluZ1RvcCArIGludGVycChiYXNlLnkoKSwgMSwgLTEsIDAsIGdyYXBoLnBhZGRpbmdCb3goKS5oZWlnaHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gYnggKyB0aGlzLnBvc2l0aW9uKCkueCgpIC0gYXg7XG4gICAgICAgICAgICB5ID0gYnkgKyB0aGlzLnBvc2l0aW9uKCkueSgpIC0gYXk7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCBoZWlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmltYWdlKCkub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZmV0Y2hlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAtMSwgMCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBncmFwaC5yZW5kZXIoY29udGV4dCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5pbWFnZSgpLnNyYyA9IHRoaXMuc3JjKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBJbWc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgTGFiZWxlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbGFiZWxlci5qcycpLFxuICAgICAgICBUZXh0ID0gcmVxdWlyZSgnLi4vLi4vY29yZS90ZXh0LmpzJyksXG4gICAgICAgIEF4aXMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2F4aXMuanMnKSxcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKExhYmVsZXIucmVuZGVyTGFiZWwpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBMYWJlbGVyOyB9XG5cbiAgICBMYWJlbGVyLnJlc3BvbmRzVG8oXCJtZWFzdXJlU3RyaW5nV2lkdGhcIiwgZnVuY3Rpb24gKGNvbnRleHQsIHN0cmluZykge1xuICAgICAgICB2YXIgdCA9IG5ldyBUZXh0KHN0cmluZyk7XG4gICAgICAgIHQuZm9udCh0aGlzLmZvbnQoKSk7XG4gICAgICAgIHJldHVybiB0LmluaXRpYWxpemVHZW9tZXRyeSh7XG4gICAgICAgICAgICBcImNvbnRleHRcIiA6IGNvbnRleHQsXG4gICAgICAgICAgICBcImFuZ2xlXCIgICA6IHRoaXMuYW5nbGUoKVxuICAgICAgICB9KS5yb3RhdGVkV2lkdGgoKTtcbiAgICB9KTtcblxuICAgIExhYmVsZXIucmVzcG9uZHNUbyhcIm1lYXN1cmVTdHJpbmdIZWlnaHRcIiwgZnVuY3Rpb24gKGNvbnRleHQsIHN0cmluZykge1xuICAgICAgICB2YXIgdCA9IG5ldyBUZXh0KHN0cmluZyk7XG4gICAgICAgIHQuZm9udCh0aGlzLmZvbnQoKSk7XG4gICAgICAgIHJldHVybiB0LmluaXRpYWxpemVHZW9tZXRyeSh7XG4gICAgICAgICAgICBcImNvbnRleHRcIiA6IGNvbnRleHQsXG4gICAgICAgICAgICBcImFuZ2xlXCIgICA6IHRoaXMuYW5nbGUoKVxuICAgICAgICB9KS5yb3RhdGVkSGVpZ2h0KCk7XG4gICAgfSk7XG5cbiAgICBMYWJlbGVyLnJlc3BvbmRzVG8oXCJyZW5kZXJMYWJlbFwiLCBmdW5jdGlvbiAoY29udGV4dCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGF4aXMgICAgICAgICAgICA9IHRoaXMuYXhpcygpLFxuICAgICAgICAgICAgc3RvcmVkQW5jaG9yICAgID0gdGhpcy5hbmNob3IoKSxcbiAgICAgICAgICAgIGFuZ2xlICAgICAgICAgICA9IHRoaXMuYW5nbGUoKSxcbiAgICAgICAgICAgIHBlcnBPZmZzZXQgICAgICA9IGF4aXMucGVycE9mZnNldCgpLFxuICAgICAgICAgICAgYSAgICAgICAgICAgICAgID0gYXhpcy5kYXRhVmFsdWVUb0F4aXNWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSBuZXcgVGV4dCh0aGlzLmZvcm1hdHRlcigpLmZvcm1hdCh2YWx1ZSkpLFxuICAgICAgICAgICAgcGl4ZWxBbmNob3IsXG4gICAgICAgICAgICBiYXNlO1xuXG4gICAgICAgIGZvcm1hdHRlZFN0cmluZy5mb250KHRoaXMuZm9udCgpKTtcbiAgICAgICAgZm9ybWF0dGVkU3RyaW5nLmluaXRpYWxpemVHZW9tZXRyeSh7XG4gICAgICAgICAgICBcImNvbnRleHRcIiA6IGNvbnRleHQsXG4gICAgICAgICAgICBcImFuZ2xlXCIgICA6IGFuZ2xlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBpeGVsQW5jaG9yID0gbmV3IFBvaW50KFxuICAgICAgICAgICAgMC41ICogZm9ybWF0dGVkU3RyaW5nLm9yaWdXaWR0aCgpICogKHN0b3JlZEFuY2hvci54KCkgKyAxKSxcbiAgICAgICAgICAgIDAuNSAqIGZvcm1hdHRlZFN0cmluZy5vcmlnSGVpZ2h0KCkgKiAoc3RvcmVkQW5jaG9yLnkoKSArIDEpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGF4aXMub3JpZW50YXRpb24oKSA9PT0gQXhpcy5IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBiYXNlID0gbmV3IFBvaW50KGEsIHBlcnBPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZSA9IG5ldyBQb2ludChwZXJwT2Zmc2V0LCBhKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5jb2xvcigpLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgIGZvcm1hdHRlZFN0cmluZy5kcmF3VGV4dChjb250ZXh0LCBwaXhlbEFuY2hvciwgYmFzZSwgdGhpcy5wb3NpdGlvbigpLCBhbmdsZSk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIExhYmVsZXI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgTGVnZW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9sZWdlbmQuanMnKSxcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKExlZ2VuZC5yZW5kZXJMZWdlbmQpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBMZWdlbmQ7IH1cblxuICAgIExlZ2VuZC5yZXNwb25kc1RvKFwiYmVnaW5cIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIDEsIHRoaXMueCgpLCB0aGlzLnkoKSk7XG4gICAgfSk7XG5cbiAgICBMZWdlbmQucmVzcG9uZHNUbyhcImVuZFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIExlZ2VuZC5yZXNwb25kc1RvKFwicmVuZGVyTGVnZW5kXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBib3JkZXIgPSB0aGlzLmJvcmRlcigpO1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgaWYgKGJvcmRlciA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlcmNvbG9yKCkudG9SR0JBKCk7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoYm9yZGVyLzIsIGJvcmRlci8yLCB0aGlzLndpZHRoKCkgLSBib3JkZXIvMiwgdGhpcy5oZWlnaHQoKSAtIGJvcmRlci8yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5jb2xvcigpLnRvUkdCQSh0aGlzLm9wYWNpdHkoKSk7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoYm9yZGVyLCBib3JkZXIsIHRoaXMud2lkdGgoKSAtICgyICogYm9yZGVyKSwgdGhpcy5oZWlnaHQoKSAtICgyICogYm9yZGVyKSk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgTGVnZW5kLnJlc3BvbmRzVG8oXCJyZW5kZXJMYWJlbFwiLCBmdW5jdGlvbiAobGFiZWwsIGNvbnRleHQsIHgsIHkpIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDEpXCI7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCB5ICsgdGhpcy5tYXhMYWJlbEhlaWdodCgpLzIgLSBsYWJlbC5vcmlnSGVpZ2h0KCkvMik7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQobGFiZWwuc3RyaW5nKCksIHgsIDApO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBMZWdlbmQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkLCB3aW5kb3cpIHtcbiAgICB2YXIgTXVsdGlncmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbXVsdGlncmFwaC5qcycpKCQpLFxuICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICAgICAgdkYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKTtcblxuICAgIGlmICh0eXBlb2YoTXVsdGlncmFwaC5yZW5kZXIpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBNdWx0aWdyYXBoOyB9XG5cbiAgICBNdWx0aWdyYXBoLmhhc0EoXCJjYW52YXNcIik7ICAvLyBjYW52YXMgb2JqZWN0IGl0c2VsZiAodGhlICc8Y2FudmFzPicgdGFnIGl0c2VsZilcbiAgICBNdWx0aWdyYXBoLmhhc0EoXCJjb250ZXh0XCIpOyAvLyBjYW52YXMgY29udGV4dCBvYmplY3RcbiAgICBNdWx0aWdyYXBoLmhhc0EoXCJ3aWR0aFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgTXVsdGlncmFwaC5oYXNBKFwiaGVpZ2h0XCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcblxuICAgIE11bHRpZ3JhcGgucmVzcG9uZHNUbyhcInJlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnJlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIE11bHRpZ3JhcGgucmVzcG9uZHNUbyhcImluaXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGRpdiA9ICQodGhpcy5kaXYoKSk7XG4gICAgICAgIHRoaXMud2lkdGgoJGRpdi53aWR0aCgpKTtcbiAgICAgICAgdGhpcy5oZWlnaHQoJGRpdi5oZWlnaHQoKSk7XG4gICAgICAgIGlmICh0aGlzLndpZHRoKCkgPiAwICYmIHRoaXMuaGVpZ2h0KCkgPiAwKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGNhbnZhc1xuICAgICAgICAgICAgJChcIjxjYW52YXMgd2lkdGg9XFxcIlwiK3RoaXMud2lkdGgoKSp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbytcIlxcXCIgaGVpZ2h0PVxcXCJcIit0aGlzLmhlaWdodCgpKndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvK1wiXFxcIiBzdHlsZT1cXFwid2lkdGg6XCIrdGhpcy53aWR0aCgpK1wicHg7IGhlaWdodDpcIit0aGlzLmhlaWdodCgpK1wicHg7XFxcIi8+XCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKCRkaXYpO1xuXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVTdXJmYWNlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYnVzeVNwaW5uZXIoJCgnPGRpdiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7bWFyZ2luLXRvcDotMTZweDttYXJnaW4tbGVmdDotMTZweFwiPjwvZGl2PicpIC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kVG8oJGRpdikgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXN5X3NwaW5uZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9KTtcblxuICAgIE11bHRpZ3JhcGgucmVzcG9uZHNUbyhcInJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0KCksXG4gICAgICAgICAgICB3aWR0aCAgID0gdGhpcy53aWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0ICA9IHRoaXMuaGVpZ2h0KCksXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjb250ZXh0LnNjYWxlKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplR2VvbWV0cnkod2lkdGgsIGhlaWdodCwge1wiY29udGV4dFwiIDogY29udGV4dH0pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5ncmFwaHMoKS5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5ncmFwaHMoKS5hdChpKS5yZW5kZXIoY29udGV4dCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE11bHRpZ3JhcGgucmVzcG9uZHNUbyhcInJlZ2lzdGVyRXZlbnRzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzKCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJNb3VzZUV2ZW50cyhjYW52YXMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVG91Y2hFdmVudHMoY2FudmFzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclJlc2l6ZUV2ZW50cyhjYW52YXMpO1xuICAgIH0pO1xuXG4gICAgTXVsdGlncmFwaC5yZXNwb25kc1RvKFwicmVzaXplU3VyZmFjZVwiLCBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jb250ZXh0KCkuY2FudmFzO1xuICAgICAgICBjYW52YXMud2lkdGggID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSk7XG5cbiAgICBNdWx0aWdyYXBoLnJlc3BvbmRzVG8oXCJpbml0aWFsaXplU3VyZmFjZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzKCQodGhpcy5kaXYoKSkuY2hpbGRyZW4oXCJjYW52YXNcIilbMF0pO1xuICAgICAgICB0aGlzLmNvbnRleHQodGhpcy5jYW52YXMoKS5nZXRDb250ZXh0KFwiMmRcIikpO1xuICAgIH0pO1xuXG4gICAgLy8gICAgdmFyIGFwcGx5TWl4aW5zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IG9wdGlvbnMubWVzc2FnZUhhbmRsZXIuZXJyb3I7XG4gICAgLy8gICAgICAgIHdpbmRvdy5tdWx0aWdyYXBoLnBhcnNlci5taXhpbi5hcHBseSh3aW5kb3cubXVsdGlncmFwaCwgXCJwYXJzZVhNTFwiKTtcbiAgICAvLyAgICAgICAgbnMubWl4aW4uYXBwbHkod2luZG93Lm11bHRpZ3JhcGguY29yZSk7XG4gICAgLy8gICAgICAgIHdpbmRvdy5tdWx0aWdyYXBoLmV2ZW50cy5kcmFnZ2FibGUubWl4aW4uYXBwbHkod2luZG93Lm11bHRpZ3JhcGgsIGVycm9ySGFuZGxlcik7XG4gICAgLy8gICAgICAgIHdpbmRvdy5tdWx0aWdyYXBoLmV2ZW50cy5tb3VzZS5taXhpbi5hcHBseSh3aW5kb3cubXVsdGlncmFwaCwgZXJyb3JIYW5kbGVyKTtcbiAgICAvLyAgICAgICAgd2luZG93Lm11bHRpZ3JhcGguZXZlbnRzLnRvdWNoLm1peGluLmFwcGx5KHdpbmRvdy5tdWx0aWdyYXBoLCBlcnJvckhhbmRsZXIpO1xuICAgIC8vICAgICAgICB3aW5kb3cubXVsdGlncmFwaC5ub3JtYWxpemVyLm1peGluLmFwcGx5KHdpbmRvdy5tdWx0aWdyYXBoLmNvcmUpO1xuICAgIC8vICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZmYgdGhlIHN0cmluZyBgc2AgbG9va3MgbGlrZSBhIGpzb24gb2JqZWN0LlxuICAgIC8vIFRoaXMgc2ltcGx5IGNoZWNrcyB0byBzZWUgaWYgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlIGNoYXIgaXMgYSAneycgb3IgJ1snLlxuICAgIGZ1bmN0aW9uIGxvb2tzX2xpa2VfanNvbihzKSB7XG4gICAgICAgIHJldHVybiAvXlxccypbe1xcW10vLnRlc3Qocyk7XG4gICAgfVxuXG4gICAgdmFyIGdlbmVyYXRlSW5pdGlhbEdyYXBoID0gZnVuY3Rpb24gKG11Z2wsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIEpRdWVyeVhNTFBhcnNlciA9IHJlcXVpcmUoJy4uLy4uL3BhcnNlci94bWwvanF1ZXJ5X3htbF9wYXJzZXIuanMnKSgkKTtcbiAgICAgICAgcmVxdWlyZSgnLi4vLi4vcGFyc2VyL2pzb24vanNvbl9wYXJzZXIuanMnKSgkKTtcbiAgICAgICAgdmFyIG11bHRpZ3JhcGg7XG4gICAgICAgIGlmICh2Ri50eXBlT2YobXVnbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAobG9va3NfbGlrZV9qc29uKG11Z2wpKSB7XG4gICAgICAgICAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5MzU2MzIvcGFyc2UtanNvbi1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IEpTT04gJiYgSlNPTi5wYXJzZShtdWdsKSB8fCAkLnBhcnNlSlNPTihtdWdsKTtcbiAgICAgICAgICAgICAgICBtdWx0aWdyYXBoID0gTXVsdGlncmFwaC5wYXJzZUpTT04oIG9iaiwgb3B0aW9ucy5tdWdsLCBvcHRpb25zLm1lc3NhZ2VIYW5kbGVyICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB4bWxPYmogPSBKUXVlcnlYTUxQYXJzZXIuc3RyaW5nVG9KUXVlcnlYTUxPYmoobXVnbCk7XG4gICAgICAgICAgICAgICAgbXVsdGlncmFwaCA9IE11bHRpZ3JhcGgucGFyc2VYTUwoIHhtbE9iaiwgb3B0aW9ucy5tdWdsLCBvcHRpb25zLm1lc3NhZ2VIYW5kbGVyICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0aWdyYXBoID0gTXVsdGlncmFwaC5wYXJzZUpTT04oIG11Z2wsIG9wdGlvbnMubXVnbCwgb3B0aW9ucy5tZXNzYWdlSGFuZGxlciApO1xuICAgICAgICB9XG5cblxuICAgICAgICBtdWx0aWdyYXBoLm5vcm1hbGl6ZSgpO1xuICAgICAgICBtdWx0aWdyYXBoLmRpdihvcHRpb25zLmRpdik7XG4gICAgICAgICQob3B0aW9ucy5kaXYpLmNzcyhcImN1cnNvclwiICwgXCJwb2ludGVyXCIpO1xuICAgICAgICBtdWx0aWdyYXBoLmluaXQoKTtcbiAgICAgICAgbXVsdGlncmFwaC5yZWdpc3RlckV2ZW50cygpO1xuICAgICAgICBtdWx0aWdyYXBoLnJlZ2lzdGVyQ29tbW9uRGF0YUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgbXVsdGlncmFwaC5yZWRyYXcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtdWx0aWdyYXBoO1xuICAgIH07XG5cbiAgICBNdWx0aWdyYXBoLmNyZWF0ZUNhbnZhc0dyYXBoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG11Z2xQcm9taXNlLFxuICAgICAgICAgICAgZGVmZXJyZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vYXBwbHlNaXhpbnMob3B0aW9ucyk7XG4gICAgICAgICAgICByZXF1aXJlKCcuLi8uLi9ldmVudHMvYWxsLmpzJykoJCwgd2luZG93LCBvcHRpb25zLm1lc3NhZ2VIYW5kbGVyLmVycm9yKTtcbiAgICAgICAgICAgIG11Z2xQcm9taXNlID0gJC5hamF4KHtcbiAgICAgICAgICAgICAgICBcInVybFwiICAgICAgOiBvcHRpb25zLm11Z2wsXG4gICAgICAgICAgICAgICAgXCJkYXRhVHlwZVwiIDogXCJ0ZXh0XCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuLy9jb25zb2xlLmxvZygnYXQgYyAxJyk7XG50aHJvdyBlO1xuLy8gICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2VIYW5kbGVyLmVycm9yKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbXVnbFByb21pc2UuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBkaXYgc2l6ZSBJUyBhdmFpbGFibGUgaGVyZTsgc2VlIGJlbG93LiAgV2hhdCdzIGdvaW5nIG9uPz8/ISEhXG4gICAgICAgICAgICAgICAgdmFyIG11bHRpZ3JhcGggPSBnZW5lcmF0ZUluaXRpYWxHcmFwaChkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG11bHRpZ3JhcGgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuLy9jb25zb2xlLmxvZygnYXQgYyAyJyk7XG50aHJvdyBlO1xuLy8gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlSGFuZGxlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICB9O1xuXG4gICAgTXVsdGlncmFwaC5jcmVhdGVDYW52YXNHcmFwaEZyb21TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmZXJyZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vYXBwbHlNaXhpbnMob3B0aW9ucyk7XG4gICAgICAgICAgICByZXF1aXJlKCcuLi8uLi9ldmVudHMvYWxsLmpzJykoJCwgd2luZG93LCBvcHRpb25zLm1lc3NhZ2VIYW5kbGVyLmVycm9yKTtcbiAgICAgICAgICAgIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogZmlndXJlIHRoaXMgb3V0ISAgZGl2IHNpemUgaXMgbm90IGF2YWlsYWJsZSBoZXJlPyAgQXBwYXJlbnRseSwgYXQgdGhpcyBwb2ludCBpblxuICAgICAgICAgICAgLy8gY29kZSBleGVjdXRpb24sIHRoZSBicm93c2VyIGhhc24ndCBsYWlkIHRoaW5ncyBvdXQgZW5vdWdoIGZvciB0aGUgZGl2IHRvIGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gYXNzaWduZWQgYSBzaXplLCBhdCBsZWFzdCBzb21ldGltZXM/Pz8gIEJ1dCBpdCBJUyBhdmFpbGFibGUgYXQgdGhlIGNvcnJlc3BvbmRpbmcgcGxhY2UgaW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZUNhbnZhc0dyYXBoIGFib3ZlPyAgVGhpcyBpcyB3b3JrZWQgYXJvdW5kIGJ5IHRoZSBjb2RlIGluXG4gICAgICAgICAgICAvLyBzcmMvY29yZS9tdWx0aWdyYXBoLmpzOmNyZWF0ZUdyYXBoKCkgdGhhdCBmb3JjZXMgdGhlIGRpdiB0byBoYXZlIHRoZSBzaXplIHNwZWNpZmllZCBpblxuICAgICAgICAgICAgLy8gdGhlIG9wdGlvbnMgLS0tIHNvIHdlIGNhbiB3b3JrIGFyb3VuZCB0aGUgcHJvYmxlbSBieSBwYXNzaW5nIGFuIGV4cGxpY2l0IHNpemUgaW4gdGhlXG4gICAgICAgICAgICAvLyBvcHRpb25zLiAgQnV0IHdlIG5lZWQgdG8gcmVhbGx5IGZpZ3VyZSBvdXQgd2hhdCdzIGdvaW5nIG9uIGFuZCByZXNvbHZlIGl0LlxuICAgICAgICAgICAgdmFyIG11bHRpZ3JhcGggPSBnZW5lcmF0ZUluaXRpYWxHcmFwaChvcHRpb25zLm11Z2xTdHJpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShtdWx0aWdyYXBoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuLy9jb25zb2xlLmxvZygnYXQgYyAzJyk7XG50aHJvdyBlO1xuLy8gICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2VIYW5kbGVyLmVycm9yKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE11bHRpZ3JhcGg7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgUGxvdGFyZWEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3Bsb3RhcmVhLmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKFBsb3RhcmVhLnJlbmRlcik9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIFBsb3RhcmVhOyB9XG5cbiAgICBQbG90YXJlYS5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uIChncmFwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcGxvdEJveCA9IGdyYXBoLnBsb3RCb3goKSxcbiAgICAgICAgICAgIGJvcmRlciA9IHRoaXMuYm9yZGVyKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sb3IoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuY29sb3IoKS5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBwbG90Qm94LndpZHRoKCksIHBsb3RCb3guaGVpZ2h0KCkpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm9yZGVyID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcjtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlcmNvbG9yKCkuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgtYm9yZGVyLzIsIC1ib3JkZXIvMiwgcGxvdEJveC53aWR0aCgpICsgYm9yZGVyLCBwbG90Qm94LmhlaWdodCgpICsgYm9yZGVyKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUGxvdGFyZWE7XG59O1xuIiwidmFyIF9JTkNMVURFRCA9IGZhbHNlO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQmFuZFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vY29yZS9yZW5kZXJlcnMvYmFuZF9yZW5kZXJlci5qcycpO1xuXG4gICAgaWYgKF9JTkNMVURFRCkgeyByZXR1cm4gQmFuZFJlbmRlcmVyOyB9XG4gICAgX0lOQ0xVREVEID0gdHJ1ZTtcblxuICAgIC8vIGNhY2hlZCBzdGF0ZSBvYmplY3QsIGZvciBxdWljayBhY2Nlc3MgZHVyaW5nIHJlbmRlcmluZywgcG9wdWxhdGVkIGluIGJlZ2luKCkgbWV0aG9kOlxuICAgIEJhbmRSZW5kZXJlci5oYXNBKFwic3RhdGVcIik7XG5cbiAgICBCYW5kUmVuZGVyZXIucmVzcG9uZHNUbyhcImJlZ2luXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIFwiY29udGV4dFwiICAgICAgICAgICAgOiBjb250ZXh0LFxuICAgICAgICAgICAgXCJydW5cIiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgXCJsaW5lY29sb3JcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJsaW5lY29sb3JcIiksXG4gICAgICAgICAgICBcImxpbmUxY29sb3JcIiAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmUxY29sb3JcIiksXG4gICAgICAgICAgICBcImxpbmUyY29sb3JcIiAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmUyY29sb3JcIiksXG4gICAgICAgICAgICBcImxpbmV3aWR0aFwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmV3aWR0aFwiKSxcbiAgICAgICAgICAgIFwibGluZTF3aWR0aFwiICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwibGluZTF3aWR0aFwiKSxcbiAgICAgICAgICAgIFwibGluZTJ3aWR0aFwiICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwibGluZTJ3aWR0aFwiKSxcbiAgICAgICAgICAgIFwiZmlsbGNvbG9yXCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiZmlsbGNvbG9yXCIpLFxuICAgICAgICAgICAgXCJmaWxsb3BhY2l0eVwiICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJmaWxsb3BhY2l0eVwiKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlKHN0YXRlKTtcbiAgICB9KTtcblxuICAgIC8vIFRoaXMgcmVuZGVyZXIncyBkYXRhUG9pbnQoKSBtZXRob2Qgd29ya3MgYnkgYWNjdW11bGF0aW5nXG4gICAgLy8gYW5kIGRyYXdpbmcgb25lIFwicnVuXCIgb2YgZGF0YSBwb2ludHMgYXQgYSB0aW1lLiAgQSBcInJ1blwiIG9mXG4gICAgLy8gcG9pbnRzIGNvbnNpc3RzIG9mIGEgY29uc2VjdXRpdmUgc2VxdWVuY2Ugb2Ygbm9uLW1pc3NpbmdcbiAgICAvLyBkYXRhIHBvaW50cyB3aGljaCBoYXZlIHRoZSBzYW1lIGZpbGwgY29sb3IuICAoVGhlIGZpbGxcbiAgICAvLyBjb2xvciBjYW4gY2hhbmdlIGlmIHRoZSBkYXRhIGxpbmUgY3Jvc3NlcyB0aGUgZmlsbCBiYXNlXG4gICAgLy8gbGluZSwgaWYgdGhlIGRvd25maWxsY29sb3IgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgLy8gZmlsbGNvbG9yLilcbiAgICBCYW5kUmVuZGVyZXIucmVzcG9uZHNUbyhcImRhdGFQb2ludFwiLCBmdW5jdGlvbiAoZGF0YXApIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzTWlzc2luZyhkYXRhcCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBtaXNzaW5nIHBvaW50LCByZW5kZXIgYW5kIHJlc2V0IHRoZSBjdXJyZW50IHJ1biwgaWYgYW55XG4gICAgICAgICAgICBpZiAoc3RhdGUucnVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJ1bigpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJ1biA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCB0cmFuc2Zvcm0gcG9pbnQgdG8gcGl4ZWwgY29vcmRzXG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoZGF0YXApO1xuICAgICAgICAgICAgLy8gYW5kIGFkZCBpdCB0byB0aGUgY3VycmVudCBydW5cbiAgICAgICAgICAgIHN0YXRlLnJ1bi5wdXNoKHApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBCYW5kUmVuZGVyZXIucmVzcG9uZHNUbyhcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUoKTtcbiAgICAgICAgLy8gcmVuZGVyIHRoZSBjdXJyZW50IHJ1biwgaWYgYW55XG4gICAgICAgIGlmIChzdGF0ZS5ydW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW4oKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiBQcml2YXRlIHV0aWxpdHkgZnVuY3Rpb24gdG8gc3Ryb2tlIGxpbmUgc2VnbWVudHMgY29ubmVjdGluZyB0aGUgcG9pbnRzIG9mIGEgcnVuXG4gICAgICovXG4gICAgdmFyIHN0cm9rZVJ1bkxpbmUgPSBmdW5jdGlvbihjb250ZXh0LCBydW4sIHdoaWNoTGluZSwgY29sb3IsIGRlZmF1bHRDb2xvciwgd2lkdGgsIGRlZmF1bHRXaWR0aCkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICB3aWR0aCA9ICh3aWR0aCA+PSAwKSA/IHdpZHRoIDogZGVmYXVsdFdpZHRoO1xuICAgICAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjb2xvciA9IChjb2xvciAhPT0gbnVsbCkgPyBjb2xvciA6IGRlZmF1bHRDb2xvcjtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHJ1blswXVswXSwgcnVuWzBdW3doaWNoTGluZV0pO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHJ1bi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ1bltpXVswXSwgcnVuW2ldW3doaWNoTGluZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFJlbmRlciB0aGUgY3VycmVudCBydW4gb2YgZGF0YSBwb2ludHMuICBUaGlzIGNvbnNpc3RzIG9mIGRyYXdpbmcgdGhlIGZpbGwgcmVnaW9uXG4gICAgLy8gaW4gdGhlIGJhbmQgYmV0d2VlbiB0aGUgdHdvIGRhdGEgbGluZXMsIGFuZCBjb25uZWN0aW5nIHRoZSBwb2ludHMgb2YgZWFjaCBkYXRhIGxpbmVcbiAgICAvLyB3aXRoIGxpbmVzIG9mIHRoZSBhcHByb3ByaWF0ZSBjb2xvci5cbiAgICBCYW5kUmVuZGVyZXIucmVzcG9uZHNUbyhcInJlbmRlclJ1blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSAgID0gdGhpcy5zdGF0ZSgpLFxuICAgICAgICAgICAgY29udGV4dCA9IHN0YXRlLmNvbnRleHQsXG4gICAgICAgICAgICBydW4gICAgID0gc3RhdGUucnVuLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBmaWxsIHRoZSBydW5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBzdGF0ZS5maWxsb3BhY2l0eTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzdGF0ZS5maWxsY29sb3IuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgLy8gdHJhY2UgdG8gdGhlIHJpZ2h0IGFsb25nIGxpbmUgMVxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhydW5bMF1bMF0sIHJ1blswXVsxXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBydW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ1bltpXVswXSwgcnVuW2ldWzFdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmFjZSBiYWNrIHRvIHRoZSBsZWZ0IGFsb25nIGxpbmUgMlxuICAgICAgICBjb250ZXh0LmxpbmVUbyhydW5bcnVuLmxlbmd0aC0xXVswXSwgcnVuW3J1bi5sZW5ndGgtMV1bMl0pO1xuICAgICAgICBmb3IgKGkgPSBydW4ubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhydW5baV1bMF0sIHJ1bltpXVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vIHN0cm9rZSBsaW5lMVxuICAgICAgICBzdHJva2VSdW5MaW5lKGNvbnRleHQsIHJ1biwgMSwgc3RhdGUubGluZTFjb2xvciwgc3RhdGUubGluZWNvbG9yLCBzdGF0ZS5saW5lMXdpZHRoLCBzdGF0ZS5saW5ld2lkdGgpO1xuXG4gICAgICAgIC8vIHN0cm9rZSBsaW5lMlxuICAgICAgICBzdHJva2VSdW5MaW5lKGNvbnRleHQsIHJ1biwgMiwgc3RhdGUubGluZTJjb2xvciwgc3RhdGUubGluZWNvbG9yLCBzdGF0ZS5saW5lMndpZHRoLCBzdGF0ZS5saW5ld2lkdGgpO1xuICAgIH0pO1xuXG4gICAgQmFuZFJlbmRlcmVyLnJlc3BvbmRzVG8oXCJyZW5kZXJMZWdlbmRJY29uXCIsIGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCBpY29uKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUoKSxcbiAgICAgICAgICAgIGljb25XaWR0aCAgPSBpY29uLndpZHRoKCksXG4gICAgICAgICAgICBpY29uSGVpZ2h0ID0gaWNvbi5oZWlnaHQoKTtcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgeCwgeSk7XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIC8vIERyYXcgaWNvbiBiYWNrZ3JvdW5kICh3aXRoIG9wYWNpdHkpXG4gICAgICAgIGlmIChpY29uV2lkdGggPCAxMCB8fCBpY29uSGVpZ2h0IDwgMTApIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3RhdGUuZmlsbGNvbG9yLnRvUkdCQSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNGRkZGRkZcIjtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGljb25XaWR0aCwgaWNvbkhlaWdodCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vIERyYXcgaWNvbiBncmFwaGljc1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gKHN0YXRlLmxpbmUyY29sb3IgIT09IG51bGwpID8gc3RhdGUubGluZTJjb2xvciA6IHN0YXRlLmxpbmVjb2xvcjtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggICA9IChzdGF0ZS5saW5lMndpZHRoID49IDApID8gc3RhdGUubGluZTJ3aWR0aCA6IHN0YXRlLmxpbmV3aWR0aDtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgICA9IHN0YXRlLmZpbGxjb2xvci50b1JHQkEoc3RhdGUuZmlsbG9wYWNpdHkpO1xuXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgICAgICAgICAyKmljb25IZWlnaHQvOCk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKDAsICAgICAgICAgNippY29uSGVpZ2h0LzgpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhpY29uV2lkdGgsIDcqaWNvbkhlaWdodC84KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oaWNvbldpZHRoLCAzKmljb25IZWlnaHQvOCk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKDAsICAgICAgICAgMippY29uSGVpZ2h0LzgpO1xuICAgICAgICBcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQmFuZFJlbmRlcmVyO1xufTtcbiIsInZhciBfSU5DTFVERUQgPSBmYWxzZTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJhclJlbmRlcmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vY29yZS9yZW5kZXJlcnMvYmFyX3JlbmRlcmVyLmpzJyk7XG5cbiAgICBpZiAoX0lOQ0xVREVEKSB7IHJldHVybiBCYXJSZW5kZXJlcjsgfVxuICAgIF9JTkNMVURFRCA9IHRydWU7XG5cbiAgICAvLyBjYWNoZWQgc2V0dGluZ3Mgb2JqZWN0LCBmb3IgcXVpY2sgYWNjZXNzIGR1cmluZyByZW5kZXJpbmcsIHBvcHVsYXRlZCBpbiBiZWdpbigpIG1ldGhvZDpcbiAgICBCYXJSZW5kZXJlci5oYXNBKFwic2V0dGluZ3NcIik7XG5cbiAgICBCYXJSZW5kZXJlci5yZXNwb25kc1RvKFwiYmVnaW5cIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgXCJjb250ZXh0XCIgICAgICAgICAgICA6IGNvbnRleHQsXG4gICAgICAgICAgICBcImJhcnBpeGVsd2lkdGhcIiAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImJhcndpZHRoXCIpLmdldFJlYWxWYWx1ZSgpICogdGhpcy5wbG90KCkuaG9yaXpvbnRhbGF4aXMoKS5heGlzVG9EYXRhUmF0aW8oKSxcbiAgICAgICAgICAgIFwiYmFyb2Zmc2V0XCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiYmFyb2Zmc2V0XCIpLFxuICAgICAgICAgICAgXCJiYXJwaXhlbGJhc2VcIiAgICAgICA6ICh0aGlzLmdldE9wdGlvblZhbHVlKFwiYmFyYmFzZVwiKSAhPT0gbnVsbCk/dGhpcy5wbG90KCkudmVydGljYWxheGlzKCkuZGF0YVZhbHVlVG9BeGlzVmFsdWUodGhpcy5nZXRPcHRpb25WYWx1ZShcImJhcmJhc2VcIikpOjAsXG4gICAgICAgICAgICBcImZpbGxjb2xvclwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImZpbGxjb2xvclwiKSxcbiAgICAgICAgICAgIFwibGluZWNvbG9yXCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwibGluZWNvbG9yXCIpLFxuICAgICAgICAgICAgXCJoaWRlbGluZXNcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJoaWRlbGluZXNcIiksXG4gICAgICAgICAgICBcImJhckdyb3Vwc1wiICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBcImN1cnJlbnRCYXJHcm91cFwiICAgIDogbnVsbCxcbiAgICAgICAgICAgIFwicHJldkNvcm5lclwiICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgXCJwaXhlbEVkZ2VUb2xlcmFuY2VcIiA6IDFcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldHRpbmdzKHNldHRpbmdzKTtcbiAgICB9KTtcblxuICAgIC8vIFRoaXMgYmFyIHJlbmRlcmVyIHVzZXMgYSBzb21ld2hhdCBzb3BoaXN0aWNhdGVkIHRlY2huaXF1ZSB3aGVuIGRyYXdpbmdcbiAgICAvLyB0aGUgb3V0bGluZXMgYXJvdW5kIHRoZSBiYXJzLCBpbiBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCBpdCBvbmx5IGRyYXdzXG4gICAgLy8gb25lIHZlcnRpY2FsIGxpbmUgYmV0d2VlbiB0d28gYmFycyB0aGF0IHNoYXJlIGFuIGVkZ2UuICBJZiBhIGNvbXBsZXRlXG4gICAgLy8gb3V0bGluZSB3ZXJlIGRyYXduIGFyb3VuZCBlYWNoIGJhciBzZXBhcmF0ZWx5LCB0aGUgY29tbW9uIGVkZ2UgYmV0d2VlblxuICAgIC8vIGFkamFjZW50IGJhcnMgd291bGQgZ2V0IGRyYXduIHR3aWNlLCBvbmNlIGZvciBlYWNoIGJhciwgcG9zc2libHkgaW5cbiAgICAvLyBzbGlnaHRseSBkaWZmZXJlbnQgbG9jYXRpb25zIG9uIHRoZSBzY3JlZW4gZHVlIHRvIHJvdW5kb2ZmIGVycm9yLFxuICAgIC8vIHRoZXJlYnkgbWFraW5nIHNvbWUgb2YgdGhlIG91dGxpbmUgbGluZXMgYXBwZWFyIHRoaWNrZXIgdGhhbiBvdGhlcnMuXG4gICAgLy8gXG4gICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgdGhpcyByb3VuZG9mZiBhcnRpZmFjdCwgdGhpcyByZW5kZXIgb25seSBkcmF3cyB0aGVcbiAgICAvLyBiYXJzICh0aGUgZmlsbGVkIHJlZ2lvbiBvZiB0aGUgYmFyLCB0aGF0IGlzKSBpbiBpdHMgZGF0YVBvaW50KCkgbWV0aG9kLFxuICAgIC8vIGFuZCBrZWVwcyBhIHJlY29yZCBvZiB0aGUgYmFyIGxvY2F0aW9ucyBhbmQgaGVpZ2h0cyBzbyB0aGF0IGl0IGNhbiBkcmF3IGFsbFxuICAgIC8vIG9mIHRoZSBiYXIgb3V0bGluZXMgYXQgb25jZSwgaW4gaXRzIGVuZCgpIG1ldGhvZC4gIFRoZSBiYXIgbG9jYXRpb25zIGFuZFxuICAgIC8vIGhlaWdodHMgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSBjYWxsZWQgX2Jhckdyb3Vwcywgd2hpY2ggaXMgYW4gYXJyYXkgb2ZcbiAgICAvLyBcImJhciBncm91cFwiIG9iamVjdHMuICBFYWNoIFwiYmFyIGdyb3VwXCIgY29ycmVzcG9uZHMgdG8gYSBzZXF1ZW5jZSBvZiBhZGphY2VudFxuICAgIC8vIGJhcnMgLS0tIHR3byBiYXJzIGFyZSBjb25zaWRlcmVkIHRvIGJlIGFkamFjZW50IGlmIHRoZSByaWdodCBlZGdlIG9mIHRoZSBsZWZ0XG4gICAgLy8gYmFyIGlzIHdpdGhpbiBfcGl4ZWxFZGdlVG9sZXJhbmNlIHBpeGVscyBvZiB0aGUgbGVmdCBlZGdlIG9mIHRoZSByaWdodCBiYXIuXG4gICAgLy8gQSBcImJhciBncm91cFwiIGlzIHJlcHJlc2VudGVkIGJ5IGFuIGFycmF5IG9mIHBvaW50cyByZXByZXNlbnRpbmcgdGhlIHBpeGVsXG4gICAgLy8gY29vcmRpbmF0ZXMgb2YgdGhlIHVwcGVyIGxlZnQgY29ybmVycyBvZiBhbGwgdGhlIGJhcnMgaW4gdGhlIGdyb3VwLCBmb2xsb3dlZCBieVxuICAgIC8vIHRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdXBwZXIgcmlnaHQgY29ybmVyIG9mIHRoZSByaWdodC1tb3N0IGJhciBpbiB0aGUgZ3JvdXAuXG4gICAgLy8gKFRoZSBsYXN0LCByaWdodC1tb3N0LCBiYXIgaXMgdGhlIG9ubHkgb25lIHdob3NlIHVwcGVyIHJpZ2h0IGNvcm5lciBpcyBpbmNsdWRlZFxuICAgIC8vIGluIHRoZSBsaXN0KS4gIFNvLCBmb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBiYXIgZ3JvdXBcbiAgICAvLyBcbiAgICAvLyAgICAgICAgKi0tKlxuICAgIC8vICAgICAgICB8ICB8LS0qXG4gICAgLy8gICAgICotLSogIHwgIHxcbiAgICAvLyAgICAgfCAgfCAgfCAgfFxuICAgIC8vICAgICB8ICB8ICB8ICB8XG4gICAgLy8gICAtLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAgICAgMSAgMiAgMyAgNFxuICAgIC8vIFxuICAgIC8vIHdvdWxkIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBhcnJheVxuICAgIC8vXG4gICAgLy8gICAgWyBbMSwyXSwgWzIsM10sIFszLDNdLCBbNCwzXSBdXG4gICAgLy9cbiAgICBcbiAgICBCYXJSZW5kZXJlci5yZXNwb25kc1RvKFwiZGF0YVBvaW50XCIsIGZ1bmN0aW9uIChkYXRhcCkge1xuICAgICAgICBpZiAodGhpcy5pc01pc3NpbmcoZGF0YXApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzKCksXG4gICAgICAgICAgICBjb250ZXh0ICA9IHNldHRpbmdzLmNvbnRleHQsXG4gICAgICAgICAgICBwICA9IHRoaXMudHJhbnNmb3JtUG9pbnQoZGF0YXApLFxuICAgICAgICAgICAgeDAgPSBwWzBdICsgc2V0dGluZ3MuYmFyb2Zmc2V0LFxuICAgICAgICAgICAgeDEgPSBwWzBdICsgc2V0dGluZ3MuYmFyb2Zmc2V0ICsgc2V0dGluZ3MuYmFycGl4ZWx3aWR0aDtcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmdldE9wdGlvblZhbHVlKFwiZmlsbGNvbG9yXCIsIGRhdGFwWzFdKS5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHgwLCBzZXR0aW5ncy5iYXJwaXhlbGJhc2UsIHNldHRpbmdzLmJhcnBpeGVsd2lkdGgsIHBbMV0gLSBzZXR0aW5ncy5iYXJwaXhlbGJhc2UpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuYmFycGl4ZWx3aWR0aCA+IHNldHRpbmdzLmhpZGVsaW5lcykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnByZXZDb3JuZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5jdXJyZW50QmFyR3JvdXAgPSBbIFt4MCxwWzFdXSBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeDAgLSBzZXR0aW5ncy5wcmV2Q29ybmVyWzBdKSA8PSBzZXR0aW5ncy5waXhlbEVkZ2VUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY3VycmVudEJhckdyb3VwLnB1c2goIFt4MCxwWzFdXSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbnRCYXJHcm91cC5wdXNoKCBzZXR0aW5ncy5wcmV2Q29ybmVyICk7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmJhckdyb3Vwcy5wdXNoKCBzZXR0aW5ncy5jdXJyZW50QmFyR3JvdXAgKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY3VycmVudEJhckdyb3VwID0gWyBbeDAscFsxXV0gXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR0aW5ncy5wcmV2Q29ybmVyID0gW3gxLHBbMV1dO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgQmFyUmVuZGVyZXIucmVzcG9uZHNUbyhcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyAgICAgPSB0aGlzLnNldHRpbmdzKCksXG4gICAgICAgICAgICBjb250ZXh0ICAgICAgPSBzZXR0aW5ncy5jb250ZXh0LFxuICAgICAgICAgICAgYmFycGl4ZWxiYXNlID0gc2V0dGluZ3MuYmFycGl4ZWxiYXNlLFxuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICBiYXJHcm91cCxcbiAgICAgICAgICAgIGksIGosIG47XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnByZXZDb3JuZXIgIT09IG51bGwgJiYgc2V0dGluZ3MuY3VycmVudEJhckdyb3VwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5jdXJyZW50QmFyR3JvdXAucHVzaCggc2V0dGluZ3MucHJldkNvcm5lciApO1xuICAgICAgICAgICAgc2V0dGluZ3MuYmFyR3JvdXBzLnB1c2goIHNldHRpbmdzLmN1cnJlbnRCYXJHcm91cCApO1xuICAgICAgICB9ICAgICAgICBcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHNldHRpbmdzLmxpbmVjb2xvci5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2V0dGluZ3MuYmFyR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiYXJHcm91cCA9IHNldHRpbmdzLmJhckdyb3Vwc1tpXTtcbiAgICAgICAgICAgIG4gPSBiYXJHcm91cC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA8IDIpIHsgcmV0dXJuOyB9IC8vIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGb3IgdGhlIGZpcnN0IHBvaW50LCBkcmF3IDMgbGluZXM6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgICAgeSB8LS0tLS0tXG4gICAgICAgICAgICAvLyAgICAgICAgIHxcbiAgICAgICAgICAgIC8vICAgICAgICAgfFxuICAgICAgICAgICAgLy8gICAgYmFzZSB8LS0tLS0tXG4gICAgICAgICAgICAvLyAgICAgICAgIF4gICAgIF5cbiAgICAgICAgICAgIC8vICAgICAgICAgeCAgICAgeChuZXh0KVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gICBob3Jpem9udGFsIGxpbmUgQCB5IGZyb20geChuZXh0KSB0byB4XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhiYXJHcm91cFsxXVswXSwgYmFyR3JvdXBbMF1bMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYmFyR3JvdXBbMF1bMF0sIGJhckdyb3VwWzBdWzFdKTtcbiAgICAgICAgICAgIC8vICAgdmVydGljYWwgbGluZSBAIHggZnJvbSB5IHRvIGJhc2VcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGJhckdyb3VwWzBdWzBdLCBiYXJwaXhlbGJhc2UpO1xuICAgICAgICAgICAgLy8gICBob3Jpem9udGFsIGxpbmUgQCBiYXNlIGZyb20geCB0byB4KG5leHQpXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhiYXJHcm91cFsxXVswXSwgYmFycGl4ZWxiYXNlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IG4gLSAxOyArK2opIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgaW50ZXJtZWRpYXRlIHBvaW50cywgZHJhdyAzIGxpbmVzOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgeSB8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB8LS0tLS0tIHkobmV4dClcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHwtLS0tLS0gYmFzZVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgXiAgICAgXlxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgeCAgICAgeChuZXh0KVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICB2ZXJ0aWNhbCBsaW5lIEAgeCBmcm9tIG1pbiB0byBtYXggb2YgKHksIHkobmV4dCksIGJhc2UpXG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oYmFyR3JvdXBbal1bMF0sIG1pbihiYXJHcm91cFtqLTFdWzFdLCBiYXJHcm91cFtqXVsxXSwgYmFycGl4ZWxiYXNlKSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYmFyR3JvdXBbal1bMF0sIG1heChiYXJHcm91cFtqLTFdWzFdLCBiYXJHcm91cFtqXVsxXSwgYmFycGl4ZWxiYXNlKSk7XG4gICAgICAgICAgICAgICAgLy8gICBob3Jpem9udGFsIGxpbmUgQCB5KG5leHQpIGZyb20geCB0byB4KG5leHQpXG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oYmFyR3JvdXBbal1bMF0sICAgYmFyR3JvdXBbal1bMV0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGJhckdyb3VwW2orMV1bMF0sIGJhckdyb3VwW2pdWzFdKTtcbiAgICAgICAgICAgICAgICAvLyAgIGhvcml6b250YWwgbGluZSBAIGJhc2UgZnJvbSB4IHRvIHgobmV4dClcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhiYXJHcm91cFtqXVswXSwgICBiYXJwaXhlbGJhc2UpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGJhckdyb3VwW2orMV1bMF0sIGJhcnBpeGVsYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3IgbGFzdCBwb2ludCwgZHJhdyBvbmUgbGluZTpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgICB5IHxcbiAgICAgICAgICAgIC8vICAgICAgICAgfFxuICAgICAgICAgICAgLy8gICAgICAgICB8XG4gICAgICAgICAgICAvLyAgICBiYXNlIHxcbiAgICAgICAgICAgIC8vICAgICAgICAgXiAgICAgXlxuICAgICAgICAgICAgLy8gICAgICAgICB4ICAgICB4KG5leHQpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICB2ZXJ0aWNhbCBsaW5lIEAgeCBmcm9tIGJhc2UgdG8geVxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oYmFyR3JvdXBbbi0xXVswXSwgYmFyR3JvdXBbbi0xXVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhiYXJHcm91cFtuLTFdWzBdLCBiYXJwaXhlbGJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgQmFyUmVuZGVyZXIucmVzcG9uZHNUbyhcInJlbmRlckxlZ2VuZEljb25cIiwgZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIGljb24pIHtcbiAgICAgICAgdmFyIHNldHRpbmdzICAgICAgICAgID0gdGhpcy5zZXR0aW5ncygpLFxuICAgICAgICAgICAgcmVuZGVyZXJGaWxsQ29sb3IgPSB0aGlzLmdldE9wdGlvblZhbHVlKFwiZmlsbGNvbG9yXCIsIDApLnRvUkdCQSh0aGlzLmdldE9wdGlvblZhbHVlKFwiZmlsbG9wYWNpdHlcIiwgMCkpO1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybSgxLCAwLCAwLCAxLCB4LCB5KTtcblxuICAgICAgICAvLyBEcmF3IGljb24gYmFja2dyb3VuZCAod2l0aCBvcGFjaXR5KVxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAxKVwiO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGljb24ud2lkdGgoKSwgaWNvbi5oZWlnaHQoKSk7XG5cbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHJlbmRlcmVyRmlsbENvbG9yO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5iYXJwaXhlbHdpZHRoIDwgc2V0dGluZ3MuaGlkZWxpbmVzKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gcmVuZGVyZXJGaWxsQ29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmVjb2xvclwiLCAwKS50b1JHQkEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkanVzdCB0aGUgd2lkdGggb2YgdGhlIGljb25zIGJhcnMgYmFzZWQgdXBvbiB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgaWNvbiBSYW5nZXM6IHsyMCwgMTAsIDB9XG4gICAgICAgIHZhciBpY29uV2lkdGggPSBpY29uLndpZHRoKCksXG4gICAgICAgICAgICBpY29uSGVpZ2h0ID0gaWNvbi5oZWlnaHQoKSxcbiAgICAgICAgICAgIGJhcndpZHRoO1xuICAgICAgICBpZiAoaWNvbldpZHRoID4gMjAgfHwgaWNvbkhlaWdodCA+IDIwKSB7XG4gICAgICAgICAgICBiYXJ3aWR0aCA9IGljb25XaWR0aCAvIDY7XG4gICAgICAgIH0gZWxzZSBpZiAoaWNvbldpZHRoID4gMTAgfHwgaWNvbkhlaWdodCA+IDEwKSB7XG4gICAgICAgICAgICBiYXJ3aWR0aCA9IGljb25XaWR0aCAvIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXJ3aWR0aCA9IGljb25XaWR0aCAvIDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgaWNvbiBpcyBsYXJnZSBlbm91Z2ggZHJhdyBleHRyYSBiYXJzXG4gICAgICAgIGlmIChpY29uV2lkdGggPiAyMCAmJiBpY29uSGVpZ2h0ID4gMjApIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoICAgKGljb25XaWR0aCAvIDQpIC0gKGJhcndpZHRoIC8gMiksICAgICAgICAgICAgIDAsIGJhcndpZHRoLCBpY29uSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoIChpY29uV2lkdGggLyA0KSAtIChiYXJ3aWR0aCAvIDIpLCAgICAgICAgICAgICAwLCBiYXJ3aWR0aCwgaWNvbkhlaWdodCAvIDIpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KCAgIGljb25XaWR0aCAtIChpY29uV2lkdGggLyA0KSAtIChiYXJ3aWR0aCAvIDIpLCAwLCBiYXJ3aWR0aCwgaWNvbkhlaWdodCAvIDMpO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KCBpY29uV2lkdGggLSAoaWNvbldpZHRoIC8gNCkgLSAoYmFyd2lkdGggLyAyKSwgMCwgYmFyd2lkdGgsIGljb25IZWlnaHQgLyAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoICAgICAgIChpY29uV2lkdGggLyAyKSAtIChiYXJ3aWR0aCAvIDIpLCAgICAgICAgICAgICAwLCBiYXJ3aWR0aCwgaWNvbkhlaWdodCAtIChpY29uSGVpZ2h0IC8gNCkpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoICAgICAoaWNvbldpZHRoIC8gMikgLSAoYmFyd2lkdGggLyAyKSwgICAgICAgICAgICAgMCwgYmFyd2lkdGgsIGljb25IZWlnaHQgLSAoaWNvbkhlaWdodCAvIDQpKTtcblxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gQmFyUmVuZGVyZXI7XG59O1xuXG4iLCJ2YXIgX0lOQ0xVREVEID0gZmFsc2U7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBGaWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9jb3JlL3JlbmRlcmVycy9maWxsX3JlbmRlcmVyLmpzJyksXG4gICAgICAgIG1hdGhVdGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aC91dGlsLmpzJyk7XG5cbiAgICBpZiAoX0lOQ0xVREVEKSB7IHJldHVybiBGaWxsUmVuZGVyZXI7IH1cbiAgICBfSU5DTFVERUQgPSB0cnVlO1xuXG4gICAgLy8gY2FjaGVkIHN0YXRlIG9iamVjdCwgZm9yIHF1aWNrIGFjY2VzcyBkdXJpbmcgcmVuZGVyaW5nLCBwb3B1bGF0ZWQgaW4gYmVnaW4oKSBtZXRob2Q6XG4gICAgRmlsbFJlbmRlcmVyLmhhc0EoXCJzdGF0ZVwiKTtcblxuICAgIEZpbGxSZW5kZXJlci5yZXNwb25kc1RvKFwiYmVnaW5cIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgXCJjb250ZXh0XCIgICAgICAgICAgICA6IGNvbnRleHQsXG4gICAgICAgICAgICBcInJ1blwiICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBcInByZXZpb3VzcG9pbnRcIiAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIFwibGluZWNvbG9yXCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwibGluZWNvbG9yXCIpLFxuICAgICAgICAgICAgXCJsaW5ld2lkdGhcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJsaW5ld2lkdGhcIiksXG4gICAgICAgICAgICBcImZpbGxjb2xvclwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImZpbGxjb2xvclwiKSxcbiAgICAgICAgICAgIFwiZG93bmZpbGxjb2xvclwiICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiZG93bmZpbGxjb2xvclwiKSxcbiAgICAgICAgICAgIFwiZmlsbG9wYWNpdHlcIiAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiZmlsbG9wYWNpdHlcIiksXG4gICAgICAgICAgICBcImZpbGxiYXNlXCIgICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImZpbGxiYXNlXCIpLFxuICAgICAgICAgICAgXCJjdXJyZW50ZmlsbGNvbG9yXCIgICA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN0YXRlLmRvd25maWxsY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLmRvd25maWxsY29sb3IgPSBzdGF0ZS5maWxsY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZpbGxiYXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS5maWxscGl4ZWxiYXNlID0gdGhpcy5wbG90KCkudmVydGljYWxheGlzKCkuZGF0YVZhbHVlVG9BeGlzVmFsdWUoc3RhdGUuZmlsbGJhc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuZmlsbHBpeGVsYmFzZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlKHN0YXRlKTtcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzdGF0ZS5maWxsY29sb3IuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICB9KTtcblxuICAgIC8vIFRoaXMgcmVuZGVyZXIncyBkYXRhUG9pbnQoKSBtZXRob2Qgd29ya3MgYnkgYWNjdW11bGF0aW5nXG4gICAgLy8gYW5kIGRyYXdpbmcgb25lIFwicnVuXCIgb2YgZGF0YSBwb2ludHMgYXQgYSB0aW1lLiAgQSBcInJ1blwiIG9mXG4gICAgLy8gcG9pbnRzIGNvbnNpc3RzIG9mIGEgY29uc2VjdXRpdmUgc2VxdWVuY2Ugb2Ygbm9uLW1pc3NpbmdcbiAgICAvLyBkYXRhIHBvaW50cyB3aGljaCBoYXZlIHRoZSBzYW1lIGZpbGwgY29sb3IuICAoVGhlIGZpbGxcbiAgICAvLyBjb2xvciBjYW4gY2hhbmdlIGlmIHRoZSBkYXRhIGxpbmUgY3Jvc3NlcyB0aGUgZmlsbCBiYXNlXG4gICAgLy8gbGluZSwgaWYgdGhlIGRvd25maWxsY29sb3IgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgLy8gZmlsbGNvbG9yLilcbiAgICBGaWxsUmVuZGVyZXIucmVzcG9uZHNUbyhcImRhdGFQb2ludFwiLCBmdW5jdGlvbiAoZGF0YXApIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZSgpLFxuICAgICAgICAgICAgZmlsbHBpeGVsYmFzZSA9IHN0YXRlLmZpbGxwaXhlbGJhc2UsXG4gICAgICAgICAgICBmaWxsY29sb3IsXG4gICAgICAgICAgICBsaW5lY29sb3IsXG4gICAgICAgICAgICBwO1xuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBtaXNzaW5nIHBvaW50LCBhbmQgaWYgaXQncyBub3QgdGhlIGZpcnN0IHBvaW50LCBlbmQgdGhlIGN1cnJlbnQgcnVuIGFuZCByZW5kZXIgaXRcbiAgICAgICAgaWYgKHRoaXMuaXNNaXNzaW5nKGRhdGFwKSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnByZXZpb3VzcG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ydW4ucHVzaCggW3N0YXRlLnByZXZpb3VzcG9pbnRbMF0sIGZpbGxwaXhlbGJhc2VdICk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW4oKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ydW4gPSBbXTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcmV2aW91c3BvaW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyYW5zZm9ybSBwb2ludCB0byBwaXhlbCBjb29yZHNcbiAgICAgICAgcCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoZGF0YXApO1xuXG4gICAgICAgIC8vIHNldCB0aGUgZmlsbGNvbG9yIGFuZCBsaW5lY29sb3IgZm9yIHRoaXMgZGF0YSBwb2ludCwgYmFzZWQgb24gd2hldGhlciBpdCdzIGFib3ZlXG4gICAgICAgIC8vIG9yIGJlbG93IHRoZSBiYXNlIGxpbmVcbiAgICAgICAgaWYgKHBbMV0gPj0gZmlsbHBpeGVsYmFzZSkge1xuICAgICAgICAgICAgZmlsbGNvbG9yID0gc3RhdGUuZmlsbGNvbG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsbGNvbG9yID0gc3RhdGUuZG93bmZpbGxjb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlJ3JlIHN0YXJ0aW5nIGEgbmV3IHJ1biwgc3RhcnQgd2l0aCB0aGlzIGRhdGEgcG9pbnQncyBiYXNlIGxpbmUgcHJvamVjdGlvblxuICAgICAgICBpZiAoc3RhdGUucnVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdGUucnVuLnB1c2goIFtwWzBdLCBmaWxscGl4ZWxiYXNlXSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgbm90IHN0YXJ0aW5nIGEgbmV3IHJ1biwgYnV0IHRoZSBmaWxsIGNvbG9yXG4gICAgICAgICAgICAvLyBoYXMgY2hhbmdlZCwgaW50ZXJwb2xhdGUgdG8gZmluZCB0aGUgZXhhY3QgYmFzZVxuICAgICAgICAgICAgLy8gbGluZSBjcm9zc2luZyBwb2ludCwgZW5kIHRoZSBjdXJyZW50IHJ1biB3aXRoIHRoYXRcbiAgICAgICAgICAgIC8vIHBvaW50LCByZW5kZXIgaXQsIGFuZCBzdGFydCBhIG5ldyBydW4gd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGNyb3NzaW5nIHBvaW50LlxuICAgICAgICAgICAgaWYgKCFmaWxsY29sb3IuZXEoc3RhdGUuY3VycmVudGZpbGxjb2xvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IG1hdGhVdGlsLnNhZmVfaW50ZXJwKGZpbGxwaXhlbGJhc2UsIHN0YXRlLnByZXZpb3VzcG9pbnRbMV0sIHBbMV0sIHN0YXRlLnByZXZpb3VzcG9pbnRbMF0sIHBbMF0pO1xuICAgICAgICAgICAgICAgIC8vIGJhc2UgbGluZSBjcm9zc2luZyBwb2ludCBpcyBbeCwgc3RhdGUuZmlsbHBpeGVsYmFzZV1cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBwb2ludHMgYXJlIHB1c2hlZCB0d2ljZSBzbyB0aGUgb3V0bGluZSBvZiB0aGUgZmlsbCB3aWxsIGJlIGRyYXduIHByb3Blcmx5LFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGUgb3V0bGluZSB3b3VsZCBub3QgYmUgZHJhd24gYXJvdW5kIHRoZSBzZWdtZW50cyB0aGF0IGNyb3NzIHRoZSBiYXNlbGluZS5cbiAgICAgICAgICAgICAgICBzdGF0ZS5ydW4ucHVzaCggW3gsIGZpbGxwaXhlbGJhc2VdICk7XG4gICAgICAgICAgICAgICAgc3RhdGUucnVuLnB1c2goIFt4LCBmaWxscGl4ZWxiYXNlXSApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUnVuKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUucnVuID0gW107XG4gICAgICAgICAgICAgICAgc3RhdGUucnVuLnB1c2goIFt4LCBmaWxscGl4ZWxiYXNlXSApO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJ1bi5wdXNoKCBbeCwgZmlsbHBpeGVsYmFzZV0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGlzIHBvaW50IHRvIHRoZSBjdXJyZW50IHJ1biwgYW5kIHJlbWVtYmVyIGl0IGFuZCB0aGUgY3VycmVudCBjb2xvcnMgZm9yIG5leHQgdGltZVxuICAgICAgICBzdGF0ZS5ydW4ucHVzaChwKTtcbiAgICAgICAgc3RhdGUucHJldmlvdXNwb2ludCA9IHA7XG4gICAgICAgIHN0YXRlLmN1cnJlbnRmaWxsY29sb3IgPSBmaWxsY29sb3I7XG4gICAgfSk7XG5cbiAgICBGaWxsUmVuZGVyZXIucmVzcG9uZHNUbyhcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUoKSxcbiAgICAgICAgICAgIGNvbnRleHQgPSBzdGF0ZS5jb250ZXh0O1xuICAgICAgICBpZiAoc3RhdGUucnVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXRlLnJ1bi5wdXNoKCBbc3RhdGUucnVuW3N0YXRlLnJ1bi5sZW5ndGgtMV1bMF0sIHN0YXRlLmZpbGxwaXhlbGJhc2VdICk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gUmVuZGVyIHRoZSBjdXJyZW50IHJ1biBvZiBkYXRhIHBvaW50cy4gIFRoaXMgY29uc2lzdHMgb2YgZHJhd2luZyB0aGUgZmlsbCByZWdpb25cbiAgICAvLyB1bmRlciB0aGUgcG9pbnRzLCBhbmQgdGhlIGxpbmVzIGNvbm5lY3RpbmcgdGhlIHBvaW50cy4gIFRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHNcbiAgICAvLyBpbiB0aGUgcnVuIGFycmF5IGFyZSBhbHdheXMgb24gdGhlIGJhc2UgbGluZTsgdGhlIHBvaW50cyBpbiBiZXR3ZWVuIHRoZXNlIHR3b1xuICAgIC8vIGFyZSB0aGUgYWN0dWFsIGRhdGEgcG9pbnRzLlxuICAgIEZpbGxSZW5kZXJlci5yZXNwb25kc1RvKFwicmVuZGVyUnVuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZSgpLFxuICAgICAgICAgICAgY29udGV4dCA9IHN0YXRlLmNvbnRleHQsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGZpbGwgdGhlIHJ1blxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHN0YXRlLmZpbGxvcGFjaXR5O1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0YXRlLmN1cnJlbnRmaWxsY29sb3IuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oc3RhdGUucnVuWzBdWzBdLCBzdGF0ZS5ydW5bMF1bMV0pO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgc3RhdGUucnVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhzdGF0ZS5ydW5baV1bMF0sIHN0YXRlLnJ1bltpXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vIHN0cm9rZSB0aGUgcnVuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3RhdGUubGluZWNvbG9yLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3RhdGUubGluZXdpZHRoO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhzdGF0ZS5ydW5bMV1bMF0sIHN0YXRlLnJ1blsxXVsxXSk7XG4gICAgICAgIGZvciAoaSA9IDI7IGkgPCBzdGF0ZS5ydW4ubGVuZ3RoLTE7ICsraSkge1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oc3RhdGUucnVuW2ldWzBdLCBzdGF0ZS5ydW5baV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgRmlsbFJlbmRlcmVyLnJlc3BvbmRzVG8oXCJyZW5kZXJMZWdlbmRJY29uXCIsIGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCBpY29uKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUoKSxcbiAgICAgICAgICAgIGljb25XaWR0aCA9IGljb24ud2lkdGgoKSxcbiAgICAgICAgICAgIGljb25IZWlnaHQgPSBpY29uLmhlaWdodCgpO1xuICAgICAgICBcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIDEsIHgsIHkpO1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAvLyBEcmF3IGljb24gYmFja2dyb3VuZCAod2l0aCBvcGFjaXR5KVxuICAgICAgICBpZiAoaWNvbldpZHRoIDwgMTAgfHwgaWNvbkhlaWdodCA8IDEwKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0YXRlLmZpbGxjb2xvci50b1JHQkEoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBpY29uV2lkdGgsIGljb25IZWlnaHQpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3RhdGUubGluZWNvbG9yLnRvUkdCQSgpO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCAgID0gc3RhdGUubGluZXdpZHRoO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSAgID0gc3RhdGUuZmlsbGNvbG9yLnRvUkdCQShzdGF0ZS5maWxsb3BhY2l0eSk7XG5cbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIC8vIERyYXcgdGhlIG1pZGRsZSByYW5nZSBpY29uIG9yIHRoZSBsYXJnZSByYW5nZSBpY29uIGlmIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFsbG93IGl0XG4gICAgICAgIGlmIChpY29uV2lkdGggPiAxMCB8fCBpY29uSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICAgIC8vIERyYXcgYSBtb3JlIGNvbXBsZXggaWNvbiBpZiB0aGUgaWNvbnMgd2lkdGggYW5kIGhlaWdodCBhcmUgbGFyZ2UgZW5vdWdoXG4gICAgICAgICAgICBpZiAoaWNvbldpZHRoID4gMjAgfHwgaWNvbkhlaWdodCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oaWNvbldpZHRoIC8gNiwgaWNvbkhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGljb25XaWR0aCAvIDMsIGljb25IZWlnaHQgLyA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGljb25XaWR0aCAvIDIsIGljb25IZWlnaHQgLSBpY29uSGVpZ2h0IC8gNCk7XG5cbiAgICAgICAgICAgIGlmIChpY29uV2lkdGggPiAyMCB8fCBpY29uSGVpZ2h0ID4gMjApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhpY29uV2lkdGggLSBpY29uV2lkdGggLyAzLCBpY29uSGVpZ2h0IC8gNCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oaWNvbldpZHRoIC0gaWNvbldpZHRoIC8gNiwgaWNvbkhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubGluZVRvKGljb25XaWR0aCwgMCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEZpbGxSZW5kZXJlcjtcbn07XG4iLCJ2YXIgX0lOQ0xVREVEID0gZmFsc2U7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBQb2ludGxpbmVSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvcmUvcmVuZGVyZXJzL3BvaW50bGluZV9yZW5kZXJlci5qcycpLFxuICAgICAgICBSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvcmUvcmVuZGVyZXIuanMnKTtcblxuICAgIGlmIChfSU5DTFVERUQpIHsgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyOyB9XG4gICAgX0lOQ0xVREVEID0gdHJ1ZTtcblxuICAgIC8vIGNhY2hlZCBzZXR0aW5ncyBvYmplY3QsIGZvciBxdWljayBhY2Nlc3MgZHVyaW5nIHJlbmRlcmluZywgcG9wdWxhdGVkIGluIGJlZ2luKCkgbWV0aG9kOlxuICAgIFBvaW50bGluZVJlbmRlcmVyLmhhc0EoXCJzZXR0aW5nc1wiKTtcblxuICAgIFBvaW50bGluZVJlbmRlcmVyLnJlc3BvbmRzVG8oXCJiZWdpblwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBcImNvbnRleHRcIiAgICAgICAgICAgIDogY29udGV4dCxcbiAgICAgICAgICAgIFwicG9pbnRzXCIgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIFwiZmlyc3RcIiAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgXCJwb2ludHNoYXBlXCIgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJwb2ludHNoYXBlXCIpLFxuICAgICAgICAgICAgXCJwb2ludGNvbG9yXCIgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJwb2ludGNvbG9yXCIpLFxuICAgICAgICAgICAgXCJwb2ludG9wYWNpdHlcIiAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJwb2ludG9wYWNpdHlcIiksXG4gICAgICAgICAgICBcInBvaW50c2l6ZVwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcInBvaW50c2l6ZVwiKSxcbiAgICAgICAgICAgIFwicG9pbnRvdXRsaW5ld2lkdGhcIiAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwicG9pbnRvdXRsaW5ld2lkdGhcIiksXG4gICAgICAgICAgICBcInBvaW50b3V0bGluZWNvbG9yXCIgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcInBvaW50b3V0bGluZWNvbG9yXCIpLFxuICAgICAgICAgICAgXCJsaW5lc3Ryb2tlXCIgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJsaW5lc3Ryb2tlXCIpLFxuICAgICAgICAgICAgXCJsaW5lY29sb3JcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJsaW5lY29sb3JcIiksXG4gICAgICAgICAgICBcImxpbmV3aWR0aFwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmV3aWR0aFwiKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHR1cm5zIG9mZiBwb2ludHMgZm9yIGxpbmUgcmVuZGVyZXJzXG4gICAgICAgIGlmICh0aGlzLnR5cGUoKSA9PT0gUmVuZGVyZXIuTElORSkge1xuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRzaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0dXJucyBvZmYgbGluZXMgZm9yIHBvaW50IHJlbmRlcmVyc1xuICAgICAgICBpZiAodGhpcy50eXBlKCkgPT09IFJlbmRlcmVyLlBPSU5UKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5saW5ld2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0dGluZ3Moc2V0dGluZ3MpO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5saW5ld2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubGluZXN0cm9rZSA9PT0gUG9pbnRsaW5lUmVuZGVyZXIuREFTSEVEKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbNSw1XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNldHRpbmdzLmxpbmV3aWR0aDtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzZXR0aW5ncy5saW5lY29sb3IuZ2V0SGV4U3RyaW5nKFwiI1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcigpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcigpLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBQb2ludGxpbmVSZW5kZXJlci5yZXNwb25kc1RvKFwiZGF0YVBvaW50XCIsIGZ1bmN0aW9uIChkYXRhcCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzKCksXG4gICAgICAgICAgICBjb250ZXh0ICA9IHNldHRpbmdzLmNvbnRleHQsXG4gICAgICAgICAgICBwO1xuICAgICAgICBpZiAodGhpcy5pc01pc3NpbmcoZGF0YXApKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5maXJzdCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoZGF0YXApO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXIoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyKCkuZmlsdGVyKGRhdGFwLCBwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MubGluZXdpZHRoID4gMCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmZpcnN0KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLnBvaW50c2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50cy5wdXNoKHApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBQb2ludGxpbmVSZW5kZXJlci5yZXNwb25kc1RvKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncygpLFxuICAgICAgICAgICAgY29udGV4dCAgPSBzZXR0aW5ncy5jb250ZXh0O1xuICAgICAgICBpZiAoc2V0dGluZ3MubGluZXdpZHRoID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5wb2ludHNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdQb2ludHMoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBQb2ludGxpbmVSZW5kZXJlci5yZXNwb25kc1RvKFwiZHJhd1BvaW50c1wiLCBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgICA9IHRoaXMuc2V0dGluZ3MoKSxcbiAgICAgICAgICAgIGNvbnRleHQgICAgPSBzZXR0aW5ncy5jb250ZXh0LFxuICAgICAgICAgICAgcG9pbnRzICAgICA9IHNldHRpbmdzLnBvaW50cyxcbiAgICAgICAgICAgIHBvaW50c2hhcGUgPSBzZXR0aW5ncy5wb2ludHNoYXBlLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgaWYgKChwb2ludHNoYXBlID09PSBQb2ludGxpbmVSZW5kZXJlci5QTFVTKSB8fCAocG9pbnRzaGFwZSA9PT0gUG9pbnRsaW5lUmVuZGVyZXIuWCkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzZXR0aW5ncy5wb2ludGNvbG9yLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNldHRpbmdzLnBvaW50b3V0bGluZXdpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5wb2ludGNvbG9yLnRvUkdCQShzZXR0aW5ncy5wb2ludG9wYWNpdHkpO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHNldHRpbmdzLnBvaW50b3V0bGluZWNvbG9yLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNldHRpbmdzLnBvaW50b3V0bGluZXdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpPTA7IGk8cG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdQb2ludChjb250ZXh0LCBzZXR0aW5ncywgcG9pbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKChwb2ludHNoYXBlID09PSBQb2ludGxpbmVSZW5kZXJlci5QTFVTKSB8fCAocG9pbnRzaGFwZSA9PT0gUG9pbnRsaW5lUmVuZGVyZXIuWCkpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIFBvaW50bGluZVJlbmRlcmVyLnJlc3BvbmRzVG8oXCJkcmF3UG9pbnRcIiwgZnVuY3Rpb24gKGNvbnRleHQsIHNldHRpbmdzLCBwKSB7XG4gICAgICAgIHZhciBwb2ludHNpemUgPSBzZXR0aW5ncy5wb2ludHNpemUsXG4gICAgICAgICAgICBwMCA9IHBbMF0sXG4gICAgICAgICAgICBwMSA9IHBbMV0sXG4gICAgICAgICAgICBhLGIsZDtcblxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLnBvaW50c2hhcGUpIHtcbiAgICAgICAgY2FzZSBQb2ludGxpbmVSZW5kZXJlci5QTFVTOlxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocDAsICAgICAgICAgICAgIHAxIC0gcG9pbnRzaXplKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwLCAgICAgICAgICAgICBwMSArIHBvaW50c2l6ZSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwMCAtIHBvaW50c2l6ZSwgcDEpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgKyBwb2ludHNpemUsIHAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBQb2ludGxpbmVSZW5kZXJlci5YOlxuICAgICAgICAgICAgZCA9IDAuNzA3MTAgKiBwb2ludHNpemU7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwMC1kLCBwMS1kKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwK2QsIHAxK2QpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocDAtZCwgcDErZCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCtkLCBwMS1kKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBQb2ludGxpbmVSZW5kZXJlci5TUVVBUkU6XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwMCAtIHBvaW50c2l6ZSwgcDEgLSBwb2ludHNpemUpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgKyBwb2ludHNpemUsIHAxIC0gcG9pbnRzaXplKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwICsgcG9pbnRzaXplLCBwMSArIHBvaW50c2l6ZSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCAtIHBvaW50c2l6ZSwgcDEgKyBwb2ludHNpemUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFBvaW50bGluZVJlbmRlcmVyLlRSSUFOR0xFOlxuICAgICAgICAgICAgZCA9IDEuNSAqIHBvaW50c2l6ZTtcbiAgICAgICAgICAgIGEgPSAwLjg2NjAyNSAqIGQ7XG4gICAgICAgICAgICBiID0gMC41ICogZDtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHAwLCAgICAgcDEgKyBkKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwICsgYSwgcDEgLSBiKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwIC0gYSwgcDEgLSBiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBQb2ludGxpbmVSZW5kZXJlci5ESUFNT05EOlxuICAgICAgICAgICAgZCA9IDEuNSAqIHBvaW50c2l6ZTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHAwIC0gcG9pbnRzaXplLCBwMSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCwgICAgICAgICAgICAgcDEgKyBkKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwICsgcG9pbnRzaXplLCBwMSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCwgICAgICAgICAgICAgcDEgLSBkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBQb2ludGxpbmVSZW5kZXJlci5TVEFSOlxuICAgICAgICAgICAgZCA9IDEuNSAqIHBvaW50c2l6ZTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHAwIC0gZCowLjAwMDAsIHAxICsgZCoxLjAwMDApO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgKyBkKjAuMzUzNiwgcDEgKyBkKjAuMzUzNik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCArIGQqMC45NTExLCBwMSArIGQqMC4zMDkwKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwICsgZCowLjQ0NTUsIHAxIC0gZCowLjIyNzApO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgKyBkKjAuNTg3OCwgcDEgLSBkKjAuODA5MCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCAtIGQqMC4wNzgyLCBwMSAtIGQqMC40OTM4KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwIC0gZCowLjU4NzgsIHAxIC0gZCowLjgwOTApO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocDAgLSBkKjAuNDkzOCwgcDEgLSBkKjAuMDc4Mik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwMCAtIGQqMC45NTExLCBwMSArIGQqMC4zMDkwKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAwIC0gZCowLjIyNzAsIHAxICsgZCowLjQ0NTUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFBvaW50bGluZVJlbmRlcmVyLkNJUkNMRTpcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHAwICsgcG9pbnRzaXplLCBwMSk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYyhwMCwgcDEsIHBvaW50c2l6ZSwgMCwgMipNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFBvaW50bGluZVJlbmRlcmVyLnJlc3BvbmRzVG8oXCJyZW5kZXJMZWdlbmRJY29uXCIsIGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCBpY29uKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyAgID0gdGhpcy5zZXR0aW5ncygpLFxuICAgICAgICAgICAgcG9pbnRzaGFwZSA9IHNldHRpbmdzLnBvaW50c2hhcGUsXG4gICAgICAgICAgICBpY29uV2lkdGggID0gaWNvbi53aWR0aCgpLFxuICAgICAgICAgICAgaWNvbkhlaWdodCA9IGljb24uaGVpZ2h0KCk7XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIC8vIERyYXcgaWNvbiBiYWNrZ3JvdW5kICh3aXRoIG9wYWNpdHkpXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpXCI7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgaWNvbldpZHRoLCBpY29uSGVpZ2h0KTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MubGluZXdpZHRoID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHNldHRpbmdzLmxpbmVjb2xvci50b1JHQkEoKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoICAgPSBzZXR0aW5ncy5saW5ld2lkdGg7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSArIGljb25IZWlnaHQvMik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgaWNvbldpZHRoLCB5ICsgaWNvbkhlaWdodC8yKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLnBvaW50c2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoKHBvaW50c2hhcGUgPT09IFBvaW50bGluZVJlbmRlcmVyLlBMVVMpIHx8IChwb2ludHNoYXBlID09PSBQb2ludGxpbmVSZW5kZXJlci5YKSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzZXR0aW5ncy5wb2ludGNvbG9yLnRvUkdCQSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoICAgPSBzZXR0aW5ncy5wb2ludG91dGxpbmV3aWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgICA9IHNldHRpbmdzLnBvaW50Y29sb3IudG9SR0JBKHNldHRpbmdzLnBvaW50b3BhY2l0eSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHNldHRpbmdzLnBvaW50b3V0bGluZWNvbG9yLnRvUkdCQSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoICAgPSBzZXR0aW5ncy5wb2ludG91dGxpbmV3aWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kcmF3UG9pbnQoY29udGV4dCwgc2V0dGluZ3MsIFsoeCArIGljb25XaWR0aC8yKSwgKHkgKyBpY29uSGVpZ2h0LzIpXSk7XG5cbiAgICAgICAgICAgIGlmICghKChwb2ludHNoYXBlID09PSBQb2ludGxpbmVSZW5kZXJlci5QTFVTKSB8fCAocG9pbnRzaGFwZSA9PT0gUG9pbnRsaW5lUmVuZGVyZXIuWCkpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFBvaW50bGluZVJlbmRlcmVyO1xufTtcbiIsInZhciBfSU5DTFVERUQgPSBmYWxzZTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFJhbmdlQmFyUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9jb3JlL3JlbmRlcmVycy9yYW5nZWJhcl9yZW5kZXJlci5qcycpO1xuXG4gICAgaWYgKF9JTkNMVURFRCkgeyByZXR1cm4gUmFuZ2VCYXJSZW5kZXJlcjsgfVxuICAgIF9JTkNMVURFRCA9IHRydWU7XG5cbiAgICAvLyBjYWNoZWQgc3RhdGUgb2JqZWN0LCBmb3IgcXVpY2sgYWNjZXNzIGR1cmluZyByZW5kZXJpbmcsIHBvcHVsYXRlZCBpbiBiZWdpbigpIG1ldGhvZDpcbiAgICBSYW5nZUJhclJlbmRlcmVyLmhhc0EoXCJzdGF0ZVwiKTtcblxuICAgIFJhbmdlQmFyUmVuZGVyZXIucmVzcG9uZHNUbyhcImJlZ2luXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIFwiY29udGV4dFwiICAgICAgICAgICAgOiBjb250ZXh0LFxuICAgICAgICAgICAgXCJydW5cIiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgXCJiYXJwaXhlbHdpZHRoXCIgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJiYXJ3aWR0aFwiKS5nZXRSZWFsVmFsdWUoKSAqIHRoaXMucGxvdCgpLmhvcml6b250YWxheGlzKCkuYXhpc1RvRGF0YVJhdGlvKCksXG4gICAgICAgICAgICBcImJhcnBpeGVsb2Zmc2V0XCIgICAgIDogMCxcbiAgICAgICAgICAgIFwiYmFyb2Zmc2V0XCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiYmFyb2Zmc2V0XCIpLFxuICAgICAgICAgICAgXCJmaWxsY29sb3JcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJmaWxsY29sb3JcIiksXG4gICAgICAgICAgICBcImZpbGxvcGFjaXR5XCIgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImZpbGxvcGFjaXR5XCIpLFxuICAgICAgICAgICAgXCJsaW5lY29sb3JcIiAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uVmFsdWUoXCJsaW5lY29sb3JcIiksXG4gICAgICAgICAgICBcImxpbmV3aWR0aFwiICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25WYWx1ZShcImxpbmV3aWR0aFwiKSxcbiAgICAgICAgICAgIFwiaGlkZWxpbmVzXCIgICAgICAgICAgOiB0aGlzLmdldE9wdGlvblZhbHVlKFwiaGlkZWxpbmVzXCIpXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlLmJhcnBpeGVsb2Zmc2V0ID0gc3RhdGUuYmFycGl4ZWx3aWR0aCAqIHN0YXRlLmJhcm9mZnNldDtcbiAgICAgICAgdGhpcy5zdGF0ZShzdGF0ZSk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH0pO1xuXG4gICAgUmFuZ2VCYXJSZW5kZXJlci5yZXNwb25kc1RvKFwiZGF0YVBvaW50XCIsIGZ1bmN0aW9uIChkYXRhcCkge1xuICAgICAgICBpZiAodGhpcy5pc01pc3NpbmcoZGF0YXApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlKCksXG4gICAgICAgICAgICBjb250ZXh0ID0gc3RhdGUuY29udGV4dCxcbiAgICAgICAgICAgIHAgPSB0aGlzLnRyYW5zZm9ybVBvaW50KGRhdGFwKSxcbiAgICAgICAgICAgIHgwID0gcFswXSAtIHN0YXRlLmJhcnBpeGVsb2Zmc2V0LFxuICAgICAgICAgICAgeDEgPSB4MCArIHN0YXRlLmJhcnBpeGVsd2lkdGg7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAsIHBbMV0pO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MCwgcFsyXSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgxLCBwWzJdKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEsIHBbMV0pO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MCwgcFsxXSk7XG4gICAgfSk7XG5cbiAgICBSYW5nZUJhclJlbmRlcmVyLnJlc3BvbmRzVG8oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlKCksXG4gICAgICAgICAgICBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcblxuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gc3RhdGUuZmlsbG9wYWNpdHk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3RhdGUuZmlsbGNvbG9yLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICBpZiAoc3RhdGUubGluZXdpZHRoID4gMCAmJiBzdGF0ZS5iYXJwaXhlbHdpZHRoID4gc3RhdGUuaGlkZWxpbmVzKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3RhdGUubGluZWNvbG9yLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0YXRlLmxpbmV3aWR0aDtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBSYW5nZUJhclJlbmRlcmVyLnJlc3BvbmRzVG8oXCJyZW5kZXJMZWdlbmRJY29uXCIsIGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCBpY29uKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUoKSxcbiAgICAgICAgICAgIGljb25XaWR0aCAgPSBpY29uLndpZHRoKCksXG4gICAgICAgICAgICBpY29uSGVpZ2h0ID0gaWNvbi5oZWlnaHQoKSxcbiAgICAgICAgICAgIGJhcndpZHRoO1xuXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybSgxLCAwLCAwLCAxLCB4LCB5KTtcblxuICAgICAgICAvLyBEcmF3IGljb24gYmFja2dyb3VuZCAod2l0aCBvcGFjaXR5KVxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwiI0ZGRkZGRlwiO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI0ZGRkZGRlwiO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGljb25XaWR0aCwgaWNvbkhlaWdodCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vIERyYXcgaWNvbiBncmFwaGljc1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0YXRlLmZpbGxjb2xvci50b1JHQkEoc3RhdGUuZmlsbG9wYWNpdHkpO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0YXRlLmxpbmV3aWR0aDtcbiAgICAgICAgaWYgKHN0YXRlLmJhcnBpeGVsd2lkdGggPCAxMCkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0YXRlLmZpbGxjb2xvci50b1JHQkEoc3RhdGUuZmlsbG9wYWNpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0YXRlLmxpbmVjb2xvci5nZXRIZXhTdHJpbmcoXCIjXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRqdXN0IHRoZSB3aWR0aCBvZiB0aGUgaWNvbnMgYmFycyBiYXNlZCB1cG9uIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBpY29uIFJhbmdlczogezIwLCAxMCwgMH1cbiAgICAgICAgaWYgKGljb25XaWR0aCA+IDIwIHx8IGljb25IZWlnaHQgPiAyMCkge1xuICAgICAgICAgICAgYmFyd2lkdGggPSBpY29uV2lkdGggLyA2O1xuICAgICAgICB9IGVsc2UgaWYoaWNvbldpZHRoID4gMTAgfHwgaWNvbkhlaWdodCA+IDEwKSB7XG4gICAgICAgICAgICBiYXJ3aWR0aCA9IGljb25XaWR0aCAvIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXJ3aWR0aCA9IGljb25XaWR0aCAvIDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgaWNvbiBpcyBsYXJnZSBlbm91Z2ggZHJhdyBleHRyYSBiYXJzXG4gICAgICAgIGlmIChpY29uV2lkdGggPiAyMCAmJiBpY29uSGVpZ2h0ID4gMjApIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoICBpY29uV2lkdGgvNCAtIGJhcndpZHRoLzIsICAgICAgICAgICAgIGljb25IZWlnaHQvOCwgYmFyd2lkdGgsIGljb25IZWlnaHQvMik7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoaWNvbldpZHRoLzQgLSBiYXJ3aWR0aC8yLCAgICAgICAgICAgICBpY29uSGVpZ2h0LzgsIGJhcndpZHRoLCBpY29uSGVpZ2h0LzIpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KCAgaWNvbldpZHRoIC0gaWNvbldpZHRoLzQgLSBiYXJ3aWR0aC8yLCBpY29uSGVpZ2h0LzQsIGJhcndpZHRoLCBpY29uSGVpZ2h0LzMpO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGljb25XaWR0aCAtIGljb25XaWR0aC80IC0gYmFyd2lkdGgvMiwgaWNvbkhlaWdodC80LCBiYXJ3aWR0aCwgaWNvbkhlaWdodC8zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoICBpY29uV2lkdGgvMiAtIGJhcndpZHRoLzIsIDAsIGJhcndpZHRoLCBpY29uSGVpZ2h0LWljb25IZWlnaHQvNCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChpY29uV2lkdGgvMiAtIGJhcndpZHRoLzIsIDAsIGJhcndpZHRoLCBpY29uSGVpZ2h0LWljb25IZWlnaHQvNCk7XG5cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUmFuZ2VCYXJSZW5kZXJlcjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBUZXh0ID0gcmVxdWlyZSgnLi4vLi4vY29yZS90ZXh0LmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKFRleHQuZHJhd1RleHQpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBUZXh0OyB9XG5cbiAgICBUZXh0LnJlc3BvbmRzVG8oXCJpbml0aWFsaXplR2VvbWV0cnlcIiwgZnVuY3Rpb24gKGdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgICB2YXIgb3JpZ1dpZHRoLFxuICAgICAgICAgICAgb3JpZ0hlaWdodCxcbiAgICAgICAgICAgIHJvdGF0ZWRXaWR0aCxcbiAgICAgICAgICAgIHJvdGF0ZWRIZWlnaHQ7XG5cbiAgICAgICAgZ3JhcGhpY3NDb250ZXh0LmNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBpZiAodGhpcy5mb250KCkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIC8vIHRoZSBuZXcgd2F5OiB1c2UgdGhlIFwiZm9udFwiIHByb3BlcnR5XG4gICAgICAgICAgICBncmFwaGljc0NvbnRleHQuY29udGV4dC5mb250ID0gdGhpcy5mb250KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JhcGhpY3NDb250ZXh0LmZvbnRTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbGQgd2F5LCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAoXCJmb250U2l6ZVwiIHByb3BlcnR5IG9mIGdyYXBoaWNzIGNvbnRleHQgb2JqZWN0KTpcbiAgICAgICAgICAgIGdyYXBoaWNzQ29udGV4dC5jb250ZXh0LmZvbnQgPSBncmFwaGljc0NvbnRleHQuZm9udFNpemUgKyBcIiBzYW5zLXNlcmlmXCI7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnV2lkdGggID0gdGhpcy5tZWFzdXJlU3RyaW5nV2lkdGgoZ3JhcGhpY3NDb250ZXh0LmNvbnRleHQpO1xuICAgICAgICBvcmlnSGVpZ2h0ID0gdGhpcy5tZWFzdXJlU3RyaW5nSGVpZ2h0KGdyYXBoaWNzQ29udGV4dC5jb250ZXh0KTtcblxuICAgICAgICBncmFwaGljc0NvbnRleHQuY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgaWYgKGdyYXBoaWNzQ29udGV4dC5hbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBncmFwaGljc0NvbnRleHQuYW5nbGUvMTgwICogTWF0aC5QSTtcbiAgICAgICAgICAgIHJvdGF0ZWRXaWR0aCA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSkgKiBvcmlnV2lkdGggKyBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpICogb3JpZ0hlaWdodDtcbiAgICAgICAgICAgIHJvdGF0ZWRIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpICogb3JpZ1dpZHRoICsgTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKSAqIG9yaWdIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3RhdGVkV2lkdGggPSBvcmlnV2lkdGg7XG4gICAgICAgICAgICByb3RhdGVkSGVpZ2h0ID0gb3JpZ0hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3JpZ1dpZHRoKG9yaWdXaWR0aCk7XG4gICAgICAgIHRoaXMub3JpZ0hlaWdodChvcmlnSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5yb3RhdGVkV2lkdGgocm90YXRlZFdpZHRoKTtcbiAgICAgICAgdGhpcy5yb3RhdGVkSGVpZ2h0KHJvdGF0ZWRIZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB1bnJvdGF0ZWQgd2lkdGggZm9yIHRoZSBzdG9yZWQgc3RyaW5nIGluIHRoZSBjYW52YXMgZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG1lYXN1cmVTdHJpbmdXaWR0aFxuICAgICAqIEBmb3IgVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7RmxvYXR9IFVucm90YXRlZCB3aWR0aCBvZiBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgVGV4dC5yZXNwb25kc1RvKFwibWVhc3VyZVN0cmluZ1dpZHRoXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0cmluZygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lYXN1cmVTdHJpbmdXaWR0aCByZXF1aXJlcyB0aGUgc3RyaW5nIGF0dHIgdG8gYmUgc2V0LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRyaWNzID0gY29udGV4dC5tZWFzdXJlVGV4dCh0aGlzLnN0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG1ldHJpY3Mud2lkdGg7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHVucm90YXRlZCBoZWlnaHQgZm9yIHRoZSBzdG9yZWQgc3RyaW5nIGluIHRoZSBjYW52YXMgZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG1lYXN1cmVTdHJpbmdIZWlnaHRcbiAgICAgKiBAZm9yIFRleHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Zsb2F0fSBVbnJvdGF0ZWQgaGVpZ2h0IG9mIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBUZXh0LnJlc3BvbmRzVG8oXCJtZWFzdXJlU3RyaW5nSGVpZ2h0XCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0cmluZygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lYXN1cmVTdHJpbmdIZWlnaHQgcmVxdWlyZXMgdGhlIHN0cmluZyBhdHRyIHRvIGJlIHNldC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvL05PVEU6IGtsdWRnZTogY2FudmFzIGNhbm5vdCBleGFjdGx5IG1lYXN1cmUgdGV4dCBoZWlnaHQsIHNvIHdlIGp1c3QgcmV0dXJuIGEgdmFsdWVcbiAgICAgICAgLy8gICAgICBlc3RpbWF0ZWQgYnkgdXNpbmcgdGhlIHdpZHRoIG9mIGFuIFwiTVwiIGFzIGEgc3Vic3RpdHV0ZS4gIE1heWJlIGltcHJvdmUgdGhpc1xuICAgICAgICAvLyAgICAgIGxhdGVyIGJ5IHVzaW5nIGEgYmV0dGVyIHdvcmthcm91bmQuXG4gICAgICAgIHZhciBtZXRyaWNzID0gY29udGV4dC5tZWFzdXJlVGV4dChcIk1cIiksXG4gICAgICAgICAgICBuZXdsaW5lQ291bnQgPSB0aGlzLnN0cmluZygpLm1hdGNoKC9cXG4vZyk7XG4gICAgICAgIHJldHVybiAobmV3bGluZUNvdW50ICE9PSBudWxsID8gKG5ld2xpbmVDb3VudC5sZW5ndGggKyAxKSA6IDEpICogbWV0cmljcy53aWR0aDtcbiAgICB9KTtcblxuICAgIFRleHQucmVzcG9uZHNUbyhcInNldFRyYW5zZm9ybVwiLCBmdW5jdGlvbiAoY29udGV4dCwgYW5jaG9yLCBiYXNlLCBwb3NpdGlvbiwgYW5nbGUpIHtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oMSwgMCwgMCwgLTEsIDAsIDIgKiBiYXNlLnkoKSk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIDEsIGJhc2UueCgpLCBiYXNlLnkoKSk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKDEsIDAsIDAsIDEsIHBvc2l0aW9uLngoKSwgLXBvc2l0aW9uLnkoKSk7XG4gICAgICAgIGNvbnRleHQucm90YXRlKC1hbmdsZSAqIE1hdGguUEkvMTgwLjApO1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybSgxLCAwLCAwLCAxLCAtYW5jaG9yLngoKSwgYW5jaG9yLnkoKSk7XG4gICAgfSk7XG5cbiAgICBUZXh0LnJlc3BvbmRzVG8oXCJkcmF3VGV4dFwiLCBmdW5jdGlvbiAoY29udGV4dCwgYW5jaG9yLCBiYXNlLCBwb3NpdGlvbiwgYW5nbGUpIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGNvbnRleHQsIGFuY2hvciwgYmFzZSwgcG9zaXRpb24sIGFuZ2xlKTtcbiAgICAgICAgaWYgKHRoaXMuZm9udCgpICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZvbnQgPSB0aGlzLmZvbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMuc3RyaW5nKCksIDAsIDApO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBUZXh0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFdpbmRvdyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvd2luZG93LmpzJyk7XG5cbiAgICBpZiAodHlwZW9mKFdpbmRvdy5yZW5kZXIpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBXaW5kb3c7IH1cblxuICAgIFdpbmRvdy5yZXNwb25kc1RvKFwicmVuZGVyXCIsIGZ1bmN0aW9uIChjb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5tYXJnaW4oKS5sZWZ0KCk7XG5cbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5ib3JkZXJjb2xvcigpLmdldEhleFN0cmluZyhcIiNcIik7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QobSwgbSwgd2lkdGggLSAyKm0sIGhlaWdodCAtIDIqbSk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFdpbmRvdztcbn07XG4iLCJyZXF1aXJlKCcuLi9saWIvanF1ZXJ5L2pxdWVyeS5taW4uanMnKTtcbnJlcXVpcmUoJy4vbWFpbi5qcycpO1xuIiwicmVxdWlyZSgnLi4vbGliL2FqYXh0aHJvdHRsZS9zcmMvYWpheHRocm90dGxlLmpzJyk7XG5yZXF1aXJlKCcuLi9saWIvbGlnaHRib3gvbGlnaHRib3guanMnKTtcbnJlcXVpcmUoJy4uL2xpYi9qcXVlcnkvanF1ZXJ5Lm1vdXNld2hlZWwuanMnKTtcbnJlcXVpcmUoJy4uL2xpYi9idXN5LXNwaW5uZXIvYnVzeV9zcGlubmVyLmpzJyk7XG5yZXF1aXJlKCcuLi9saWIvZXJyb3ItZGlzcGxheS9idWlsZC9lcnJvckRpc3BsYXkuanMnKTtcbnJlcXVpcmUoJy4uL2xpYi9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLmpzJyk7XG5cbnJlcXVpcmUoJy4vcGFyc2VyL3htbC9qcXVlcnlfeG1sX3BhcnNlci5qcycpKCQpO1xucmVxdWlyZSgnLi9wYXJzZXIvanNvbi9qc29uX3BhcnNlci5qcycpKCQpO1xucmVxdWlyZSgnLi9ncmFwaGljcy9jYW52YXMvYWxsLmpzJykoJCwgd2luZG93KTtcblxuLy8gVGhpcyBmb3JjZXMgLi9ldmVudHMvbXVsdGlncmFwaC5qcyB0byBsb2FkLCB3aGljaCBpcyB3aGVyZSB0aGUgJ21haW4nIHByb2dyYW1cbi8vIHJlYWxseSBsaXZlcyAtLS0gaS5lLiBpbnN0YWxsYXRpb24gb2YgdGhlIE11bHRpZ3JhcGggalF1ZXJ5IHBsdWdpbiwgYW5kIHRoZVxuLy8gJChkb2N1bWVudCkucmVhZHkoLi4uKSBzdHVmZiB0aGF0IHNwcmluZ3MgaW50byBhY3Rpb24gb25jZSB0aGUgcGFnZSBoYXMgbG9hZGVkLlxuLy8gTm90ZSB0aGF0IHRoZSAzcmQgYXJnIHRvIHJlcXVpcmUoJy4vZXZlbnRzL211bHRpZ3JhcGguanMnKSBpcyB1bnVzZWQuXG5yZXF1aXJlKCcuL2V2ZW50cy9tdWx0aWdyYXBoLmpzJykoJCwgd2luZG93LCB1bmRlZmluZWQpO1xuXG4vLyBGb3IgSlMgYXBwbGljYXRpb25zIHRoYXQgd2FudCB0byB1c2UgdGhlIGJ1bmRsZWQgbXVsdGlncmFwaCBmaWxlLCBpbnN0ZWFkIG9mXG4vLyByZWZlcmVuY2luZyBNdWx0aWdyYXBoIHRocm91Z2ggbnBtLXN0eWxlIHJlcXVpcmUgc3RhdGVtZW50cywgYW5kIGZvciBiYWNrd2FyZFxuLy8gY29tcGF0aWJpbGl0eSB3aXRoIHByZS1ucG0gdmVyc2lvbnMgb2YgTXVsdGlncmFwaCwgY3JlYXRlIHRoZSBnbG9iYWVsXG4vLyB3aW5kb3cubXVsdGlncmFwaCBvYmplY3Qgd2hpY2ggZXhwb3NlcyBhIGJ1bmNoIG9mIG9iamVjdHMvZnVuY3Rpb25zIGZyb20gdGhlXG4vLyBNdWx0aWdyYXBoIGNvZGUuXG52YXIgTXVsdGlncmFwaCA9IHJlcXVpcmUoJy4vY29yZS9tdWx0aWdyYXBoLmpzJykoJCk7XG52YXIgdXRpbGl0eUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyk7XG52YXIgcGFyc2luZ0Z1bmN0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyk7XG52YXIgdmFsaWRhdGlvbkZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbC92YWxpZGF0aW9uRnVuY3Rpb25zLmpzJyk7XG5cbndpbmRvdy5tdWx0aWdyYXBoID0ge1xuICAgICdjb3JlJyA6IHtcbiAgICAgICAgJ011bHRpZ3JhcGgnOiAgICAgICAgICAgICAgICBcdE11bHRpZ3JhcGgsXG4gICAgICAgICdDU1ZEYXRhJzogICAgICAgICAgICAgICAgXHRcdHJlcXVpcmUoJy4vY29yZS9jc3ZfZGF0YS5qcycpKCQpLFxuICAgICAgICAnV2ViU2VydmljZURhdGEnOiAgICAgICAgICAgICBcdHJlcXVpcmUoJy4vY29yZS93ZWJfc2VydmljZV9kYXRhLmpzJykoJCksXG5cbiAgICAgICAgJ0FycmF5RGF0YSc6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvYXJyYXlfZGF0YS5qcycpLFxuICAgICAgICAnQXhpcyc6ICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9heGlzLmpzJyksXG4gICAgICAgICdBeGlzQmluZGluZyc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2F4aXNfYmluZGluZy5qcycpLFxuICAgICAgICAnQXhpc1RpdGxlJzogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9heGlzX3RpdGxlLmpzJyksXG4gICAgICAgICdCYWNrZ3JvdW5kJzogICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2JhY2tncm91bmQuanMnKSxcbiAgICAgICAgJ0NvbnN0YW50UGxvdCc6ICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvY29uc3RhbnRfcGxvdC5qcycpLFxuICAgICAgICAnRGF0YSc6ICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9kYXRhLmpzJyksXG4gICAgICAgICdEYXRhRm9ybWF0dGVyJzogICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2RhdGFfZm9ybWF0dGVyLmpzJyksXG4gICAgICAgICdEYXRhTWVhc3VyZSc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2RhdGFfbWVhc3VyZS5qcycpLFxuICAgICAgICAnRGF0YVBsb3QnOiAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9kYXRhX3Bsb3QuanMnKSxcbiAgICAgICAgJ0RhdGFWYWx1ZSc6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgICAgICAnRGF0YVZhcmlhYmxlJzogICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9kYXRhX3ZhcmlhYmxlLmpzJyksXG4gICAgICAgICdEYXRhdGlwcyc6ICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2RhdGF0aXBzLmpzJyksXG4gICAgICAgICdEYXRhdGlwc1ZhcmlhYmxlJzogICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2RhdGF0aXBzX3ZhcmlhYmxlLmpzJyksXG4gICAgICAgICdEYXRldGltZUZvcm1hdHRlcic6ICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2RhdGV0aW1lX2Zvcm1hdHRlci5qcycpLFxuICAgICAgICAnRGF0ZXRpbWVNZWFzdXJlJzogICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9kYXRldGltZV9tZWFzdXJlLmpzJyksXG4gICAgICAgICdEYXRldGltZVZhbHVlJzogICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2RhdGV0aW1lX3ZhbHVlLmpzJyksXG4gICAgICAgICdFdmVudEVtaXR0ZXInOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2V2ZW50X2VtaXR0ZXIuanMnKSxcbiAgICAgICAgJ0ZpbHRlck9wdGlvbic6ICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvZmlsdGVyX29wdGlvbi5qcycpLFxuICAgICAgICAnRmlsdGVyJzogICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9maWx0ZXIuanMnKSxcbiAgICAgICAgJ0dyYXBoJzogICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvZ3JhcGguanMnKSxcbiAgICAgICAgJ0dyaWQnOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvZ3JpZC5qcycpLFxuICAgICAgICAnSWNvbic6ICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9pY29uLmpzJyksXG4gICAgICAgICdJbWcnOiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2ltZy5qcycpLFxuICAgICAgICAnTGFiZWxlcic6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9sYWJlbGVyLmpzJyksXG4gICAgICAgICdMZWdlbmQnOiAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL2xlZ2VuZC5qcycpLFxuICAgICAgICAnTWl4aW4nOiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9taXhpbi5qcycpLFxuICAgICAgICAnTnVtYmVyRm9ybWF0dGVyJzogICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9udW1iZXJfZm9ybWF0dGVyLmpzJyksXG4gICAgICAgICdOdW1iZXJNZWFzdXJlJzogICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL251bWJlcl9tZWFzdXJlLmpzJyksXG4gICAgICAgICdOdW1iZXJWYWx1ZSc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL251bWJlcl92YWx1ZS5qcycpLFxuICAgICAgICAnUGFuJzogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9wYW4uanMnKSxcbiAgICAgICAgJ1BlcmlvZGljQXJyYXlEYXRhJzogICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvcGVyaW9kaWNfYXJyYXlfZGF0YS5qcycpLFxuICAgICAgICAnUGxvdCc6ICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9wbG90LmpzJyksXG4gICAgICAgICdQbG90TGVnZW5kJzogICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL3Bsb3RfbGVnZW5kLmpzJyksXG4gICAgICAgICdQbG90YXJlYSc6ICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL3Bsb3RhcmVhLmpzJyksXG4gICAgICAgICdSZW5kZXJlcic6ICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL3JlbmRlcmVyLmpzJyksXG4gICAgICAgICdCYW5kUmVuZGVyZXInOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL3JlbmRlcmVycy9iYW5kX3JlbmRlcmVyLmpzJyksXG4gICAgICAgICdCYXJSZW5kZXJlcic6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL3JlbmRlcmVycy9iYXJfcmVuZGVyZXIuanMnKSxcbiAgICAgICAgJ0ZpbGxSZW5kZXJlcic6ICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvcmVuZGVyZXJzL2ZpbGxfcmVuZGVyZXIuanMnKSxcbiAgICAgICAgJ1BvaW50bGluZVJlbmRlcmVyJzogICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvcmVuZGVyZXJzL3BvaW50bGluZV9yZW5kZXJlci5qcycpLFxuICAgICAgICAnUmFuZ2VCYXJSZW5kZXJlcic6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS9yZW5kZXJlcnMvcmFuZ2ViYXJfcmVuZGVyZXIuanMnKSxcbiAgICAgICAgJ1RleHQnOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvcmUvdGV4dC5qcycpLFxuICAgICAgICAnVGl0bGUnOiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS90aXRsZS5qcycpLFxuICAgICAgICAnV2FybmluZyc6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS93YXJuaW5nLmpzJyksXG4gICAgICAgICdXZWJTZXJ2aWNlRGF0YUNhY2hlTm9kZSc6ICAgICAgcmVxdWlyZSgnLi9jb3JlL3dlYl9zZXJ2aWNlX2RhdGFfY2FjaGVfbm9kZS5qcycpLFxuICAgICAgICAnV2ViU2VydmljZURhdGFJdGVyYXRvcic6ICAgICAgIHJlcXVpcmUoJy4vY29yZS93ZWJfc2VydmljZV9kYXRhX2l0ZXJhdG9yLmpzJyksXG4gICAgICAgICdXaW5kb3cnOiAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb3JlL3dpbmRvdy5qcycpLFxuICAgICAgICAnWm9vbSc6ICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29yZS96b29tLmpzJyksXG5cbiAgICAgICAgJ2Jyb3dzZXJIYXNDYW52YXNTdXBwb3J0JyA6IE11bHRpZ3JhcGguYnJvd3Nlckhhc0NhbnZhc1N1cHBvcnQsXG4gICAgICAgICdicm93c2VySGFzU1ZHU3VwcG9ydCcgICAgOiBNdWx0aWdyYXBoLmJyb3dzZXJIYXNTVkdTdXBwb3J0XG4gICAgfSxcblxuICAgICdjcmVhdGUnOiBNdWx0aWdyYXBoLmNyZWF0ZSxcblxuICAgICdtYXRoJzoge1xuICAgICAgICAnQm94JzogXHRcdFx0XHRyZXF1aXJlKCcuL21hdGgvYm94LmpzJyksXG4gICAgICAgICdEaXNwbGFjZW1lbnQnOiBcdHJlcXVpcmUoJy4vbWF0aC9kaXNwbGFjZW1lbnQuanMnKSxcbiAgICAgICAgJ0VudW0nOiBcdFx0XHRyZXF1aXJlKCcuL21hdGgvZW51bS5qcycpLFxuICAgICAgICAnSW5zZXRzJzogXHRcdFx0cmVxdWlyZSgnLi9tYXRoL2luc2V0cy5qcycpLFxuICAgICAgICAnUG9pbnQnOiBcdFx0XHRyZXF1aXJlKCcuL21hdGgvcG9pbnQuanMnKSxcbiAgICAgICAgJ1JHQkNvbG9yJzogXHRcdHJlcXVpcmUoJy4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgJ3V0aWwnOiBcdFx0XHRyZXF1aXJlKCcuL21hdGgvdXRpbC5qcycpXG4gICAgfSxcbiAgICAncGFyc2VyJyA6IHtcbiAgICAgICAgJ2pxdWVyeScgOiB7XG4gICAgICAgICAgICAnc3RyaW5nVG9KUXVlcnlYTUxPYmonIDogKHJlcXVpcmUoJy4vcGFyc2VyL3htbC9qcXVlcnlfeG1sX3BhcnNlci5qcycpKCQpKS5zdHJpbmdUb0pRdWVyeVhNTE9ialxuICAgICAgICB9XG4gICAgfSxcblxuICAgICd1dGlsaXR5RnVuY3Rpb25zJyA6IHtcbiAgICAgICAgJ2dldEtleXMnIFx0XHRcdFx0XHQ6IHV0aWxpdHlGdW5jdGlvbnMuZ2V0S2V5cyxcbiAgICAgICAgJ2luc2VydERlZmF1bHRzJyBcdFx0XHQ6IHV0aWxpdHlGdW5jdGlvbnMuaW5zZXJ0RGVmYXVsdHMsXG4gICAgICAgICdnZXREZWZhdWx0VmFsdWVzRnJvbVhTRCcgXHQ6IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QsXG4gICAgICAgIFxuICAgICAgICAncGFyc2VBdHRyaWJ1dGUnIFx0XHRcdDogcGFyc2luZ0Z1bmN0aW9ucy5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgJ3BhcnNlSW50ZWdlcicgXHRcdFx0XHQ6IHBhcnNpbmdGdW5jdGlvbnMucGFyc2VJbnRlZ2VyLFxuICAgICAgICAncGFyc2VCb29sZWFuJyBcdFx0XHRcdDogcGFyc2luZ0Z1bmN0aW9ucy5wYXJzZUJvb2xlYW4sXG4gICAgICAgICdnZXRYTUxBdHRyJyBcdFx0XHRcdDogcGFyc2luZ0Z1bmN0aW9ucy5nZXRYTUxBdHRyLFxuICAgICAgICBcbiAgICAgICAgJ3ZhbGlkYXRlTnVtYmVyUmFuZ2UnIFx0XHQ6IHZhbGlkYXRpb25GdW5jdGlvbnMudmFsaWRhdGVOdW1iZXJSYW5nZSxcbiAgICAgICAgJ3R5cGVPZicgXHRcdFx0XHRcdDogdmFsaWRhdGlvbkZ1bmN0aW9ucy50eXBlT2ZcbiAgICB9LFxuXG4gICAgJ2plcm1haW5lJzogcmVxdWlyZSgnLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpLFxuXG4gICAgJ2pRdWVyeScgOiAkXG59O1xud2luZG93LnNwcmludGYgPSByZXF1aXJlKCdzcHJpbnRmJyk7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBCb3ggPSBuZXcgamVybWFpbmUuTW9kZWwoXCJCb3hcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcIndpZHRoXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJoZWlnaHRcIikud2hpY2guaXNBKFwibnVtYmVyXCIpO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJ3aWR0aFwiLCBcImhlaWdodFwiKTtcbn0pO1xuICAgIFxubW9kdWxlLmV4cG9ydHMgPSBCb3g7XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyksXG4gICAgdmFsaWRhdGlvbkZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpO1xuXG52YXIgRGlzcGxhY2VtZW50ID0ge307XG4vKipcbiAqIEEgRGlzcGxhY2VtZW50IHJlcHJlc2VudHMgYSBnZW9tZXRyaWMgcG9zaXRpb24gYWxvbmcgYSBsaW5lXG4gKiBzZWdtZW50LCBleHByZXNzZWQgaW4gdGVybXMgb2YgdHdvIHF1YW50aXRpZXM6IGEgcmVsYXRpdmVcbiAqIHBvc2l0aW9uIGNhbGxlZCBgYWAsIGFuZCBhbiBhYnNvbHV0ZSBvZmZzZXQgY2FsbGVkIGBiYC4gIFRoZVxuICogbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgaXMgbm90IGtub3duIGluIGFkdmFuY2UgLS0tIHRoZSBpZGVhXG4gKiBpcyB0aGF0IHRoZSBEaXNwbGFjZW1lbnQgb2JqZWN0IGVuY2Fwc3VsYXRlcyBhIHJ1bGUgZm9yXG4gKiBkZXRlcm1pbmluZyBhIGxvY2F0aW9uIGFsb25nIEFOWSBsaW5lIHNlZ21lbnQuICBUaGUgRGlzcGxhY2VtZW50XG4gKiBoYXMgbWV0aG9kcyB3aGljaCB0YWtlIHRoZSBsaW5lIHNlZ21lbnQgbGVuZ3RoIGFzIGFuIGFyZ3VtZW50XG4gKiBhbmQgcmV0dXJuIHRoZSBjb21wdXRlZCBmaW5hbCBwb3NpdGlvbi5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGRpZmZlcmVudCBwb3NpdGlvbi1jYWxjdWF0aW5nIG1ldGhvZHMsXG4gKiBjb3JyZXNwb25kaW5nIHRvIHR3byBkaWZmZXJlbnQgaW50ZXJwcmV0YXRpb25zIG9mIHRoZSByZWxhdGl2ZVxuICogdmFsdWUgYGFgOlxuICpcbiAqICoqcmVsYXRpdmUgbGVuZ3RoKio6XG4gKiAgICAgYGFgIGlzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSwgcmVwcmVzZW50aW5nIGEgZnJhY3Rpb24gb2ZcbiAqICAgICAgIHRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGxpbmUgc2VnbWVudDsgdGhlIHJlbGF0aXZlXG4gKiAgICAgICBwb3NpdGlvbiBkZXRlcm1pbmVkIGJ5IGBhYCBpcyB0aGUgZnJhY3Rpb24gYGFgIG9mIHRoZVxuICogICAgICAgdG90YWwgbGVuZ3RoIG9mIHRoZSBzZWdtZW50LlxuICogICAgIEluIHRoaXMgY2FzZSwgdGhlIHBvc2l0aW9uLWNhbGN1bGF0aW5nIG1ldGhvZFxuICogICAgICAgYGNhbGN1bGF0ZUxlbmd0aChMKWAgcmV0dXJucyB0aGUgbnVtYmVyIGBhICogTCArIGJgLCB3aGljaFxuICogICAgICAgY29ycmVzcG9uZHMgdG8gbW92aW5nIGBhYCBvZiB0aGUgd2F5IGFsb25nIHRoZSBsZW5ndGggTCxcbiAqICAgICAgIHRoZW4gYWRkaW5nIGBiYDpcbiAqXG4gKiAgICAgICAgICAgICBbLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1YLS0tLS0tLS0tLS0tXVxuICogICAgICAgICAgICAgfDwtLS0tIGEgKiBMIC0tLT58PC0tLS0gYiAtLS0tLS0+fFxuICogICAgICAgICAgICAgfDwtLS0tLS0tLS0tLS0tLS0tLS0gIEwgIC0tLS0tLS0tLS0tLS0tLS0tLS0tPnxcbiAqXG4gKiAqKnJlbGF0aXZlIGNvb3JkaW5hdGUqKjpcbiAqICAgICBgYWAgaXMgYSBudW1iZXIgYmV0d2VlbiAtMSBhbmQgMSwgcmVwcmVzZW50aW5nIGEgY29vcmRpbmF0ZVxuICogICAgICAgdmFsdWUgaW4gYSBbLTEsMV0gY29vcmRpbmF0ZSBzeXN0ZW0gYWxvbmcgdGhlIGxpbmVcbiAqICAgICAgIHNlZ21lbnQuXG4gKiAgICAgSW4gdGhpcyBjYXNlLCB0aGUgcG9zaXRpb24tY2FsY3VsYXRpbmcgbWV0aG9kXG4gKiAgICAgICBgY2FsY3VsYXRlQ29vcmRpbmF0ZShMKWAgcmV0dXJucyB0aGUgbnVtYmVyIGAoYSsxKSAqIEwvMiArXG4gKiAgICAgICBiYC4gIHdoaWNoIGNvcnJlc3BvbmRzIHRvIG1vdmluZyB0byB0aGUgcG9zaXRpb25cbiAqICAgICAgIGRldGVybWluZWQgYnkgdGhlIGBhYCBjb29yZGluYXRlLCB0aGVuIGFkZGluZyBgYmA6XG4gKlxuICogICAgICAgICAgICAgWy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVgtLS0tLS0tLV1cbiAqICAgICAgICAgICAgIHw8LS0tIChhKzEpICogTC8yIC0tLT58PC0tLS0gYiAtLS0tLT58XG4gKiAgICAgICAgICAgICB8PC0tLS0tLS0tLS0tLS0tLS0tLSAgTCAgLS0tLS0tLS0tLS0tLS0tLS0tLS0+fFxuICpcbiAqIEBjbGFzcyBEaXNwbGFjZW1lbnRcbiAqIEBmb3IgRGlzcGxhY2VtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGIgKE9QVElPTkFMKVxuICovXG5EaXNwbGFjZW1lbnQgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJEaXNwbGFjZW1lbnRcIiwgZnVuY3Rpb24gKCkge1xuICAgIFxuICAgIHRoaXMuaGFzQShcImFcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkZ1bmN0aW9ucy52YWxpZGF0ZU51bWJlclJhbmdlKGEsIC0xLjAsIDEuMCk7XG4gICAgfSk7XG4gICAgdGhpcy5oYXNBKFwiYlwiKS53aGljaC5pc0EoXCJpbnRlZ2VyXCIpLmFuZC5kZWZhdWx0c1RvKDApO1xuICAgIHRoaXMuaXNCdWlsdFdpdGgoXCJhXCIsIFwiJWJcIik7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJjYWxjdWxhdGVMZW5ndGhcIiwgZnVuY3Rpb24gKHRvdGFsTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmEoKSAqIHRvdGFsTGVuZ3RoICsgdGhpcy5iKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJjYWxjdWxhdGVDb29yZGluYXRlXCIsIGZ1bmN0aW9uICh0b3RhbExlbmd0aCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYSgpICsgMSkgKiB0b3RhbExlbmd0aC8yLjAgKyB0aGlzLmIoKTtcbiAgICB9KTtcblxufSk7XG5cbkRpc3BsYWNlbWVudC5yZWdFeHAgPSAvXihbXFwrXFwtXT9bMC05XFwuXSspKFsrXFwtXSkoWzAtOVxcLitcXC1dKykkLztcblxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgaW50byBhIERpc3BsYWNlbWVudC4gIFRoZSBzdHJpbmcgc2hvdWxkIGJlIG9mIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1zOlxuICpcbiAqICAgICBcIkErQlwiICA9PT4gIGE9QSAgYj1CXG4gKiAgICAgXCJBLUJcIiAgPT0+ICBhPUEgIGI9LUJcbiAqICAgICBcIkFcIiAgICA9PT4gIGE9QSAgYj0wXG4gKiAgICAgXCIrQVwiICAgPT0+ICBhPUEgIGI9MFxuICogICAgIFwiLUFcIiAgID09PiAgYT0tQSBiPTBcbiAqIFxuICogSWYgdGhlIGlucHV0IGFyZ3VtZW50IGlzIG5vdCBhIHN0cmluZywgaXQgaXMgY29lcmNlZCBpbnRvIG9uZS5cbiAqL1xuRGlzcGxhY2VtZW50LnBhcnNlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICh0eXBlb2Yoc3RyaW5nKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdHJpbmcgPSBTdHJpbmcoc3RyaW5nKTtcbiAgICB9XG4gICAgdmFyIGFyID0gRGlzcGxhY2VtZW50LnJlZ0V4cC5leGVjKHN0cmluZyksXG4gICAgICAgIGQsXG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIHNpZ247XG4gICAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGQgPSBuZXcgRGlzcGxhY2VtZW50KDEpO1xuICAgIH0gZWxzZSBpZiAoYXIgIT09IG51bGwpIHtcbiAgICAgICAgYSA9IHBhcnNlRmxvYXQoYXJbMV0pO1xuICAgICAgICBiID0gcGFyc2VGbG9hdChhclszXSk7XG4gICAgICAgIHN3aXRjaCAoYXJbMl0pIHtcbiAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgIHNpZ24gPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNpZ24gPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgIGlmIChpc05hTihhKSB8fCBzaWduID09IDAgfHwgaXNOYU4oYikpIHtcbiAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCdwYXJzZSBlcnJvcicpO1xuICAgICAgICAgfVxuICAgICAgICAgKi9cbiAgICAgICAgZCA9IG5ldyBEaXNwbGFjZW1lbnQoYSwgc2lnbiAqIGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEgPSBwYXJzZUZsb2F0KHN0cmluZyk7XG4gICAgICAgIC8qblxuICAgICAgICAgaWYgKGlzTmFOKGEpKSB7XG4gICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigncGFyc2UgZXJyb3InKTtcbiAgICAgICAgIH1cbiAgICAgICAgICovXG4gICAgICAgIGQgPSBuZXcgRGlzcGxhY2VtZW50KGEpO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGxhY2VtZW50O1xuIiwiLy8gVXNlIEVudW0gdG8gY3JlYXRlIG9iamVjdHMgdGhhdCBhY3QgbGlrZSBlbnVtZXJhdGlvbnMgaW4gb3RoZXIgbGFuZ3VhZ2VzIChzdWNoIGFzIEphdmEpLlxuLy8gXG4vLyBVc2FnZSBpcyBsaWtlIHRoaXM6XG4vLyBcbi8vICAgdmFyIFN1aXQgPSBFbnVtKFwiU3VpdFwiKTtcbi8vICAgdmFyIGNsdWJzID0gbmV3IFN1aXQoXCJjbHVic1wiKTtcbi8vICAgdmFyIGRpYW1vbmRzID0gbmV3IFN1aXQoXCJkaWFtb25kc1wiKTtcbi8vICAgdmFyIHNwYWRlcyA9IG5ldyBTdWl0KFwic3BhZGVzXCIpO1xuLy8gICB2YXIgaGVhcnRzID0gbmV3IFN1aXQoXCJoZWFydHNcIik7XG4vLyBcbi8vICAgdmFyIGMgPSBTdWl0LnBhcnNlKFwiY2x1YnNcIik7ICAjIGMgaXMgZ3VhcmFudGVlZCB0byBlcXVhbCB0aGUgY2x1YnMgdmFyaWFibGUgZnJvbSBhYm92ZVxuLy8gXG52YXIgRW51bSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICB2YXIgaW5zdGFuY2VzID0ge307XG5cbiAgICB2YXIgRW51bSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dGVtcHQgdG8gcmVkZWZpbmUgXCIrbmFtZStcIiBFbnVtIHdpdGgga2V5ICdcIitrZXkrXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW51bVR5cGUgPSBuYW1lO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgaW5zdGFuY2VzW2tleV0gPSB0aGlzO1xuICAgIH07XG5cbiAgICBFbnVtLnBhcnNlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2tleV07XG4gICAgfTtcblxuICAgIEVudW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfTtcblxuICAgIEVudW0uaXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIChvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgJiYgb2JqLmVudW1UeXBlID09PSBuYW1lKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEVudW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVudW07XG4iLCJ2YXIgamVybWFpbmUgPSByZXF1aXJlKCcuLi8uLi9saWIvamVybWFpbmUvc3JjL2plcm1haW5lLmpzJyk7XG5cbnZhciBJbnNldHMgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJJbnNldHNcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGFzQShcInRvcFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5oYXNBKFwibGVmdFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5oYXNBKFwiYm90dG9tXCIpLndoaWNoLmlzQShcIm51bWJlclwiKTtcbiAgICB0aGlzLmhhc0EoXCJyaWdodFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5yZXNwb25kc1RvKFwic2V0XCIsIGZ1bmN0aW9uICh0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQpIHtcbiAgICAgICAgdGhpcy50b3AodG9wKTtcbiAgICAgICAgdGhpcy5sZWZ0KGxlZnQpO1xuICAgICAgICB0aGlzLmJvdHRvbShib3R0b20pO1xuICAgICAgICB0aGlzLnJpZ2h0KHJpZ2h0KTtcbiAgICB9KTtcbiAgICB0aGlzLmlzQnVpbHRXaXRoKFwidG9wXCIsIFwibGVmdFwiLCBcImJvdHRvbVwiLCBcInJpZ2h0XCIpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5zZXRzO1xuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgUG9pbnQgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJQb2ludFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXNBKFwieFwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5oYXNBKFwieVwiKS53aGljaC5pc0EoXCJudW1iZXJcIik7XG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInhcIiwgXCJ5XCIpO1xuICAgIHRoaXMucmVzcG9uZHNUbyhcImVxXCIsIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMueCgpPT09cC54KCkpICYmICh0aGlzLnkoKT09PXAueSgpKSk7XG4gICAgfSk7XG59KTtcblxudmFyIHJlZ0V4cCA9IC9eXFxzKihbMC05XFwtXFwrXFwuZUVdKykoLHxcXHMrfFxccyosXFxzK3xcXHMrLFxccyopKFswLTlcXC1cXCtcXC5lRV0rKVxccyokLztcblxuUG9pbnQucGFyc2UgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgdmFyIGFyID0gcmVnRXhwLmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgcDtcbiAgICAvLyBhclsxXSBpcyB4IHZhbHVlXG4gICAgLy8gYXJbMl0gaXMgc2VwYXJhdG9yIGJldHdlZW4geCBhbmQgeVxuICAgIC8vIGFyWzNdIGlzIHkgdmFsdWVcbiAgICBcbiAgICBpZiAoIWFyIHx8IChhci5sZW5ndGggIT09IDQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBwYXJzZSBzdHJpbmcgJ1wiK3N0cmluZytcIicgYXMgYSBQb2ludFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb2ludChwYXJzZUZsb2F0KGFyWzFdKSwgcGFyc2VGbG9hdChhclszXSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuIiwidmFyIGplcm1haW5lID0gcmVxdWlyZSgnLi4vLi4vbGliL2plcm1haW5lL3NyYy9qZXJtYWluZS5qcycpO1xuXG52YXIgdmFsaWRhdGlvbkZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpO1xuXG52YXIgUkdCQ29sb3IgPSBuZXcgamVybWFpbmUuTW9kZWwoXCJSR0JDb2xvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgXG4gICAgdGhpcy5oYXNBKFwiclwiKS53aGljaC52YWxpZGF0ZXNXaXRoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uRnVuY3Rpb25zLnZhbGlkYXRlTnVtYmVyUmFuZ2UociwgMCwgMS4wKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhc0EoXCJnXCIpLndoaWNoLnZhbGlkYXRlc1dpdGgoZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25GdW5jdGlvbnMudmFsaWRhdGVOdW1iZXJSYW5nZShnLCAwLCAxLjApO1xuICAgIH0pO1xuICAgIHRoaXMuaGFzQShcImJcIikud2hpY2gudmFsaWRhdGVzV2l0aChmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkZ1bmN0aW9ucy52YWxpZGF0ZU51bWJlclJhbmdlKGIsIDAsIDEuMCk7XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIG51bWJlclRvSGV4ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICBudW1iZXIgPSBwYXJzZUludChudW1iZXIgKiAyNTUsIDEwKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChudW1iZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBudW1iZXIgPSBcIjBcIiArIG51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5yZXNwb25kc1RvKFwiZ2V0SGV4U3RyaW5nXCIsIGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgaWYgKCFwcmVmaXgpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IFwiMHhcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlZml4ICsgbnVtYmVyVG9IZXgodGhpcy5yKCkpICsgbnVtYmVyVG9IZXgodGhpcy5nKCkpICsgbnVtYmVyVG9IZXgodGhpcy5iKCkpO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMucmVzcG9uZHNUbyhcInRvUkdCQVwiLCBmdW5jdGlvbiAoYWxwaGEpIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YoYWxwaGEpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSR0JDb2xvci50b1JHQkE6IFRoZSBhcmd1bWVudCwgaWYgcHJlc2VudCwgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgKDI1NSp0aGlzLnIoKSkgKyBcIiwgXCIgKyAoMjU1KnRoaXMuZygpKSArIFwiLCBcIiArICgyNTUqdGhpcy5iKCkpICsgXCIsIFwiICsgYWxwaGEgKyBcIilcIjtcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLnJlc3BvbmRzVG8oXCJlcVwiLCBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5yKCk9PT1jb2xvci5yKCkpICYmICh0aGlzLmcoKT09PWNvbG9yLmcoKSkgJiYgKHRoaXMuYigpPT09Y29sb3IuYigpKSk7XG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5pc0J1aWx0V2l0aChcInJcIiwgXCJnXCIsIFwiYlwiKTtcbiAgICBcbn0pO1xuXG5cbi8qXG4gKiBUbyByZW1vdmUgc3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBjb2xvciBuYW1lcywgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24sXG4gKiBhbmQgZmluZCBhbGwgcmVmZXJlbmNlcyB0byBpdCBlbHNld2hlcmUgaW4gdGhlIHNvdXJjZSBjb2RlLCBhbmQgcmVtb3ZlIHRoZW0sXG4gKiBhbG9uZyB3aXRoIGFjY29tcGFueWluZyBjb2RlIHRoYXQgZ2VuZXJhdGVzIHdhcm5pbmcgbWVzc2FnZS4gIEFsc28gcmVtb3ZlXG4gKiBzdXBwb3J0IGZvciB0aGVzZSA5IGNvbG9yIG5hbWVzIGZyb20gUkdCQ29sb3IucGFyc2UgYmVsb3cuXG4gKi9cblJHQkNvbG9yLmNvbG9yTmFtZUlzRGVwcmVjYXRlZCA9IGZ1bmN0aW9uIChjb2xvck5hbWUpIHtcbiAgICBzd2l0Y2ggKGNvbG9yTmFtZSkge1xuICAgIGNhc2UgXCJncmV5XCI6IHJldHVybiBcIjB4ZWVlZWVlXCI7XG4gICAgY2FzZSBcInNreWJsdWVcIjogcmV0dXJuIFwiMHg4N2NlZWJcIjtcbiAgICBjYXNlIFwia2hha2lcIjogcmV0dXJuIFwiMHhmMGU2OGNcIjtcbiAgICBjYXNlIFwib3JhbmdlXCI6IHJldHVybiBcIjB4ZmZhNTAwXCI7XG4gICAgY2FzZSBcInNhbG1vblwiOiByZXR1cm4gXCIweGZhODA3MlwiO1xuICAgIGNhc2UgXCJvbGl2ZVwiOiByZXR1cm4gXCIweDlhY2QzMlwiO1xuICAgIGNhc2UgXCJzaWVubmFcIjogcmV0dXJuIFwiMHhhMDUyMmRcIjtcbiAgICBjYXNlIFwicGlua1wiOiByZXR1cm4gXCIweGZmYjVjNVwiO1xuICAgIGNhc2UgXCJ2aW9sZXRcIjogcmV0dXJuIFwiMHhlZTgyZWVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUkdCQ29sb3IucGFyc2UgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgcmVkLFxuICAgICAgICBncmVlbixcbiAgICAgICAgYmx1ZSxcbiAgICAgICAgZ3JleSxcbiAgICAgICAgcGFyc2VkSW5wdXQsXG4gICAgICAgIGNvbG9yT2JqO1xuICAgIFxuICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBhcnNlZElucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgY2FzZSBcImJsYWNrXCI6XG4gICAgICAgICAgICByZWQgPSAwO1xuICAgICAgICAgICAgZ3JlZW4gPSAwO1xuICAgICAgICAgICAgYmx1ZSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlZFwiOlxuICAgICAgICAgICAgcmVkID0gMTtcbiAgICAgICAgICAgIGdyZWVuID0gMDtcbiAgICAgICAgICAgIGJsdWUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJncmVlblwiOlxuICAgICAgICAgICAgcmVkID0gMDtcbiAgICAgICAgICAgIGdyZWVuID0gMTtcbiAgICAgICAgICAgIGJsdWUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJibHVlXCI6XG4gICAgICAgICAgICByZWQgPSAwO1xuICAgICAgICAgICAgZ3JlZW4gPSAwO1xuICAgICAgICAgICAgYmx1ZSA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInllbGxvd1wiOlxuICAgICAgICAgICAgcmVkID0gMTtcbiAgICAgICAgICAgIGdyZWVuID0gMTtcbiAgICAgICAgICAgIGJsdWUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYWdlbnRhXCI6XG4gICAgICAgICAgICByZWQgPSAxO1xuICAgICAgICAgICAgZ3JlZW4gPSAwO1xuICAgICAgICAgICAgYmx1ZSA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImN5YW5cIjpcbiAgICAgICAgICAgIHJlZCA9IDA7XG4gICAgICAgICAgICBncmVlbiA9IDE7XG4gICAgICAgICAgICBibHVlID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwid2hpdGVcIjpcbiAgICAgICAgICAgIHJlZCA9IDE7XG4gICAgICAgICAgICBncmVlbiA9IDE7XG4gICAgICAgICAgICBibHVlID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ3JleVwiOlxuICAgICAgICAgICAgZ3JleSA9IHBhcnNlSW50KFwiZWVcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgcmVkID0gZ3JleTtcbiAgICAgICAgICAgIGdyZWVuID0gZ3JleTtcbiAgICAgICAgICAgIGJsdWUgPSBncmV5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJza3libHVlXCI6XG4gICAgICAgICAgICByZWQgPSBwYXJzZUludChcIjg3XCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQoXCJjZVwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBibHVlID0gcGFyc2VJbnQoXCJlYlwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImtoYWtpXCI6XG4gICAgICAgICAgICByZWQgPSBwYXJzZUludChcImYwXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQoXCJlNlwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBibHVlID0gcGFyc2VJbnQoXCI4Y1wiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9yYW5nZVwiOlxuICAgICAgICAgICAgcmVkID0gcGFyc2VJbnQoXCJmZlwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBncmVlbiA9IHBhcnNlSW50KFwiYTVcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgYmx1ZSA9IHBhcnNlSW50KFwiMDBcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzYWxtb25cIjpcbiAgICAgICAgICAgIHJlZCA9IHBhcnNlSW50KFwiZmFcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgZ3JlZW4gPSBwYXJzZUludChcIjgwXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGJsdWUgPSBwYXJzZUludChcIjcyXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2xpdmVcIjpcbiAgICAgICAgICAgIHJlZCA9IHBhcnNlSW50KFwiOWFcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgZ3JlZW4gPSBwYXJzZUludChcImNkXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGJsdWUgPSBwYXJzZUludChcIjMyXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2llbm5hXCI6XG4gICAgICAgICAgICByZWQgPSBwYXJzZUludChcImEwXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQoXCI1MlwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBibHVlID0gcGFyc2VJbnQoXCIyZFwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBpbmtcIjpcbiAgICAgICAgICAgIHJlZCA9IHBhcnNlSW50KFwiZmZcIiwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgZ3JlZW4gPSBwYXJzZUludChcImI1XCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGJsdWUgPSBwYXJzZUludChcImM1XCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidmlvbGV0XCI6XG4gICAgICAgICAgICByZWQgPSBwYXJzZUludChcImVlXCIsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQoXCI4MlwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBibHVlID0gcGFyc2VJbnQoXCJlZVwiLCAxNikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gcGFyc2VkSW5wdXQucmVwbGFjZSgvKDAoeHxYKXwjKS8sIFwiXCIpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0LnNlYXJjaChuZXcgUmVnRXhwKC8oW14wLTlhLWZdKS8pKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInXCIgKyBpbnB1dCArIFwiJyBpcyBub3QgYSB2YWxpZCBjb2xvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0Lmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgICAgICAgIHJlZCA9IHBhcnNlSW50KHBhcnNlZElucHV0LnN1YnN0cmluZygwLDIpLCAxNikgLyAyNTU7XG4gICAgICAgICAgICAgICAgZ3JlZW4gPSBwYXJzZUludChwYXJzZWRJbnB1dC5zdWJzdHJpbmcoMiw0KSwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgICAgIGJsdWUgPSBwYXJzZUludChwYXJzZWRJbnB1dC5zdWJzdHJpbmcoNCw2KSwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZWRJbnB1dC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZWQgPSBwYXJzZUludChwYXJzZWRJbnB1dC5jaGFyQXQoMCksIDE2KSAvIDE1O1xuICAgICAgICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQocGFyc2VkSW5wdXQuY2hhckF0KDEpLCAxNikgLyAxNTtcbiAgICAgICAgICAgICAgICBibHVlID0gcGFyc2VJbnQocGFyc2VkSW5wdXQuY2hhckF0KDIpLCAxNikgLyAxNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ1wiICsgaW5wdXQgKyBcIicgaXMgbm90IGEgdmFsaWQgY29sb3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb2xvck9iaiA9IG5ldyBSR0JDb2xvcihyZWQsIGdyZWVuLCBibHVlKTtcbiAgICAgICAgcmV0dXJuIGNvbG9yT2JqO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCInXCIgKyBpbnB1dCArIFwiJyBpcyBub3QgYSB2YWxpZCBjb2xvclwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUkdCQ29sb3I7XG4iLCJVdGlsID0ge307XG5cblV0aWwuaW50ZXJwID0gZnVuY3Rpb24gKHgsIHgwLCB4MSwgeTAsIHkxKSB7XG4gICAgLy8gcmV0dXJuIHRoZSAneScgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgb24gdGhlIGxpbmUgc2VnbWVudFxuICAgIC8vIGNvbm5lY3RpbmcgdGhlIHR3byBwb2ludHMgKHgwLHkwKSBhbmQgKHgxLHkxKSB3aG9zZSAneCdcbiAgICAvLyBjb29yZGluYXRlIGlzIHhcbiAgICByZXR1cm4geTAgKyAoKHkxIC0geTApICogKHggLSB4MCkpIC8gKHgxIC0geDApO1xufTtcblxuVXRpbC5zYWZlX2ludGVycCA9IGZ1bmN0aW9uICh4LCB4MCwgeDEsIHkwLCB5MSkge1xuICAgIC8vIHNhbWUgYXMgXCJpbnRlcnBcIiwgYnV0IGlmIHRoZSBsaW5lIGlzIHZlcnRpY2FsICh4MCA9PT0geDEpLCByZXR1cm5cbiAgICAvLyB0aGUgYXZlcmFnZSBvZiB0aGUgdHdvIHkgdmFsdWVzLCByYXRoZXIgdGhhbiBOYU5cbiAgICBpZiAoeDAgPT09IHgxKSB7IHJldHVybiAoeTAgKyB5MSkgLyAyOyB9XG4gICAgcmV0dXJuIFV0aWwuaW50ZXJwKHgsIHgwLCB4MSwgeTAsIHkxKTtcbn07XG5cblV0aWwubDJkaXN0ID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIGR4ID0geDEgLSB4MjtcbiAgICB2YXIgZHkgPSB5MSAtIHkyO1xuICAgIHJldHVybiBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWw7XG4iLCJcbi8vICBcImhvcml6b250YWxheGlzXCIgOiB7XG4vLyAgICBcImlkXCIgOiBTVFJJTkcsIFwidHlwZVwiIDogREFUQVRZUEUobnVtYmVyKSwgXCJsZW5ndGhcIiA6IFJFTExFTigxLjApLCBcImJhc2VcIiA6IFBPSU5UKC0xLDEpLCBcImFuY2hvclwiIDogRE9VQkxFKC0xKSwgXCJwb3NpdGlvblwiIDogUE9JTlQoMCwwKSxcbi8vICAgIFwibWluXCIgOiBEQVRBVkFMVUVPUkFVVE8oYXV0byksIFwibWF4XCIgOiBEQVRBVkFMVUVPUkFVVE8oYXV0byksIFwibWlucG9zaXRpb25cIiA6IFJFTFBPUygtMS4wKSwgXCJtYXhwb3NpdGlvblwiIDogUkVMUE9TKDEuMCksIFwiY29sb3JcIiA6IENPTE9SKGJsYWNrKSwgXCJsaW5ld2lkdGhcIiA6IElOVEVHRVIoMSksXG4vLyAgICBcInRpY2ttaW5cIiA6IElOVEVHRVIoLTMpLCBcInRpY2ttYXhcIiA6IElOVEVHRVIoMyksIFwidGlja2NvbG9yXCIgOiBDT0xPUihibGFjayksXG4vLyAgICBcImxhYmVsc1wiIDoge1xuLy8gICAgICAgXCJmb3JtYXRcIiA6IFNUUklORywgXCJzdGFydFwiIDogREFUQVZBTFVFKDApLCBcImFuZ2xlXCIgOiBET1VCTEUoMCksIFwicG9zaXRpb25cIiA6IFBPSU5ULFxuLy8gICAgICAgXCJhbmNob3JcIiA6IFBPSU5ULCBcImNvbG9yXCIgOiBDT0xPUihibGFjayksIFwic3BhY2luZ1wiIDogU1RSSU5HLCBcImRlbnNpdHlmYWN0b3JcIiA6IERPVUJMRSgxLjApLFxuLy8gICAgICAgXCJsYWJlbFwiIDogW1xuLy8gICAgICAgICAgIHsgXCJmb3JtYXRcIiA6IFNUUklORywgXCJzdGFydFwiIDogU1RSSU5HLCBcImFuZ2xlXCIgOiBET1VCTEUsIFwicG9zaXRpb25cIiA6IFBPSU5ULCBcImFuY2hvclwiIDogUE9JTlQsIFwic3BhY2luZ1wiIDogU1RSSU5HLCBcImRlbnNpdHlmYWN0b3JcIiA6IERPVUJMRSB9LFxuLy8gICAgICAgICAgIHsgXCJmb3JtYXRcIiA6IFNUUklORywgXCJzdGFydFwiIDogU1RSSU5HLCBcImFuZ2xlXCIgOiBET1VCTEUsIFwicG9zaXRpb25cIiA6IFBPSU5ULCBcImFuY2hvclwiIDogUE9JTlQsIFwic3BhY2luZ1wiIDogU1RSSU5HLCBcImRlbnNpdHlmYWN0b3JcIiA6IERPVUJMRSB9LFxuLy8gICAgICAgICAgIC4uLlxuLy8gICAgICAgIF1cbi8vICAgIH1cbi8vICAgIFwidGl0bGVcIiA6IHsgXCJiYXNlXCIgOiBET1VCTEUoMCksIFwiYW5jaG9yXCIgOiBQT0lOVCwgXCJwb3NpdGlvblwiIDogUE9JTlQsIFwiYW5nbGVcIiA6IERPVUJMRSgwKSwgXCJ0ZXh0XCIgOiBcIlRJVExFVEVYVFwiLCBcImZvbnRcIjogU1RSSU5HIH0sXG4vLyAgICBcImdyaWRcIiA6IHsgXCJjb2xvclwiIDogQ09MT1IoMHhlZWVlZWUpLCBcInZpc2libGVcIiA6IEJPT0xFQU4oZmFsc2UpIH0sXG4vLyAgICBcInBhblwiIDogeyBcImFsbG93ZWRcIiA6IEJPT0xFQU4oeWVzKSwgXCJtaW5cIiA6IERBVEFWQUxVRSwgXCJtYXhcIiA6IERBVEFWQUxVRSB9LFxuLy8gICAgXCJ6b29tXCIgOiB7IFwiYWxsb3dlZFwiIDogQk9PTEVBTih5ZXMpLCBcIm1pblwiIDogREFUQU1FQVNVUkUsIFwibWF4XCIgOiBEQVRBTUVBU1VSRSwgXCJhbmNob3JcIiA6IERBVEFWQUxVRSB9LFxuLy8gICAgXCJiaW5kaW5nXCIgOiB7IFwiaWRcIiA6IFNUUklORyEsIFwibWluXCIgOiBEQVRBVkFMVUUhLCBcIm1heFwiIDogREFUQVZBTFVFISB9XG4vLyAgICBcInZpc2libGVcIiA6IEJPT0xFQU4odHJ1ZSlcbi8vICB9XG5cblxuLy8gdGhlc2UgYXJlIG5lZWRlZCBzbyB0aGF0IHRoZWlyIC5wYXJzZUpTT04gbWV0aG9kcyB3aWxsIGJlIGRlZmluZWQgd2hlbiBjYWxsZWQgYmVsb3c6XG5yZXF1aXJlKCcuL2xhYmVsZXIuanMnKTtcbnJlcXVpcmUoJy4vYXhpc190aXRsZS5qcycpO1xucmVxdWlyZSgnLi9ncmlkLmpzJyk7XG5yZXF1aXJlKCcuL3Bhbi5qcycpO1xucmVxdWlyZSgnLi96b29tLmpzJyk7XG5cbnZhciBBeGlzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzLmpzJyksXG4gICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICB2RiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpLFxuICAgIHVGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyk7XG5cbnZhciBwYXJzZUxhYmVscyA9IGZ1bmN0aW9uIChqc29uLCBheGlzKSB7XG4gICAgdmFyIHNwYWNpbmdzLFxuICAgICAgICBsYWJlbGVycyAgPSBheGlzLmxhYmVsZXJzKCksXG4gICAgICAgIExhYmVsZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2xhYmVsZXIuanMnKSxcbiAgICAgICAgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIGk7XG5cbiAgICBzcGFjaW5ncyA9IFtdO1xuICAgIGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGpzb24uc3BhY2luZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFjaW5ncyA9IHZGLnR5cGVPZihqc29uLnNwYWNpbmcpID09PSAnYXJyYXknID8ganNvbi5zcGFjaW5nIDogWyBqc29uLnNwYWNpbmcgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3BhY2luZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBzcGFjaW5nIGF0dHIgb24gdGhlIDxsYWJlbHM+IHRhZywgY3JlYXRlIGEgbmV3IGxhYmVsZXIgZm9yXG4gICAgICAgIC8vIGVhY2ggc3BhY2luZyBwcmVzZW50IGluIGl0LCB1c2luZyB0aGUgb3RoZXIgdmFsdWVzIGZyb20gdGhlIDxsYWJlbHM+IHRhZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2luZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxhYmVsZXJzLmFkZChMYWJlbGVyLnBhcnNlSlNPTihqc29uLCBheGlzLCB1bmRlZmluZWQsIHNwYWNpbmdzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxhYmVsICE9PSB1bmRlZmluZWQgJiYganNvbi5sYWJlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSA8bGFiZWw+IHRhZ3MsIHBhcnNlIHRoZSA8bGFiZWxzPiB0YWcgdG8gZ2V0IGRlZmF1bHQgdmFsdWVzXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IExhYmVsZXIucGFyc2VKU09OKGpzb24sIGF4aXMsIHVuZGVmaW5lZCwgbnVsbCk7XG4gICAgICAgIC8vIEFuZCBsb29wIG92ZXIgZWFjaCA8bGFiZWw+IHRhZywgY3JlYXRpbmcgbGFiZWxlcnMgZm9yIGVhY2gsIHNwbGl0dGluZyBtdWx0aXBsZVxuICAgICAgICAvLyBzcGFjaW5ncyBvbiB0aGUgc2FtZSA8bGFiZWw+IHRhZyBpbnRvIG11bHRpcGxlIGxhYmVsZXJzOlxuICAgICAgICBqc29uLmxhYmVsLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIHNwYWNpbmcgPSBbXTtcbiAgICAgICAgICAgIGlmIChlLnNwYWNpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNwYWNpbmcgPSB2Ri50eXBlT2YoZS5zcGFjaW5nKSA9PT0gJ2FycmF5JyA/IGUuc3BhY2luZyA6IFsgZS5zcGFjaW5nIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGFjaW5nLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIGxhYmVsZXJzLmFkZCggTGFiZWxlci5wYXJzZUpTT04oZSwgYXhpcywgZGVmYXVsdHMsIHMpICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNyZWF0ZSBsYWJlbGVycyB1c2luZyB0aGUgZGVmYXVsdCBzcGFjaW5nLCB3aXRoIHRoZSBvdGhlciB2YWx1ZXNcbiAgICAgICAgLy8gZnJvbSB0aGUgPGxhYmVscz4gdGFnXG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWVzID0gKHVGLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEKCkpLmhvcml6b250YWxheGlzLmxhYmVscztcbiAgICAgICAgdmFyIGRlZmF1bHRTcGFjaW5ncyA9IGF4aXMudHlwZSgpID09PSBEYXRhVmFsdWUuTlVNQkVSID9cbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzLmRlZmF1bHROdW1iZXJTcGFjaW5nIDpcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzLmRlZmF1bHREYXRldGltZVNwYWNpbmc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZWZhdWx0U3BhY2luZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxhYmVsZXJzLmFkZChMYWJlbGVyLnBhcnNlSlNPTihqc29uLCBheGlzLCB1bmRlZmluZWQsIGRlZmF1bHRTcGFjaW5nc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5BeGlzLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBvcmllbnRhdGlvbiwgbWVzc2FnZUhhbmRsZXIsIG11bHRpZ3JhcGgpIHtcblxuICAgIHZhciBEYXRhVmFsdWUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgRGlzcGxhY2VtZW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9kaXNwbGFjZW1lbnQuanMnKSxcbiAgICAgICAgQXhpc1RpdGxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzX3RpdGxlLmpzJyksXG4gICAgICAgIEdyaWQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2dyaWQuanMnKSxcbiAgICAgICAgUGFuID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wYW4uanMnKSxcbiAgICAgICAgWm9vbSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvem9vbS5qcycpLFxuICAgICAgICBBeGlzQmluZGluZyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpc19iaW5kaW5nLmpzJyksXG5cbiAgICAgICAgYXhpcyAgICAgICAgICAgICAgPSBuZXcgQXhpcyhvcmllbnRhdGlvbiksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlRGlzcGxhY2VtZW50ID0gRGlzcGxhY2VtZW50LnBhcnNlLFxuICAgICAgICBwYXJzZUpTT05Qb2ludCAgICA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIG5ldyBQb2ludChwWzBdLCBwWzFdKTsgfSxcbiAgICAgICAgcGFyc2VSR0JDb2xvciAgICAgPSBSR0JDb2xvci5wYXJzZSxcbiAgICAgICAgYXR0ciwgY2hpbGQsXG4gICAgICAgIHZhbHVlO1xuXG4gICAgaWYgKGpzb24pIHtcblxuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmlkLCAgICAgYXhpcy5pZCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24udHlwZSwgICBheGlzLnR5cGUsICAgRGF0YVZhbHVlLnBhcnNlVHlwZSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubGVuZ3RoLCBheGlzLmxlbmd0aCwgcGFyc2VEaXNwbGFjZW1lbnQpO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgc3VwcG9ydCBmb3IgdGhlIGRlcHJlY2F0ZWQgXCJwb3NpdGlvbmJhc2VcIiBheGlzIGF0dHJpYnV0ZTtcbiAgICAgICAgLy8gTVVHTCBmaWxlcyBzaG91bGQgdXNlIHRoZSBcImJhc2VcIiBhdHRyaWJ1dGUgaW5zdGVhZC4gIFdoZW4gd2UncmUgcmVhZHkgdG8gcmVtb3ZlXG4gICAgICAgIC8vIHN1cHBvcnQgZm9yIHRoZSBkZXByZWNhdGVkIGF0dHJpYnV0ZSwgZGVsZXRlIHRoaXMgYmxvY2sgb2YgY29kZTpcbiAgICAgICAgLy9cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbmJhc2UgPSBqc29uLnBvc2l0aW9uYmFzZTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbmJhc2UpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci53YXJuaW5nKCdVc2Ugb2YgZGVwcmVjYXRlZCBheGlzIGF0dHJpYnV0ZSBcInBvc2l0aW9uYmFzZVwiOyB1c2UgXCJiYXNlXCIgYXR0cmlidXRlIGluc3RlYWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoKHBvc2l0aW9uYmFzZSA9PT0gXCJsZWZ0XCIpIHx8IChwb3NpdGlvbmJhc2UgPT09IFwiYm90dG9tXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMuYmFzZShuZXcgUG9pbnQoLTEsIC0xKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbmJhc2UgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgICAgICBheGlzLmJhc2UobmV3IFBvaW50KDEsIC0xKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbmJhc2UgPT09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5iYXNlKG5ldyBQb2ludCgtMSwgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSgpKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gRW5kIG9mIGNvZGUgdG8gZGVsZXRlIHdoZW4gcmVtb3Zpbmcgc3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBcInBvc2l0aW9uYmFzZVwiXG4gICAgICAgIC8vIGF0dHJpYnV0ZS5cbiAgICAgICAgLy9cblxuICAgICAgICBhdHRyID0ganNvbi5wb3NpdGlvbjtcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihhdHRyKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGF4aXMucG9zaXRpb24ocGFyc2VKU09OUG9pbnQoYXR0cikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwb3NpdGlvbiBpcyBub3QgYW4gYXJyYXksIGFuZCBpZiBpdCBjYW4gYmUgaW50ZXJwcmV0ZWRcbiAgICAgICAgICAgICAgICAvLyBhcyBhIG51bWJlciwgY29uc3RydWN0IHRoZSBwb3NpdGlvbiBwb2ludCBieSBpbnRlcnByZXRpbmcgdGhhdFxuICAgICAgICAgICAgICAgIC8vIG51bWJlciBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgMCBsb2NhdGlvbiBhbG9uZyB0aGUgcGVycGVuZGljdWxhclxuICAgICAgICAgICAgICAgIC8vIGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAodkYuaXNOdW1iZXJOb3ROYU4oYXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBBeGlzLkhPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMucG9zaXRpb24obmV3IFBvaW50KDAsIGF0dHIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMucG9zaXRpb24obmV3IFBvaW50KGF0dHIsIDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF4aXMgcG9zaXRpb24gJ1wiK2F0dHIrXCInIGlzIG9mIHRoZSB3cm9uZyB0eXBlOyBpdCBzaG91bGQgYmUgYSBudW1iZXIgb3IgYSBwb2ludFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlOiB3ZSBjb2VyY2UgdGhlIG1pbiBhbmQgbWF4IHZhbHVlcyB0byBzdHJpbmdzIGhlcmUsIGJlY2F1c2UgdGhlIFwibWluXCIgYW5kIFwibWF4XCIgYXR0cnNcbiAgICAgICAgLy8gb2YgdGhlIEF4aXMgb2JqZWN0IHJlcXVpcmUgc3RyaW5ncy4gIFNlZSB0aGUgY29tbWVudHMgYWJvdXQgdGhlc2UgcHJvcGVydGllcyBpbiBzcmMvY29yZS9heGlzLmpzXG4gICAgICAgIC8vIGZvciBhIGRpc2N1c3Npb24gb2Ygd2h5IHRoaXMgaXMgdGhlIGNhc2UuXG4gICAgICAgIGlmIChcIm1pblwiIGluIGpzb24pIHtcbiAgICAgICAgICAgIGF4aXMubWluKHVGLmNvZXJjZVRvU3RyaW5nKGpzb24ubWluKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXMubWluKCkgIT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICBheGlzLmRhdGFNaW4oRGF0YVZhbHVlLnBhcnNlKGF4aXMudHlwZSgpLCBheGlzLm1pbigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwibWF4XCIgaW4ganNvbikge1xuICAgICAgICAgICAgYXhpcy5tYXgodUYuY29lcmNlVG9TdHJpbmcoanNvbi5tYXgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpcy5tYXgoKSAhPT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgIGF4aXMuZGF0YU1heChEYXRhVmFsdWUucGFyc2UoYXhpcy50eXBlKCksIGF4aXMubWF4KCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ucHJlZ2FwLCAgICAgICAgIGF4aXMucHJlZ2FwKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5wb3N0Z2FwLCAgICAgICAgYXhpcy5wb3N0Z2FwKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5hbmNob3IsICAgICAgICAgYXhpcy5hbmNob3IpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJhc2UsICAgICAgICAgICBheGlzLmJhc2UsICAgICAgICAgICBwYXJzZUpTT05Qb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubWlucG9zaXRpb24sICAgIGF4aXMubWlucG9zaXRpb24sICAgIHBhcnNlRGlzcGxhY2VtZW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5tYXhwb3NpdGlvbiwgICAgYXhpcy5tYXhwb3NpdGlvbiwgICAgcGFyc2VEaXNwbGFjZW1lbnQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm1pbm9mZnNldCwgICAgICBheGlzLm1pbm9mZnNldCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubWF4b2Zmc2V0LCAgICAgIGF4aXMubWF4b2Zmc2V0KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5jb2xvciwgICAgICAgICAgYXhpcy5jb2xvciwgICAgICAgICAgcGFyc2VSR0JDb2xvcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24udGlja2NvbG9yLCAgICAgIGF4aXMudGlja2NvbG9yLCAgICAgIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnRpY2t3aWR0aCwgICAgICBheGlzLnRpY2t3aWR0aCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24udGlja21pbiwgICAgICAgIGF4aXMudGlja21pbik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24udGlja21heCwgICAgICAgIGF4aXMudGlja21heCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uaGlnaGxpZ2h0c3R5bGUsIGF4aXMuaGlnaGxpZ2h0c3R5bGUpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmxpbmV3aWR0aCwgICAgICBheGlzLmxpbmV3aWR0aCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoXCJ0aXRsZVwiIGluIGpzb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoanNvbi50aXRsZSkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMudGl0bGUobmV3IEF4aXNUaXRsZShheGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLnRpdGxlKEF4aXNUaXRsZS5wYXJzZUpTT04oe30sIGF4aXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBheGlzLnRpdGxlKEF4aXNUaXRsZS5wYXJzZUpTT04oanNvbi50aXRsZSwgYXhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXhpcy50aXRsZShuZXcgQXhpc1RpdGxlKGF4aXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqc29uLmdyaWQpIHtcbiAgICAgICAgICAgIGF4aXMuZ3JpZChHcmlkLnBhcnNlSlNPTihqc29uLmdyaWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqc29uLnZpc2libGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXhpcy52aXNpYmxlKGpzb24udmlzaWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJwYW5cIiBpbiBqc29uKSB7XG4gICAgICAgICAgICBheGlzLnBhbihQYW4ucGFyc2VKU09OKGpzb24ucGFuLCBheGlzLnR5cGUoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwiem9vbVwiIGluIGpzb24pIHtcbiAgICAgICAgICAgIGF4aXMuem9vbShab29tLnBhcnNlSlNPTihqc29uLnpvb20sIGF4aXMudHlwZSgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoanNvbi5sYWJlbHMpIHtcbiAgICAgICAgICAgIHBhcnNlTGFiZWxzKGpzb24ubGFiZWxzLCBheGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqc29uLmJpbmRpbmcpIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nTWluRGF0YVZhbHVlID0gRGF0YVZhbHVlLnBhcnNlKGF4aXMudHlwZSgpLCBqc29uLmJpbmRpbmcubWluKSxcbiAgICAgICAgICAgICAgICBiaW5kaW5nTWF4RGF0YVZhbHVlID0gRGF0YVZhbHVlLnBhcnNlKGF4aXMudHlwZSgpLCBqc29uLmJpbmRpbmcubWF4KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoanNvbi5iaW5kaW5nLmlkKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXhpcyBiaW5kaW5nIGlkOiAnXCIgKyBqc29uLmJpbmRpbmcuaWQgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISBEYXRhVmFsdWUuaXNJbnN0YW5jZShiaW5kaW5nTWluRGF0YVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXhpcyBiaW5kaW5nIG1pbjogJ1wiICsganNvbi5iaW5kaW5nLm1pbiArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghIERhdGFWYWx1ZS5pc0luc3RhbmNlKGJpbmRpbmdNYXhEYXRhVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBheGlzIGJpbmRpbmcgbWF4OiAnXCIgKyBqc29uLmJpbmRpbmcubWF4ICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQXhpc0JpbmRpbmcuZmluZEJ5SWRPckNyZWF0ZU5ldyhqc29uLmJpbmRpbmcuaWQpLmFkZEF4aXMoYXhpcywgYmluZGluZ01pbkRhdGFWYWx1ZSwgYmluZGluZ01heERhdGFWYWx1ZSwgbXVsdGlncmFwaCk7XG4gICAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gYXhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpcztcbiIsInZhciBBeGlzVGl0bGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2F4aXNfdGl0bGUuanMnKTtcblxuLy8gXCJ0aXRsZVwiIHsgXCJiYXNlXCI6IDIzLjIsIFwiYW5jaG9yXCI6IFsxMiwgNF0sIFwicG9zaXRpb25cIjogWzMsIDddLCBcImFuZ2xlXCI6IDQ1LCBcInRleHRcIiA6IFwidGVtcGVyYXR1cmVcIiwgXCJmb250XCIgOiBcIlJvYm90b1wiIH1cbi8vIGVtcHR5IHRpdGxlOlxuLy8gICBcInRpdGxlXCIge31cbi8vICAgXCJ0aXRsZVwiIHtcInRleHRcIiA6IFwiXCIgfVxuQXhpc1RpdGxlLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBheGlzKSB7XG4gICAgdmFyIHRpdGxlID0gbmV3IEF4aXNUaXRsZShheGlzKSxcbiAgICAgICAgVGV4dCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdGV4dC5qcycpLFxuICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKS5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgbm9uRW1wdHlUaXRsZSA9IGZhbHNlLFxuICAgICAgICBwYXJzZUpTT05Qb2ludCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIG5ldyBQb2ludChwWzBdLCBwWzFdKTsgfSxcbiAgICAgICAgdGV4dDtcblxuICAgIGlmIChqc29uKSB7XG4gICAgICAgIHRleHQgPSBqc29uLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0ICE9PSBcIlwiICYmIHRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGl0bGUuY29udGVudChuZXcgVGV4dCh0ZXh0KSk7XG4gICAgICAgICAgICBub25FbXB0eVRpdGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmFuY2hvciwgICB0aXRsZS5hbmNob3IsICAgcGFyc2VKU09OUG9pbnQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJhc2UsICAgICB0aXRsZS5iYXNlKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5wb3NpdGlvbiwgdGl0bGUucG9zaXRpb24sIHBhcnNlSlNPTlBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5hbmdsZSwgICAgdGl0bGUuYW5nbGUpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmZvbnQsICAgIHRpdGxlLmZvbnQpO1xuICAgIH1cblxuICAgIGlmIChub25FbXB0eVRpdGxlID09PSB0cnVlKSB7IFxuICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aXNUaXRsZTtcbiIsInZhciBCYWNrZ3JvdW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9iYWNrZ3JvdW5kLmpzJyk7XG5cbi8vIFwiYmFja2dyb3VuZFwiIDoge1xuLy8gICBcImNvbG9yXCI6IFwiI2ZmZmYwMFwiLFxuLy8gICBcImltZ1wiIDogeyBcInNyY1wiOiBcImZvby5wbmdcIiwgXCJhbmNob3JcIjogWy0xLCA1XSwgXCJiYXNlXCI6IFszLCAxMl0sIFwicG9zaXRpb25cIjogWy0yLCAzXSwgXCJmcmFtZVwiOiBcInBhZGRpbmdcIiB9XG4vLyB9XG5CYWNrZ3JvdW5kLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBtdWx0aWdyYXBoKSB7XG4gICAgdmFyIGJhY2tncm91bmQgICAgICAgPSBuZXcgQmFja2dyb3VuZCgpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJykucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIFJHQkNvbG9yICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICBJbWcgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9pbWcuanMnKSxcbiAgICAgICAgY2hpbGQ7XG5cbiAgICBpZiAoanNvbikge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmNvbG9yLCBiYWNrZ3JvdW5kLmNvbG9yLCBSR0JDb2xvci5wYXJzZSk7XG4gICAgICAgIGlmIChqc29uLmltZykge1xuICAgICAgICAgICAgYmFja2dyb3VuZC5pbWcoSW1nLnBhcnNlSlNPTihqc29uLmltZywgbXVsdGlncmFwaCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYWNrZ3JvdW5kO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrZ3JvdW5kO1xuIiwiLy8gVGhpcyBmaWxlIHVzZXMgalF1ZXJ5LiAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZVxuLy8gZnVuY3Rpb24gcmV0dXJuZWQgYnkgcmVxdWlyaW5nIHRoaXMgZmlsZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIHZhciBEYXRhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhLmpzJyk7XG5cbiAgICAvLyBpZiBwYXJzZVhNTCBtZXRob2QgYWxyZWFkeSBoYXMgYmVlbiBkZWZpbmVkLCB3aGljaCB3b3VsZCBiZSB0aGUgY2FzZSBpZiB0aGlzXG4gICAgLy8gZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkLCBqdXN0IHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0eXBlb2YoRGF0YS5wYXJzZUpTT04pPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBEYXRhOyB9O1xuXG4gICAgLy8gXCJkYXRhXCIgOiB7XG4gICAgLy8gICBcImFkYXB0ZXJcIiAgICAgIDogU1RSSU5HLFxuICAgIC8vICAgXCJtaXNzaW5ndmFsdWVcIiA6IFwiREFUQVZBTFVFXCIsXG4gICAgLy8gICBcIm1pc3NpbmdvcFwiICAgIDogXCJDT01QQVJBVE9SXCI+LFxuICAgIC8vICAgXCJ2YXJpYWJsZXNcIiA6IFtcbiAgICAvLyAgICAgICAgIHsgXCJpZFwiIDogU1RSSU5HISwgXCJjb2x1bW5cIiA6IElOVEVHRVIsIFwidHlwZVwiIDogREFUQVRZUEUobnVtYmVyKSwgXCJtaXNzaW5ndmFsdWVcIiA6IFNUUklORywgXCJtaXNzaW5nb3BcIiA6IENPTVBBUkFUT1IgfVxuICAgIC8vICAgICAgICAgeyBcImlkXCIgOiBTVFJJTkchLCBcImNvbHVtblwiIDogSU5URUdFUiwgXCJ0eXBlXCIgOiBEQVRBVFlQRShudW1iZXIpLCBcIm1pc3Npbmd2YWx1ZVwiIDogU1RSSU5HLCBcIm1pc3NpbmdvcFwiIDogQ09NUEFSQVRPUiB9XG4gICAgLy8gICAgICAgICAuLi5cbiAgICAvLyAgIF0sXG4gICAgLy8gICBcInJlcGVhdFwiIDogeyBcInBlcmlvZFwiIDogU1RSSU5HIH0sXG4gICAgLy8gICBcInJlcGVhdFwiIDogU1RSSU5HLFxuICAgIC8vICAgXCJ2YWx1ZXNcIiA6IFtcbiAgICAvLyAgICAgIFsgMy4yLCAxLjQsIC4uLl0sXG4gICAgLy8gICAgICBbIDUuMSwgNy44LCAuLi5dLFxuICAgIC8vICAgICAgLi4uXG4gICAgLy8gICBdLFxuICAgIC8vICAgXCJjc3ZcIiA6IFNUUklORyxcbiAgICAvLyAgIFwiY3N2XCIgOiB7IFwibG9jYXRpb25cIiA6IFNUUklORyB9LFxuICAgIC8vICAgXCJzZXJ2aWNlXCIgOiBTVFJJTkcsXG4gICAgLy8gICBcInNlcnZpY2VcIiA6IHtcbiAgICAvLyAgICAgICBcImxvY2F0aW9uXCIgOiBTVFJJTkchXG4gICAgLy8gICAgICAgXCJmb3JtYXRcIiAgIDogU1RSSU5HXG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIERhdGEucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24sIG11bHRpZ3JhcGgsIG1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHZhciBBcnJheURhdGEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2FycmF5X2RhdGEuanMnKSxcbiAgICAgICAgICAgIERhdGFWYXJpYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YXJpYWJsZS5qcycpLFxuICAgICAgICAgICAgRGF0YU1lYXN1cmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfbWVhc3VyZS5qcycpLFxuICAgICAgICAgICAgUGVyaW9kaWNBcnJheURhdGEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3BlcmlvZGljX2FycmF5X2RhdGEuanMnKSxcbiAgICAgICAgICAgIENTVkRhdGEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Nzdl9kYXRhLmpzJykoJCksXG4gICAgICAgICAgICBXZWJTZXJ2aWNlRGF0YSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvd2ViX3NlcnZpY2VfZGF0YS5qcycpKCQpLFxuICAgICAgICAgICAgTXVsdGlncmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbXVsdGlncmFwaC5qcycpKCQpLFxuICAgICAgICAgICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgICAgIHZGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC92YWxpZGF0aW9uRnVuY3Rpb25zLmpzJyksXG4gICAgICAgICAgICB1RiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgICAgICAgICAgZGVmYXVsdE1pc3Npbmd2YWx1ZVN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHRNaXNzaW5nb3BTdHJpbmcsXG4gICAgICAgICAgICBkYXRhVmFyaWFibGVzID0gW10sXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgYWRhcCwgYWRhcHRlciA9IEFycmF5RGF0YTtcblxuICAgICAgICByZXF1aXJlKCcuL2RhdGFfdmFyaWFibGUuanMnKTsgLy8gc28gdGhhdCBEYXRhVmFyaWFibGUucGFyc2VKU09OIG1ldGhvZCBpcyBkZWZpbmVkIHdoZW4gbmVlZGVkIGJlbG93XG5cbiAgICAgICAgaWYgKGpzb24pIHtcblxuICAgICAgICAgICAgYWRhcCA9IGpzb24uYWRhcHRlcjtcbiAgICAgICAgICAgIGlmIChhZGFwICE9PSB1bmRlZmluZWQgJiYgYWRhcCAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGFkYXB0ZXIgPSBNdWx0aWdyYXBoLmdldERhdGFBZGFwdGVyKGFkYXApO1xuICAgICAgICAgICAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBkYXRhIGFkYXBhdGVyOiBcIiArIGFkYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmUgc3VyZSB0byBsZWF2ZSBkZWZhdWx0TWlzc2luZ3ZhbHVlU3RyaW5nIHVuZGVmaW5lZCBpZlxuICAgICAgICAgICAgLy8ganNvbi5taXNzaW5ndmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgdGhlIFN0cmluZyBjYXN0XG4gICAgICAgICAgICAvLyBoZXJlIHdpbGwgcmVzdWx0IGluIHRoZSBzdHJpbmcgXCJ1bmRlZmluZWRcIiwgd2hpY2ggd3JlYWtzIGhhdm9jIVxuICAgICAgICAgICAgaWYgKGpzb24ubWlzc2luZ3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdE1pc3Npbmd2YWx1ZVN0cmluZyA9IHVGLmNvZXJjZVRvU3RyaW5nKGpzb24ubWlzc2luZ3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHRNaXNzaW5nb3BTdHJpbmcgICAgPSBqc29uLm1pc3NpbmdvcDtcblxuICAgICAgICAgICAgaWYgKGpzb24udmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAganNvbi52YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbih2YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhVmFyaWFibGVzLnB1c2goRGF0YVZhcmlhYmxlLnBhcnNlSlNPTih2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIDxyZXBlYXQ+IHNlY3Rpb24sIGFuZCBpZiBzbywgZ3JhYiB0aGUgcGVyaW9kIGZyb20gaXRcbiAgICAgICAgICAgIHZhciBoYXZlUmVwZWF0ID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgcGVyaW9kO1xuICAgICAgICAgICAgaWYgKFwicmVwZWF0XCIgaW4ganNvbikge1xuICAgICAgICAgICAgICAgIHZhciBwZXJpb2RQcm9wID0gKHZGLnR5cGVPZihqc29uLnJlcGVhdCkgPT09ICdvYmplY3QnKSA/IGpzb24ucmVwZWF0LnBlcmlvZCA6IGpzb24ucmVwZWF0O1xuICAgICAgICAgICAgICAgIGlmIChwZXJpb2RQcm9wID09PSB1bmRlZmluZWQgfHwgcGVyaW9kUHJvcCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci53YXJuaW5nKFwicmVwZWF0IHJlcXVpcmVzIGEgcGVyaW9kOyBkYXRhIHRyZWF0ZWQgYXMgbm9uLXJlcGVhdGluZ1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZXJpb2QgPSBEYXRhTWVhc3VyZS5wYXJzZShkYXRhVmFyaWFibGVzWzBdLnR5cGUoKSwgcGVyaW9kUHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGhhdmVSZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIDx2YWx1ZXM+IHNlY3Rpb24sIHBhcnNlIGl0IGFuZCByZXR1cm4gYW4gQXJyYXlEYXRhIGluc3RhbmNlOlxuICAgICAgICAgICAgaWYgKGpzb24udmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGlzIGRvZXMgbm90IHVzZSB0aGUgZGF0YSBhZGFwdGVyIC0tIG5vdCBzdXBwb3J0ZWQgZm9yIGlubGluZSBqc29uIGRhdGFcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nVmFsdWVzID0ganNvbi52YWx1ZXM7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmVSZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBQZXJpb2RpY0FycmF5RGF0YShkYXRhVmFyaWFibGVzLCBzdHJpbmdWYWx1ZXMsIHBlcmlvZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBBcnJheURhdGEoZGF0YVZhcmlhYmxlcywgc3RyaW5nVmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSA8Y3N2PiBzZWN0aW9uLCBwYXJzZSBpdCBhbmQgcmV0dXJuIGEgQ1NWRGF0YSBpbnN0YW5jZTpcbiAgICAgICAgICAgIGlmIChqc29uLmNzdikge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9ICh2Ri50eXBlT2YoanNvbi5jc3YpID09PSAnb2JqZWN0JykgPyBqc29uLmNzdi5sb2NhdGlvbiA6IGpzb24uY3N2O1xuICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgQ1NWRGF0YShkYXRhVmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoID8gbXVsdGlncmFwaC5yZWJhc2VVcmwoZmlsZW5hbWUpIDogZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoID8gbXVsdGlncmFwaC5nZXRBamF4VGhyb3R0bGUoZmlsZW5hbWUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIDxzZXJ2aWNlPiBzZWN0aW9uLCBwYXJzZSBpdCBhbmQgcmV0dXJuIGEgV2ViU2VydmljZURhdGEgaW5zdGFuY2U6XG4gICAgICAgICAgICBpZiAoanNvbi5zZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gKHZGLnR5cGVPZihqc29uLnNlcnZpY2UpID09PSAnb2JqZWN0JykgPyBqc29uLnNlcnZpY2UubG9jYXRpb24gOiBqc29uLnNlcnZpY2U7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBXZWJTZXJ2aWNlRGF0YShkYXRhVmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlncmFwaCA/IG11bHRpZ3JhcGgucmViYXNlVXJsKGxvY2F0aW9uKSA6IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoID8gbXVsdGlncmFwaC5nZXRBamF4VGhyb3R0bGUobG9jYXRpb24pIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24uc2VydmljZSkgPT09ICdvYmplY3QnICYmIChcImZvcm1hdFwiIGluIGpzb24uc2VydmljZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JtYXQoanNvbi5zZXJ2aWNlLmZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUganNvbiBjb250YWlucyBhbiBcImlkXCIgcHJvcGVydHksIHBhc3MgaXQgb24gdG8gb3VyIGRhdGEgb2JqZWN0OlxuICAgICAgICAgICAgaWYgKFwiaWRcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5pZChqc29uLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdE1pc3Npbmd2YWx1ZVN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5kZWZhdWx0TWlzc2luZ3ZhbHVlKGRlZmF1bHRNaXNzaW5ndmFsdWVTdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZmF1bHRNaXNzaW5nb3BTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZGVmYXVsdE1pc3NpbmdvcChkZWZhdWx0TWlzc2luZ29wU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEuYWRhcHRlcihhZGFwdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHJldHVybiBEYXRhO1xufTtcblxuXG4iLCJ2YXIgRGF0YVZhcmlhYmxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhcmlhYmxlLmpzJyk7XG5cbi8vICBcInZhcmlhYmxlXCIgOiB7XG4vLyAgICAgIFwiaWRcIiAgICAgICAgICAgOiBTVFJJTkchLFxuLy8gICAgICBcImNvbHVtblwiICAgICAgIDogSU5URUdFUixcbi8vICAgICAgXCJ0eXBlXCIgICAgICAgICA6IERBVEFUWVBFKG51bWJlciksXG4vLyAgICAgIFwibWlzc2luZ3ZhbHVlXCIgOiBTVFJJTkcsXG4vLyAgICAgIFwibWlzc2luZ29wXCIgICAgOiBDT01QQVJBVE9SLFxuLy8gIH1cbkRhdGFWYXJpYWJsZS5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbiwgZGF0YSkge1xuICAgIHZhciB2YXJpYWJsZSxcbiAgICAgICAgcEYgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgRGF0YVZhbHVlICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgYXR0cjtcblxuICAgIGlmIChqc29uICYmIGpzb24uaWQpIHtcbiAgICAgICAgdmFyaWFibGUgPSBuZXcgRGF0YVZhcmlhYmxlKGpzb24uaWQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmNvbHVtbiwgICAgICAgdmFyaWFibGUuY29sdW1uKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi50eXBlLCAgICAgICAgIHZhcmlhYmxlLnR5cGUsICAgICAgICAgRGF0YVZhbHVlLnBhcnNlVHlwZSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubWlzc2luZ3ZhbHVlLCB2YXJpYWJsZS5taXNzaW5ndmFsdWUsIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIERhdGFWYWx1ZS5wYXJzZSh2YXJpYWJsZS50eXBlKCksIHYpOyB9KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5taXNzaW5nb3AsICAgIHZhcmlhYmxlLm1pc3NpbmdvcCwgICAgRGF0YVZhbHVlLnBhcnNlQ29tcGFyYXRvcik7XG4gICAgfVxuICAgIHJldHVybiB2YXJpYWJsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZhcmlhYmxlO1xuIiwidmFyIERhdGF0aXBzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhdGlwcy5qcycpO1xuXG4vLyBcImRhdGF0aXBzXCIgOiB7XG4vLyAgIFwiZm9ybWF0XCIgICAgICAgICAgIDogXCJTVFJJTkchXCIsXG4vLyAgIFwiYmdjb2xvclwiICAgICAgICAgIDogXCJDT0xPUlwiLFxuLy8gICBcImJnYWxwaGFcIiAgICAgICAgICA6IFwiRE9VQkxFXCIsXG4vLyAgIFwiYm9yZGVyXCIgICAgICAgICAgIDogXCJJTlRFR0VSXCIsXG4vLyAgIFwiYm9yZGVyY29sb3JcIiAgICAgIDogXCJDT0xPUlwiLFxuLy8gICBcInBhZFwiICAgICAgICAgICAgICA6IFwiSU5URUdFUlwiLFxuLy8gICBcInZhcmlhYmxlLWZvcm1hdHNcIiA6IFsgXCJTVFJJTkchXCIsIC4uLiBdXG4vLyB9XG5EYXRhdGlwcy5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciBkYXRhdGlwcyAgICAgICAgID0gbmV3IERhdGF0aXBzKCksXG4gICAgICAgIFJHQkNvbG9yICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICBEYXRhdGlwc1ZhcmlhYmxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhdGlwc192YXJpYWJsZS5qcycpLFxuICAgICAgICBwRiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHVGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWxpdHlGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VSR0JDb2xvciAgICA9IFJHQkNvbG9yLnBhcnNlLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlSW50ZWdlciAgICAgPSBwRi5wYXJzZUludGVnZXIsXG4gICAgICAgIGNoaWxkO1xuICAgIGlmIChqc29uKSB7XG4gICAgICAgIGlmIChqc29uW1widmFyaWFibGUtZm9ybWF0c1wiXSkge1xuICAgICAgICAgICAganNvbltcInZhcmlhYmxlLWZvcm1hdHNcIl0uZm9yRWFjaChmdW5jdGlvbihmbXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHR2ID0gbmV3IERhdGF0aXBzVmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICBkdHYuZm9ybWF0U3RyaW5nKGZtdCk7XG4gICAgICAgICAgICAgICAgZGF0YXRpcHMudmFyaWFibGVzKCkuYWRkKGR0dik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5mb3JtYXQsICAgICAgZGF0YXRpcHMuZm9ybWF0U3RyaW5nKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5iZ2NvbG9yLCAgICAgZGF0YXRpcHMuYmdjb2xvciwgICAgIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJnYWxwaGEsICAgICBkYXRhdGlwcy5iZ2FscGhhKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5ib3JkZXIsICAgICAgZGF0YXRpcHMuYm9yZGVyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5ib3JkZXJjb2xvciwgZGF0YXRpcHMuYm9yZGVyY29sb3IsIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnBhZCwgICAgICAgICBkYXRhdGlwcy5wYWQpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YXRpcHM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGF0aXBzO1xuIiwidmFyIEZpbHRlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZmlsdGVyLmpzJyk7XG5cbi8vIFwiZmlsdGVyXCIgOiB7XG4vLyAgIFwidHlwZVwiOiBcIlNUUklOR1wiXG4vLyAgIFwib3B0aW9uc1wiIDogW1xuLy8gICAgIHsgXCJuYW1lXCIgOiBcIlNUUklORyFcIiwgXCJ2YWx1ZVwiIDogXCJTVFJJTkchXCIgfSxcbi8vICAgICB7IFwibmFtZVwiIDogXCJTVFJJTkchXCIsIFwidmFsdWVcIiA6IFwiU1RSSU5HIVwiIH1cbi8vICAgICAuLi5cbi8vICAgfVxuLy8gfVxuRmlsdGVyLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgdmFyIGZpbHRlciA9IG5ldyBGaWx0ZXIoKSxcbiAgICAgICAgRmlsdGVyT3B0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9maWx0ZXJfb3B0aW9uLmpzJyksXG4gICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHVGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgICAgIG87XG5cbiAgICByZXF1aXJlKCcuL2ZpbHRlcl9vcHRpb24uanMnKTsgLy8gc28gdGhhdCBGaWx0ZXJPcHRpb24ucGFyc2VKU09OIHdpbGwgZXhpc3QgYmVsb3dcblxuICAgIGlmIChqc29uKSB7XG4gICAgICAgIGlmIChqc29uLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAob3B0IGluIGpzb24ub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLm9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgICAgICAgICAgICAgICBvID0gbmV3IEZpbHRlck9wdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBvLm5hbWUob3B0KTtcbiAgICAgICAgICAgICAgICAgICAgby52YWx1ZSh1Ri5jb2VyY2VUb1N0cmluZyhqc29uLm9wdGlvbnNbb3B0XSkpO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIub3B0aW9ucygpLmFkZCggbyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBGLnBhcnNlQXR0cmlidXRlKGpzb24udHlwZSwgZmlsdGVyLnR5cGUpO1xuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH07XG5cbiAgICByZXR1cm4gRmlsdGVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXI7XG4iLCJ2YXIgRmlsdGVyT3B0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9maWx0ZXJfb3B0aW9uLmpzJyk7XG5cbi8vIFwib3B0aW9uXCIgOiB7IFwibmFtZVwiIDogXCJTVFJJTkchXCIsICBcInZhbHVlXCIgOiBcIlNUUklORyFcIiB9XG5GaWx0ZXJPcHRpb24ucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICB2YXIgcEYgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHVGICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbGl0eUZ1bmN0aW9ucy5qcycpLFxuICAgICAgICBvcHRpb24gPSBuZXcgRmlsdGVyT3B0aW9uKCk7XG4gICAgaWYgKGpzb24pIHtcbiAgICAgICAgb3B0aW9uLm5hbWUoanNvbi5uYW1lKTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBqc29uICYmIGpzb24udmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIC8vIGNvZXJjZSB0byBzdHJpbmcgc2luY2UgXCJ2YWx1ZVwiIGF0dHIgb2YgZmlsdGVyX29wdGlvbiBpcyBvZiB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uLnZhbHVlKHVGLmNvZXJjZVRvU3RyaW5nKGpzb24udmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJPcHRpb247XG4iLCIvLyBUaGlzIGZpbGUgdXNlcyBqUXVlcnkuICBBIHZhbGlkIGpRdWVyeSBvYmplY3QgbXVzdCBiZSBwYXNzZWQgdG8gdGhlXG4vLyBmdW5jdGlvbiByZXR1cm5lZCBieSByZXF1aXJpbmcgdGhpcyBmaWxlLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkKSB7XG4gICAgdmFyIEdyYXBoID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ncmFwaC5qcycpLFxuICAgICAgICBwRiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpO1xuXG4gICAgLy8gaWYgcGFyc2VKU09OIG1ldGhvZCBhbHJlYWR5IGhhcyBiZWVuIGRlZmluZWQsIHdoaWNoIHdvdWxkIGJlIHRoZSBjYXNlIGlmIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBjYWxsZWQsIGp1c3QgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKHR5cGVvZihHcmFwaC5wYXJzZUpTT04pPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBHcmFwaDsgfTtcblxuICAgIEdyYXBoLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBtdWx0aWdyYXBoLCBtZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB2YXIgZ3JhcGggPSBuZXcgR3JhcGgoKSxcbiAgICAgICAgICAgIEF4aXMgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzLmpzJyksXG4gICAgICAgICAgICBXaW5kb3cgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3dpbmRvdy5qcycpLFxuICAgICAgICAgICAgTGVnZW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9sZWdlbmQuanMnKSxcbiAgICAgICAgICAgIEJhY2tncm91bmQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2JhY2tncm91bmQuanMnKSxcbiAgICAgICAgICAgIFBsb3RhcmVhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wbG90YXJlYS5qcycpLFxuICAgICAgICAgICAgQ29uc2VjdXRpdmVEaXN0YW5jZUZpbHRlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29uc2VjdXRpdmVfZGlzdGFuY2VfZmlsdGVyLmpzJyksXG4gICAgICAgICAgICBUaXRsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdGl0bGUuanMnKSxcbiAgICAgICAgICAgIERhdGEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGEuanMnKSxcbiAgICAgICAgICAgIFBsb3QgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3Bsb3QuanMnKSxcbiAgICAgICAgICAgIHVGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgICAgICAgICB2RiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpLFxuICAgICAgICAgICAgZGVmYXVsdHMgPSB1Ri5nZXREZWZhdWx0VmFsdWVzRnJvbVhTRCgpLFxuICAgICAgICAgICAgY2hpbGQ7XG5cbiAgICAgICAgLy8gc28gdGhhdCB0aGVzZSBvYmplY3RzJyAucGFyc2VKU09OIG1ldGhvZHMgd2lsbCBleGlzdCB3aGVuIG5lZWRlZCBiZWxvdzpcbiAgICAgICAgcmVxdWlyZSgnLi93aW5kb3cuanMnKTtcbiAgICAgICAgcmVxdWlyZSgnLi9sZWdlbmQuanMnKTtcbiAgICAgICAgcmVxdWlyZSgnLi9iYWNrZ3JvdW5kLmpzJyk7XG4gICAgICAgIHJlcXVpcmUoJy4vcGxvdGFyZWEuanMnKTtcbiAgICAgICAgcmVxdWlyZSgnLi90aXRsZS5qcycpO1xuICAgICAgICByZXF1aXJlKCcuL2F4aXMuanMnKTtcbiAgICAgICAgcmVxdWlyZSgnLi9kYXRhLmpzJykoJCk7XG4gICAgICAgIHJlcXVpcmUoJy4vcGxvdC5qcycpO1xuXG4gICAgICAgIGdyYXBoLm11bHRpZ3JhcGgobXVsdGlncmFwaCk7XG4gICAgICAgIGlmIChqc29uKSB7XG5cbiAgICAgICAgICAgIGlmIChqc29uLndpbmRvdykge1xuICAgICAgICAgICAgICAgIGdyYXBoLndpbmRvdyggV2luZG93LnBhcnNlSlNPTihqc29uLndpbmRvdykgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFwibGVnZW5kXCIgaW4ganNvbikge1xuICAgICAgICAgICAgICAgIGdyYXBoLmxlZ2VuZCggTGVnZW5kLnBhcnNlSlNPTihqc29uLmxlZ2VuZCkgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JhcGgubGVnZW5kKCBMZWdlbmQucGFyc2VKU09OKCkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpzb24uYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgICAgIGdyYXBoLmJhY2tncm91bmQoIEJhY2tncm91bmQucGFyc2VKU09OKGpzb24uYmFja2dyb3VuZCwgZ3JhcGgubXVsdGlncmFwaCgpKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoanNvbi5wbG90YXJlYSkge1xuICAgICAgICAgICAgICAgIGdyYXBoLnBsb3RhcmVhKCBQbG90YXJlYS5wYXJzZUpTT04oanNvbi5wbG90YXJlYSkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpzb24udGl0bGUpIHtcbiAgICAgICAgICAgICAgICBncmFwaC50aXRsZSggVGl0bGUucGFyc2VKU09OKGpzb24udGl0bGUsIGdyYXBoKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXCJmaWx0ZXJcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi5maWx0ZXIpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YoanNvbi5maWx0ZXIudHlwZSkgIT09ICd1bmRlZmluZWQnKSAmJiAoanNvbi5maWx0ZXIudHlwZSAhPT0gJ2NvbnNlY3V0aXZlZGlzdGFuY2UnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBmaWx0ZXIgdHlwZTogJyArIGpzb24uZmlsdGVyLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguZmlsdGVyKG5ldyBDb25zZWN1dGl2ZURpc3RhbmNlRmlsdGVyKGpzb24uZmlsdGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24uZmlsdGVyKSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpbHRlciBwcm9wZXJ0eTogJyArIGpzb24uZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbi5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5maWx0ZXIobmV3IENvbnNlY3V0aXZlRGlzdGFuY2VGaWx0ZXIoe30pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaGF4ZXMgPSBqc29uLmhvcml6b250YWxheGlzID8ganNvbi5ob3Jpem9udGFsYXhpcyA6IGpzb24uaG9yaXpvbnRhbGF4ZXM7XG4gICAgICAgICAgICBpZiAoanNvbi5ob3Jpem9udGFsYXhpcyAmJiBqc29uLmhvcml6b250YWxheGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ3JhcGggbWF5IG5vdCBoYXZlIGJvdGggJ2hvcml6b250YWxheGlzJyBhbmQgJ2hvcml6b250YWxheGVzJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXhlcykge1xuICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoaGF4ZXMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIGhheGVzLmZvckVhY2goZnVuY3Rpb24oYXhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguYXhlcygpLmFkZCggQXhpcy5wYXJzZUpTT04oYXhpcywgQXhpcy5IT1JJWk9OVEFMLCBtZXNzYWdlSGFuZGxlciwgZ3JhcGgubXVsdGlncmFwaCgpKSApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFwaC5heGVzKCkuYWRkKCBBeGlzLnBhcnNlSlNPTihoYXhlcywgQXhpcy5IT1JJWk9OVEFMLCBtZXNzYWdlSGFuZGxlciwgZ3JhcGgubXVsdGlncmFwaCgpKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZheGVzID0ganNvbi52ZXJ0aWNhbGF4aXMgPyBqc29uLnZlcnRpY2FsYXhpcyA6IGpzb24udmVydGljYWxheGVzO1xuICAgICAgICAgICAgaWYgKGpzb24udmVydGljYWxheGlzICYmIGpzb24udmVydGljYWxheGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ3JhcGggbWF5IG5vdCBoYXZlIGJvdGggJ3ZlcnRpY2FsYXhpcycgYW5kICd2ZXJ0aWNhbGF4ZXMnXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZheGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZih2YXhlcykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmF4ZXMuZm9yRWFjaChmdW5jdGlvbihheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5heGVzKCkuYWRkKCBBeGlzLnBhcnNlSlNPTihheGlzLCBBeGlzLlZFUlRJQ0FMLCBtZXNzYWdlSGFuZGxlciwgZ3JhcGgubXVsdGlncmFwaCgpKSApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFwaC5heGVzKCkuYWRkKCBBeGlzLnBhcnNlSlNPTih2YXhlcywgQXhpcy5WRVJUSUNBTCwgbWVzc2FnZUhhbmRsZXIsIGdyYXBoLm11bHRpZ3JhcGgoKSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkQWpheFRocm90dGxlKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiAgICA9IHQucGF0dGVybiAgICA/IHQucGF0dGVybiAgICA6IGRlZmF1bHRzLnRocm90dGxlLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzICAgPSB0LnJlcXVlc3RzICAgPyB0LnJlcXVlc3RzICAgOiBkZWZhdWx0cy50aHJvdHRsZS5yZXF1ZXN0cyxcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kICAgICA9IHQucGVyaW9kICAgICA/IHQucGVyaW9kICAgICA6IGRlZmF1bHRzLnRocm90dGxlLnBlcmlvZCxcbiAgICAgICAgICAgICAgICAgICAgY29uY3VycmVudCA9IHQuY29uY3VycmVudCA/IHQuY29uY3VycmVudCA6IGRlZmF1bHRzLnRocm90dGxlLmNvbmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgbXVsdGlncmFwaC5hZGRBamF4VGhyb3R0bGUocGF0dGVybiwgcmVxdWVzdHMsIHBlcmlvZCwgY29uY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGhyb3R0bGVzID0ganNvbi50aHJvdHRsZSA/IGpzb24udGhyb3R0bGUgOiBqc29uLnRocm90dGxlcztcbiAgICAgICAgICAgIGlmIChqc29uLnRocm90dGxlICYmIGpzb24udGhyb3R0bGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ3JhcGggbWF5IG5vdCBoYXZlIGJvdGggJ3Rocm90dGxlJyBhbmQgJ3Rocm90dGxlcydcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhyb3R0bGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZih0aHJvdHRsZXMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlcy5mb3JFYWNoKGFkZEFqYXhUaHJvdHRsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkQWpheFRocm90dGxlKHRocm90dGxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLmRhdGEpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb24uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLmRhdGEoKS5hZGQoIERhdGEucGFyc2VKU09OKGRhdGEsIGdyYXBoLm11bHRpZ3JhcGgoKSwgbWVzc2FnZUhhbmRsZXIpICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLmRhdGEoKS5hZGQoIERhdGEucGFyc2VKU09OKGpzb24uZGF0YSwgZ3JhcGgubXVsdGlncmFwaCgpLCBtZXNzYWdlSGFuZGxlcikgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwbG90cyA9IGpzb24ucGxvdCA/IGpzb24ucGxvdCA6IGpzb24ucGxvdHM7XG4gICAgICAgICAgICBpZiAoanNvbi5wbG90ICYmIGpzb24ucGxvdHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJncmFwaCBtYXkgbm90IGhhdmUgYm90aCAncGxvdCcgYW5kICdwbG90cydcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGxvdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKHBsb3RzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICBwbG90cy5mb3JFYWNoKGZ1bmN0aW9uKHBsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLnBsb3RzKCkuYWRkKCBQbG90LnBhcnNlSlNPTihwbG90LCBncmFwaCwgbWVzc2FnZUhhbmRsZXIpICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLnBsb3RzKCkuYWRkKCBQbG90LnBhcnNlSlNPTihwbG90cywgZ3JhcGgsIG1lc3NhZ2VIYW5kbGVyKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JhcGgucG9zdFBhcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH07XG5cbiAgICByZXR1cm4gR3JhcGg7XG59O1xuIiwidmFyIEdyaWQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2dyaWQuanMnKTtcblxuLy8gXCJncmlkXCI6IHsgXCJjb2xvclwiOiBcIiNmZjAwZmZcIiwgdmlzaWJsZTogdHJ1ZSB9XG5HcmlkLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgdmFyIGdyaWQgICAgICAgICAgICAgPSBuZXcgR3JpZCgpLFxuICAgICAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBhdHRyO1xuICAgIGlmIChqc29uKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uY29sb3IsIGdyaWQuY29sb3IsIFJHQkNvbG9yLnBhcnNlKTtcbiAgICAgICAgLy9OT1RFOiB2aXNpYmxlIGF0dHJpYnV0ZSBzaG91bGQgZGVmYXVsdCB0byB0cnVlIHdoZW4gcGFyc2luZywgc28gdGhhdFxuICAgICAgICAvLyAgICAgIHRoZSBwcmVzZW5jZSBvZiBhIFwiZ3JpZFwiIHByb3BlcnR5IGF0IGFsbCB3aWxsIHR1cm4gb24gYSBncmlkLiAgSW5cbiAgICAgICAgLy8gICAgICB0aGUgR3JpZCBvYmplY3QgaXRzZWxmLCB0aG91Z2gsIHRoZSBkZWZhdWx0IGZvciB0aGUgdmlzaWJsZVxuICAgICAgICAvLyAgICAgIGF0dHJpYnV0ZSBpcyBmYWxzZSwgc28gdGhhdCB3aGVuIHdlIGNyZWF0ZSBhIGRlZmF1bHQgZ3JpZCBvYmplY3RcbiAgICAgICAgLy8gICAgICBpbiBjb2RlIChhcyBvcHBvc2VkIHRvIHBhcnNpbmcpLCBpdCBkZWZhdWx0cyB0byBub3QgdmlzaWJsZS5cbiAgICAgICAgYXR0ciA9IGpzb24udmlzaWJsZTtcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZ3JpZC52aXNpYmxlKGF0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC52aXNpYmxlKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmlkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkO1xuIiwidmFyIEljb24gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ljb24uanMnKTtcblxuLy8gXCJpY29uXCIgOiB7IFwiYm9yZGVyXCI6IDIsIFwid2lkdGhcIjogMzAsIFwiaGVpZ2h0XCI6IDIwIH1cbkljb24ucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICB2YXIgaWNvbiA9IG5ldyBJY29uKCksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJykucGFyc2VBdHRyaWJ1dGU7XG4gICAgaWYgKGpzb24pIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5oZWlnaHQsIGljb24uaGVpZ2h0KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi53aWR0aCwgIGljb24ud2lkdGgpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJvcmRlciwgaWNvbi5ib3JkZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaWNvbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSWNvbjtcbiIsInZhciBJbWcgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ltZy5qcycpO1xuXG4vLyBcImltZ1wiIDogeyBcInNyY1wiOiBcImZvby5wbmdcIiwgXCJhbmNob3JcIjogWy0xLCA1XSwgXCJiYXNlXCI6IFszLCAxMl0sIFwicG9zaXRpb25cIjogWy0yLCAzXSwgXCJmcmFtZVwiOiBcInBhZGRpbmdcIiB9XG5JbWcucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24sIG11bHRpZ3JhcGgpIHtcbiAgICB2YXIgaW1nLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBQb2ludCAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICAgICAgcGFyc2VKU09OUG9pbnQgPSBmdW5jdGlvbihwKSB7IHJldHVybiBuZXcgUG9pbnQocFswXSwgcFsxXSk7IH07XG4gICAgaWYgKGpzb24gJiYganNvbi5zcmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3JjID0ganNvbi5zcmM7XG4gICAgICAgIGlmICghc3JjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltZyByZXF1aXJlcyBhIFwic3JjXCIgcHJvcGVydHknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGlncmFwaCkge1xuICAgICAgICAgICAgc3JjID0gbXVsdGlncmFwaC5yZWJhc2VVcmwoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBpbWcgPSBuZXcgSW1nKHNyYyk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYW5jaG9yLCAgIGltZy5hbmNob3IsICAgcGFyc2VKU09OUG9pbnQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJhc2UsICAgICBpbWcuYmFzZSwgICAgIHBhcnNlSlNPTlBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5wb3NpdGlvbiwgaW1nLnBvc2l0aW9uLCBwYXJzZUpTT05Qb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uZnJhbWUsICAgIGltZy5mcmFtZSwgICAgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGltZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1nO1xuIiwiLy8gdXNhZ2U6XG4vLyBcbi8vICAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSByZXF1aXJpbmcgdGhpcyBmaWxlLlxuLy9cbi8vICAgICAgcmVxdWlyZSgnLi4uL3NyYy9wYXJzZXIvanNvbi9qc29uX3BhcnNlci5qcycpKCQpO1xuLy8gICAgICB2YXIgTXVsdGlncmFwaCA9IHJlcXVpcmUoJy4uLi9zcmMvY29yZS9tdWx0aWdyYXBoLmpzJykoJCk7XG4vLyAgICAgIHZhciBtID0gTXVsdGlncmFwaC5wYXJzZUpTT04oIHsuLi59IH07XG4vLyBcbi8vICAgd2hlcmUgey4uLn0gaXMgdGhlIEpTT04gb2JqZWN0IHRvIGJlIHBhcnNlZC5cbi8vXG52YXIgaW5jbHVkZWQgPSBmYWxzZTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIGlmIChpbmNsdWRlZCkgeyByZXR1cm47IH1cbiAgICBpbmNsdWRlZCA9IHRydWU7XG5cbiAgICByZXF1aXJlKCcuL2RhdGEuanMnKSgkKTtcbiAgICByZXF1aXJlKCcuL2dyYXBoLmpzJykoJCk7XG4gICAgcmVxdWlyZSgnLi9tdWx0aWdyYXBoLmpzJykoJCk7XG5cbiAgICByZXF1aXJlKCcuL2F4aXMuanMnKTtcbiAgICByZXF1aXJlKCcuL2F4aXNfdGl0bGUuanMnKTtcbiAgICByZXF1aXJlKCcuL2JhY2tncm91bmQuanMnKTtcbiAgICByZXF1aXJlKCcuL2RhdGF0aXBzLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9kYXRhX3ZhcmlhYmxlLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9maWx0ZXIuanMnKTtcbiAgICByZXF1aXJlKCcuL2ZpbHRlcl9vcHRpb24uanMnKTtcbiAgICByZXF1aXJlKCcuL2dyaWQuanMnKTtcbiAgICByZXF1aXJlKCcuL2ljb24uanMnKTtcbiAgICByZXF1aXJlKCcuL2ltZy5qcycpO1xuICAgIHJlcXVpcmUoJy4vanNvbl9wYXJzZXIuanMnKTtcbiAgICByZXF1aXJlKCcuL2xhYmVsZXIuanMnKTtcbiAgICByZXF1aXJlKCcuL2xlZ2VuZC5qcycpO1xuICAgIHJlcXVpcmUoJy4vcGFuLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9wbG90YXJlYS5qcycpO1xuICAgIHJlcXVpcmUoJy4vcGxvdC5qcycpO1xuICAgIHJlcXVpcmUoJy4vcGxvdF9sZWdlbmQuanMnKTtcbiAgICByZXF1aXJlKCcuL3JlbmRlcmVyLmpzJyk7XG4gICAgcmVxdWlyZSgnLi90aXRsZS5qcycpO1xuICAgIHJlcXVpcmUoJy4vd2luZG93LmpzJyk7XG4gICAgcmVxdWlyZSgnLi96b29tLmpzJyk7XG59O1xuIiwidmFyIExhYmVsZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2xhYmVsZXIuanMnKTtcblxuLy8gXCJsYWJlbHNcIiA6IHtcbi8vICAgXCJmb3JtYXQ6IFNUUklORyxcbi8vICAgXCJzdGFydFwiIDogREFUQVZBTFVFKDApLFxuLy8gICBcImFuZ2xlXCIgOiBET1VCTEUoMCksXG4vLyAgIFwicG9zaXRpb25cIiA6IFBPSU5ULFxuLy8gICBcImFuY2hvclwiIDogUE9JTlQsXG4vLyAgIFwiY29sb3JcIiA6IENPTE9SKGJsYWNrKSxcbi8vICAgXCJzcGFjaW5nXCIgOiBTVFJJTkcsXG4vLyAgIFwiZm9udFwiOiBTVFJJTkcsXG4vLyAgIFwiZGVuc2l0eWZhY3RvclwiIDogRE9VQkxFKDEuMCksXG4vLyAgIFwibGFiZWxcIiA6IFtcbi8vICAgICB7IFwiZm9ybWF0XCI6IFwiJVlcIiwgXCJzdGFydFwiOiBTVFJJTkcsIFwiYW5nbGVcIjogNDUsIFwicG9zaXRpb25cIjogWzIsM10sXG4vLyAgICAgICBcImFuY2hvclwiOiBbMSwxXSwgXCJzcGFjaW5nXCI6IFwiMVlcIiwgXCJkZW5zaXR5ZmFjdG9yXCI6IDAuMiB9LFxuLy8gICAgIHsgXCJmb3JtYXRcIjogXCIlTVwiLCBcInN0YXJ0XCI6IFNUUklORywgXCJhbmdsZVwiOiA0NSwgXCJwb3NpdGlvblwiOiBbMiwzXSxcbi8vICAgICAgIFwiYW5jaG9yXCI6IFsxLDFdLCBcInNwYWNpbmdcIjogW1wiMU1cIiwgXCIxRFwiXSwgXCJkZW5zaXR5ZmFjdG9yXCI6IDkuMCB9XG4vLyAgIF1cbi8vIH1cbi8vXG4vLyBGZWF0dXJlIGFkZGVkIDIwMTUtMTItMTY6XG4vLyAgIFRoZSBcImZvcm1hdFwiIGF0dHJpYnV0ZSAoZm9yIGFuIGF4aXMgb2YgdHlwZSBudW1iZXIgb25seSkgY2FuIGJlIGFuXG4vLyAgIGFycmF5IG9mIHN0cmluZ3MgdG8gYmUgZGlzcGxheWVkIGZvciB0aGUgdmFsdWVzIDAuLkwtMSB3aGVyZSBMIGlzIHRoZVxuLy8gICBudW1iZXIgb2Ygc3RyaW5ncyBpbiB0aGUgYXJyYXkuICBGb3IgZXhhbXBsZTpcbi8vICAgICAgICBcImZvcm1hdFwiOiBbXCJKYW5cIixcIkZlYlwiLFwiTWFyXCIsXCJBcHJcIixcIk1heVwiLFwiSnVuXCIsXCJKdWxcIixcIkF1Z1wiLFwiU2VwXCIsXCJPY3RcIixcIk5vdlwiXVxuLy8gICB3b3VsZCBjYXVzZSBcIkphblwiIHRvIGJlIHJlbmRlcmVkIGFzIHRoZSBsYWJlbCBmb3IgdmFsdWUgMCwgXCJGZWJcIiBmb3IgdmFsdWUgMSxcbi8vICAgYW5kIHNvIG9uLiAgVGhlcmUgaXMgY3VycmVudGx5IG5vIHdheSB0byBjdXN0b21pemUgdGhlIGFzc29jaWF0aW9uIGJldHdlZW4gbnVtZXJpY2FsXG4vLyAgIHZhbHVlcyBhbmQgc3RyaW5ncyAtLSBpdCdzIGhhcmRjb2RlZCB0byBiZSB0aGUgaW50ZWdlcnMgc3RhcnRpbmcgd2l0aCAwLlxuXG5MYWJlbGVyLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBheGlzLCBkZWZhdWx0cywgc3BhY2luZykge1xuICAgIC8vIFRoaXMgcGFyc2VyIHRha2VzIGFuIG9wdGlvbmFsIGZpbmFsIGFyZ3VtZW50LCBzcGFjaW5nLCB3aGljaCBpcyBhIHN0cmluZyByZXByZXNlbnRpbmdcbiAgICAvLyB0aGUgc3BhY2luZyB0byBiZSBwYXJzZWQgZm9yIHRoZSBsYWJlbGVyLiAgSWYgdGhhdCBhcmd1bWVudCBpcyBub3QgcHJlc2VudCwgdGhlIHNwYWNpbmdcbiAgICAvLyB2YWx1ZSBpcyB0YWtlbiBmcm9tIHRoZSBqc29uIG9iamVjdC4gIElmIGEgc3BhY2luZyBhcmd1bWVudCBpcyBwcmVzZW50LCBpdCBpcyBwYXJzZWRcbiAgICAvLyBhbmQgdXNlZCB0byBzZXQgdGhlIHNwYWNpbmcgYXR0cmlidXRlIG9mIHRoZSBMYWJlbGVyIG9iamVjdCwgYW5kIGluIHRoaXMgY2FzZSwgYW55XG4gICAgLy8gc3BhY2luZyB2YWx1ZSBwcmVzZW50IGluIHRoZSBqc29uIGlzIGlnbm9yZWQuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgc3BhY2luZyBhcmd1bWVudCBoYXMgdGhlIHZhbHVlIG51bGwsIHRoZSByZXN1bHRpbmcgbGFiZWxlciB3aWxsIGhhdmUgbm8gc3BhY2luZ1xuICAgIC8vIGF0dHJpYnV0ZSBzZXQgYXQgYWxsLlxuICAgIHZhciBsYWJlbGVyLFxuICAgICAgICBQb2ludCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICAgICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICBEYXRhTWVhc3VyZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV9tZWFzdXJlLmpzJyksXG4gICAgICAgIERhdGFWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgICAgICBEYXRhRm9ybWF0dGVyID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX2Zvcm1hdHRlci5qcycpLFxuICAgICAgICBDYXRlZ29yeUZvcm1hdHRlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY2F0ZWdvcnlfZm9ybWF0dGVyLmpzJyksXG4gICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHZGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC92YWxpZGF0aW9uRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHBhcnNlSlNPTlBvaW50ID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gbmV3IFBvaW50KHBbMF0sIHBbMV0pOyB9O1xuXG4gICAgLy8gYHBhcnNlQXR0cmlidXRlYCByZXR1cm5zIHRydWUgb3IgZmFsc2UgZGVwZW5kaW5nIG9uIHdoZXRoZXIgb3Igbm90IGl0IHNldCB0aGUgYXR0cmlidXRlLlxuICAgIC8vIElmIGl0IGRpZCBub3QgYW5kIGlmIHRoZSBgZGVmYXVsdHNgIG9iamVjdCBleGlzdHMgdGhlbiB0aGUgYXR0cmlidXRlIGlzIHNldCB0byB0aGVcbiAgICAvLyBhcHByb3ByaWF0ZSBkZWZhdWx0IHZhbHVlLlxuICAgIHZhciBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodmFsdWUsIGF0dHJpYnV0ZSwgcHJlcHJvY2Vzc29yLCBkZWZhdWx0TmFtZSkge1xuICAgICAgICBpZiAoIXBGLnBhcnNlQXR0cmlidXRlKHZhbHVlLCBhdHRyaWJ1dGUsIHByZXByb2Nlc3NvcikgJiYgZGVmYXVsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXR0cmlidXRlKGRlZmF1bHRzW2RlZmF1bHROYW1lXSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBhcnNlRGF0YUZvcm1hdHRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRhRm9ybWF0dGVyLmNyZWF0ZSh0eXBlLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgcGFyc2VEYXRhVmFsdWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0YVZhbHVlLnBhcnNlKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgaWYgKGpzb24pIHtcbiAgICAgICAgbGFiZWxlciA9IG5ldyBMYWJlbGVyKGF4aXMpO1xuICAgICAgICBpZiAoc3BhY2luZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNwYWNpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNwYWNpbmcgPSBqc29uLnNwYWNpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL05PVEU6IHNwYWNpbmcgbWlnaHQgc3RpbGwgPT09IHVuZGVmaW5lZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUoc3BhY2luZywgbGFiZWxlci5zcGFjaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIERhdGFNZWFzdXJlLnBhcnNlKGF4aXMudHlwZSgpLCB2KTsgfSwgLy9wRi5wYXJzZURhdGFNZWFzdXJlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFjaW5nXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLmZvcm1hdCkgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKGpzb24uZm9ybWF0LCAgICBsYWJlbGVyLmZvcm1hdHRlciwgICAgIGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlGb3JtYXR0ZXIoanNvbi5mb3JtYXQpO1xuICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShqc29uLmZvcm1hdCwgICAgICAgIGxhYmVsZXIuZm9ybWF0dGVyLCAgICAgcGFyc2VEYXRhRm9ybWF0dGVyKGF4aXMudHlwZSgpKSwgICAgICAgICAgXCJmb3JtYXR0ZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUoanNvbi5zdGFydCwgICAgICAgICBsYWJlbGVyLnN0YXJ0LCAgICAgICAgIHBhcnNlRGF0YVZhbHVlKGF4aXMudHlwZSgpKSwgICAgICAgICAgICAgICAgICBcInN0YXJ0XCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUoanNvbi5hbmdsZSwgICAgICAgICBsYWJlbGVyLmFuZ2xlLCAgICAgICAgIHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFuZ2xlXCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUoanNvbi5wb3NpdGlvbiwgICAgICBsYWJlbGVyLnBvc2l0aW9uLCAgICAgIHBhcnNlSlNPTlBvaW50LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUoanNvbi5hbmNob3IsICAgICAgICBsYWJlbGVyLmFuY2hvciwgICAgICAgIHBhcnNlSlNPTlBvaW50LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFuY2hvclwiKTtcbiAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKGpzb24uZGVuc2l0eWZhY3RvciwgbGFiZWxlci5kZW5zaXR5ZmFjdG9yLCB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkZW5zaXR5ZmFjdG9yXCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUoanNvbi5jb2xvciwgICAgICAgICBsYWJlbGVyLmNvbG9yLCAgICAgICAgIFJHQkNvbG9yLnBhcnNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUoanNvbi5mb250LCAgICAgICAgICBsYWJlbGVyLmZvbnQsICAgICAgICAgIHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnRcIik7XG4gICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShqc29uLnZpc2libGUsICAgICAgIGxhYmVsZXIudmlzaWJsZSwgICAgICAgcEYucGFyc2VCb29sZWFuLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidmlzaWJsZVwiKTtcblxuICAgIH1cbiAgICByZXR1cm4gbGFiZWxlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGFiZWxlcjtcbiIsInZhciBMZWdlbmQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2xlZ2VuZC5qcycpO1xuXG4vLyBcImxlZ2VuZFwiIDoge1xuLy8gICAgIFwidmlzaWJsZVwiICAgICAgOiBcIkJPT0xFQU5cIixcbi8vICAgICBcImJhc2VcIiAgICAgICAgIDogXCJQT0lOVCgxLDEpXCIsXG4vLyAgICAgXCJhbmNob3JcIiAgICAgICA6IFwiUE9JTlQoMSwxKVwiLFxuLy8gICAgIFwicG9zaXRpb25cIiAgICAgOiBcIlBPSU5UKDAsMClcIixcbi8vICAgICBcImZyYW1lXCIgICAgICAgIDogXCJGUkFNRShwYWRkaW5nKVwiLFxuLy8gICAgIFwiY29sb3JcIiAgICAgICAgOiBcIkNPTE9SKHdoaXRlKVwiLFxuLy8gICAgIFwib3BhY2l0eVwiICAgICAgOiBcIkRPVUJMRSgxLjApXCIsXG4vLyAgICAgXCJib3JkZXJcIiAgICAgICA6IFwiSU5URUdFUigxKVwiLFxuLy8gICAgIFwiYm9yZGVyY29sb3JcIiAgOiBcIkNPTE9SKGJsYWNrKVwiLFxuLy8gICAgIFwicm93c1wiICAgICAgICAgOiBcIklOVEVHRVJcIixcbi8vICAgICBcImNvbHVtbnNcIiAgICAgIDogXCJJTlRFR0VSXCIsXG4vLyAgICAgXCJjb3JuZXJyYWRpdXNcIiA6IFwiSU5URUdFUigwKVwiLFxuLy8gICAgIFwicGFkZGluZ1wiICAgICAgOiBcIklOVEVHRVIoMClcIixcbi8vICAgICBcImljb25cIiA6IHtcbi8vICAgICAgIFwid2lkdGhcIiAgOiBcIklOVEVHRVIoNDApXCIsXG4vLyAgICAgICBcImhlaWdodFwiIDogXCJJTlRFR0VSKDMwKVwiLFxuLy8gICAgICAgXCJib3JkZXJcIiA6IFwiSU5URUdFUigxKVwiXG4vLyAgICAgfVxuLy8gfVxuTGVnZW5kLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgdmFyIGxlZ2VuZCAgICAgICAgICAgPSBuZXcgTGVnZW5kKCksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgUG9pbnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICAgICAgUkdCQ29sb3IgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgIFBvaW50ICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIEljb24gICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ljb24uanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBwYXJzZUpTT05Qb2ludCAgID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gbmV3IFBvaW50KHBbMF0sIHBbMV0pOyB9O1xuXG4gICAgcmVxdWlyZSgnLi9pY29uLmpzJyk7IC8vIGZvciBJY29uLnBhcnNlSlNPTiBiZWxvd1xuXG4gICAgaWYgKHR5cGVvZihqc29uKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbiwgbGVnZW5kLnZpc2libGUpO1xuICAgIH0gZWxzZSBpZiAoanNvbikge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnZpc2libGUsICAgICAgbGVnZW5kLnZpc2libGUsICAgICAgcEYucGFyc2VCb29sZWFuKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5iYXNlLCAgICAgICAgIGxlZ2VuZC5iYXNlLCAgICAgICAgIHBhcnNlSlNPTlBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5hbmNob3IsICAgICAgIGxlZ2VuZC5hbmNob3IsICAgICAgIHBhcnNlSlNPTlBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5wb3NpdGlvbiwgICAgIGxlZ2VuZC5wb3NpdGlvbiwgICAgIHBhcnNlSlNPTlBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5mcmFtZSwgICAgICAgIGxlZ2VuZC5mcmFtZSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uY29sb3IsICAgICAgICBsZWdlbmQuY29sb3IsICAgICAgICBSR0JDb2xvci5wYXJzZSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYm9yZGVyY29sb3IsICBsZWdlbmQuYm9yZGVyY29sb3IsICBSR0JDb2xvci5wYXJzZSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ub3BhY2l0eSwgICAgICBsZWdlbmQub3BhY2l0eSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYm9yZGVyLCAgICAgICBsZWdlbmQuYm9yZGVyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5yb3dzLCAgICAgICAgIGxlZ2VuZC5yb3dzKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5jb2x1bW5zLCAgICAgIGxlZ2VuZC5jb2x1bW5zKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5jb3JuZXJyYWRpdXMsIGxlZ2VuZC5jb3JuZXJyYWRpdXMpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnBhZGRpbmcsICAgICAgbGVnZW5kLnBhZGRpbmcpO1xuXG4gICAgICAgIGlmIChqc29uLmljb24pIHtcbiAgICAgICAgICAgIGxlZ2VuZC5pY29uKEljb24ucGFyc2VKU09OKGpzb24uaWNvbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlZ2VuZDtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgTXVsdGlncmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbXVsdGlncmFwaC5qcycpKCQpO1xuXG4gICAgLy8gaWYgcGFyc2VKU09OIG1ldGhvZCBhbHJlYWR5IGhhcyBiZWVuIGRlZmluZWQsIHdoaWNoIHdvdWxkIGJlIHRoZSBjYXNlIGlmIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBjYWxsZWQsIGp1c3QgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKHR5cGVvZihNdWx0aWdyYXBoLnBhcnNlSlNPTik9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIE11bHRpZ3JhcGg7IH07XG5cbiAgICBNdWx0aWdyYXBoLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBtdWdsLCBtZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB2YXIgbXVsdGlncmFwaCA9IG5ldyBNdWx0aWdyYXBoKCksXG4gICAgICAgICAgICBncmFwaHMgICAgID0gbXVsdGlncmFwaC5ncmFwaHMoKSxcbiAgICAgICAgICAgIEdyYXBoICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2dyYXBoLmpzJyksXG4gICAgICAgICAgICB2RiAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC92YWxpZGF0aW9uRnVuY3Rpb25zLmpzJyk7XG5cbiAgICAgICAgcmVxdWlyZSgnLi9ncmFwaC5qcycpKCQpOyAvLyBmb3IgR3JhcGgucGFyc2VKU09OIGJlbG93XG5cbiAgICAgICAgbXVsdGlncmFwaC5tdWdsKG11Z2wpOyAvLyBzZXQgdGhlIG11Z2wgdXJsXG4gICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24pID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAganNvbi5mb3JFYWNoKGZ1bmN0aW9uKGdyYXBoKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBocy5hZGQoIEdyYXBoLnBhcnNlSlNPTihncmFwaCwgbXVsdGlncmFwaCwgbWVzc2FnZUhhbmRsZXIpICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyYXBocy5hZGQoIEdyYXBoLnBhcnNlSlNPTihqc29uLCBtdWx0aWdyYXBoLCBtZXNzYWdlSGFuZGxlcikgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXVsdGlncmFwaDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE11bHRpZ3JhcGg7XG59O1xuIiwidmFyIFBhbiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGFuLmpzJyk7XG5cblBhbi5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbiwgdHlwZSkge1xuICAgIHZhciBwYW4gICAgICAgICAgICA9IG5ldyBQYW4oKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgdkYgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ZhbGlkYXRpb25GdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgcGFyc2VCb29sZWFuICAgPSBwRi5wYXJzZUJvb2xlYW4sXG4gICAgICAgIERhdGFWYWx1ZSAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIHBhcnNlRGF0YVZhbHVlID0gZnVuY3Rpb24odikgeyByZXR1cm4gRGF0YVZhbHVlLnBhcnNlKHR5cGUsIHYpOyB9O1xuICAgIGlmICh2Ri50eXBlT2YoanNvbikgPT09ICdib29sZWFuJykge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLCAgICAgICAgIHBhbi5hbGxvd2VkLCBwYXJzZUJvb2xlYW4pO1xuICAgIH0gZWxzZSBpZiAoanNvbikge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmFsbG93ZWQsIHBhbi5hbGxvd2VkLCBwYXJzZUJvb2xlYW4pO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm1pbiwgICAgIHBhbi5taW4sICAgICBwYXJzZURhdGFWYWx1ZSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubWF4LCAgICAgcGFuLm1heCwgICAgIHBhcnNlRGF0YVZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFuO1xuIiwidmFyIFBsb3QgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3Bsb3QuanMnKTtcblxuLy8gXCJwbG90XCIgOiB7XG4vLyAgIFwibGVnZW5kXCIgOiB7IFwidmlzaWJsZVwiOiBcIkJPT0xFQU5cIiwgXCJsYWJlbFwiOiBcIlNUUklOR1wiIH0sIFxuLy8gICBcImxlZ2VuZFwiIDogQk9PTEVBTixcbi8vICAgICAgICAgICAgICAgICAvL05POiAgXCJob3Jpem9udGFsYXhpc1wiIDoge1xuLy8gICAgICAgICAgICAgICAgIC8vTk86ICAgIFwicmVmXCIgOiBTVFJJTkchLFxuLy8gICAgICAgICAgICAgICAgIC8vTk86ICAgIFwidmFyaWFibGVzXCIgWyBTVFJJTkcsIC4uLiBdXG4vLyAgICAgICAgICAgICAgICAgLy9OTzogIH0sXG4vLyAgICAgICAgICAgICAgICAgLy9OTzogIFwidmVydGljYWxheGlzXCIgOiB7XG4vLyAgICAgICAgICAgICAgICAgLy9OTzogICAgXCJyZWZcIiA6IFNUUklORyEsXG4vLyAgICAgICAgICAgICAgICAgLy9OTzogICAgXCJ2YXJpYWJsZXNcIiBbIFNUUklORywgLi4uIF0sXG4vLyAgICAgICAgICAgICAgICAgLy9OTzogICAgXCJjb25zdGFudFwiIDogREFUQVZBTFVFXG4vLyAgICAgICAgICAgICAgICAgLy9OTzogIH0sXG4vLyBcbi8vICAgXCJob3Jpem9udGFsYXhpc1wiIDogQVhJUy1JRChzdHJpbmcpXG4vLyAgIFwiaG9yaXpvbnRhbGF4aXNcIiA6IFsgVkFSSUFCTEUtSUQoc3RyaW5nKSwgLi4uIF1cbi8vICAgXCJob3Jpem9udGFsYXhpc1wiIDogeyBBWElTLUlEKHN0cmluZyk6IFsgVkFSSUFCTEUtSUQoc3RyaW5nKSwgLi4uIF0gfVxuLy8gXG4vLyAgIFwidmVydGljYWxheGlzXCIgOiBbIFZBUklBQkxFLUlEKHN0cmluZyksIC4uLiBdXG4vLyAgIFwidmVydGljYWxheGlzXCIgOiB7IEFYSVMtSUQoc3RyaW5nKTogREFUQS1WQUxVRShudW1iZXIgb3Igc3RyaW5nKSB9ICAgICA8LS0gQ29uc3RhbnRQbG90XG4vLyAgIFwidmVydGljYWxheGlzXCIgOiB7IEFYSVMtSUQoc3RyaW5nKTogVkFSSUFCTEUtSUQoc3RyaW5nKSB9XG4vLyAgIFwidmVydGljYWxheGlzXCIgOiB7IEFYSVMtSUQoc3RyaW5nKTogWyBWQVJJQUJMRS1JRChzdHJpbmcpLCAuLi4gXSB9XG4vLyAgIFwidmVydGljYWxheGlzXCIgOiBEQVRBLVZBTFVFKG51bWJlciBvciBzdHJpbmcpICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gQ29uc3RhbnRQbG90XG4vLyAgIFwidmVydGljYWxheGlzXCIgOiBBWElTLUlEKHN0cmluZylcbi8vICAgXCJ2aXNpYmxlXCIgOiBCT09MRUFOKHRydWUpXG4vLyAgIFwicmVuZGVyZXJcIiA6IHtcbi8vICAgICBcInR5cGVcIiA6IFJFTkRFUkVSVFlQRShsaW5lKSxcbi8vICAgICBcIm9wdGlvbnNcIiA6IHtcbi8vICAgICAgICAgXCJvcHRpb24xXCI6IHZhbHVlMSxcbi8vICAgICAgICAgXCJvcHRpb24yXCI6IHZhbHVlMixcbi8vICAgICAgICAgXCJvcHRpb24zXCI6IFsgeyBcInZhbHVlXCI6IHZhbHVlMywgXCJtaW5cIjogREFUQVZBTFVFLCBcIm1heFwiIDogREFUQVZBTFVFIH0sIC4uIF1cbi8vICAgICAgICAgLi4uXG4vLyAgICAgfSxcbi8vICAgfSxcbi8vICAgXCJkYXRhdGlwc1wiIDoge1xuLy8gICAgIFwiZm9ybWF0XCIgICAgICAgICAgIDogU1RSSU5HISxcbi8vICAgICBcImJnY29sb3JcIiAgICAgICAgICA6IENPTE9SLFxuLy8gICAgIFwiYmdhbHBoYVwiICAgICAgICAgIDogRE9VQkxFLFxuLy8gICAgIFwiYm9yZGVyXCIgICAgICAgICAgIDogSU5URUdFUixcbi8vICAgICBcImJvcmRlcmNvbG9yXCIgICAgICA6IENPTE9SLFxuLy8gICAgIFwicGFkXCIgICAgICAgICAgICAgIDogSU5URUdFUixcbi8vICAgICBcInZhcmlhYmxlLWZvcm1hdHNcIiA6IFsgU1RSSU5HISwgLi4uIF1cbi8vICAgfVxuLy8gfVxuLy9cbi8vIEFsdGVybmF0ZWx5LCBpbnN0ZWFkIG9mIHRoZSBcInJlbmRlcmVyXCIgc2VjdGlvbiwgdGhlIFwicGxvdFwiIHNlY3Rpb24gbWF5IGluc3RlYWQgY29udGFpblxuLy8gdGhlIGZvbGxvd2luZyAoYXQgdGhlIHRvcCBsZXZlbCBvZiB0aGUgXCJwbG90XCIgb2JqZWN0KTpcbi8vIFxuLy8gICBcInN0eWxlXCIgOiBSRU5ERVJFUlRZUEUobGluZSksXG4vLyAgIFwib3B0aW9uc1wiIDoge1xuLy8gICAgICAgXCJvcHRpb24xXCI6IHZhbHVlMSxcbi8vICAgICAgIFwib3B0aW9uMlwiOiB2YWx1ZTIsXG4vLyAgICAgICBcIm9wdGlvbjNcIjogWyB7IFwidmFsdWVcIjogdmFsdWUzLCBcIm1pblwiOiBEQVRBVkFMVUUsIFwibWF4XCIgOiBEQVRBVkFMVUUgfSwgLi4gXVxuLy8gICAgICAgLi4uXG4vLyAgIH0sXG4vLyBcblBsb3QucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24sIGdyYXBoLCBtZXNzYWdlSGFuZGxlcikge1xuICAgIHZhciBEYXRhUGxvdCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3Bsb3QuanMnKSxcbiAgICAgICAgUGxvdExlZ2VuZCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGxvdF9sZWdlbmQuanMnKSxcbiAgICAgICAgQ29uc3RhbnRQbG90ICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29uc3RhbnRfcGxvdC5qcycpLFxuICAgICAgICBEYXRhVmFsdWUgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIERhdGVUaW1lVmFsdWUgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGV0aW1lX3ZhbHVlLmpzJyksXG4gICAgICAgIFJlbmRlcmVyICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3JlbmRlcmVyLmpzJyksXG4gICAgICAgIEZpbHRlciAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ZpbHRlci5qcycpLFxuICAgICAgICBDb25zZWN1dGl2ZURpc3RhbmNlRmlsdGVyID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb25zZWN1dGl2ZV9kaXN0YW5jZV9maWx0ZXIuanMnKSxcbiAgICAgICAgRGF0YXRpcHMgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YXRpcHMuanMnKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICB2RiAgICAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC92YWxpZGF0aW9uRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHBsb3QsXG4gICAgICAgIGhheGlzLFxuICAgICAgICB2YXhpcyxcbiAgICAgICAgdmFyaWFibGUsXG4gICAgICAgIGF0dHI7XG5cbiAgICAvLyBzbyB0aGF0IFBsb3RMZWdlbmQsUmVuZGVyZXIsRmlsdGVyLERhdGF0aXBzIHdpbGwgaGF2ZSAucGFyc2VKU09OIHdoZW4gY2FsbGVkIGJlbG93OlxuICAgIHJlcXVpcmUoJy4vcGxvdF9sZWdlbmQuanMnKTtcbiAgICByZXF1aXJlKCcuL3JlbmRlcmVyLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9maWx0ZXIuanMnKTtcbiAgICByZXF1aXJlKCcuL2RhdGF0aXBzLmpzJyk7XG5cbiAgICAvLyByZXR1cm4gdGhlIChmaXJzdCkga2V5IG9mIGFuIG9iamVjdDsgaW50ZW5kZWQgZm9yIGNvbnZlbmllbnQgZmV0Y2hpbmcgb2YgdGhlXG4gICAgLy8ga2V5IG5hbWUgb2YgYW4gb2JqZWN0ICh2ZXJ0aWNhbGF4aXMgb3IgaG9yaXpvbnRhbGF4aXMpIHRoYXQgY29udGFpbnMgb25seSBvbmUga2V5XG4gICAgZnVuY3Rpb24ga2V5KG9iaikge1xuICAgICAgICByZXR1cm4gKE9iamVjdC5rZXlzKG9iaikpWzBdO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB0aGUgbnVtYmVyIG9mIGtleXMgaW4gYW4gb2JqZWN0XG4gICAgZnVuY3Rpb24ga2V5Q291bnQob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZmYgdGhlIHZhbHVlIHYgbG9va3MgbGlrZSBhIGRhdGFfdmFsdWUgLS0gaS5lLiBpdCdzIGVpdGhlciBhIG51bWJlcixcbiAgICAvLyBvciBhIHN0cmluZyB0aGF0IGxvb2tzIGxpa2UgaXQgY291bGQgYmUgcGFyc2VkIGludG8gZWl0aGVyIGEgbnVtYmVyIG9yIGEgZGF0ZXRpbWUgdmFsdWUuXG4gICAgZnVuY3Rpb24gbG9va3NfbGlrZV9kYXRhX3ZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHZGLnR5cGVPZih2KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZGLnR5cGVPZih2KSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vICFpc05hTiBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIHRlc3Qgd2hldGhlciBhIHN0cmluZyByZXByZXNlbnRzIGEgdmFsaWQgbnVtYmVyXG4gICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3NTczOS9pcy10aGVyZS1hLWJ1aWx0LWluLXdheS1pbi1qYXZhc2NyaXB0LXRvLWNoZWNrLWlmLWEtc3RyaW5nLWlzLWEtdmFsaWQtbnVtYmVyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHYpKSB7ICBcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0cmluZyBpc24ndCBhIHZhbGlkIG51bWJlciwgdHJ5IHRvIHBhcnNlIGl0IGFzIGEgRGF0ZXRpbWVWYWx1ZVxuICAgICAgICAgICAgICAgIHRyeSB7IERhdGV0aW1lVmFsdWUucGFyc2Uodik7IH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChqc29uKSB7XG4gICAgICAgIHZhciB2YXJzID0ge1xuICAgICAgICAgICAgXCJob3Jpem9udGFsXCIgOiBbXSxcbiAgICAgICAgICAgIFwidmVydGljYWxcIiAgIDogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGF4aXNpZCA9IHtcbiAgICAgICAgICAgIFwiaG9yaXpvbnRhbFwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgXCJ2ZXJ0aWNhbFwiICAgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcblxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogWyBWQVJJQUJMRS1JRChzdHJpbmcpLCAuLi4gXVxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogeyBBWElTLUlEKHN0cmluZyk6IERBVEEtVkFMVUUobnVtYmVyIG9yIHN0cmluZykgfSAgICAgPC0tIENvbnN0YW50UGxvdFxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogeyBBWElTLUlEKHN0cmluZyk6IFZBUklBQkxFLUlEKHN0cmluZykgfVxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogeyBBWElTLUlEKHN0cmluZyk6IFsgVkFSSUFCTEUtSUQoc3RyaW5nKSwgLi4uIF0gfVxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogREFUQS1WQUxVRShudW1iZXIgb3Igc3RyaW5nKSAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tIENvbnN0YW50UGxvdFxuLy8gICBcInZlcnRpY2FsYXhpc1wiIDogQVhJUy1JRChzdHJpbmcpXG5cbiAgICAgICAgLy8gZGVhbCB3aXRoIHZlcnRpY2FsIGF4aXMgZmlyc3QsIGJlY2F1c2UgaXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHdlIGhhdmVcbiAgICAgICAgLy8gYSBDb25zdGFudFBsb3Qgb3IgYSBEYXRhUGxvdFxuICAgICAgICB2YXIgY29uc3RhbnRfdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChqc29uLnZlcnRpY2FsYXhpcykge1xuICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLnZlcnRpY2FsYXhpcykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGFuIGFycmF5LCBpdCdzIGEgbGlzdCBvZiB2YXJpYWJsZSBpZHMgZm9yIHRoZSBwbG90LFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgYXhpc2lkIGlzIHVuc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgdmFycy52ZXJ0aWNhbCA9IGpzb24udmVydGljYWxheGlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2Ri50eXBlT2YoanNvbi52ZXJ0aWNhbGF4aXMpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIGluIHRoZW9yeSB3ZSdkIGxpa2UgdG8gdmFsaWRhdGUgaGVyZSB0aGF0IHRoZSB2ZXJ0aWNhbCBheGlzIHR5cGUgaXMgTlVNQkVSLCBidXRcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCBkbyB0aGF0IGJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSB0aGUgYXhpcyB5ZXQgLS0gaXRzIGlkIGlzIGltcGxpZWRcbiAgICAgICAgICAgICAgICAvLyBzbyBpdCB3aWxsIGJlIGRldGVybWluZWQgbGF0ZXIuICBTbyB3ZSBzZXQgYSBudW1lcmljIGNvbnN0YW50IHZhbHVlIGFuZCBob3BlXG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBiZXN0LlxuICAgICAgICAgICAgICAgIGNvbnN0YW50X3ZhbHVlID0gRGF0YVZhbHVlLnBhcnNlKERhdGFWYWx1ZS5OVU1CRVIsIGpzb24udmVydGljYWxheGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodkYudHlwZU9mKGpzb24udmVydGljYWxheGlzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgc3RyaW5nIHRoYXQgaXMgZWl0aGVyIGFuIGF4aXMgaWQsIG9yIGEgRGF0ZXRpbWVWYWx1ZSBjb25zdGFudCAod2VcbiAgICAgICAgICAgICAgICAvLyBrbm93IGl0J3Mgbm90IGEgbnVtYmVyIGNvbnN0YW50LCBiZWNhdXNlIHRoYXQgd291bGQgaGF2ZSBiZWVuIGNhdWdodCBieVxuICAgICAgICAgICAgICAgIC8vIHRoZSAnbnVtYmVyJyBjYXNlIGFib3ZlKS5cbiAgICAgICAgICAgICAgICBpZiAobG9va3NfbGlrZV9kYXRhX3ZhbHVlKGpzb24udmVydGljYWxheGlzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZ2FpbiwgaW4gdGhlb3J5LCB3ZSdkIGxpa2UgdG8gdmFsaWRhdGUgdGhhdCB0aGUgYXhpcyB0eXBlIGlzIERhdGVUaW1lLFxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2UgY2FuJ3QgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoZSBheGlzIHlldC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRfdmFsdWUgPSBEYXRhVmFsdWUucGFyc2UoRGF0YVZhbHVlLkRBVEVUSU1FLCBqc29uLnZlcnRpY2FsYXhpcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpc2lkLnZlcnRpY2FsID0ganNvbi52ZXJ0aWNhbGF4aXM7XG4gICAgICAgICAgICAgICAgICAgIHZheGlzID0gZ3JhcGguYXhpc0J5SWQoYXhpc2lkLnZlcnRpY2FsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZih2YXhpcykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwbG90IHJlZmVycyB0byB1bmtub3duIHZlcnRpY2FsIGF4aXMgaWQ6IFwiICsgYXhpc2lkLnZlcnRpY2FsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodkYudHlwZU9mKGpzb24udmVydGljYWxheGlzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGFuIG9iamVjdCwgdGhlIGtleSBpcyB0aGUgYXhpcyBpZCwgYW5kIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIGlzIGVpdGhlcjpcbiAgICAgICAgICAgICAgICAvLyAgICBjYXNlIDE6IGFuIGFycmF5IG9mIHZhcmlhYmxlIGlkcywgb3JcbiAgICAgICAgICAgICAgICAvLyAgICBjYXNlIDI6IGEgc2luZ2xlIHZhbHVlIHRoYXQgaXMgZWl0aGVyIGFuIGF4aXMgaWQsIG9yXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICBhIGNvbnN0YW50IHZhbHVlIGZvciBhIGNvbnN0YW50IHBsb3RcbiAgICAgICAgICAgICAgICBpZiAoa2V5Q291bnQoanNvbi52ZXJ0aWNhbGF4aXMpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBsb3QudmVydGljYWxheGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gZXhhY3RseSBvbmUga2V5L3ZhbHVlIHBhaXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF4aXNpZC52ZXJ0aWNhbCA9IGtleShqc29uLnZlcnRpY2FsYXhpcyk7XG4gICAgICAgICAgICAgICAgdmF4aXMgPSBncmFwaC5heGlzQnlJZChheGlzaWQudmVydGljYWwpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YodmF4aXMpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwbG90IHJlZmVycyB0byB1bmtub3duIHZlcnRpY2FsIGF4aXMgaWQ6IFwiICsgYXhpc2lkLnZlcnRpY2FsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLnZlcnRpY2FsYXhpc1theGlzaWQudmVydGljYWxdKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF0pID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDE6IGFycmF5IG9mIHZhcmlhYmxlIGlkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMudmVydGljYWwgPSBqc29uLnZlcnRpY2FsYXhpc1theGlzaWQudmVydGljYWxdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAyOiBzaW5nbGUgdmFsdWUsIGVpdGhlciBheGlzIGlkLCBvciBjb25zdGFudCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgaWYgaXQncyBhIG51bWJlciwgaXQgbXVzdCBiZSBhIGNvbnN0YW50IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF0pID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXhpcy50eXBlKCkgIT09IERhdGFWYWx1ZS5OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3RhbnQgdmFsdWUgb2YgJ1wiICsganNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBcIicgbm90IGFwcHJvcHJpYXRlIGZvciBheGlzIG9mIHR5cGUgJ1wiICsgdmF4aXMudHlwZSgpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudF92YWx1ZSA9IERhdGFWYWx1ZS5wYXJzZShEYXRhVmFsdWUuTlVNQkVSLCBqc29uLnZlcnRpY2FsYXhpc1theGlzaWQudmVydGljYWxdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3QgYSBudW1iZXIsIHNvIGl0IG11c3QgYmUgYSBzdHJpbmcgdGhhdCBpcyBlaXRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGNvbnN0YW50IERhdGV0aW1lVmFsdWUsIG9yIGFuIGF4aXMgaWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLnZlcnRpY2FsYXhpc1theGlzaWQudmVydGljYWxdKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgZm9yIGtleSAnXCIgKyBheGlzaWQudmVydGljYWwgKyBcIicgZm9yIHZlcnRpY2FsYXhpcyBpcyBvZiB3cm9uZyB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9va3NfbGlrZV9kYXRhX3ZhbHVlKGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50X3ZhbHVlID0gRGF0YVZhbHVlLnBhcnNlKHZheGlzLnR5cGUoKSwganNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFycy52ZXJ0aWNhbCA9IFsganNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25zdGFudF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwbG90ID0gbmV3IENvbnN0YW50UGxvdChjb25zdGFudF92YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbG90ID0gbmV3IERhdGFQbG90KCk7XG4gICAgICAgIH1cblxuICAgICAgICBwbG90LnZlcnRpY2FsYXhpcyh2YXhpcyk7XG5cbiAgICAgICAgLy8gICBcImhvcml6b250YWxheGlzXCIgOiBBWElTLUlEKHN0cmluZylcbiAgICAgICAgLy8gICBcImhvcml6b250YWxheGlzXCIgOiBbIFZBUklBQkxFLUlEKHN0cmluZyksIC4uLiBdXG4gICAgICAgIC8vICAgXCJob3Jpem9udGFsYXhpc1wiIDogeyBBWElTLUlEKHN0cmluZyk6IFsgVkFSSUFCTEUtSUQoc3RyaW5nKSwgLi4uIF0gfVxuICAgICAgICBpZiAoanNvbi5ob3Jpem9udGFsYXhpcykge1xuICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLmhvcml6b250YWxheGlzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgYW4gYXJyYXksIGl0J3MgYSBsaXN0IG9mIHZhcmlhYmxlIGlkcyBmb3IgdGhlIHBsb3QsXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBheGlzaWQgaXMgdW5zcGVjaWZpZWRcbiAgICAgICAgICAgICAgICB2YXJzLmhvcml6b250YWwgPSBqc29uLmhvcml6b250YWxheGlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2Ri50eXBlT2YoanNvbi5ob3Jpem9udGFsYXhpcykgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYXhpc2lkLmhvcml6b250YWwgPSBqc29uLmhvcml6b250YWxheGlzO1xuICAgICAgICAgICAgICAgIGhheGlzID0gZ3JhcGguYXhpc0J5SWQoYXhpc2lkLmhvcml6b250YWwpO1xuICAgICAgICAgICAgICAgIGlmIChoYXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QuaG9yaXpvbnRhbGF4aXMoaGF4aXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgSG9yaXpvbnRhbCBBeGlzIEVycm9yOiBUaGUgZ3JhcGggZG9lcyBub3QgY29udGFpbiBhbiBheGlzIHdpdGggYW4gaWQgb2YgJ1wiICsgYXhpc2lkLmhvcml6b250YWwgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2Ri50eXBlT2YoanNvbi5ob3Jpem9udGFsYXhpcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbiBvYmplY3QsIHRoZSBrZXkgaXMgdGhlIGF4aXMgaWQsIGFuZCB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyBpcyBlaXRoZXI6XG4gICAgICAgICAgICAgICAgLy8gICAgY2FzZSAxOiBhbiBhcnJheSBvZiB2YXJpYWJsZSBpZHMsIG9yXG4gICAgICAgICAgICAgICAgLy8gICAgY2FzZSAyOiBhbiBheGlzIGlkXG4gICAgICAgICAgICAgICAgaWYgKGtleUNvdW50KGpzb24uaG9yaXpvbnRhbGF4aXMpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBsb3QuaG9yaXpvbnRhbGF4aXMgb2JqZWN0IG11c3QgY29udGFpbiBleGFjdGx5IG9uZSBrZXkvdmFsdWUgcGFpclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXhpc2lkLmhvcml6b250YWwgPSBrZXkoanNvbi5ob3Jpem9udGFsYXhpcyk7XG4gICAgICAgICAgICAgICAgaGF4aXMgPSBncmFwaC5heGlzQnlJZChheGlzaWQuaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICAgICAgaWYgKGhheGlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxvdC5ob3Jpem9udGFsYXhpcyhoYXhpcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxvdCBIb3Jpem9udGFsIEF4aXMgRXJyb3I6IFRoZSBncmFwaCBkb2VzIG5vdCBjb250YWluIGFuIGF4aXMgd2l0aCBhbiBpZCBvZiAnXCIgKyBheGlzaWQuaG9yaXpvbnRhbCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLmhvcml6b250YWxheGlzW2F4aXNpZC5ob3Jpem9udGFsXSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLmhvcml6b250YWxheGlzW2F4aXNpZC5ob3Jpem9udGFsXSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMTogYXJyYXkgb2YgdmFyaWFibGUgaWRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFycy5ob3Jpem9udGFsID0ganNvbi5ob3Jpem9udGFsYXhpc1theGlzaWQuaG9yaXpvbnRhbF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDI6IGFuIGF4aXMgaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIGEgc3RyaW5nIHRoYXQgaXMgYW4gYXhpcyBpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24uaG9yaXpvbnRhbGF4aXNbYXhpc2lkLmhvcml6b250YWxdKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgZm9yIGtleSAnXCIgKyBheGlzaWQuaG9yaXpvbnRhbCArIFwiJyBmb3IgaG9yaXpvbnRhbGF4aXMgaXMgb2Ygd3JvbmcgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJzLmhvcml6b250YWwgPSBbIGpzb24uaG9yaXpvbnRhbGF4aXNbYXhpc2lkLmhvcml6b250YWxdIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgRGF0YVBsb3QsIHBhcnNlIHZhcmlhYmxlc1xuICAgICAgICBpZiAocGxvdCBpbnN0YW5jZW9mIERhdGFQbG90KSB7XG5cbiAgICAgICAgICAgIC8vIHByb3ZpZGUgZGVmYXVsdCBob3Jpem9udGFsYXhpcyB2YXJpYWJsZSBpZiBub25lIHByZXNlbnRcbiAgICAgICAgICAgIGlmICh2YXJzLmhvcml6b250YWwubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBwbG90LnZhcmlhYmxlKCkuYWRkKG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1RPRE86IGRlZmVyIHBvcHVsYXRpb24gb2YgdmFyaWFibGVzIHVudGlsIG5vcm1hbGl6ZXIgaGFzIGV4ZWN1dGVkXG4gICAgICAgICAgICAvLyBwb3B1bGF0ZSBheGlzIHZhcmlhYmxlc1xuICAgICAgICAgICAgaWYgKGdyYXBoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsbHZhcnMgPSBbXS5jb25jYXQodmFycy5ob3Jpem9udGFsLCB2YXJzLnZlcnRpY2FsKTtcbiAgICAgICAgICAgICAgICBhbGx2YXJzLmZvckVhY2goZnVuY3Rpb24odmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gZ3JhcGgudmFyaWFibGVCeUlkKHZpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbG90LmRhdGEoIHZhcmlhYmxlLmRhdGEoKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC52YXJpYWJsZSgpLmFkZCh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbG90IFZhcmlhYmxlIEVycm9yOiBObyBEYXRhIHRhZyBjb250YWlucyBhIHZhcmlhYmxlIHdpdGggYW4gaWQgb2YgJ1wiICsgdmlkICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG5cblxuXG4vL3h4eCAgICAgICAgLy8gcG9wdWxhdGUgdmVydGljYWxheGlzXG4vL3h4eCAgICAgICAgaWYgKGpzb24udmVydGljYWxheGlzKSB7XG4vL3h4eCAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi52ZXJ0aWNhbGF4aXMpID09PSAnc3RyaW5nJykge1xuLy94eHggICAgICAgICAgICAgICAgYXhpc2lkLnZlcnRpY2FsID0ganNvbi52ZXJ0aWNhbGF4aXM7XG4vL3h4eCAgICAgICAgICAgIH0gZWxzZSB7XG4vL3h4eCAgICAgICAgICAgICAgICBpZiAoa2V5Q291bnQoanNvbi52ZXJ0aWNhbGF4aXMpICE9PSAxKSB7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGxvdC52ZXJ0aWNhbGF4aXMgbXVzdCBjb250YWluIGV4YWN0bHkgb25lIGtleS92YWx1ZSBwYWlyXCIpO1xuLy94eHggICAgICAgICAgICAgICAgfVxuLy94eHggICAgICAgICAgICAgICAgYXhpc2lkLnZlcnRpY2FsID0ga2V5KGpzb24udmVydGljYWxheGlzKTtcbi8veHh4ICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbi8veHh4ICAgICAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF0pID09PSAnYXJyYXknKSB7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMudmVydGljYWwgPSBqc29uLnZlcnRpY2FsYXhpc1theGlzaWQudmVydGljYWxdO1xuLy94eHggICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMudmVydGljYWwgPSBbIGpzb24udmVydGljYWxheGlzW2F4aXNpZC52ZXJ0aWNhbF0gXTtcbi8veHh4ICAgICAgICAgICAgICAgICAgICB9XG4vL3h4eCAgICAgICAgICAgICAgICB9XG4vL3h4eCAgICAgICAgICAgIH1cbi8veHh4ICAgICAgICAgICAgdmF4aXMgPSBncmFwaC5heGlzQnlJZChheGlzaWQudmVydGljYWwpO1xuLy94eHggICAgICAgICAgICBpZiAodmF4aXMgPT09IHVuZGVmaW5lZCkge1xuLy94eHggICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxvdCBWZXJ0aWNhbCBBeGlzIEVycm9yOiBUaGUgZ3JhcGggZG9lcyBub3QgY29udGFpbiBhbiBheGlzIHdpdGggYW4gaWQgb2YgJ1wiICsgYXhpc2lkLnZlcnRpY2FsICsgXCInXCIpO1xuLy94eHggICAgICAgICAgICB9XG4vL3h4eCAgICAgICAgfVxuLy94eHhcbi8veHh4XG4vL3h4eC8vICAgICAgICAvLyBwb3B1bGF0ZSB2ZXJ0aWNhbGF4aXNcbi8veHh4Ly8gICAgICAgIGlmIChqc29uLnZlcnRpY2FsYXhpcyAmJiBqc29uLnZlcnRpY2FsYXhpcy5yZWYpIHtcbi8veHh4Ly8gICAgICAgICAgICB2YXhpcyA9IGdyYXBoLmF4aXNCeUlkKGpzb24udmVydGljYWxheGlzLnJlZik7XG4vL3h4eC8vICAgICAgICAgICAgaWYgKHZheGlzID09PSB1bmRlZmluZWQpIHtcbi8veHh4Ly8gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxvdCBWZXJ0aWNhbCBBeGlzIEVycm9yOiBUaGUgZ3JhcGggZG9lcyBub3QgY29udGFpbiBhbiBheGlzIHdpdGggYW4gaWQgb2YgJ1wiICsganNvbi52ZXJ0aWNhbGF4aXMucmVmICsgXCInXCIpO1xuLy94eHgvLyAgICAgICAgICAgIH1cbi8veHh4Ly8gICAgICAgIH1cbi8veHh4XG4vL3h4eCAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB2ZXJ0aWNhbGF4aXMgb2JqZWN0LCBhbmQgaWYgdGhlIHZhbHVlIGl0IGNvbnRhaW5zIGxvb2tzIGxpa2UgYVxuLy94eHggICAgICAgIC8vIG51bWJlciBvciBkYXRldGltZSB2YWx1ZSwgYXNzdW1lIGl0J3MgYSBDb25zdGFudCBQbG90LiAgT3RoZXJ3aXNlIGFzc3VtZSB0aGVcbi8veHh4ICAgICAgICAvLyB2YWx1ZSBpcyBlaXRoZXIgYSB2YXJpYWJsZSBpZCwgb3IgYSBsaXN0IG9mIHZhcmlhYmxlIGlkcywgc28gd2UgaGF2ZSBhIERhdGEgUGxvdC5cbi8veHh4ICAgICAgICBpZiAoKHZGLnR5cGVPZihqc29uLnZlcnRpY2FsYXhpcykgPT09ICdvYmplY3QnKSAmJiBsb29rc19saWtlX2RhdGFfdmFsdWUoanNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXSkpIHtcbi8veHh4ICAgICAgICAgICAgcGxvdCA9IG5ldyBDb25zdGFudFBsb3QoRGF0YVZhbHVlLnBhcnNlKHZheGlzLnR5cGUoKSwganNvbi52ZXJ0aWNhbGF4aXNbYXhpc2lkLnZlcnRpY2FsXSkpO1xuLy94eHggICAgICAgIH0gZWxzZSB7XG4vL3h4eCAgICAgICAgICAgIHBsb3QgPSBuZXcgRGF0YVBsb3QoKTtcbi8veHh4ICAgICAgICB9XG4vL3h4eFxuLy94eHgvLyAgICAgICAgaWYgKGpzb24udmVydGljYWxheGlzICYmIGpzb24udmVydGljYWxheGlzLmNvbnN0YW50KSB7XG4vL3h4eC8vICAgICAgICAgICAgcGxvdCA9IG5ldyBDb25zdGFudFBsb3QoRGF0YVZhbHVlLnBhcnNlKHZheGlzLnR5cGUoKSwganNvbi52ZXJ0aWNhbGF4aXMuY29uc3RhbnQpKTtcbi8veHh4Ly8gICAgICAgIH0gZWxzZSB7XG4vL3h4eC8vICAgICAgICAgICAgcGxvdCA9IG5ldyBEYXRhUGxvdCgpO1xuLy94eHgvLyAgICAgICAgfVxuLy94eHhcbi8veHh4ICAgICAgICBwbG90LnZlcnRpY2FsYXhpcyh2YXhpcyk7XG4vL3h4eFxuLy94eHggICAgICAgIC8vIHBvcHVsYXRlIGhvcml6b250YWxheGlzXG4vL3h4eCAgICAgICAgaWYgKGpzb24uaG9yaXpvbnRhbGF4aXMpIHtcbi8veHh4ICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLmhvcml6b250YWxheGlzKSA9PT0gJ3N0cmluZycpIHtcbi8veHh4ICAgICAgICAgICAgICAgIGF4aXNpZC5ob3Jpem9udGFsID0ganNvbi5ob3Jpem9udGFsYXhpcztcbi8veHh4ICAgICAgICAgICAgfSBlbHNlIHtcbi8veHh4ICAgICAgICAgICAgICAgIGlmIChrZXlDb3VudChqc29uLmhvcml6b250YWxheGlzKSAhPT0gMSkge1xuLy94eHggICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBsb3QuaG9yaXpvbnRhbGF4aXMgbXVzdCBjb250YWluIGV4YWN0bHkgb25lIGtleS92YWx1ZSBwYWlyXCIpO1xuLy94eHggICAgICAgICAgICAgICAgfVxuLy94eHggICAgICAgICAgICAgICAgYXhpc2lkLmhvcml6b250YWwgPSBrZXkoanNvbi5ob3Jpem9udGFsYXhpcyk7XG4vL3h4eCAgICAgICAgICAgICAgICBpZiAodkYudHlwZU9mKGpzb24uaG9yaXpvbnRhbGF4aXNbYXhpc2lkLmhvcml6b250YWxdKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuLy94eHggICAgICAgICAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi5ob3Jpem9udGFsYXhpc1theGlzaWQuaG9yaXpvbnRhbF0pID09PSAnYXJyYXknKSB7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuaG9yaXpvbnRhbCA9IGpzb24uaG9yaXpvbnRhbGF4aXNbYXhpc2lkLmhvcml6b250YWxdO1xuLy94eHggICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuaG9yaXpvbnRhbCA9IFsganNvbi5ob3Jpem9udGFsYXhpc1theGlzaWQuaG9yaXpvbnRhbF0gXTtcbi8veHh4ICAgICAgICAgICAgICAgICAgICB9XG4vL3h4eCAgICAgICAgICAgICAgICB9XG4vL3h4eCAgICAgICAgICAgICAgICBoYXhpcyA9IGdyYXBoLmF4aXNCeUlkKGF4aXNpZC5ob3Jpem9udGFsKTtcbi8veHh4ICAgICAgICAgICAgICAgIGlmIChoYXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgcGxvdC5ob3Jpem9udGFsYXhpcyhoYXhpcyk7XG4vL3h4eCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuLy94eHggICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgSG9yaXpvbnRhbCBBeGlzIEVycm9yOiBUaGUgZ3JhcGggZG9lcyBub3QgY29udGFpbiBhbiBheGlzIHdpdGggYW4gaWQgb2YgJ1wiICsgYXhpc2lkLmhvcml6b250YWwgKyBcIidcIik7XG4vL3h4eCAgICAgICAgICAgICAgICB9XG4vL3h4eCAgICAgICAgICAgIH1cbi8veHh4ICAgICAgICB9XG4vL3h4eFxuLy94eHgvLyAgICAgICAgaWYgKGpzb24uaG9yaXpvbnRhbGF4aXMgJiYganNvbi5ob3Jpem9udGFsYXhpcy5yZWYpIHtcbi8veHh4Ly8gICAgICAgICAgICBoYXhpcyA9IGdyYXBoLmF4aXNCeUlkKGpzb24uaG9yaXpvbnRhbGF4aXMucmVmKTtcbi8veHh4Ly8gICAgICAgICAgICBpZiAoaGF4aXMgIT09IHVuZGVmaW5lZCkge1xuLy94eHgvLyAgICAgICAgICAgICAgICBwbG90Lmhvcml6b250YWxheGlzKGhheGlzKTtcbi8veHh4Ly8gICAgICAgICAgICB9IGVsc2Uge1xuLy94eHgvLyAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbG90IEhvcml6b250YWwgQXhpcyBFcnJvcjogVGhlIGdyYXBoIGRvZXMgbm90IGNvbnRhaW4gYW4gYXhpcyB3aXRoIGFuIGlkIG9mICdcIiArIGpzb24uaG9yaXpvbnRhbGF4aXMucmVmICsgXCInXCIpO1xuLy94eHgvLyAgICAgICAgICAgIH1cbi8veHh4Ly8gICAgICAgIH1cbi8veHh4XG4vL3h4eCAgICAgICAgLy8gaWYgdGhpcyBpcyBhIERhdGFQbG90LCBwYXJzZSB2YXJpYWJsZXNcbi8veHh4ICAgICAgICBpZiAocGxvdCBpbnN0YW5jZW9mIERhdGFQbG90KSB7XG4vL3h4eFxuLy94eHggICAgICAgICAgICAvLyBwcm92aWRlIGRlZmF1bHQgaG9yaXpvbnRhbGF4aXMgdmFyaWFibGUgaWYgbm9uZSBwcmVzZW50XG4vL3h4eCAgICAgICAgICAgIGlmICh2YXJzLmhvcml6b250YWwubGVuZ3RoID09IDApIHtcbi8veHh4ICAgICAgICAgICAgICAgIHBsb3QudmFyaWFibGUoKS5hZGQobnVsbCk7XG4vL3h4eCAgICAgICAgICAgIH1cbi8veHh4XG4vL3h4eCAgICAgICAgICAgIC8vVE9ETzogZGVmZXIgcG9wdWxhdGlvbiBvZiB2YXJpYWJsZXMgdW50aWwgbm9ybWFsaXplciBoYXMgZXhlY3V0ZWRcbi8veHh4ICAgICAgICAgICAgLy8gcG9wdWxhdGUgYXhpcyB2YXJpYWJsZXNcbi8veHh4ICAgICAgICAgICAgaWYgKGdyYXBoKSB7XG4vL3h4eCAgICAgICAgICAgICAgICB2YXIgYWxsdmFycyA9IFtdLmNvbmNhdCh2YXJzLmhvcml6b250YWwsIHZhcnMudmVydGljYWwpO1xuLy94eHggICAgICAgICAgICAgICAgYWxsdmFycy5mb3JFYWNoKGZ1bmN0aW9uKHZpZCkge1xuLy94eHggICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gZ3JhcGgudmFyaWFibGVCeUlkKHZpZCk7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlICE9PSB1bmRlZmluZWQpIHtcbi8veHh4ICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5kYXRhKCB2YXJpYWJsZS5kYXRhKCkgKTtcbi8veHh4ICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC52YXJpYWJsZSgpLmFkZCh2YXJpYWJsZSk7XG4vL3h4eCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbi8veHh4ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxvdCBWYXJpYWJsZSBFcnJvcjogTm8gRGF0YSB0YWcgY29udGFpbnMgYSB2YXJpYWJsZSB3aXRoIGFuIGlkIG9mICdcIiArIHZpZCArIFwiJ1wiKTtcbi8veHh4ICAgICAgICAgICAgICAgICAgICB9XG4vL3h4eCAgICAgICAgICAgICAgICB9KTtcbi8veHh4ICAgICAgICAgICAgfVxuLy94eHggICAgICAgIH1cblxuXG5cbi8vICAgICAgICAvLyBpZiB0aGlzIGlzIGEgRGF0YVBsb3QsIHBhcnNlIHZhcmlhYmxlc1xuLy8gICAgICAgIGlmIChwbG90IGluc3RhbmNlb2YgRGF0YVBsb3QpIHtcbi8vICAgICAgICAgICAgLy8gcHJvdmlkZSBkZWZhdWx0IGhvcml6b250YWxheGlzIHZhcmlhYmxlIGlmIG5vdCBwcmVzZW50XG4vLyAgICAgICAgICAgIGlmICghanNvbi5ob3Jpem9udGFsYXhpcyB8fCAhanNvbi5ob3Jpem9udGFsYXhpcy52YXJpYWJsZXMgfHwganNvbi5ob3Jpem9udGFsYXhpcy52YXJpYWJsZXMubGVuZ3RoID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICBwbG90LnZhcmlhYmxlKCkuYWRkKG51bGwpO1xuLy8gICAgICAgICAgICB9XG4vL1xuLy8gICAgICAgICAgICAvL1RPRE86IGRlZmVyIHBvcHVsYXRpb24gb2YgdmFyaWFibGVzIHVudGlsIG5vcm1hbGl6ZXIgaGFzIGV4ZWN1dGVkXG4vLyAgICAgICAgICAgIC8vIHBvcHVsYXRlIGF4aXMgdmFyaWFibGVzXG4vLyAgICAgICAgICAgIHZhciB2YXJzID0gW107XG4vLyAgICAgICAgICAgIGlmIChncmFwaCkge1xuLy8gICAgICAgICAgICAgICAgaWYgKGpzb24uaG9yaXpvbnRhbGF4aXMgJiYganNvbi5ob3Jpem9udGFsYXhpcy52YXJpYWJsZXMpIHtcbi8vICAgICAgICAgICAgICAgICAgICB2YXJzID0gdmFycy5jb25jYXQoanNvbi5ob3Jpem9udGFsYXhpcy52YXJpYWJsZXMpO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgaWYgKGpzb24udmVydGljYWxheGlzICYmIGpzb24udmVydGljYWxheGlzLnZhcmlhYmxlcykge1xuLy8gICAgICAgICAgICAgICAgICAgIHZhcnMgPSB2YXJzLmNvbmNhdChqc29uLnZlcnRpY2FsYXhpcy52YXJpYWJsZXMpO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgdmFycy5mb3JFYWNoKGZ1bmN0aW9uKHZpZCkge1xuLy8gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gZ3JhcGgudmFyaWFibGVCeUlkKHZpZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlICE9PSB1bmRlZmluZWQpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5kYXRhKCB2YXJpYWJsZS5kYXRhKCkgKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC52YXJpYWJsZSgpLmFkZCh2YXJpYWJsZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxvdCBWYXJpYWJsZSBFcnJvcjogTm8gRGF0YSB0YWcgY29udGFpbnMgYSB2YXJpYWJsZSB3aXRoIGFuIGlkIG9mICdcIiArIHZpZCArIFwiJ1wiKTtcbi8vICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgfVxuLy8gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJsZWdlbmRcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICBwbG90LmxlZ2VuZChQbG90TGVnZW5kLnBhcnNlSlNPTihqc29uLmxlZ2VuZCwgcGxvdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGxvdC5sZWdlbmQoUGxvdExlZ2VuZC5wYXJzZUpTT04odW5kZWZpbmVkLCBwbG90KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKFwicmVuZGVyZXJcIiBpbiBqc29uKSAmJiAoKFwic3R5bGVcIiBpbiBqc29uKSB8fCAoXCJvcHRpb25zXCIgaW4ganNvbikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwbG90IG1heSBub3QgY29udGFpbiBib3RoICdyZW5kZXJlcicgYW5kICdzdHlsZScsIG9yICdyZW5kZXJlcicgYW5kICdvcHRpb25zJ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqc29uLnZpc2libGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGxvdC52aXNpYmxlKGpzb24udmlzaWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJyZW5kZXJlclwiIGluIGpzb24pIHtcbiAgICAgICAgICAgIHBsb3QucmVuZGVyZXIoUmVuZGVyZXIucGFyc2VKU09OKGpzb24ucmVuZGVyZXIsIHBsb3QsIG1lc3NhZ2VIYW5kbGVyKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJzdHlsZVwiIGluIGpzb24pIHtcbiAgICAgICAgICAgIC8vIGpzb24ub3B0aW9ucyBtYXkgb3IgbWF5IG5vdCBiZSBwcmVzZW50IGhlcmVcbiAgICAgICAgICAgIHBsb3QucmVuZGVyZXIoUmVuZGVyZXIucGFyc2VKU09OKFxuICAgICAgICAgICAgICAgIHsgXCJ0eXBlXCIgOiBqc29uLnN0eWxlLCBcIm9wdGlvbnNcIiA6IGpzb24ub3B0aW9ucyB9LFxuICAgICAgICAgICAgICAgIHBsb3QsIG1lc3NhZ2VIYW5kbGVyKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJvcHRpb25zXCIgaW4ganNvbikge1xuICAgICAgICAgICAgLy8ganNvbi5vcHRpb25zIGlzIHByZXNlbnQsIGJ1dCBqc29uLnN0eWxlIGlzIG5vdCBoZXJlXG4gICAgICAgICAgICAvLyBqc29uLm9wdGlvbnMgbWF5IG9yIG1heSBub3QgYmUgcHJlc2VudCBoZXJlXG4gICAgICAgICAgICBwbG90LnJlbmRlcmVyKFJlbmRlcmVyLnBhcnNlSlNPTihcbiAgICAgICAgICAgICAgICB7IFwidHlwZVwiIDogXCJsaW5lXCIsIFwib3B0aW9uc1wiIDoganNvbi5vcHRpb25zIH0sXG4gICAgICAgICAgICAgICAgcGxvdCwgbWVzc2FnZUhhbmRsZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcImZpbHRlclwiIGluIGpzb24pIHtcbiAgICAgICAgICAgIGlmICh2Ri50eXBlT2YoanNvbi5maWx0ZXIpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mKGpzb24uZmlsdGVyLnR5cGUpICE9PSAndW5kZWZpbmVkJykgJiYgKGpzb24uZmlsdGVyLnR5cGUgIT09ICdjb25zZWN1dGl2ZWRpc3RhbmNlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGZpbHRlciB0eXBlOiAnICsganNvbi5maWx0ZXIudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBsb3QucmVuZGVyZXIoKS5maWx0ZXIobmV3IENvbnNlY3V0aXZlRGlzdGFuY2VGaWx0ZXIoanNvbi5maWx0ZXIpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodkYudHlwZU9mKGpzb24uZmlsdGVyKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncmFwaCAmJiBncmFwaC5maWx0ZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5yZW5kZXJlcigpLmZpbHRlcihncmFwaC5maWx0ZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbG90LnJlbmRlcmVyKCkuZmlsdGVyKG5ldyBDb25zZWN1dGl2ZURpc3RhbmNlRmlsdGVyKHt9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWx0ZXIgcHJvcGVydHk6ICcgKyBqc29uLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JhcGggJiYgZ3JhcGguZmlsdGVyKCkpIHtcbiAgICAgICAgICAgIHBsb3QucmVuZGVyZXIoKS5maWx0ZXIoZ3JhcGguZmlsdGVyKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwiZGF0YXRpcHNcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICBwbG90LmRhdGF0aXBzKERhdGF0aXBzLnBhcnNlSlNPTihqc29uLmRhdGF0aXBzKSk7XG4gICAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gcGxvdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGxvdDtcbiIsInZhciBQbG90TGVnZW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wbG90X2xlZ2VuZC5qcycpO1xuXG4vLyBcImxlZ2VuZFwiIDogeyBcInZpc2libGVcIiA6IEJPT0xFQU4sICBcImxhYmVsXCIgOiBcIlNUUklOR1wiIH1cbi8vIEJPT0xFQU5cblBsb3RMZWdlbmQucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24sIHBsb3QpIHtcbiAgICB2YXIgbGVnZW5kICAgICAgICAgICA9IG5ldyBQbG90TGVnZW5kKCksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgVGV4dCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdGV4dC5qcycpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIGNoaWxkO1xuICAgIGlmICh0eXBlb2YoanNvbikgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGxlZ2VuZC52aXNpYmxlKGpzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnZpc2libGUsIGxlZ2VuZC52aXNpYmxlLCBwRi5wYXJzZUJvb2xlYW4pO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5sYWJlbCwgICBsZWdlbmQubGFiZWwsICAgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgVGV4dCh2YWx1ZSk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsZWdlbmQubGFiZWwoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIHVnbHkgcGF0Y2ggd2l0aCBzb21ldGhpbmcgdGhhdCB3b3JrcyBwcm9wZXJseVxuICAgICAgICBpZiAodHlwZW9mKHBsb3QudmFyaWFibGUpPT09XCJmdW5jdGlvblwiICYmIHBsb3QudmFyaWFibGUoKS5zaXplKCkgPj0gMikgeyBcbiAgICAgICAgICAgIGxlZ2VuZC5sYWJlbChuZXcgVGV4dChwbG90LnZhcmlhYmxlKCkuYXQoMSkuaWQoKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVnZW5kLmxhYmVsKG5ldyBUZXh0KFwicGxvdFwiKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGVnZW5kO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbG90TGVnZW5kO1xuIiwidmFyIFBsb3RhcmVhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wbG90YXJlYS5qcycpO1xuXG4vLyAgXCJwbG90YXJlYVwiIDoge1xuLy8gICAgIFwibWFyZ2luYm90dG9tXCI6IElOVEVHRVIoMzUpLFxuLy8gICAgIFwibWFyZ2lubGVmdFwiOiBJTlRFR0VSKDM4KSxcbi8vICAgICBcIm1hcmdpbnRvcFwiOiBJTlRFR0VSKDEwKSxcbi8vICAgICBcIm1hcmdpbnJpZ2h0XCI6IElOVEVHRVIoMzUpLFxuLy8gICAgIFwiYm9yZGVyXCI6IElOVEVHRVIoMCksXG4vLyAgICAgXCJib3JkZXJjb2xvclwiOiBDT0xPUigweGVlZWVlZSksXG4vLyAgICAgXCJjb2xvclwiOiBDT0xPUixcbi8vICB9XG5QbG90YXJlYS5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciBwbG90YXJlYSA9IG5ldyBQbG90YXJlYSgpLFxuICAgICAgICBtYXJnaW4gPSBwbG90YXJlYS5tYXJnaW4oKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgcGFyc2VSR0JDb2xvciAgICA9IFJHQkNvbG9yLnBhcnNlLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlSW50ZWdlciAgICAgPSBwRi5wYXJzZUludGVnZXI7XG4gICAgaWYgKGpzb24pIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5tYXJnaW5ib3R0b20sIG1hcmdpbi5ib3R0b20pO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm1hcmdpbmxlZnQsICAgbWFyZ2luLmxlZnQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm1hcmdpbnRvcCwgICAgbWFyZ2luLnRvcCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24ubWFyZ2lucmlnaHQsICBtYXJnaW4ucmlnaHQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJvcmRlciwgICAgICAgcGxvdGFyZWEuYm9yZGVyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5jb2xvciwgICAgICAgIHBsb3RhcmVhLmNvbG9yLCAgICAgICBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5ib3JkZXJjb2xvciwgIHBsb3RhcmVhLmJvcmRlcmNvbG9yLCBwYXJzZVJHQkNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHBsb3RhcmVhO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbG90YXJlYTtcbiIsInZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcmVuZGVyZXIuanMnKTtcblxuLy8gXCJyZW5kZXJlclwiIDoge1xuLy8gICAgIFwidHlwZVwiIDogUkVOREVSRVJUWVBFKGxpbmUpXG4vLyAgICAgXCJvcHRpb25zXCIgOiBbXG4vLyAgICAgICB7IFwibmFtZVwiIDogXCJTVFJJTkchXCIsIFwidmFsdWVcIiA6IFwiU1RSSU5HIVwiLCBcIm1pblwiIDogXCJEQVRBVkFMVUVcIiwgXCJtYXhcIiA6IFwiREFUQVZBTFVFXCIgfSxcbi8vICAgICAgIHsgXCJuYW1lXCIgOiBcIlNUUklORyFcIiwgXCJ2YWx1ZVwiIDogXCJTVFJJTkchXCIsIFwibWluXCIgOiBcIkRBVEFWQUxVRVwiLCBcIm1heFwiIDogXCJEQVRBVkFMVUVcIiB9LFxuLy8gICAgICAgLi4uXG4vLyAgICAgXVxuLy8gICB9XG5SZW5kZXJlci5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbiwgcGxvdCwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICB2YXIgRGF0YVZhbHVlICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL251bWJlcl92YWx1ZS5qcycpLFxuICAgICAgICBXYXJuaW5nICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvd2FybmluZy5qcycpLFxuICAgICAgICBwRiAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICB2RiAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpLFxuICAgICAgICByZW5kZXJlclR5cGUsXG4gICAgICAgIHJlbmRlcmVyLFxuICAgICAgICBvcHQ7XG5cbiAgICByZXF1aXJlKCcuLi8uLi9jb3JlL3JlbmRlcmVycy9hbGxfcmVuZGVyZXJzLmpzJyk7XG5cbiAgICBmdW5jdGlvbiBzZXRPcHRpb24obmFtZSwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRPcHRpb25Gcm9tU3RyaW5nKG5hbWUsIHZhbHVlLCBtaW4sIG1heCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgV2FybmluZykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLndhcm5pbmcoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoanNvbiAmJiBqc29uLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW5kZXJlclR5cGUgPSBSZW5kZXJlci5UeXBlLnBhcnNlKGpzb24udHlwZSk7XG4gICAgICAgIGlmICghUmVuZGVyZXIuVHlwZS5pc0luc3RhbmNlKHJlbmRlcmVyVHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gcmVuZGVyZXIgdHlwZSAnXCIgKyBqc29uLnR5cGUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIgPSBSZW5kZXJlci5jcmVhdGUocmVuZGVyZXJUeXBlKTtcbiAgICAgICAgcmVuZGVyZXIucGxvdChwbG90KTtcblxuICAgICAgICBpZiAoanNvbi5vcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKG9wdCBpbiBqc29uLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5vcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZGLnR5cGVPZihqc29uLm9wdGlvbnNbb3B0XSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24ub3B0aW9uc1tvcHRdLmZvckVhY2goZnVuY3Rpb24oc3Vib3B0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKG9wdCwgc3Vib3B0LnZhbHVlLCBzdWJvcHQubWluLCBzdWJvcHQubWF4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKG9wdCwganNvbi5vcHRpb25zW29wdF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcbiIsInZhciBUaXRsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdGl0bGUuanMnKTtcblxuLy8gIFwidGl0bGVcIiA6IHtcbi8vICAgICAgXCJiYXNlXCIgOiBQT0lOVCgwLDEpLFxuLy8gICAgICBcImFuY2hvclwiIDogUE9JTlQoMCwxKSxcbi8vICAgICAgXCJwb3NpdGlvblwiIDogUE9JTlQoMCwwKSxcbi8vICAgICAgXCJmcmFtZVwiIDogRlJBTUUocGFkZGluZyksXG4vLyAgICAgIFwiY29sb3JcIiA6IENPTE9SKHdoaXRlKSxcbi8vICAgICAgXCJvcGFjaXR5XCIgOiBET1VCTEUoMS4wKSxcbi8vICAgICAgXCJib3JkZXJcIiA6IElOVEVHRVIoMCksXG4vLyAgICAgIFwiYm9yZGVyY29sb3JcIiA6IENPTE9SKGJsYWNrKSxcbi8vICAgICAgXCJwYWRkaW5nXCIgOiBJTlRFR0VSKDApLFxuLy8gICAgICBcImNvcm5lcnJhZGl1c1wiIDogSU5URUdFUigxNSksXG4vLyAgICAgIFwiZm9udHNpemVcIiA6IElOVEVHRVIsXG4vLyAgICAgIFwidGV4dFwiIDogU1RSSU5HXG4vLyAgfVxuVGl0bGUucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24sIGdyYXBoKSB7XG4gICAgdmFyIFBvaW50ICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIFJHQkNvbG9yICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICBUZXh0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS90ZXh0LmpzJyksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VKU09OUG9pbnQgICA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIG5ldyBQb2ludChwWzBdLCBwWzFdKTsgfSxcbiAgICAgICAgcGFyc2VSR0JDb2xvciAgICA9IFJHQkNvbG9yLnBhcnNlLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHRpdGxlO1xuXG4gICAgaWYgKGpzb24pIHtcbiAgICAgICAgdmFyIHRleHQgPSBqc29uLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB0aXRsZSA9IG5ldyBUaXRsZShuZXcgVGV4dCh0ZXh0KSwgZ3JhcGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSAgICAgICAgICAgICAgICBcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5mcmFtZSwgICAgICAgIHRpdGxlLmZyYW1lLCAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5ib3JkZXIsICAgICAgIHRpdGxlLmJvcmRlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uY29sb3IsICAgICAgICB0aXRsZS5jb2xvciwgICAgICAgIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJvcmRlcmNvbG9yLCAgdGl0bGUuYm9yZGVyY29sb3IsICBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5vcGFjaXR5LCAgICAgIHRpdGxlLm9wYWNpdHkpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLnBhZGRpbmcsICAgICAgdGl0bGUucGFkZGluZyk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uY29ybmVycmFkaXVzLCB0aXRsZS5jb3JuZXJyYWRpdXMpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmFuY2hvciwgICAgICAgdGl0bGUuYW5jaG9yLCAgICAgICBwYXJzZUpTT05Qb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYmFzZSwgICAgICAgICB0aXRsZS5iYXNlLCAgICAgICAgIHBhcnNlSlNPTlBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5wb3NpdGlvbiwgICAgIHRpdGxlLnBvc2l0aW9uLCAgICAgcGFyc2VKU09OUG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGl0bGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpdGxlO1xuIiwidmFyIFdpbmRvdyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvd2luZG93LmpzJyk7XG5cbi8vIFwid2luZG93XCIge1xuLy8gICAgICAgXCJ3aWR0aFwiOiBJTlRFR0VSLFxuLy8gICAgICAgXCJoZWlnaHRcIjogSU5URUdFUixcbi8vICAgICAgIFwiYm9yZGVyXCI6IElOVEVHRVIoMiksXG4vLyAgICAgICBcImJvcmRlcmNvbG9yXCI6IENPTE9SKGJsYWNrKSxcbi8vICAgICAgIFwibWFyZ2luXCI6IElOVEVHRVIoMiksXG4vLyAgICAgICBcInBhZGRpbmdcIjogSU5URUdFUig1KSxcbi8vIH1cbldpbmRvdy5wYXJzZUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciB3ID0gbmV3IFdpbmRvdygpLFxuICAgICAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlSW50ZWdlciAgICAgPSBwRi5wYXJzZUludGVnZXIsXG4gICAgICAgIGF0dHI7XG4gICAgaWYgKGpzb24pIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi53aWR0aCwgIHcud2lkdGgpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmhlaWdodCwgdy5oZWlnaHQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmJvcmRlciwgdy5ib3JkZXIpO1xuXG4gICAgICAgIGF0dHIgPSBqc29uLm1hcmdpbjtcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdy5tYXJnaW4oKS5zZXQoYXR0cixhdHRyLGF0dHIsYXR0cik7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyID0ganNvbi5wYWRkaW5nO1xuICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdy5wYWRkaW5nKCkuc2V0KGF0dHIsYXR0cixhdHRyLGF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24uYm9yZGVyY29sb3IsIHcuYm9yZGVyY29sb3IsIFJHQkNvbG9yLnBhcnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRvdztcbiIsInZhciBab29tID0gcmVxdWlyZSgnLi4vLi4vY29yZS96b29tLmpzJyk7XG5cblpvb20ucGFyc2VKU09OID0gZnVuY3Rpb24gKGpzb24sIHR5cGUpIHtcbiAgICB2YXIgem9vbSAgICAgICAgICAgICA9IG5ldyBab29tKCksXG4gICAgICAgIERhdGFWYWx1ZSAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgRGF0YU1lYXN1cmUgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV9tZWFzdXJlLmpzJyksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgdkYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdmFsaWRhdGlvbkZ1bmN0aW9ucy5qcycpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlQm9vbGVhbiAgICAgPSBwRi5wYXJzZUJvb2xlYW4sXG4gICAgICAgIHBhcnNlRGF0YU1lYXN1cmUgPSBmdW5jdGlvbih2KSB7IHJldHVybiBEYXRhTWVhc3VyZS5wYXJzZSh0eXBlLCB2KTsgfSwgLy9wRi5wYXJzZURhdGFNZWFzdXJlXG4gICAgICAgIGF0dHI7XG4gICAgaWYgKHZGLnR5cGVPZihqc29uKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKGpzb24sICAgICAgICAgem9vbS5hbGxvd2VkLCBwYXJzZUJvb2xlYW4pO1xuICAgIH0gZWxzZSBpZiAoanNvbikge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLmFsbG93ZWQsIHpvb20uYWxsb3dlZCwgcGFyc2VCb29sZWFuKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUoanNvbi5taW4sICAgICB6b29tLm1pbiwgICAgIHBhcnNlRGF0YU1lYXN1cmUpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShqc29uLm1heCwgICAgIHpvb20ubWF4LCAgICAgcGFyc2VEYXRhTWVhc3VyZSk7XG4gICAgICAgIGF0dHIgPSBqc29uLmFuY2hvcjtcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihhdHRyKSA9PT0gXCJzdHJpbmdcIiAmJiBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgem9vbS5hbmNob3IobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHpvb20uYW5jaG9yKCBEYXRhVmFsdWUucGFyc2UodHlwZSwgYXR0cikgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gem9vbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWm9vbTtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG5cbi8vICA8aG9yaXpvbnRhbGF4aXMgaWQ9XCJTVFJJTkdcIiB0eXBlPVwiREFUQVRZUEUobnVtYmVyKVwiIGxlbmd0aD1cIlJFTExFTigxLjApXCIgYmFzZT1cIlBPSU5UKC0xLDEpXCIgYW5jaG9yPVwiRE9VQkxFKC0xKVwiIHBvc2l0aW9uPVwiUE9JTlQoMCwwKVwiXG4vLyAgICAgIG1pbj1cIkRBVEFWQUxVRU9SQVVUTyhhdXRvKVwiIG1heD1cIkRBVEFWQUxVRU9SQVVUTyhhdXRvKVwiIG1pbnBvc2l0aW9uPVwiUkVMUE9TKC0xLjApXCIgbWF4cG9zaXRpb249XCJSRUxQT1MoMS4wKVwiIGNvbG9yPVwiQ09MT1IoYmxhY2spXCIgbGluZXdpZHRoPVwiSU5URUdFUigxKVwiXG4vLyAgICAgIHRpY2ttaW49XCJJTlRFR0VSKC0zKVwiIHRpY2ttYXg9XCJJTlRFR0VSKDMpXCIgdGlja2NvbG9yPVwiQ09MT1IoYmxhY2spXCI+XG4vLyAgICA8bGFiZWxzIGZvcm1hdD1cIlNUUklOR1wiIHN0YXJ0PVwiREFUQVZBTFVFKDApXCIgYW5nbGU9XCJET1VCTEUoMClcIiBwb3NpdGlvbj1cIlBPSU5UXCIgYW5jaG9yPVwiUE9JTlRcIiBjb2xvcj1cIkNPTE9SKGJsYWNrKVwiIHNwYWNpbmc9XCJTVFJJTkdcIiBkZW5zaXR5ZmFjdG9yPVwiRE9VQkxFKDEuMClcIj5cbi8vICAgICAgICA8bGFiZWwgZm9ybWF0PVwiU1RSSU5HXCIgc3RhcnQ9XCJTVFJJTkdcIiBhbmdsZT1cIkRPVUJMRVwiIHBvc2l0aW9uPVwiUE9JTlRcIiBhbmNob3I9XCJQT0lOVFwiIHNwYWNpbmc9XCJTVFJJTkdcIiBkZW5zaXR5ZmFjdG9yPVwiRE9VQkxFXCI+XG4vLyAgICAgICAgPGxhYmVsIGZvcm1hdD1cIlNUUklOR1wiIHN0YXJ0PVwiU1RSSU5HXCIgYW5nbGU9XCJET1VCTEVcIiBwb3NpdGlvbj1cIlBPSU5UXCIgYW5jaG9yPVwiUE9JTlRcIiBzcGFjaW5nPVwiU1RSSU5HXCIgZGVuc2l0eWZhY3Rvcj1cIkRPVUJMRVwiPlxuLy8gICAgICA8L2xhYmVsPlxuLy8gICAgPC9sYWJlbHM+XG4vLyAgICA8dGl0bGUgYmFzZT1cIkRPVUJMRSgwKVwiIGFuY2hvcj1cIlBPSU5UXCIgcG9zaXRpb249XCJQT0lOVFwiIGFuZ2xlPVwiRE9VQkxFKDApXCI+VElUTEVURVhUPC90aXRsZT5cbi8vICAgIDxncmlkIGNvbG9yPVwiQ09MT1IoMHhlZWVlZWUpXCIgdmlzaWJsZT1cIkJPT0xFQU4oZmFsc2UpXCIgLz5cbi8vICAgIDxwYW4gYWxsb3dlZD1cIkJPT0xFQU4oeWVzKVwiIG1pbj1cIkRBVEFWQUxVRVwiIG1heD1cIkRBVEFWQUxVRVwiIC8+XG4vLyAgICA8em9vbSBhbGxvd2VkPVwiQk9PTEVBTih5ZXMpXCIgbWluPVwiREFUQU1FQVNVUkVcIiBtYXg9XCJEQVRBTUVBU1VSRVwiIGFuY2hvcj1cIkRBVEFWQUxVRVwiIC8+XG4vLyAgICA8YmluZGluZyBpZD1cIlNUUklORyFcIiBtaW49XCJEQVRBVkFMVUUhXCIgbWF4PVwiREFUQVZBTFVFIVwiIC8+XG4vLyAgPC9ob3Jpem9udGFsYXhpcz5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkKSB7XG4gICAgdmFyIEF4aXMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2F4aXMuanMnKSxcbiAgICAgICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKTtcblxuICAgIC8vIGlmIHBhcnNlWE1MIG1ldGhvZCBhbHJlYWR5IGhhcyBiZWVuIGRlZmluZWQsIHdoaWNoIHdvdWxkIGJlIHRoZSBjYXNlIGlmIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBjYWxsZWQsIGp1c3QgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKHR5cGVvZihBeGlzLnBhcnNlWE1MKT09PVwiZnVuY3Rpb25cIikgeyByZXR1cm4gQXhpczsgfTtcblxuICAgIHZhciBwYXJzZUxhYmVscyA9IGZ1bmN0aW9uICh4bWwsIGF4aXMpIHtcbiAgICAgICAgdmFyIHNwYWNpbmdTdHJpbmdzID0gW10sXG4gICAgICAgICAgICBzcGFjaW5nU3RyaW5nLFxuICAgICAgICAgICAgbGFiZWxzVGFnID0geG1sLmZpbmQoXCJsYWJlbHNcIiksXG4gICAgICAgICAgICBsYWJlbFRhZ3MgPSB4bWwuZmluZChcImxhYmVsXCIpLFxuICAgICAgICAgICAgbGFiZWxlcnMgID0gYXhpcy5sYWJlbGVycygpLFxuICAgICAgICAgICAgTGFiZWxlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbGFiZWxlci5qcycpLFxuICAgICAgICAgICAgRGF0YVZhbHVlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgICAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgICAgICAgICBpO1xuICAgICAgICBzcGFjaW5nU3RyaW5nID0gJC50cmltKHBGLmdldFhNTEF0dHIobGFiZWxzVGFnLFwic3BhY2luZ1wiKSk7XG4gICAgICAgIGlmIChzcGFjaW5nU3RyaW5nICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBzcGFjaW5nU3RyaW5ncyA9IHNwYWNpbmdTdHJpbmcuc3BsaXQoL1xccysvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BhY2luZ1N0cmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgc3BhY2luZyBhdHRyIG9uIHRoZSA8bGFiZWxzPiB0YWcsIGNyZWF0ZSBhIG5ldyBsYWJlbGVyIGZvclxuICAgICAgICAgICAgLy8gZWFjaCBzcGFjaW5nIHByZXNlbnQgaW4gaXQsIHVzaW5nIHRoZSBvdGhlciB2YWx1ZXMgZnJvbSB0aGUgPGxhYmVscz4gdGFnXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2luZ1N0cmluZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsYWJlbGVycy5hZGQoTGFiZWxlci5wYXJzZVhNTChsYWJlbHNUYWcsIGF4aXMsIHVuZGVmaW5lZCwgc3BhY2luZ1N0cmluZ3NbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsYWJlbFRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIDxsYWJlbD4gdGFncywgcGFyc2UgdGhlIDxsYWJlbHM+IHRhZyB0byBnZXQgZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IExhYmVsZXIucGFyc2VYTUwobGFiZWxzVGFnLCBheGlzLCB1bmRlZmluZWQsIG51bGwpO1xuICAgICAgICAgICAgLy8gQW5kIGxvb3Agb3ZlciBlYWNoIDxsYWJlbD4gdGFnLCBjcmVhdGluZyBsYWJlbGVycyBmb3IgZWFjaCwgc3BsaXR0aW5nIG11bHRpcGxlXG4gICAgICAgICAgICAvLyBzcGFjaW5ncyBvbiB0aGUgc2FtZSA8bGFiZWw+IHRhZyBpbnRvIG11bHRpcGxlIGxhYmVsZXJzOlxuICAgICAgICAgICAgJC5lYWNoKGxhYmVsVGFncywgZnVuY3Rpb24gKGosIGUpIHtcbiAgICAgICAgICAgICAgICBzcGFjaW5nU3RyaW5nID0gJC50cmltKHBGLmdldFhNTEF0dHIoJChlKSwgXCJzcGFjaW5nXCIpKTtcbiAgICAgICAgICAgICAgICBzcGFjaW5nU3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChzcGFjaW5nU3RyaW5nICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmdTdHJpbmdzID0gc3BhY2luZ1N0cmluZy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2luZ1N0cmluZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxlcnMuYWRkKCBMYWJlbGVyLnBhcnNlWE1MKCQoZSksIGF4aXMsIGRlZmF1bHRzLCBzcGFjaW5nU3RyaW5nc1tpXSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgbGFiZWxlcnMgdXNpbmcgdGhlIGRlZmF1bHQgc3BhY2luZywgd2l0aCB0aGUgb3RoZXIgdmFsdWVzXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSA8bGFiZWxzPiB0YWdcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWVzID0gKHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSkuaG9yaXpvbnRhbGF4aXMubGFiZWxzO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRTcGFjaW5ncyA9IGF4aXMudHlwZSgpID09PSBEYXRhVmFsdWUuTlVNQkVSID9cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlcy5kZWZhdWx0TnVtYmVyU3BhY2luZyA6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXMuZGVmYXVsdERhdGV0aW1lU3BhY2luZztcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZWZhdWx0U3BhY2luZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsYWJlbGVycy5hZGQoTGFiZWxlci5wYXJzZVhNTChsYWJlbHNUYWcsIGF4aXMsIHVuZGVmaW5lZCwgZGVmYXVsdFNwYWNpbmdzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgXG4gICAgQXhpcy5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwsIG9yaWVudGF0aW9uLCBtZXNzYWdlSGFuZGxlciwgbXVsdGlncmFwaCkge1xuXG4gICAgICAgIHZhciBEYXRhVmFsdWUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpLFxuICAgICAgICAgICAgUkdCQ29sb3IgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICAgICAgRGlzcGxhY2VtZW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9kaXNwbGFjZW1lbnQuanMnKSxcbiAgICAgICAgICAgIEF4aXNUaXRsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYXhpc190aXRsZS5qcycpLFxuICAgICAgICAgICAgR3JpZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZ3JpZC5qcycpLFxuICAgICAgICAgICAgUGFuID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wYW4uanMnKSxcbiAgICAgICAgICAgIFpvb20gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3pvb20uanMnKSxcbiAgICAgICAgICAgIEF4aXNCaW5kaW5nID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzX2JpbmRpbmcuanMnKSxcblxuICAgICAgICAgICAgYXhpcyAgICAgICAgICAgICAgPSBuZXcgQXhpcyhvcmllbnRhdGlvbiksXG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICAgICAgcGFyc2VJbnRlZ2VyICAgICAgPSBwRi5wYXJzZUludGVnZXIsXG4gICAgICAgICAgICBwYXJzZURpc3BsYWNlbWVudCA9IERpc3BsYWNlbWVudC5wYXJzZSxcbiAgICAgICAgICAgIHBhcnNlUG9pbnQgICAgICAgID0gUG9pbnQucGFyc2UsXG4gICAgICAgICAgICBwYXJzZVJHQkNvbG9yICAgICA9IFJHQkNvbG9yLnBhcnNlLFxuICAgICAgICAgICAgYXR0ciwgY2hpbGQsXG4gICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICBpZiAoeG1sKSB7XG5cbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLCBcImlkXCIpLCAgICAgYXhpcy5pZCk7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJ0eXBlXCIpLCAgIGF4aXMudHlwZSwgICBEYXRhVmFsdWUucGFyc2VUeXBlKTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLCBcImxlbmd0aFwiKSwgYXhpcy5sZW5ndGgsIHBhcnNlRGlzcGxhY2VtZW50KTtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgc3VwcG9ydCBmb3IgdGhlIGRlcHJlY2F0ZWQgXCJwb3NpdGlvbmJhc2VcIiBheGlzIGF0dHJpYnV0ZTtcbiAgICAgICAgICAgIC8vIE1VR0wgZmlsZXMgc2hvdWxkIHVzZSB0aGUgXCJiYXNlXCIgYXR0cmlidXRlIGluc3RlYWQuICBXaGVuIHdlJ3JlIHJlYWR5IHRvIHJlbW92ZVxuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3IgdGhlIGRlcHJlY2F0ZWQgYXR0cmlidXRlLCBkZWxldGUgdGhpcyBibG9jayBvZiBjb2RlOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uYmFzZSA9IHBGLmdldFhNTEF0dHIoeG1sLCBcInBvc2l0aW9uYmFzZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25iYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLndhcm5pbmcoJ1VzZSBvZiBkZXByZWNhdGVkIGF4aXMgYXR0cmlidXRlIFwicG9zaXRpb25iYXNlXCI7IHVzZSBcImJhc2VcIiBhdHRyaWJ1dGUgaW5zdGVhZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHBvc2l0aW9uYmFzZSA9PT0gXCJsZWZ0XCIpIHx8IChwb3NpdGlvbmJhc2UgPT09IFwiYm90dG9tXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLmJhc2UocGFyc2VQb2ludChcIi0xIC0xXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbmJhc2UgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5iYXNlKHBhcnNlUG9pbnQoXCIxIC0xXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbmJhc2UgPT09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuYmFzZShwYXJzZVBvaW50KFwiLTEgMVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVuZCBvZiBjb2RlIHRvIGRlbGV0ZSB3aGVuIHJlbW92aW5nIHN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgXCJwb3NpdGlvbmJhc2VcIlxuICAgICAgICAgICAgLy8gYXR0cmlidXRlLlxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgYXR0ciA9IHBGLmdldFhNTEF0dHIoeG1sLCBcInBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMucG9zaXRpb24ocGFyc2VQb2ludChhdHRyKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBwb3NpdGlvbiBkaWQgbm90IHBhcnNlIGFzIGEgUG9pbnQsIGFuZCBpZiBpdCBjYW4gYmUgaW50ZXJwcmV0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgYSBudW1iZXIsIGNvbnN0cnVjdCB0aGUgcG9zaXRpb24gcG9pbnQgYnkgaW50ZXJwcmV0aW5nIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIGFzIGFuIG9mZnNldCBmcm9tIHRoZSAwIGxvY2F0aW9uIGFsb25nIHRoZSBwZXJwZW5kaWN1bGFyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChhdHRyLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHsgLy8gdGVzdCBmb3IgaXNOYU5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBBeGlzLkhPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMucG9zaXRpb24obmV3IFBvaW50KDAsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLnBvc2l0aW9uKG5ldyBQb2ludCh2YWx1ZSwgMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBheGlzLm1pbihwRi5nZXRYTUxBdHRyKHhtbCwgXCJtaW5cIikpO1xuICAgICAgICAgICAgaWYgKGF4aXMubWluKCkgIT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICAgICAgYXhpcy5kYXRhTWluKERhdGFWYWx1ZS5wYXJzZShheGlzLnR5cGUoKSwgYXhpcy5taW4oKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXhpcy5tYXgocEYuZ2V0WE1MQXR0cih4bWwsIFwibWF4XCIpKTtcbiAgICAgICAgICAgIGlmIChheGlzLm1heCgpICE9PSBcImF1dG9cIikge1xuICAgICAgICAgICAgICAgIGF4aXMuZGF0YU1heChEYXRhVmFsdWUucGFyc2UoYXhpcy50eXBlKCksIGF4aXMubWF4KCkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwicHJlZ2FwXCIpLCAgICAgICAgIGF4aXMucHJlZ2FwLCAgICAgICAgIHBhcnNlRmxvYXQpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwicG9zdGdhcFwiKSwgICAgICAgIGF4aXMucG9zdGdhcCwgICAgICAgIHBhcnNlRmxvYXQpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwiYW5jaG9yXCIpLCAgICAgICAgIGF4aXMuYW5jaG9yLCAgICAgICAgIHBhcnNlRmxvYXQpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwiYmFzZVwiKSwgICAgICAgICAgIGF4aXMuYmFzZSwgICAgICAgICAgIHBhcnNlUG9pbnQpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwibWlucG9zaXRpb25cIiksICAgIGF4aXMubWlucG9zaXRpb24sICAgIHBhcnNlRGlzcGxhY2VtZW50KTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLCBcIm1heHBvc2l0aW9uXCIpLCAgICBheGlzLm1heHBvc2l0aW9uLCAgICBwYXJzZURpc3BsYWNlbWVudCk7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJtaW5vZmZzZXRcIiksICAgICAgYXhpcy5taW5vZmZzZXQsICAgICAgcGFyc2VGbG9hdCk7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJtYXhvZmZzZXRcIiksICAgICAgYXhpcy5tYXhvZmZzZXQsICAgICAgcGFyc2VGbG9hdCk7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJjb2xvclwiKSwgICAgICAgICAgYXhpcy5jb2xvciwgICAgICAgICAgcGFyc2VSR0JDb2xvcik7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJ0aWNrY29sb3JcIiksICAgICAgYXhpcy50aWNrY29sb3IsICAgICAgcGFyc2VSR0JDb2xvcik7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJ0aWNrd2lkdGhcIiksICAgICAgYXhpcy50aWNrd2lkdGgsICAgICAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLCBcInRpY2ttaW5cIiksICAgICAgICBheGlzLnRpY2ttaW4sICAgICAgICBwYXJzZUludGVnZXIpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsIFwidGlja21heFwiKSwgICAgICAgIGF4aXMudGlja21heCwgICAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJoaWdobGlnaHRzdHlsZVwiKSwgYXhpcy5oaWdobGlnaHRzdHlsZSk7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCwgXCJsaW5ld2lkdGhcIiksICAgICAgYXhpcy5saW5ld2lkdGgsICAgICAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcInRpdGxlXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApICAgICAgICAgICAgICAgICAgICB7IGF4aXMudGl0bGUoQXhpc1RpdGxlLnBhcnNlWE1MKGNoaWxkLCBheGlzKSk7ICAgICB9XG4gICAgICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXhpcy50aXRsZShuZXcgQXhpc1RpdGxlKGF4aXMpKTsgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwiZ3JpZFwiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSAgICAgICAgICAgICAgICAgICAgeyBheGlzLmdyaWQoR3JpZC5wYXJzZVhNTChjaGlsZCkpOyAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcInBhblwiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSAgICAgICAgICAgICAgICAgICAgeyBheGlzLnBhbihQYW4ucGFyc2VYTUwoY2hpbGQsIGF4aXMudHlwZSgpKSk7ICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcInpvb21cIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkgICAgICAgICAgICAgICAgICAgIHsgYXhpcy56b29tKFpvb20ucGFyc2VYTUwoY2hpbGQsIGF4aXMudHlwZSgpKSk7ICAgIH1cbiAgICAgICAgICAgIGlmICh4bWwuZmluZChcImxhYmVsc1wiKS5sZW5ndGggPiAwKSAgICAgICB7IHBhcnNlTGFiZWxzKHhtbCwgYXhpcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJiaW5kaW5nXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZ0lkQXR0ciAgPSBwRi5nZXRYTUxBdHRyKGNoaWxkLFwiaWRcIiksXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdNaW5BdHRyID0gcEYuZ2V0WE1MQXR0cihjaGlsZCxcIm1pblwiKSxcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ01heEF0dHIgPSBwRi5nZXRYTUxBdHRyKGNoaWxkLFwibWF4XCIpLFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nTWluRGF0YVZhbHVlID0gRGF0YVZhbHVlLnBhcnNlKGF4aXMudHlwZSgpLCBiaW5kaW5nTWluQXR0ciksXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdNYXhEYXRhVmFsdWUgPSBEYXRhVmFsdWUucGFyc2UoYXhpcy50eXBlKCksIGJpbmRpbmdNYXhBdHRyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGJpbmRpbmdJZEF0dHIpICE9PSBcInN0cmluZ1wiIHx8IGJpbmRpbmdJZEF0dHIubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBheGlzIGJpbmRpbmcgaWQ6ICdcIiArIGJpbmRpbmdJZEF0dHIgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghIERhdGFWYWx1ZS5pc0luc3RhbmNlKGJpbmRpbmdNaW5EYXRhVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXhpcyBiaW5kaW5nIG1pbjogJ1wiICsgYmluZGluZ01pbkF0dHIgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghIERhdGFWYWx1ZS5pc0luc3RhbmNlKGJpbmRpbmdNYXhEYXRhVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXhpcyBiaW5kaW5nIG1heDogJ1wiICsgYmluZGluZ01heEF0dHIgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEF4aXNCaW5kaW5nLmZpbmRCeUlkT3JDcmVhdGVOZXcoYmluZGluZ0lkQXR0cikuYWRkQXhpcyhheGlzLCBiaW5kaW5nTWluRGF0YVZhbHVlLCBiaW5kaW5nTWF4RGF0YVZhbHVlLCBtdWx0aWdyYXBoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXhpcztcbn07XG4iLCJ2YXIgQXhpc1RpdGxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzX3RpdGxlLmpzJyk7XG5cbi8vIDx0aXRsZSBiYXNlPVwiMjMuMlwiIGFuY2hvcj1cIjEyIDRcIiBwb3NpdGlvbj1cIjMgN1wiIGFuZ2xlPVwiNDVcIj50ZW1wZXJhdHVyZTwvdGl0bGU+XG4vLyBlbXB0eSB0aXRsZTpcbi8vICAgPHRpdGxlLz5cbkF4aXNUaXRsZS5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwsIGF4aXMpIHtcbiAgICB2YXIgdGl0bGUgPSBuZXcgQXhpc1RpdGxlKGF4aXMpLFxuICAgICAgICBUZXh0ID0gcmVxdWlyZSgnLi4vLi4vY29yZS90ZXh0LmpzJyksXG4gICAgICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9wb2ludC5qcycpLFxuICAgICAgICBwRiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBub25FbXB0eVRpdGxlID0gZmFsc2UsXG4gICAgICAgIHBhcnNlUG9pbnQgPSBQb2ludC5wYXJzZSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgcGFyc2VUaXRsZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXR0cmlidXRlLCBwcmVwcm9jZXNzb3IpIHtcbiAgICAgICAgICAgIGlmIChwRi5wYXJzZUF0dHJpYnV0ZSh2YWx1ZSwgYXR0cmlidXRlLCBwcmVwcm9jZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8uICBEb24ndCBjb3VudCB0aGUgdGl0bGUgYXMgbm9uRW1wdHkganVzdCBiZWNhdXNlIG9mIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAgICAgLy8gSWYgYSA8dGl0bGU+IHRhZyBoYXMgb25seSBhdHRyaWJ1dGVzLCBhbmQgbm8gY29udGVudCwgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYHVuZGVmaW5lZGAgc28gdGhhdCB0aGUgbm9ybWFsaXplciB3b24ndFxuICAgICAgICAgICAgICAgIC8vIGNvbWUgYWxvbmcgbGF0ZXIgYW5kIHBvcHVsYXRlIHRoZSB0aXRsZSBjb250ZW50IHdpdGggdGhlIGF4aXMgaWQuXG4gICAgICAgICAgICAgICAgLy8gRW1wdHkgPHRpdGxlPiBjb250ZW50IG1lYW5zIGRvbid0IGRyYXcgYSB0aXRsZSBhdCBhbGwsIGluIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBpdCdzIE9LIHRvIGp1c3QgZm9yZ2V0IGFib3V0IGFueSBhdHRyaWJ1dGVzIHRoYXQgd2VyZSBzZXQuXG4gICAgICAgICAgICAgICAgLy9ub25FbXB0eVRpdGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIGlmICh4bWwpIHtcbiAgICAgICAgdGV4dCA9IHhtbC50ZXh0KCk7XG4gICAgICAgIGlmICh0ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB0aXRsZS5jb250ZW50KG5ldyBUZXh0KHRleHQpKTtcbiAgICAgICAgICAgIG5vbkVtcHR5VGl0bGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlVGl0bGVBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJhbmNob3JcIiksICAgdGl0bGUuYW5jaG9yLCAgIHBhcnNlUG9pbnQpO1xuICAgICAgICBwYXJzZVRpdGxlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYmFzZVwiKSwgICAgIHRpdGxlLmJhc2UsICAgICBwYXJzZUZsb2F0KTtcbiAgICAgICAgcGFyc2VUaXRsZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcInBvc2l0aW9uXCIpLCB0aXRsZS5wb3NpdGlvbiwgcGFyc2VQb2ludCk7XG4gICAgICAgIHBhcnNlVGl0bGVBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJhbmdsZVwiKSwgICAgdGl0bGUuYW5nbGUsICAgIHBhcnNlRmxvYXQpO1xuICAgIH1cblxuICAgIGlmIChub25FbXB0eVRpdGxlID09PSB0cnVlKSB7IFxuICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aXNUaXRsZTtcbiIsInZhciBCYWNrZ3JvdW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9iYWNrZ3JvdW5kLmpzJyk7XG5cbi8vIDxiYWNrZ3JvdW5kIGNvbG9yPVwiI2ZmZmYwMFwiPlxuLy8gICA8aW1nIHNyYz1cImZvby5wbmdcIiBhbmNob3I9XCItMSA1XCIgYmFzZT1cIjMgMTJcIiBwb3NpdGlvbj1cIi0yIDNcIiBmcmFtZT1cInBhZGRpbmdcIi8+XG4vLyA8L2JhY2tncm91bmQ+XG5CYWNrZ3JvdW5kLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgbXVsdGlncmFwaCkge1xuICAgIHZhciBiYWNrZ3JvdW5kICAgICAgID0gbmV3IEJhY2tncm91bmQoKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgSW1nICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvaW1nLmpzJyksXG4gICAgICAgIGNoaWxkO1xuXG4gICAgaWYgKHhtbCkge1xuICAgICAgICBwRi5wYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImNvbG9yXCIpLCBiYWNrZ3JvdW5kLmNvbG9yLCBSR0JDb2xvci5wYXJzZSk7XG4gICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCJpbWdcIik7XG4gICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmltZyhJbWcucGFyc2VYTUwoY2hpbGQsIG11bHRpZ3JhcGgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFja2dyb3VuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2dyb3VuZDtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgRGF0YSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YS5qcycpO1xuXG4gICAgLy8gaWYgcGFyc2VYTUwgbWV0aG9kIGFscmVhZHkgaGFzIGJlZW4gZGVmaW5lZCwgd2hpY2ggd291bGQgYmUgdGhlIGNhc2UgaWYgdGhpc1xuICAgIC8vIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGNhbGxlZCwganVzdCByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICBpZiAodHlwZW9mKERhdGEucGFyc2VYTUwpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBEYXRhOyB9O1xuXG4gICAgLy8gPGRhdGE+XG4gICAgLy8gICA8dmFyaWFibGVzXG4gICAgLy8gICAgICAgbWlzc2luZ3ZhbHVlPVwiREFUQVZBTFVFXCJcbiAgICAvLyAgICAgICBtaXNzaW5nb3A9XCJDT01QQVJBVE9SXCI+XG4gICAgLy8gICAgIDx2YXJpYWJsZVxuICAgIC8vICAgICAgICAgaWQ9XCJTVFJJTkchXCJcbiAgICAvLyAgICAgICAgIGNvbHVtbj1cIklOVEVHRVJcIlxuICAgIC8vICAgICAgICAgdHlwZT1cIkRBVEFUWVBFKG51bWJlcilcIlxuICAgIC8vICAgICAgICAgbWlzc2luZ3ZhbHVlPVwiU1RSSU5HXCJcbiAgICAvLyAgICAgICAgIG1pc3NpbmdvcD1cIkNPTVBBUkFUT1JcIj5cbiAgICAvLyAgICAgPC92YXJpYWJsZT5cbiAgICAvLyAgIDwvdmFyaWFibGVzPlxuICAgIC8vICAgPHJlcGVhdCBwZXJpb2Q9XCJTVFJJTkdcIi8+XG4gICAgLy8gICA8dmFsdWVzPlxuICAgIC8vICAgPC92YWx1ZXM+XG4gICAgLy8gICA8Y3N2XG4gICAgLy8gICAgICAgbG9jYXRpb249XCJTVFJJTkchXCI+XG4gICAgLy8gICA8L2Nzdj5cbiAgICAvLyAgIDxzZXJ2aWNlXG4gICAgLy8gICAgICAgbG9jYXRpb249XCJTVFJJTkchXCJcbiAgICAvLyAgICAgICBmb3JtYXQ9XCJTVFJJTkdcIj5cbiAgICAvLyAgIDwvc2VydmljZT5cbiAgICAvLyA8L2RhdGE+XG4gICAgRGF0YS5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwsIG11bHRpZ3JhcGgsIG1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHZhciBBcnJheURhdGEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2FycmF5X2RhdGEuanMnKSxcbiAgICAgICAgICAgIERhdGFWYXJpYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YXJpYWJsZS5qcycpLFxuICAgICAgICAgICAgRGF0YU1lYXN1cmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfbWVhc3VyZS5qcycpLFxuICAgICAgICAgICAgUGVyaW9kaWNBcnJheURhdGEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3BlcmlvZGljX2FycmF5X2RhdGEuanMnKSxcbiAgICAgICAgICAgIENTVkRhdGEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Nzdl9kYXRhLmpzJykoJCksXG4gICAgICAgICAgICBXZWJTZXJ2aWNlRGF0YSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvd2ViX3NlcnZpY2VfZGF0YS5qcycpKCQpLFxuICAgICAgICAgICAgTXVsdGlncmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbXVsdGlncmFwaC5qcycpKCQpLFxuICAgICAgICAgICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgICAgIHZhcmlhYmxlc194bWwsXG4gICAgICAgICAgICBkZWZhdWx0TWlzc2luZ3ZhbHVlU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdE1pc3NpbmdvcFN0cmluZyxcbiAgICAgICAgICAgIGRhdGFWYXJpYWJsZXMgPSBbXSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBhZGFwLCBhZGFwdGVyID0gQXJyYXlEYXRhO1xuXG4gICAgICAgIGlmICh4bWwpIHtcblxuICAgICAgICAgICAgYWRhcCA9IHBGLmdldFhNTEF0dHIoJCh4bWwpLFwiYWRhcHRlclwiKTtcbiAgICAgICAgICAgIGlmIChhZGFwICE9PSB1bmRlZmluZWQgJiYgYWRhcCAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGFkYXB0ZXIgPSBNdWx0aWdyYXBoLmdldERhdGFBZGFwdGVyKGFkYXApO1xuICAgICAgICAgICAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBkYXRhIGFkYXBhdGVyOiBcIiArIGFkYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcGFyc2UgdGhlIDx2YXJpYWJsZXM+IHNlY3Rpb25cbiAgICAgICAgICAgIHZhcmlhYmxlc194bWwgPSB4bWwuZmluZChcInZhcmlhYmxlc1wiKTtcbiAgICAgICAgICAgIGRlZmF1bHRNaXNzaW5ndmFsdWVTdHJpbmcgPSBwRi5nZXRYTUxBdHRyKHZhcmlhYmxlc194bWwsXCJtaXNzaW5ndmFsdWVcIik7XG4gICAgICAgICAgICBkZWZhdWx0TWlzc2luZ29wU3RyaW5nICAgID0gcEYuZ2V0WE1MQXR0cih2YXJpYWJsZXNfeG1sLFwibWlzc2luZ29wXCIpO1xuXG4gICAgICAgICAgICB2YXIgdmFyaWFibGVzID0gdmFyaWFibGVzX3htbC5maW5kKFwiPnZhcmlhYmxlXCIpO1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKHZhcmlhYmxlcywgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVZhcmlhYmxlcy5wdXNoKCBEYXRhVmFyaWFibGUucGFyc2VYTUwoJChlKSkgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSA8cmVwZWF0PiBzZWN0aW9uLCBhbmQgaWYgc28sIGdyYWIgdGhlIHBlcmlvZCBmcm9tIGl0XG4gICAgICAgICAgICB2YXIgaGF2ZVJlcGVhdCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBlcmlvZCxcbiAgICAgICAgICAgICAgICByZXBlYXRfeG1sID0gJCh4bWwuZmluZChcIj5yZXBlYXRcIikpO1xuICAgICAgICAgICAgaWYgKHJlcGVhdF94bWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwZXJpb2RTdHJpbmcgPSBwRi5nZXRYTUxBdHRyKCQocmVwZWF0X3htbCksXCJwZXJpb2RcIik7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmlvZFN0cmluZyA9PT0gdW5kZWZpbmVkIHx8IHBlcmlvZFN0cmluZyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci53YXJuaW5nKFwiPHJlcGVhdD4gdGFnIHJlcXVpcmVzIGEgJ3BlcmlvZCcgYXR0cmlidXRlOyBkYXRhIHRyZWF0ZWQgYXMgbm9uLXJlcGVhdGluZ1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZXJpb2QgPSBEYXRhTWVhc3VyZS5wYXJzZShkYXRhVmFyaWFibGVzWzBdLnR5cGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyaW9kU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgaGF2ZVJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgPHZhbHVlcz4gc2VjdGlvbiwgcGFyc2UgaXQgYW5kIHJldHVybiBhbiBBcnJheURhdGEgaW5zdGFuY2U6XG4gICAgICAgICAgICB2YXIgdmFsdWVzX3htbCA9ICQoeG1sLmZpbmQoXCI+dmFsdWVzXCIpKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNfeG1sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNfeG1sID0gdmFsdWVzX3htbFswXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nVmFsdWVzID0gYWRhcHRlci50ZXh0VG9TdHJpbmdBcnJheShkYXRhVmFyaWFibGVzLCAkKHZhbHVlc194bWwpLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmVSZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBQZXJpb2RpY0FycmF5RGF0YShkYXRhVmFyaWFibGVzLCBzdHJpbmdWYWx1ZXMsIHBlcmlvZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBBcnJheURhdGEoZGF0YVZhcmlhYmxlcywgc3RyaW5nVmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSA8Y3N2PiBzZWN0aW9uLCBwYXJzZSBpdCBhbmQgcmV0dXJuIGEgQ1NWRGF0YSBpbnN0YW5jZTpcbiAgICAgICAgICAgIHZhciBjc3ZfeG1sID0gJCh4bWwuZmluZChcIj5jc3ZcIikpO1xuICAgICAgICAgICAgaWYgKGNzdl94bWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNzdl94bWwgPSBjc3ZfeG1sWzBdO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IHBGLmdldFhNTEF0dHIoJChjc3ZfeG1sKSxcImxvY2F0aW9uXCIpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgQ1NWRGF0YShkYXRhVmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoID8gbXVsdGlncmFwaC5yZWJhc2VVcmwoZmlsZW5hbWUpIDogZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoID8gbXVsdGlncmFwaC5nZXRBamF4VGhyb3R0bGUoZmlsZW5hbWUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIDxzZXJ2aWNlPiBzZWN0aW9uLCBwYXJzZSBpdCBhbmQgcmV0dXJuIGEgV2ViU2VydmljZURhdGEgaW5zdGFuY2U6XG4gICAgICAgICAgICB2YXIgc2VydmljZV94bWwgPSAkKHhtbC5maW5kKFwiPnNlcnZpY2VcIikpO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VfeG1sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlX3htbCA9ICQoc2VydmljZV94bWxbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHBGLmdldFhNTEF0dHIoc2VydmljZV94bWwsXCJsb2NhdGlvblwiKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gbmV3IFdlYlNlcnZpY2VEYXRhKGRhdGFWYXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWdyYXBoID8gbXVsdGlncmFwaC5yZWJhc2VVcmwobG9jYXRpb24pIDogbG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZ3JhcGggPyBtdWx0aWdyYXBoLmdldEFqYXhUaHJvdHRsZShsb2NhdGlvbikgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXQgPSBwRi5nZXRYTUxBdHRyKHNlcnZpY2VfeG1sLFwiZm9ybWF0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRNaXNzaW5ndmFsdWVTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZGVmYXVsdE1pc3Npbmd2YWx1ZShkZWZhdWx0TWlzc2luZ3ZhbHVlU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZhdWx0TWlzc2luZ29wU3RyaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmRlZmF1bHRNaXNzaW5nb3AoZGVmYXVsdE1pc3NpbmdvcFN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmFkYXB0ZXIoYWRhcHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERhdGE7XG59O1xuXG4iLCJ2YXIgRGF0YVZhcmlhYmxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhcmlhYmxlLmpzJyk7XG5cbi8vICA8dmFyaWFibGVcbi8vICAgICAgaWQ9XCJTVFJJTkchXCJcbi8vICAgICAgY29sdW1uPVwiSU5URUdFUlwiXG4vLyAgICAgIHR5cGU9XCJEQVRBVFlQRShudW1iZXIpXCJcbi8vICAgICAgbWlzc2luZ3ZhbHVlPVwiU1RSSU5HXCJcbi8vICAgICAgbWlzc2luZ29wPVwiQ09NUEFSQVRPUlwiPlxuLy8gIDwvdmFyaWFibGU+XG5EYXRhVmFyaWFibGUucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sLCBkYXRhKSB7XG4gICAgdmFyIHZhcmlhYmxlLFxuICAgICAgICBwRiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIERhdGFWYWx1ZSAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgYXR0cjtcblxuICAgIGlmICh4bWwgJiYgcEYuZ2V0WE1MQXR0cih4bWwsXCJpZFwiKSkge1xuICAgICAgICB2YXJpYWJsZSA9IG5ldyBEYXRhVmFyaWFibGUocEYuZ2V0WE1MQXR0cih4bWwsXCJpZFwiKSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiY29sdW1uXCIpLCAgICAgICB2YXJpYWJsZS5jb2x1bW4sICAgICAgIHBGLnBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwidHlwZVwiKSwgICAgICAgICB2YXJpYWJsZS50eXBlLCAgICAgICAgIERhdGFWYWx1ZS5wYXJzZVR5cGUpO1xuICAgICAgICAvL3BhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwibWlzc2luZ3ZhbHVlXCIpLCB2YXJpYWJsZS5taXNzaW5ndmFsdWUsIHBGLnBhcnNlRGF0YVZhbHVlKHZhcmlhYmxlLnR5cGUoKSkpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcIm1pc3Npbmd2YWx1ZVwiKSwgdmFyaWFibGUubWlzc2luZ3ZhbHVlLCBmdW5jdGlvbih2KSB7IHJldHVybiBEYXRhVmFsdWUucGFyc2UodmFyaWFibGUudHlwZSgpLCB2KTsgfSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwibWlzc2luZ29wXCIpLCAgICB2YXJpYWJsZS5taXNzaW5nb3AsICAgIERhdGFWYWx1ZS5wYXJzZUNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gdmFyaWFibGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWYXJpYWJsZTtcbiIsIlxuLy8gVGhpcyBmaWxlIHVzZXMgalF1ZXJ5LiAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZVxuLy8gZnVuY3Rpb24gcmV0dXJuZWQgYnkgcmVxdWlyaW5nIHRoaXMgZmlsZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIHZhciBEYXRhdGlwcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YXRpcHMuanMnKTtcblxuICAgIC8vIGlmIHBhcnNlWE1MIG1ldGhvZCBhbHJlYWR5IGhhcyBiZWVuIGRlZmluZWQsIHdoaWNoIHdvdWxkIGJlIHRoZSBjYXNlIGlmIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBjYWxsZWQsIGp1c3QgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKHR5cGVvZihEYXRhdGlwcy5wYXJzZVhNTCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIERhdGF0aXBzOyB9O1xuXG4gICAgLy8gPGRhdGF0aXBzXG4gICAgLy8gICBmb3JtYXQ9XCJTVFJJTkchXCJcbiAgICAvLyAgIGJnY29sb3I9XCJDT0xPUlwiXG4gICAgLy8gICBiZ2FscGhhPVwiRE9VQkxFXCJcbiAgICAvLyAgIGJvcmRlcj1cIklOVEVHRVJcIlxuICAgIC8vICAgYm9yZGVyY29sb3I9XCJDT0xPUlwiXG4gICAgLy8gICBwYWQ9XCJJTlRFR0VSXCI+XG4gICAgLy8gICA8dmFyaWFibGVcbiAgICAvLyAgICAgZm9ybWF0PVwiU1RSSU5HIVwiPlxuICAgIC8vICAgPC92YXJpYWJsZT5cbiAgICAvLyA8L2RhdGF0aXBzPlxuICAgIERhdGF0aXBzLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCkge1xuICAgICAgICB2YXIgZGF0YXRpcHMgICAgICAgICA9IG5ldyBEYXRhdGlwcygpLFxuICAgICAgICAgICAgUkdCQ29sb3IgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgICAgICBEYXRhdGlwc1ZhcmlhYmxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhdGlwc192YXJpYWJsZS5qcycpLFxuICAgICAgICAgICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgICAgIHBhcnNlUkdCQ29sb3IgICAgPSBSR0JDb2xvci5wYXJzZSxcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgICAgIHBhcnNlSW50ZWdlciAgICAgPSBwRi5wYXJzZUludGVnZXIsXG4gICAgICAgICAgICBjaGlsZDtcbiAgICAgICAgaWYgKHhtbCkge1xuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcInZhcmlhYmxlXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAkLmVhY2goY2hpbGQsIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGF0aXBzLnZhcmlhYmxlcygpLmFkZCggRGF0YXRpcHNWYXJpYWJsZS5wYXJzZVhNTCgkKGUpKSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImZvcm1hdFwiKSwgICAgICBkYXRhdGlwcy5mb3JtYXRTdHJpbmcpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJiZ2NvbG9yXCIpLCAgICAgZGF0YXRpcHMuYmdjb2xvciwgICAgIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJiZ2FscGhhXCIpLCAgICAgZGF0YXRpcHMuYmdhbHBoYSwgICAgIHBhcnNlRmxvYXQpO1xuICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJib3JkZXJcIiksICAgICAgZGF0YXRpcHMuYm9yZGVyLCAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJvcmRlcmNvbG9yXCIpLCBkYXRhdGlwcy5ib3JkZXJjb2xvciwgcGFyc2VSR0JDb2xvcik7XG4gICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcInBhZFwiKSwgICAgICAgICBkYXRhdGlwcy5wYWQsICAgICAgICAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YXRpcHM7XG4gICAgfTtcblxuICAgIHJldHVybiBEYXRhdGlwcztcbn07XG4iLCJ2YXIgRGF0YXRpcHNWYXJpYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YXRpcHNfdmFyaWFibGUuanMnKTtcblxuRGF0YXRpcHNWYXJpYWJsZS5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwpIHtcbiAgICB2YXIgdmFyaWFibGUgPSBuZXcgRGF0YXRpcHNWYXJpYWJsZSgpLFxuICAgICAgICBwRiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpO1xuXG4gICAgaWYgKHhtbCkge1xuICAgICAgICBwRi5wYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImZvcm1hdFwiKSwgdmFyaWFibGUuZm9ybWF0U3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhYmxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhdGlwc1ZhcmlhYmxlO1xuIiwiLy8gVGhpcyBmaWxlIHVzZXMgalF1ZXJ5LiAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZVxuLy8gZnVuY3Rpb24gcmV0dXJuZWQgYnkgcmVxdWlyaW5nIHRoaXMgZmlsZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIHZhciBGaWx0ZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ZpbHRlci5qcycpO1xuXG4gICAgLy8gaWYgcGFyc2VYTUwgbWV0aG9kIGFscmVhZHkgaGFzIGJlZW4gZGVmaW5lZCwgd2hpY2ggd291bGQgYmUgdGhlIGNhc2UgaWYgdGhpc1xuICAgIC8vIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGNhbGxlZCwganVzdCByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICBpZiAodHlwZW9mKEZpbHRlci5wYXJzZVhNTCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIEZpbHRlcjsgfTtcblxuICAgIC8vIDxmaWx0ZXIgdHlwZT1cIlNUUklOR1wiPlxuICAgIC8vICAgIDxvcHRpb24gbmFtZT1cIlNUUklORyFcIiB2YWx1ZT1cIlNUUklORyFcIi8+XG4gICAgLy8gICAgPG9wdGlvbiBuYW1lPVwiU1RSSU5HIVwiIHZhbHVlPVwiU1RSSU5HIVwiLz5cbiAgICAvLyAgICAuLi5cbiAgICAvLyA8L2ZpbHRlcj5cbiAgICBGaWx0ZXIucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sKSB7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBuZXcgRmlsdGVyKCksXG4gICAgICAgICAgICBGaWx0ZXJPcHRpb24gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ZpbHRlcl9vcHRpb24uanMnKSxcbiAgICAgICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgICAgICBjaGlsZDtcbiAgICAgICAgaWYgKHhtbCkge1xuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKGNoaWxkLCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIub3B0aW9ucygpLmFkZCggRmlsdGVyT3B0aW9uLnBhcnNlWE1MKCQoZSkpICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwRi5wYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcInR5cGVcIiksIGZpbHRlci50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH07XG5cbiAgICByZXR1cm4gRmlsdGVyO1xufTtcblxuIiwidmFyIEZpbHRlck9wdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZmlsdGVyX29wdGlvbi5qcycpO1xuXG4vLyA8b3B0aW9uIG5hbWU9XCJTVFJJTkchXCIgdmFsdWU9XCJTVFJJTkchXCIvPlxuRmlsdGVyT3B0aW9uLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCkge1xuICAgIHZhciBwRiAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgb3B0aW9uID0gbmV3IEZpbHRlck9wdGlvbigpO1xuICAgIGlmICh4bWwpIHtcbiAgICAgICAgb3B0aW9uLm5hbWUocEYuZ2V0WE1MQXR0cih4bWwsXCJuYW1lXCIpKTtcbiAgICAgICAgb3B0aW9uLnZhbHVlKHBGLmdldFhNTEF0dHIoeG1sLFwidmFsdWVcIikgPT09IFwiXCIgPyB1bmRlZmluZWQgOiBwRi5nZXRYTUxBdHRyKHhtbCxcInZhbHVlXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyT3B0aW9uO1xuIiwiLy8gVGhpcyBmaWxlIHVzZXMgalF1ZXJ5LiAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZVxuLy8gZnVuY3Rpb24gcmV0dXJuZWQgYnkgcmVxdWlyaW5nIHRoaXMgZmlsZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIHZhciBHcmFwaCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZ3JhcGguanMnKSxcbiAgICAgICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKTtcblxuICAgIC8vIGlmIHBhcnNlWE1MIG1ldGhvZCBhbHJlYWR5IGhhcyBiZWVuIGRlZmluZWQsIHdoaWNoIHdvdWxkIGJlIHRoZSBjYXNlIGlmIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBjYWxsZWQsIGp1c3QgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKHR5cGVvZihHcmFwaC5wYXJzZVhNTCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIEdyYXBoOyB9O1xuXG4gICAgLypcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyBhbiBYTUwgZG9jdW1lbnQgbG9va2luZyBmb3IgYXR0cmlidXRlcyB2YWx1ZXMgaW52b2x2aW5nIGRlcHJlY2F0ZWRcbiAgICAgKiBjb2xvciBuYW1lcyBhbmQgaXNzdWVzIGEgd2FybmluZyBhYm91dCBlYWNoIG9uZSBmb3VuZC4gIFJlbW92ZSB0aGlzIGZ1bmN0aW9uIHdoZW4gcmVtb3ZpbmdcbiAgICAgKiBzdXBwb3J0IGZvciB0aGVzZSBuYW1lcy4gIFNlZSBzcmMvbWF0aC9yZ2JfY29sb3IuanMgZm9yIGEgbGlzdCBvZiB0aGUgZGVwcmVjYXRlZCBjb2xvcnMuXG4gICAgICovXG4gICAgdmFyIGNoZWNrRGVwcmVjYXRlZENvbG9yTmFtZXMgPSBmdW5jdGlvbiAoeG1sLCBtZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB2YXIgUkdCQ29sb3IgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgICAgICAkeG1sICAgICAgID0gJCh4bWwpLFxuICAgICAgICAgICAgYXR0cmlidXRlcyA9ICR4bWxbMF0uYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGNoaWxkcmVuICAgPSAkeG1sLmNoaWxkcmVuKCksXG4gICAgICAgICAgICBjb2xvck5hbWVJc0RlcHJlY2F0ZWQgPSBSR0JDb2xvci5jb2xvck5hbWVJc0RlcHJlY2F0ZWQsXG4gICAgICAgICAgICBkZXA7XG4gICAgICAgIGlmICh4bWwubm9kZU5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICgvY29sb3IvLnRlc3QocEYuZ2V0WE1MQXR0cigkeG1sLCduYW1lJykpKSB7XG4gICAgICAgICAgICAgICAgZGVwID0gY29sb3JOYW1lSXNEZXByZWNhdGVkKHBGLmdldFhNTEF0dHIoJHhtbCwndmFsdWUnKSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlcCkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci53YXJuaW5nKCdXYXJuaW5nOiBjb2xvciBzdHJpbmcgXCInICsgcEYuZ2V0WE1MQXR0cigkeG1sLCd2YWx1ZScpICsgJ1wiIGlzIGRlcHJlY2F0ZWQ7IHVzZSBcIicgKyBkZXAgKyAnXCIgaW5zdGVhZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgJC5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoL2NvbG9yLy50ZXN0KHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwID0gY29sb3JOYW1lSXNEZXByZWNhdGVkKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci53YXJuaW5nKCdXYXJuaW5nOiBjb2xvciBzdHJpbmcgXCInICsgdGhpcy52YWx1ZSArICdcIiBpcyBkZXByZWNhdGVkOyB1c2UgXCInICsgZGVwICsgJ1wiIGluc3RlYWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjaGVja0RlcHJlY2F0ZWRDb2xvck5hbWVzKHRoaXMsIG1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgR3JhcGgucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sLCBtdWx0aWdyYXBoLCBtZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB2YXIgZ3JhcGggPSBuZXcgR3JhcGgoKSxcbiAgICAgICAgICAgIEF4aXMgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9heGlzLmpzJyksXG4gICAgICAgICAgICBXaW5kb3cgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3dpbmRvdy5qcycpLFxuICAgICAgICAgICAgTGVnZW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9sZWdlbmQuanMnKSxcbiAgICAgICAgICAgIEJhY2tncm91bmQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2JhY2tncm91bmQuanMnKSxcbiAgICAgICAgICAgIFBsb3RhcmVhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wbG90YXJlYS5qcycpLFxuICAgICAgICAgICAgVGl0bGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RpdGxlLmpzJyksXG4gICAgICAgICAgICBEYXRhID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhLmpzJyksXG4gICAgICAgICAgICBQbG90ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9wbG90LmpzJyksXG4gICAgICAgICAgICB1dGlsaXR5RnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsaXR5RnVuY3Rpb25zLmpzJyksXG4gICAgICAgICAgICBkZWZhdWx0cyA9IHV0aWxpdHlGdW5jdGlvbnMuZ2V0RGVmYXVsdFZhbHVlc0Zyb21YU0QoKSxcbiAgICAgICAgICAgIGNoaWxkO1xuXG4gICAgICAgIGdyYXBoLm11bHRpZ3JhcGgobXVsdGlncmFwaCk7XG4gICAgICAgIGlmICh4bWwpIHtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlbGV0ZSB0aGlzIHRyeS9jYXRjaCBibG9jayB3aGVuIHJlbW92aW5nIHN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgY29sb3IgbmFtZXMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0RlcHJlY2F0ZWRDb2xvck5hbWVzKHhtbCwgbWVzc2FnZUhhbmRsZXIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGp1c3QgaWdub3JlIGFueSBlcnJvcnMgaGVyZTsgdGhlIHdvcnN0IHRoYXQgd2lsbCBoYXBwZW4gaXMgdGhhdCB0aGUgdXNlciBqdXN0XG4gICAgICAgICAgICAgICAgLy8gd29uJ3Qgc2VlIHRoZSB3YXJuaW5nc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGVuZCBvZiBibG9jayB0byBkZWxldGUgd2hlbiByZW1vdmluZyBzdXBwb3J0IGZvciBkZXByZWNhdGVkIGNvbG9yIG5hbWVzXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAvLyBOT1RFOiAnT0JKLmZpbmQoXCI+VEFHXCIpJyByZXR1cm5zIGEgbGlzdCBvZiBKUXVlcnkgb2JqZWN0cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBpbW1lZGlhdGVcbiAgICAgICAgICAgIC8vICgxc3QgZ2VuZXJhdGlvbikgY2hpbGQgbm9kZXMgb2YgT0JKIGNvcnJlc3BvbmRpbmcgdG8geG1sIHRhZyBUQUdcbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCI+d2luZG93XCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBncmFwaC53aW5kb3coIFdpbmRvdy5wYXJzZVhNTChjaGlsZCkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcIj5sZWdlbmRcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdyYXBoLmxlZ2VuZCggTGVnZW5kLnBhcnNlWE1MKGNoaWxkKSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmFwaC5sZWdlbmQoIExlZ2VuZC5wYXJzZVhNTCgpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwiPmJhY2tncm91bmRcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdyYXBoLmJhY2tncm91bmQoIEJhY2tncm91bmQucGFyc2VYTUwoY2hpbGQsIGdyYXBoLm11bHRpZ3JhcGgoKSkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCI+cGxvdGFyZWFcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdyYXBoLnBsb3RhcmVhKCBQbG90YXJlYS5wYXJzZVhNTChjaGlsZCkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0geG1sLmZpbmQoXCI+dGl0bGVcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdyYXBoLnRpdGxlKCBUaXRsZS5wYXJzZVhNTChjaGlsZCwgZ3JhcGgpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkLmVhY2goeG1sLmZpbmQoXCI+aG9yaXpvbnRhbGF4aXNcIiksIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGguYXhlcygpLmFkZCggQXhpcy5wYXJzZVhNTCgkKGUpLCBBeGlzLkhPUklaT05UQUwsIG1lc3NhZ2VIYW5kbGVyLCBncmFwaC5tdWx0aWdyYXBoKCkpICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQuZWFjaCh4bWwuZmluZChcIj52ZXJ0aWNhbGF4aXNcIiksIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGguYXhlcygpLmFkZCggQXhpcy5wYXJzZVhNTCgkKGUpLCBBeGlzLlZFUlRJQ0FMLCBtZXNzYWdlSGFuZGxlciwgZ3JhcGgubXVsdGlncmFwaCgpKSApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgIGlmICh4bWwuZmluZChcIj5kYXRhXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgIC8vIE9uIHNlY29uZCB0aHJvdWdodCwgbGV0J3Mgbm90IHRocm93IGFuIGVycm9yIGlmIG5vIDxkYXRhPiB0YWdcbiAgICAgICAgICAgICAvLyBpcyBzcGVjaWZpZWQsIGJlY2F1c2UgY29uY2VpdmFibHkgdGhlcmUgY291bGQgYmUgZ3JhcGhzIGluXG4gICAgICAgICAgICAgLy8gd2hpY2ggYWxsIHRoZSBwbG90cyBhcmUgY29uc3RhbnQgcGxvdHMsIHNvIG5vIGRhdGEgaXMgbmVlZGVkLlxuICAgICAgICAgICAgIC8vIEluIHBhcnRpY3VsYXIsIGluIG91ciBzcGVjL211Z2wvY29uc3RhbnQtcGxvdC54bWwgdGVzdCFcbiAgICAgICAgICAgICAvLyBJJ20gbm90IHN1cmUgd2hhdCBzaG91bGQgYmUgZG9uZSBoZXJlIC0tLSBtYXliZSBpc3N1ZSBhIHdhcm5pbmcsXG4gICAgICAgICAgICAgLy8gb3IgbWF5YmUgZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgICAgICAgICAgLy8gICAgbWJwIE1vbiBOb3YgMTIgMTY6MDU6MjEgMjAxMlxuICAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiR3JhcGggRGF0YSBFcnJvcjogTm8gZGF0YSB0YWdzIHNwZWNpZmllZFwiKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICQuZWFjaCh4bWwuZmluZChcIj50aHJvdHRsZVwiKSwgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiAgICA9IHBGLmdldFhNTEF0dHIoJChlKSwncGF0dGVybicpICAgID8gcEYuZ2V0WE1MQXR0cigkKGUpLCdwYXR0ZXJuJykgICAgOiBkZWZhdWx0cy50aHJvdHRsZS5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0cyAgID0gcEYuZ2V0WE1MQXR0cigkKGUpLCdyZXF1ZXN0cycpICAgPyBwRi5nZXRYTUxBdHRyKCQoZSksJ3JlcXVlc3RzJykgICA6IGRlZmF1bHRzLnRocm90dGxlLnJlcXVlc3RzLFxuICAgICAgICAgICAgICAgICAgICBwZXJpb2QgICAgID0gcEYuZ2V0WE1MQXR0cigkKGUpLCdwZXJpb2QnKSAgICAgPyBwRi5nZXRYTUxBdHRyKCQoZSksJ3BlcmlvZCcpICAgICA6IGRlZmF1bHRzLnRocm90dGxlLnBlcmlvZCxcbiAgICAgICAgICAgICAgICAgICAgY29uY3VycmVudCA9IHBGLmdldFhNTEF0dHIoJChlKSwnY29uY3VycmVudCcpID8gcEYuZ2V0WE1MQXR0cigkKGUpLCdjb25jdXJyZW50JykgOiBkZWZhdWx0cy50aHJvdHRsZS5jb25jdXJyZW50O1xuICAgICAgICAgICAgICAgIG11bHRpZ3JhcGguYWRkQWpheFRocm90dGxlKHBhdHRlcm4sIHJlcXVlc3RzLCBwZXJpb2QsIGNvbmN1cnJlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkLmVhY2goeG1sLmZpbmQoXCI+ZGF0YVwiKSwgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICAgICAgICBncmFwaC5kYXRhKCkuYWRkKCBEYXRhLnBhcnNlWE1MKCQoZSksIGdyYXBoLm11bHRpZ3JhcGgoKSwgbWVzc2FnZUhhbmRsZXIpICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQuZWFjaCh4bWwuZmluZChcIj5wbG90XCIpLCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgIGdyYXBoLnBsb3RzKCkuYWRkKCBQbG90LnBhcnNlWE1MKCQoZSksIGdyYXBoLCBtZXNzYWdlSGFuZGxlcikgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JhcGgucG9zdFBhcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH07XG5cbiAgICByZXR1cm4gR3JhcGg7XG59O1xuIiwidmFyIEdyaWQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2dyaWQuanMnKTtcblxuLy8gPGdyaWQgY29sb3I9XCIjZmYwMGZmXCIgdmlzaWJsZT1cInRydWVcIi8+XG5HcmlkLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCkge1xuICAgIHZhciBncmlkICAgICAgICAgICAgID0gbmV3IEdyaWQoKSxcbiAgICAgICAgUkdCQ29sb3IgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgIHBGICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBhdHRyO1xuICAgIGlmICh4bWwpIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJjb2xvclwiKSwgZ3JpZC5jb2xvciwgUkdCQ29sb3IucGFyc2UpO1xuICAgICAgICAvL05PVEU6IHZpc2libGUgYXR0cmlidXRlIHNob3VsZCBkZWZhdWx0IHRvIHRydWUgd2hlbiBwYXJzaW5nLCBzbyB0aGF0XG4gICAgICAgIC8vICAgICAgdGhlIHByZXNlbmNlIG9mIGEgPGdyaWQ+IHRhZyBhdCBhbGwgd2lsbCB0dXJuIG9uIGEgZ3JpZC4gIEluXG4gICAgICAgIC8vICAgICAgdGhlIEdyaWQgb2JqZWN0IGl0c2VsZiwgdGhvdWdoLCB0aGUgZGVmYXVsdCBmb3IgdGhlIHZpc2libGVcbiAgICAgICAgLy8gICAgICBhdHRyaWJ1dGUgaXMgZmFsc2UsIHNvIHRoYXQgd2hlbiB3ZSBjcmVhdGUgYSBkZWZhdWx0IGdyaWQgb2JqZWN0XG4gICAgICAgIC8vICAgICAgaW4gY29kZSAoYXMgb3Bwb3NlZCB0byBwYXJzaW5nKSwgaXQgZGVmYXVsdHMgdG8gbm90IHZpc2libGUuXG4gICAgICAgIGF0dHIgPSBwRi5nZXRYTUxBdHRyKHhtbCxcInZpc2libGVcIik7XG4gICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGdyaWQudmlzaWJsZShwRi5wYXJzZUJvb2xlYW4oYXR0cikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC52aXNpYmxlKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmlkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkO1xuIiwidmFyIEljb24gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2ljb24uanMnKTtcblxuLy8gPGljb24gYm9yZGVyPVwiMlwiIHdpZHRoPVwiMzBcIiBoZWlnaHQ9XCIyMFwiLz5cbkljb24ucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sKSB7XG5cbiAgICB2YXIgaWNvbiA9IG5ldyBJY29uKCksXG4gICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgcGFyc2VJbnRlZ2VyICAgICA9IHBGLnBhcnNlSW50ZWdlcjtcbiAgICBpZiAoeG1sKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiaGVpZ2h0XCIpLCBpY29uLmhlaWdodCwgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJ3aWR0aFwiKSwgIGljb24ud2lkdGgsICBwYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJvcmRlclwiKSwgaWNvbi5ib3JkZXIsIHBhcnNlSW50ZWdlcik7XG4gICAgfVxuICAgIHJldHVybiBpY29uO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJY29uO1xuIiwidmFyIEltZyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvaW1nLmpzJyk7XG5cbi8vICAgPGltZyBzcmM9XCJmb28ucG5nXCIgYW5jaG9yPVwiLTEgNVwiIGJhc2U9XCIzIDEyXCIgcG9zaXRpb249XCItMiAzXCIgZnJhbWU9XCJwYWRkaW5nXCIvPlxuSW1nLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgbXVsdGlncmFwaCkge1xuICAgIHZhciBpbWcsXG4gICAgICAgIHBGID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIFBvaW50ICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgcGFyc2VQb2ludCAgICAgICA9IFBvaW50LnBhcnNlO1xuICAgIGlmICh4bWwgJiYgcEYuZ2V0WE1MQXR0cih4bWwsXCJzcmNcIikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3JjID0gcEYuZ2V0WE1MQXR0cih4bWwsXCJzcmNcIik7XG4gICAgICAgIGlmICghc3JjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltZyBlbG1lbnQgcmVxdWlyZXMgYSBcInNyY1wiIGF0dHJpYnV0ZSB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdWx0aWdyYXBoKSB7XG4gICAgICAgICAgICBzcmMgPSBtdWx0aWdyYXBoLnJlYmFzZVVybChzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGltZyA9IG5ldyBJbWcoc3JjKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJhbmNob3JcIiksICAgaW1nLmFuY2hvciwgICBwYXJzZVBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJiYXNlXCIpLCAgICAgaW1nLmJhc2UsICAgICBwYXJzZVBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJwb3NpdGlvblwiKSwgaW1nLnBvc2l0aW9uLCBwYXJzZVBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJmcmFtZVwiKSwgICAgaW1nLmZyYW1lLCAgICBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW1nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWc7XG4iLCIvLyB1c2FnZTpcbi8vIFxuLy8gICBBIHZhbGlkIGpRdWVyeSBvYmplY3QgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG4vLyAgIFRoYXQgZnVuY3Rpb24gcmV0dXJucyBhIFBhcnNlWE1MIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGZvbGxvd3M6XG4vL1xuLy8gICAgICB2YXIgUGFyc2VYTUwgPSByZXF1aXJlKCdwYXJzZV94bWwuanMnKSgkKTtcbi8vICAgICAgUGFyc2VYTUwuc3RyaW5nVG9KUXVlcnlYTUxPYmooLi4uKTtcbi8vXG52YXIgSlF1ZXJ5WE1MUGFyc2VyO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkKSB7XG4gICAgaWYgKHR5cGVvZihKUXVlcnlYTUxQYXJzZXIpIT1cInVuZGVmaW5lZFwiKSB7IHJldHVybiBKUXVlcnlYTUxQYXJzZXI7IH07XG5cbiAgICBKUXVlcnlYTUxQYXJzZXIgPSB7fTtcblxuICAgIHJlcXVpcmUoJy4vYXhpcy5qcycpKCQpO1xuICAgIHJlcXVpcmUoJy4vZGF0YS5qcycpKCQpO1xuICAgIHJlcXVpcmUoJy4vZGF0YXRpcHMuanMnKSgkKTtcbiAgICByZXF1aXJlKCcuL2ZpbHRlci5qcycpKCQpO1xuICAgIHJlcXVpcmUoJy4vZ3JhcGguanMnKSgkKTtcbiAgICByZXF1aXJlKCcuL211bHRpZ3JhcGguanMnKSgkKTtcbiAgICByZXF1aXJlKCcuL3Bsb3QuanMnKSgkKTtcbiAgICByZXF1aXJlKCcuL3JlbmRlcmVyLmpzJykoJCk7XG5cbiAgICByZXF1aXJlKCcuL2F4aXNfdGl0bGUuanMnKTtcbiAgICByZXF1aXJlKCcuL2JhY2tncm91bmQuanMnKTtcbiAgICByZXF1aXJlKCcuL2RhdGF0aXBzX3ZhcmlhYmxlLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9kYXRhX3ZhcmlhYmxlLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9maWx0ZXJfb3B0aW9uLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9ncmlkLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9pY29uLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9pbWcuanMnKTtcbiAgICByZXF1aXJlKCcuL2xhYmVsZXIuanMnKTtcbiAgICByZXF1aXJlKCcuL2xlZ2VuZC5qcycpO1xuICAgIHJlcXVpcmUoJy4vcGFuLmpzJyk7XG4gICAgcmVxdWlyZSgnLi9wbG90YXJlYS5qcycpO1xuICAgIHJlcXVpcmUoJy4vcGxvdF9sZWdlbmQuanMnKTtcbiAgICByZXF1aXJlKCcuL3RpdGxlLmpzJyk7XG4gICAgcmVxdWlyZSgnLi93aW5kb3cuanMnKTtcbiAgICByZXF1aXJlKCcuL3pvb20uanMnKTtcblxuICAgIEpRdWVyeVhNTFBhcnNlci5zdHJpbmdUb0pRdWVyeVhNTE9iaiA9IGZ1bmN0aW9uICh0aGluZ3kpIHtcbiAgICAgICAgaWYgKHR5cGVvZih0aGluZ3kpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGluZ3kpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4bWwgPSAkLnBhcnNlWE1MKHRoaW5neSk7XG4gICAgICAgIHJldHVybiAkKCQoeG1sKS5jaGlsZHJlbigpWzBdKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEpRdWVyeVhNTFBhcnNlcjtcbn07XG4iLCJ2YXIgTGFiZWxlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbGFiZWxlci5qcycpO1xuXG4vLyA8bGFiZWxzXG4vLyAgIGZvcm1hdD1cIlNUUklOR1wiXG4vLyAgIHN0YXJ0PVwiREFUQVZBTFVFKDApXCJcbi8vICAgYW5nbGU9XCJET1VCTEUoMClcIlxuLy8gICBwb3NpdGlvbj1cIlBPSU5UXCJcbi8vICAgYW5jaG9yPVwiUE9JTlRcIlxuLy8gICBjb2xvcj1cIkNPTE9SKGJsYWNrKVwiXG4vLyAgIHNwYWNpbmc9XCJTVFJJTkdcIlxuLy8gICBkZW5zaXR5ZmFjdG9yPVwiRE9VQkxFKDEuMClcIj5cbi8vICAgICA8bGFiZWwgZm9ybWF0PVwiU1RSSU5HXCIgc3RhcnQ9XCJTVFJJTkdcIiBhbmdsZT1cIkRPVUJMRVwiIHBvc2l0aW9uPVwiUE9JTlRcIiBhbmNob3I9XCJQT0lOVFwiIHNwYWNpbmc9XCJTVFJJTkdcIiBkZW5zaXR5ZmFjdG9yPVwiRE9VQkxFXCI+XG4vLyAgICAgPGxhYmVsIGZvcm1hdD1cIlNUUklOR1wiIHN0YXJ0PVwiU1RSSU5HXCIgYW5nbGU9XCJET1VCTEVcIiBwb3NpdGlvbj1cIlBPSU5UXCIgYW5jaG9yPVwiUE9JTlRcIiBzcGFjaW5nPVwiU1RSSU5HXCIgZGVuc2l0eWZhY3Rvcj1cIkRPVUJMRVwiPlxuLy8gPC9sYWJlbD5cbkxhYmVsZXIucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sLCBheGlzLCBkZWZhdWx0cywgc3BhY2luZykge1xuICAgIC8vIFRoaXMgcGFyc2VyIHRha2VzIGFuIG9wdGlvbmFsIGZpbmFsIGFyZ3VtZW50LCBzcGFjaW5nLCB3aGljaCBpcyBhIHN0cmluZyByZXByZXNlbnRpbmdcbiAgICAvLyB0aGUgc3BhY2luZyB0byBiZSBwYXJzZWQgZm9yIHRoZSBsYWJlbGVyLiAgSWYgdGhhdCBhcmd1bWVudCBpcyBub3QgcHJlc2VudCwgdGhlIHNwYWNpbmdcbiAgICAvLyB2YWx1ZSBpcyB0YWtlbiBmcm9tIHRoZSB4bWwgb2JqZWN0LiAgSWYgYSBzcGFjaW5nIGFyZ3VtZW50IGlzIHByZXNlbnQsIGl0IGlzIHBhcnNlZFxuICAgIC8vIGFuZCB1c2VkIHRvIHNldCB0aGUgc3BhY2luZyBhdHRyaWJ1dGUgb2YgdGhlIExhYmVsZXIgb2JqZWN0LCBhbmQgaW4gdGhpcyBjYXNlLCBhbnlcbiAgICAvLyBzcGFjaW5nIHZhbHVlIHByZXNlbnQgaW4gdGhlIHhtbCBpcyBpZ25vcmVkLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlIHNwYWNpbmcgYXJndW1lbnQgaGFzIHRoZSB2YWx1ZSBudWxsLCB0aGUgcmVzdWx0aW5nIGxhYmVsZXIgd2lsbCBoYXZlIG5vIHNwYWNpbmdcbiAgICAvLyBhdHRyaWJ1dGUgc2V0IGF0IGFsbC5cbiAgICB2YXIgbGFiZWxlcixcbiAgICAgICAgUG9pbnQgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIFJHQkNvbG9yID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgRGF0YU1lYXN1cmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfbWVhc3VyZS5qcycpLFxuICAgICAgICBEYXRhVmFsdWUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfdmFsdWUuanMnKSxcbiAgICAgICAgRGF0YUZvcm1hdHRlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV9mb3JtYXR0ZXIuanMnKSxcbiAgICAgICAgcEYgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgcGFyc2VQb2ludCA9IFBvaW50LnBhcnNlO1xuXG4gICAgLy8gYHBhcnNlQXR0cmlidXRlYCByZXR1cm5zIHRydWUgb3IgZmFsc2UgZGVwZW5kaW5nIG9uIHdoZXRoZXIgb3Igbm90IGl0IHNldCB0aGUgYXR0cmlidXRlLlxuICAgIC8vIElmIGl0IGRpZCBub3QgYW5kIGlmIHRoZSBgZGVmYXVsdHNgIG9iamVjdCBleGlzdHMgdGhlbiB0aGUgYXR0cmlidXRlIGlzIHNldCB0byB0aGVcbiAgICAvLyBhcHByb3ByaWF0ZSBkZWZhdWx0IHZhbHVlLlxuICAgIHZhciBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodmFsdWUsIGF0dHJpYnV0ZSwgcHJlcHJvY2Vzc29yLCBkZWZhdWx0TmFtZSkge1xuICAgICAgICBpZiAoIXBGLnBhcnNlQXR0cmlidXRlKHZhbHVlLCBhdHRyaWJ1dGUsIHByZXByb2Nlc3NvcikgJiYgZGVmYXVsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXR0cmlidXRlKGRlZmF1bHRzW2RlZmF1bHROYW1lXSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBhcnNlRGF0YUZvcm1hdHRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRhRm9ybWF0dGVyLmNyZWF0ZSh0eXBlLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgcGFyc2VEYXRhVmFsdWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0YVZhbHVlLnBhcnNlKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgaWYgKHhtbCkge1xuICAgICAgICBsYWJlbGVyID0gbmV3IExhYmVsZXIoYXhpcyk7XG4gICAgICAgIGlmIChzcGFjaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc3BhY2luZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3BhY2luZyA9IHBGLmdldFhNTEF0dHIoeG1sLFwic3BhY2luZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vTk9URTogc3BhY2luZyBtaWdodCBzdGlsbCA9PT0gdW5kZWZpbmVkIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShzcGFjaW5nLCBsYWJlbGVyLnNwYWNpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24odikgeyByZXR1cm4gRGF0YU1lYXN1cmUucGFyc2UoYXhpcy50eXBlKCksIHYpOyB9LCAvL3BGLnBhcnNlRGF0YU1lYXN1cmUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNwYWNpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VMYWJlbGVyQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiZm9ybWF0XCIpLCAgICAgICAgbGFiZWxlci5mb3JtYXR0ZXIsICAgICBwYXJzZURhdGFGb3JtYXR0ZXIoYXhpcy50eXBlKCkpLCAgICAgICAgICAgICAgXCJmb3JtYXR0ZXJcIik7XG4gICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcInN0YXJ0XCIpLCAgICAgICAgIGxhYmVsZXIuc3RhcnQsICAgICAgICAgcGFyc2VEYXRhVmFsdWUoYXhpcy50eXBlKCkpLCAgICAgICAgICAgICAgICAgIFwic3RhcnRcIik7XG4gICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImFuZ2xlXCIpLCAgICAgICAgIGxhYmVsZXIuYW5nbGUsICAgICAgICAgcGFyc2VGbG9hdCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYW5nbGVcIik7XG4gICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcInBvc2l0aW9uXCIpLCAgICAgIGxhYmVsZXIucG9zaXRpb24sICAgICAgcGFyc2VQb2ludCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIik7XG4gICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImFuY2hvclwiKSwgICAgICAgIGxhYmVsZXIuYW5jaG9yLCAgICAgICAgcGFyc2VQb2ludCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYW5jaG9yXCIpO1xuICAgICAgICBwYXJzZUxhYmVsZXJBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJkZW5zaXR5ZmFjdG9yXCIpLCBsYWJlbGVyLmRlbnNpdHlmYWN0b3IsIHBhcnNlRmxvYXQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRlbnNpdHlmYWN0b3JcIik7XG4gICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImNvbG9yXCIpLCAgICAgICAgIGxhYmVsZXIuY29sb3IsICAgICAgICAgUkdCQ29sb3IucGFyc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIik7XG4gICAgICAgIHBhcnNlTGFiZWxlckF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcInZpc2libGVcIiksICAgICAgIGxhYmVsZXIudmlzaWJsZSwgICAgICAgcEYucGFyc2VCb29sZWFuLCAgICAgICAgICAgICAgICBcInZpc2libGVcIik7XG5cbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsZXI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhYmVsZXI7XG4iLCJ2YXIgTGVnZW5kID0gcmVxdWlyZSgnLi4vLi4vY29yZS9sZWdlbmQuanMnKTtcblxuLy8gPGxlZ2VuZFxuLy8gICAgIHZpc2libGU9XCJCT09MRUFOXCJcbi8vICAgICBiYXNlPVwiUE9JTlQoMSwxKVwiXG4vLyAgICAgYW5jaG9yPVwiUE9JTlQoMSwxKVwiXG4vLyAgICAgcG9zaXRpb249XCJQT0lOVCgwLDApXCJcbi8vICAgICBmcmFtZT1cIkZSQU1FKHBhZGRpbmcpXCJcbi8vICAgICBjb2xvcj1cIkNPTE9SKHdoaXRlKVwiXG4vLyAgICAgb3BhY2l0eT1cIkRPVUJMRSgxLjApXCJcbi8vICAgICBib3JkZXI9XCJJTlRFR0VSKDEpXCJcbi8vICAgICBib3JkZXJjb2xvcj1cIkNPTE9SKGJsYWNrKVwiXG4vLyAgICAgcm93cz1cIklOVEVHRVJcIlxuLy8gICAgIGNvbHVtbnM9XCJJTlRFR0VSXCJcbi8vICAgICBjb3JuZXJyYWRpdXM9XCJJTlRFR0VSKDApXCJcbi8vICAgICBwYWRkaW5nPVwiSU5URUdFUigwKVwiPlxuLy8gICA8aWNvblxuLy8gICAgICAgd2lkdGg9XCJJTlRFR0VSKDQwKVwiXG4vLyAgICAgICBoZWlnaHQ9XCJJTlRFR0VSKDMwKVwiXG4vLyAgICAgICBib3JkZXI9XCJJTlRFR0VSKDEpXCI+XG4vLyAgIDwvaWNvbj5cbi8vIDwvbGVnZW5kPlxuTGVnZW5kLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCkge1xuICAgIHZhciBsZWdlbmQgICAgICAgICAgID0gbmV3IExlZ2VuZCgpLFxuICAgICAgICBwRiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIFBvaW50ICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvaW50LmpzJyksXG4gICAgICAgIFJHQkNvbG9yICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICBJY29uICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9pY29uLmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgcGFyc2VJbnRlZ2VyICAgICA9IHBGLnBhcnNlSW50ZWdlcixcbiAgICAgICAgcGFyc2VQb2ludCAgICAgICA9IFBvaW50LnBhcnNlLFxuICAgICAgICBwYXJzZVJHQkNvbG9yICAgID0gUkdCQ29sb3IucGFyc2UsXG4gICAgICAgIGNoaWxkO1xuICAgIGlmICh4bWwpIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJ2aXNpYmxlXCIpLCAgICAgIGxlZ2VuZC52aXNpYmxlLCAgICAgIHBGLnBhcnNlQm9vbGVhbik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYmFzZVwiKSwgICAgICAgICBsZWdlbmQuYmFzZSwgICAgICAgICBwYXJzZVBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJhbmNob3JcIiksICAgICAgIGxlZ2VuZC5hbmNob3IsICAgICAgIHBhcnNlUG9pbnQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcInBvc2l0aW9uXCIpLCAgICAgbGVnZW5kLnBvc2l0aW9uLCAgICAgcGFyc2VQb2ludCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiZnJhbWVcIiksICAgICAgICBsZWdlbmQuZnJhbWUpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImNvbG9yXCIpLCAgICAgICAgbGVnZW5kLmNvbG9yLCAgICAgICAgcGFyc2VSR0JDb2xvcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYm9yZGVyY29sb3JcIiksICBsZWdlbmQuYm9yZGVyY29sb3IsICBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJvcGFjaXR5XCIpLCAgICAgIGxlZ2VuZC5vcGFjaXR5LCAgICAgIHBhcnNlRmxvYXQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJvcmRlclwiKSwgICAgICAgbGVnZW5kLmJvcmRlciwgICAgICAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJyb3dzXCIpLCAgICAgICAgIGxlZ2VuZC5yb3dzLCAgICAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiY29sdW1uc1wiKSwgICAgICBsZWdlbmQuY29sdW1ucywgICAgICBwYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImNvcm5lcnJhZGl1c1wiKSwgbGVnZW5kLmNvcm5lcnJhZGl1cywgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJwYWRkaW5nXCIpLCAgICAgIGxlZ2VuZC5wYWRkaW5nLCAgICAgIHBhcnNlSW50ZWdlcik7XG5cbiAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcImljb25cIik7XG4gICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZWdlbmQuaWNvbihJY29uLnBhcnNlWE1MKGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGVnZW5kO1xuIiwiLy8gVGhpcyBmaWxlIHVzZXMgalF1ZXJ5LiAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZVxuLy8gZnVuY3Rpb24gcmV0dXJuZWQgYnkgcmVxdWlyaW5nIHRoaXMgZmlsZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIHZhciBNdWx0aWdyYXBoID0gcmVxdWlyZSgnLi4vLi4vY29yZS9tdWx0aWdyYXBoLmpzJykoJCk7XG5cbiAgICAvLyBpZiBwYXJzZVhNTCBtZXRob2QgYWxyZWFkeSBoYXMgYmVlbiBkZWZpbmVkLCB3aGljaCB3b3VsZCBiZSB0aGUgY2FzZSBpZiB0aGlzXG4gICAgLy8gZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkLCBqdXN0IHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0eXBlb2YoTXVsdGlncmFwaC5wYXJzZVhNTCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIE11bHRpZ3JhcGg7IH07XG5cbiAgICBNdWx0aWdyYXBoLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgbXVnbCwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgdmFyIG11bHRpZ3JhcGggPSBuZXcgTXVsdGlncmFwaCgpLFxuICAgICAgICAgICAgZ3JhcGhzICAgICA9IG11bHRpZ3JhcGguZ3JhcGhzKCksXG4gICAgICAgICAgICBHcmFwaCAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ncmFwaC5qcycpLFxuICAgICAgICAgICAgY2hpbGQ7XG4gICAgICAgIG11bHRpZ3JhcGgubXVnbChtdWdsKTsgLy8gc2V0IHRoZSBtdWdsIHVybFxuICAgICAgICBpZiAoeG1sKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwiPmdyYXBoXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAkLmVhY2goY2hpbGQsIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBocy5hZGQoIEdyYXBoLnBhcnNlWE1MKCQoZSksIG11bHRpZ3JhcGgsIG1lc3NhZ2VIYW5kbGVyKSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5sZW5ndGggPT09IDAgJiYgeG1sLmNoaWxkcmVuKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdyYXBocy5hZGQoIEdyYXBoLnBhcnNlWE1MKHhtbCwgbXVsdGlncmFwaCwgbWVzc2FnZUhhbmRsZXIpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG11bHRpZ3JhcGg7XG4gICAgfTtcblxuICAgIHJldHVybiBNdWx0aWdyYXBoO1xufTtcbiIsInZhciBQYW4gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3Bhbi5qcycpO1xuXG4vLyA8cGFuIGFsbG93ZWQ9XCJ0cnVlXCIgbWluPVwiLTEwMFwiIG1heD1cIjEwMFwiLz5cblBhbi5wYXJzZVhNTCA9IGZ1bmN0aW9uICh4bWwsIHR5cGUpIHtcbiAgICB2YXIgcGFuICAgICAgICAgICAgPSBuZXcgUGFuKCksXG4gICAgICAgIHBGICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIERhdGFWYWx1ZSAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlRGF0YVZhbHVlID0gZnVuY3Rpb24odikgeyByZXR1cm4gRGF0YVZhbHVlLnBhcnNlKHR5cGUsIHYpOyB9O1xuICAgIGlmICh4bWwpIHtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJhbGxvd2VkXCIpLCBwYW4uYWxsb3dlZCwgcEYucGFyc2VCb29sZWFuKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJtaW5cIiksICAgICBwYW4ubWluLCAgICAgcGFyc2VEYXRhVmFsdWUpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcIm1heFwiKSwgICAgIHBhbi5tYXgsICAgICBwYXJzZURhdGFWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBwYW47XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhbjtcbiIsIi8vIFRoaXMgZmlsZSB1c2VzIGpRdWVyeS4gIEEgdmFsaWQgalF1ZXJ5IG9iamVjdCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbi8vIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHJlcXVpcmluZyB0aGlzIGZpbGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgUGxvdCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGxvdC5qcycpO1xuXG4gICAgLy8gaWYgcGFyc2VYTUwgbWV0aG9kIGFscmVhZHkgaGFzIGJlZW4gZGVmaW5lZCwgd2hpY2ggd291bGQgYmUgdGhlIGNhc2UgaWYgdGhpc1xuICAgIC8vIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGNhbGxlZCwganVzdCByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICBpZiAodHlwZW9mKFBsb3QucGFyc2VYTUwpPT09XCJmdW5jdGlvblwiKSB7IHJldHVybiBQbG90OyB9O1xuXG4gICAgLy8gPHBsb3Q+XG4gICAgLy8gICA8bGVnZW5kXG4gICAgLy8gICAgICAgdmlzaWJsZT1cIkJPT0xFQU5cIlxuICAgIC8vICAgICAgIGxhYmVsPVwiU1RSSU5HXCI+XG4gICAgLy8gICA8L2xlZ2VuZD5cbiAgICAvLyAgIDxob3Jpem9udGFsYXhpcyByZWY9XCJTVFJJTkchXCI+XG4gICAgLy8gICAgIDx2YXJpYWJsZSByZWY9XCJTVFJJTkchXCIgLz5cbiAgICAvLyAgIDwvaG9yaXpvbnRhbGF4aXM+XG4gICAgLy8gICA8dmVydGljYWxheGlzIHJlZj1cIlNUUklORyFcIj5cbiAgICAvLyAgICAgPHZhcmlhYmxlIHJlZj1cIlNUUklOR1wiIC8+XG4gICAgLy8gICAgIDxjb25zdGFudCB2YWx1ZT1cIkRBVEFWQUxVRVwiLz5cbiAgICAvLyAgIDwvdmVydGljYWxheGlzPlxuICAgIC8vICAgPHJlbmRlcmVyIHR5cGU9XCJSRU5ERVJFUlRZUEUobGluZSlcIj5cbiAgICAvLyAgICAgPG9wdGlvbiBuYW1lPVwiU1RSSU5HIVwiIHZhbHVlPVwiU1RSSU5HIVwiIG1pbj1cIkRBVEFWQUxVRVwiIG1heD1cIkRBVEFWQUxVRVwiLz5cbiAgICAvLyAgICAgPG9wdGlvbiBuYW1lPVwiU1RSSU5HIVwiIHZhbHVlPVwiU1RSSU5HIVwiIG1pbj1cIkRBVEFWQUxVRVwiIG1heD1cIkRBVEFWQUxVRVwiLz5cbiAgICAvLyAgICAgLi4uXG4gICAgLy8gICA8L3JlbmRlcmVyPlxuICAgIC8vICAgPGRhdGF0aXBzIGZvcm1hdD1cIlNUUklORyFcIiBiZ2NvbG9yPVwiQ09MT1JcIiBiZ2FscGhhPVwiRE9VQkxFXCIgYm9yZGVyPVwiSU5URUdFUlwiIGJvcmRlcmNvbG9yPVwiQ09MT1JcIiBwYWQ9XCJJTlRFR0VSXCI+XG4gICAgLy8gICAgIDx2YXJpYWJsZSBmb3JtYXQ9XCJTVFJJTkchXCIgLz5cbiAgICAvLyAgICAgPHZhcmlhYmxlIGZvcm1hdD1cIlNUUklORyFcIiAvPlxuICAgIC8vICAgICAuLi5cbiAgICAvLyAgIDwvZGF0YXRpcHM+XG4gICAgLy8gPC9wbG90PlxuICAgIFBsb3QucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sLCBncmFwaCwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgdmFyIERhdGFQbG90ICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV9wbG90LmpzJyksXG4gICAgICAgICAgICBQbG90TGVnZW5kICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3Bsb3RfbGVnZW5kLmpzJyksXG4gICAgICAgICAgICBDb25zdGFudFBsb3QgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbnN0YW50X3Bsb3QuanMnKSxcbiAgICAgICAgICAgIERhdGFWYWx1ZSAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YV92YWx1ZS5qcycpLFxuICAgICAgICAgICAgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9yZW5kZXJlci5qcycpLFxuICAgICAgICAgICAgRmlsdGVyICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9maWx0ZXIuanMnKSxcbiAgICAgICAgICAgIERhdGF0aXBzICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGF0YXRpcHMuanMnKSxcbiAgICAgICAgICAgIHBGICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICAgICAgcGxvdCxcbiAgICAgICAgICAgIGhheGlzLFxuICAgICAgICAgICAgdmF4aXMsXG4gICAgICAgICAgICB2YXJpYWJsZSxcbiAgICAgICAgICAgIGF0dHIsIGNoaWxkO1xuICAgICAgICBpZiAoeG1sKSB7XG5cbiAgICAgICAgICAgIC8vIHBvcHVsYXRlIHZlcnRpY2FsYXhpcyBmcm9tIHhtbFxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcIj52ZXJ0aWNhbGF4aXNcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID09PSAxICYmIHBGLmdldFhNTEF0dHIoY2hpbGQsXCJyZWZcIikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXhpcyA9IGdyYXBoLmF4aXNCeUlkKHBGLmdldFhNTEF0dHIoY2hpbGQsXCJyZWZcIikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmF4aXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxvdCBWZXJ0aWNhbCBBeGlzIEVycm9yOiBUaGUgZ3JhcGggZG9lcyBub3QgY29udGFpbiBhbiBheGlzIHdpdGggYW4gaWQgb2YgJ1wiICsgcEYuZ2V0WE1MQXR0cihjaGlsZCxcInJlZlwiKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcInZlcnRpY2FsYXhpcyBjb25zdGFudFwiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0YW50VmFsdWVTdHJpbmcgPSBwRi5nZXRYTUxBdHRyKGNoaWxkLFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0YW50VmFsdWVTdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25zdGFudCBQbG90IEVycm9yOiBBICd2YWx1ZScgYXR0cmlidXRlIGlzIG5lZWRlZCB0byBkZWZpbmUgYSBDb25zdGFudCBQbG90XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwbG90ID0gbmV3IENvbnN0YW50UGxvdChEYXRhVmFsdWUucGFyc2UodmF4aXMudHlwZSgpLCBjb25zdGFudFZhbHVlU3RyaW5nKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsb3QgPSBuZXcgRGF0YVBsb3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGxvdC52ZXJ0aWNhbGF4aXModmF4aXMpO1xuXG4gICAgICAgICAgICAvLyBwb3B1bGF0ZSBob3Jpem9udGFsYXhpcyBmcm9tIHhtbFxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcIj5ob3Jpem9udGFsYXhpc1wiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPT09IDEgJiYgcEYuZ2V0WE1MQXR0cihjaGlsZCxcInJlZlwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyYXBoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhheGlzID0gZ3JhcGguYXhpc0J5SWQocEYuZ2V0WE1MQXR0cihjaGlsZCxcInJlZlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbG90Lmhvcml6b250YWxheGlzKGhheGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgSG9yaXpvbnRhbCBBeGlzIEVycm9yOiBUaGUgZ3JhcGggZG9lcyBub3QgY29udGFpbiBhbiBheGlzIHdpdGggYW4gaWQgb2YgJ1wiICsgcEYuZ2V0WE1MQXR0cihjaGlsZCxcInJlZlwiKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIERhdGFQbG90LCBwYXJzZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmIChwbG90IGluc3RhbmNlb2YgRGF0YVBsb3QpIHtcblxuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgZGVmYXVsdCBob3Jpem9udGFsYXhpcyB2YXJpYWJsZSBpZiBub3QgcHJlc2VudCBpbiB4bWxcbiAgICAgICAgICAgICAgICBpZiAoeG1sLmZpbmQoXCJob3Jpem9udGFsYXhpcyB2YXJpYWJsZVwiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGxvdC52YXJpYWJsZSgpLmFkZChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9UT0RPOiBkZWZlciBwb3B1bGF0aW9uIG9mIHZhcmlhYmxlcyB1bnRpbCBub3JtYWxpemVyIGhhcyBleGVjdXRlZFxuICAgICAgICAgICAgICAgIC8vIHBvcHVsYXRlIGF4aXMgdmFyaWFibGVzIGZyb20geG1sXG4gICAgICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcImhvcml6b250YWxheGlzIHZhcmlhYmxlLCB2ZXJ0aWNhbGF4aXMgdmFyaWFibGVcIik7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYXBoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goY2hpbGQsIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IHBGLmdldFhNTEF0dHIoJChlKSxcInJlZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IGdyYXBoLnZhcmlhYmxlQnlJZCggYXR0ciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QuZGF0YSggdmFyaWFibGUuZGF0YSgpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QudmFyaWFibGUoKS5hZGQodmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsb3QgVmFyaWFibGUgRXJyb3I6IE5vIERhdGEgdGFnIGNvbnRhaW5zIGEgdmFyaWFibGUgd2l0aCBhbiBpZCBvZiAnXCIgKyBhdHRyICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcG9wdWxhdGUgbGVnZW5kIGZyb20geG1sXG4gICAgICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwibGVnZW5kXCIpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwbG90LmxlZ2VuZChQbG90TGVnZW5kLnBhcnNlWE1MKGNoaWxkLCBwbG90KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsb3QubGVnZW5kKFBsb3RMZWdlbmQucGFyc2VYTUwodW5kZWZpbmVkLCBwbG90KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHBvcHVsYXRlIHJlbmRlcmVyIGZyb20geG1sXG4gICAgICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwicmVuZGVyZXJcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBsb3QucmVuZGVyZXIoUmVuZGVyZXIucGFyc2VYTUwoY2hpbGQsIHBsb3QsIG1lc3NhZ2VIYW5kbGVyKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHBvcHVsYXRlIGZpbHRlciBmcm9tIHhtbFxuICAgICAgICAgICAgY2hpbGQgPSB4bWwuZmluZChcImZpbHRlclwiKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcGxvdC5maWx0ZXIoRmlsdGVyLnBhcnNlWE1MKGNoaWxkKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHBvcHVsYXRlIGRhdGF0aXBzIGZyb20geG1sXG4gICAgICAgICAgICBjaGlsZCA9IHhtbC5maW5kKFwiZGF0YXRpcHNcIik7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBsb3QuZGF0YXRpcHMoRGF0YXRpcHMucGFyc2VYTUwoY2hpbGQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbG90O1xuICAgIH07XG5cbiAgICByZXR1cm4gUGxvdDtcbn07XG4iLCJ2YXIgUGxvdExlZ2VuZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcGxvdF9sZWdlbmQuanMnKTtcblxuLy8gPGxlZ2VuZCB2aXNpYmxlPVwiQk9PTEVBTlwiIGxhYmVsPVwiU1RSSU5HXCIgLz5cblBsb3RMZWdlbmQucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sLCBwbG90KSB7XG4gICAgdmFyIGxlZ2VuZCAgICAgICAgICAgPSBuZXcgUGxvdExlZ2VuZCgpLFxuICAgICAgICBwRiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIFRleHQgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RleHQuanMnKSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBjaGlsZDtcbiAgICBpZiAoeG1sKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwidmlzaWJsZVwiKSwgbGVnZW5kLnZpc2libGUsIHBGLnBhcnNlQm9vbGVhbik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwibGFiZWxcIiksICAgbGVnZW5kLmxhYmVsLCAgIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFRleHQodmFsdWUpOyB9KTtcbiAgICB9XG5cbiAgICBpZiAobGVnZW5kLmxhYmVsKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB1Z2x5IHBhdGNoIHdpdGggc29tZXRoaW5nIHRoYXQgd29ya3MgcHJvcGVybHlcbiAgICAgICAgaWYgKHR5cGVvZihwbG90LnZhcmlhYmxlKT09PVwiZnVuY3Rpb25cIiAmJiBwbG90LnZhcmlhYmxlKCkuc2l6ZSgpID49IDIpIHsgXG4gICAgICAgICAgICBsZWdlbmQubGFiZWwobmV3IFRleHQocGxvdC52YXJpYWJsZSgpLmF0KDEpLmlkKCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2VuZC5sYWJlbChuZXcgVGV4dChcInBsb3RcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsb3RMZWdlbmQ7XG4iLCJ2YXIgUGxvdGFyZWEgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3Bsb3RhcmVhLmpzJyk7XG5cbi8vICA8cGxvdGFyZWFcbi8vICAgICBtYXJnaW5ib3R0b209XCJJTlRFR0VSKDM1KVwiXG4vLyAgICAgbWFyZ2lubGVmdD1cIklOVEVHRVIoMzgpXCJcbi8vICAgICBtYXJnaW50b3A9XCJJTlRFR0VSKDEwKVwiXG4vLyAgICAgbWFyZ2lucmlnaHQ9XCJJTlRFR0VSKDM1KVwiXG4vLyAgICAgYm9yZGVyPVwiSU5URUdFUigwKVwiXG4vLyAgICAgYm9yZGVyY29sb3I9XCJDT0xPUigweGVlZWVlZSlcIlxuLy8gICAgIGNvbG9yPVwiQ09MT1JcIj5cbi8vICA8L3Bsb3RhcmVhPlxuUGxvdGFyZWEucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sKSB7XG4gICAgdmFyIHBsb3RhcmVhID0gbmV3IFBsb3RhcmVhKCksXG4gICAgICAgIG1hcmdpbiA9IHBsb3RhcmVhLm1hcmdpbigpLFxuICAgICAgICBwRiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIFJHQkNvbG9yICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL3JnYl9jb2xvci5qcycpLFxuICAgICAgICBwYXJzZVJHQkNvbG9yICAgID0gUkdCQ29sb3IucGFyc2UsXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgcGFyc2VJbnRlZ2VyICAgICA9IHBGLnBhcnNlSW50ZWdlcjtcbiAgICBpZiAoeG1sKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwibWFyZ2luYm90dG9tXCIpLCBtYXJnaW4uYm90dG9tLCAgICAgICAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJtYXJnaW5sZWZ0XCIpLCAgIG1hcmdpbi5sZWZ0LCAgICAgICAgICBwYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcIm1hcmdpbnRvcFwiKSwgICAgbWFyZ2luLnRvcCwgICAgICAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwibWFyZ2lucmlnaHRcIiksICBtYXJnaW4ucmlnaHQsICAgICAgICAgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJib3JkZXJcIiksICAgICAgIHBsb3RhcmVhLmJvcmRlciwgICAgICBwYXJzZUludGVnZXIpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImNvbG9yXCIpLCAgICAgICAgcGxvdGFyZWEuY29sb3IsICAgICAgIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJvcmRlcmNvbG9yXCIpLCAgcGxvdGFyZWEuYm9yZGVyY29sb3IsIHBhcnNlUkdCQ29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gcGxvdGFyZWE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsb3RhcmVhO1xuIiwiLy8gVGhpcyBmaWxlIHVzZXMgalF1ZXJ5LiAgQSB2YWxpZCBqUXVlcnkgb2JqZWN0IG11c3QgYmUgcGFzc2VkIHRvIHRoZVxuLy8gZnVuY3Rpb24gcmV0dXJuZWQgYnkgcmVxdWlyaW5nIHRoaXMgZmlsZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCkge1xuICAgIHZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcmVuZGVyZXIuanMnKTtcblxuICAgIC8vIGlmIHBhcnNlWE1MIG1ldGhvZCBhbHJlYWR5IGhhcyBiZWVuIGRlZmluZWQsIHdoaWNoIHdvdWxkIGJlIHRoZSBjYXNlIGlmIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBjYWxsZWQsIGp1c3QgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKHR5cGVvZihSZW5kZXJlci5wYXJzZVhNTCk9PT1cImZ1bmN0aW9uXCIpIHsgcmV0dXJuIFJlbmRlcmVyOyB9O1xuXG4gICAgLy8gPHJlbmRlcmVyXG4gICAgLy8gICAgIHR5cGU9XCJSRU5ERVJFUlRZUEUobGluZSlcIj5cbiAgICAvLyAgIDxvcHRpb25cbiAgICAvLyAgICAgICBuYW1lPVwiU1RSSU5HIVwiXG4gICAgLy8gICAgICAgdmFsdWU9XCJTVFJJTkchXCJcbiAgICAvLyAgICAgICBtaW49XCJEQVRBVkFMVUVcIlxuICAgIC8vICAgICAgIG1heD1cIkRBVEFWQUxVRVwiPlxuICAgIC8vICAgPC9vcHRpb24+XG4gICAgLy8gICAuLi5cbiAgICAvLyA8L3JlbmRlcmVyPlxuICAgIFJlbmRlcmVyLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgcGxvdCwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgdmFyIERhdGFWYWx1ZSAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgICAgICBOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvbnVtYmVyX3ZhbHVlLmpzJyksXG4gICAgICAgICAgICBXYXJuaW5nICAgICA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvd2FybmluZy5qcycpLFxuICAgICAgICAgICAgcEYgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi91dGlsL3BhcnNpbmdGdW5jdGlvbnMuanMnKSxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZSxcbiAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgb3B0O1xuXG4gICAgICAgIHJlcXVpcmUoJy4uLy4uL2NvcmUvcmVuZGVyZXJzL2FsbF9yZW5kZXJlcnMuanMnKTtcblxuICAgICAgICBpZiAoeG1sICYmIHBGLmdldFhNTEF0dHIoeG1sLFwidHlwZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSBSZW5kZXJlci5UeXBlLnBhcnNlKHBGLmdldFhNTEF0dHIoeG1sLFwidHlwZVwiKSk7XG4gICAgICAgICAgICBpZiAoIVJlbmRlcmVyLlR5cGUuaXNJbnN0YW5jZShyZW5kZXJlclR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biByZW5kZXJlciB0eXBlICdcIiArIHBGLmdldFhNTEF0dHIoeG1sLFwidHlwZVwiKSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVyID0gUmVuZGVyZXIuY3JlYXRlKHJlbmRlcmVyVHlwZSk7XG4gICAgICAgICAgICByZW5kZXJlci5wbG90KHBsb3QpO1xuICAgICAgICAgICAgaWYgKHhtbC5maW5kKFwib3B0aW9uXCIpLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBwcm92aWRlcyBzdXBwb3J0IGZvciBkZXByZWNhdGQgdGhlIFwibWlzc2luZ3ZhbHVlXCIgYW5kXG4gICAgICAgICAgICAgICAgLy8gXCJtaXNzaW5nb3BcIiByZW5kZXJlciBvcHRpb25zLiAgVGhvc2Ugb3B0aW9ucyBhcmUgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgLy8gYW55IG1vcmU7IE1VR0wgZmlsZXMgc2hvdWxkIHVzZSB0aGUgIG1pc3Npbmd2YWx1ZS9taXNzaW5nb3AgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC8vIG9mIDxkYXRhPjx2YXJpYWJsZT4gb3IgPGRhdGE+PHZhcmlhYmxlcz4gaW5zdGVhZC4gIFdoZW4gd2UncmUgcmVhZHkgdG9cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhpcyBzdXBwb3J0LCBkZWxldGUgdGhlIGJsb2NrIG9mIGNvZGU6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKHJlbmRlcmVyLCB4bWwsIHBsb3QsIG1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1ZhbHVlT3B0aW9uID0geG1sLmZpbmQoXCJvcHRpb25bbmFtZT1taXNzaW5ndmFsdWVdXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ09wT3B0aW9uICAgID0geG1sLmZpbmQoXCJvcHRpb25bbmFtZT1taXNzaW5nb3BdXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWlzc2luZ1ZhbHVlT3B0aW9uLmxlbmd0aCA+IDAgfHwgbWlzc2luZ09wT3B0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gcGxvdC5kYXRhKCkuY29sdW1ucygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLnNpemUoKTsgICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnMuYXQoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi50eXBlKCkgPT09IERhdGFWYWx1ZS5OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZU9wdGlvbi5sZW5ndGggPiAwICYmIChjb2x1bW4ubWlzc2luZ3ZhbHVlKCkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5taXNzaW5ndmFsdWUoTnVtYmVyVmFsdWUucGFyc2UocEYuZ2V0WE1MQXR0cihtaXNzaW5nVmFsdWVPcHRpb24sXCJ2YWx1ZVwiKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nT3BPcHRpb24ubGVuZ3RoID4gMCAmJiAoY29sdW1uLm1pc3NpbmdvcCgpID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4ubWlzc2luZ29wKERhdGFWYWx1ZS5wYXJzZUNvbXBhcmF0b3IocEYuZ2V0WE1MQXR0cihtaXNzaW5nT3BPcHRpb24sXCJ2YWx1ZVwiKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nVmFsdWVPcHRpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIud2FybmluZyhcIlJlbmRlcmVyIG9wdGlvbiAnbWlzc2luZ3ZhbHVlJyBpcyBkZXByZWNhdGVkOyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidXNlICdtaXNzaW5ndmFsdWUnIGF0dHJpYnV0ZSBvZiAnZGF0YScvJ3ZhcmlhYmxlJzsgaW5zdGVhZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSB4bWwgc28gdGhhdCB0aGUgb3B0aW9uLXByb2Nlc3NpbmcgY29kZSBiZWxvdyBkb2Vzbid0IHNlZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1ZhbHVlT3B0aW9uLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nT3BPcHRpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIud2FybmluZyhcIlJlbmRlcmVyIG9wdGlvbiAnbWlzc2luZ29wJyBpcyBkZXByZWNhdGVkOyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidXNlICdtaXNzaW5ndmFsdWUnIGF0dHJpYnV0ZSBvZiAnZGF0YScvJ3ZhcmlhYmxlJzsgaW5zdGVhZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSB4bWwgc28gdGhhdCB0aGUgb3B0aW9uLXByb2Nlc3NpbmcgY29kZSBiZWxvdyBkb2Vzbid0IHNlZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ09wT3B0aW9uLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfShyZW5kZXJlciwgeG1sLCBwbG90LCBtZXNzYWdlSGFuZGxlcikpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRW5kIG9mIGNvZGUgdG8gZGVsZXRlIHdoZW4gcmVtb3Zpbmcgc3VwcG9ydCBmb3IgZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgIC8vIG1pc3Npbmd2YWx1ZS9taXNzaW5nb3AgcmVuZGVyZXIgb3B0aW9ucy5cbiAgICAgICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAgICAgJC5lYWNoKHhtbC5maW5kKFwiPm9wdGlvblwiKSwgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldE9wdGlvbkZyb21TdHJpbmcocEYuZ2V0WE1MQXR0cigkKGUpLFwibmFtZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcEYuZ2V0WE1MQXR0cigkKGUpLFwidmFsdWVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBGLmdldFhNTEF0dHIoJChlKSxcIm1pblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcEYuZ2V0WE1MQXR0cigkKGUpLFwibWF4XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBXYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIud2FybmluZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufTtcbiIsInZhciBUaXRsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdGl0bGUuanMnKTtcblxuLy8gIDx0aXRsZVxuLy8gICAgICBiYXNlPVwiUE9JTlQoMCwxKVwiXG4vLyAgICAgIGFuY2hvcj1cIlBPSU5UKDAsMSlcIlxuLy8gICAgICBwb3NpdGlvbj1cIlBPSU5UKDAsMClcIlxuLy8gICAgICBmcmFtZT1cIkZSQU1FKHBhZGRpbmcpXCJcbi8vICAgICAgY29sb3I9XCJDT0xPUih3aGl0ZSlcIlxuLy8gICAgICBvcGFjaXR5PVwiRE9VQkxFKDEuMClcIlxuLy8gICAgICBib3JkZXI9XCJJTlRFR0VSKDApXCJcbi8vICAgICAgYm9yZGVyY29sb3I9XCJDT0xPUihibGFjaylcIlxuLy8gICAgICBwYWRkaW5nPVwiSU5URUdFUigwKVwiXG4vLyAgICAgIGNvcm5lcnJhZGl1cz1cIklOVEVHRVIoMTUpXCJcbi8vICAgICAgZm9udHNpemU9XCJJTlRFR0VSXCI+XG4vLyAgPC90aXRsZT5cblRpdGxlLnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCwgZ3JhcGgpIHtcbiAgICB2YXIgUG9pbnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcG9pbnQuanMnKSxcbiAgICAgICAgUkdCQ29sb3IgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgvcmdiX2NvbG9yLmpzJyksXG4gICAgICAgIFRleHQgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RleHQuanMnKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBwYXJzZVBvaW50ICAgICAgID0gUG9pbnQucGFyc2UsXG4gICAgICAgIHBhcnNlUkdCQ29sb3IgICAgPSBSR0JDb2xvci5wYXJzZSxcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUgICA9IHBGLnBhcnNlQXR0cmlidXRlLFxuICAgICAgICBwYXJzZUludGVnZXIgICAgID0gcEYucGFyc2VJbnRlZ2VyLFxuICAgICAgICB0aXRsZTtcblxuICAgIGlmICh4bWwpIHtcbiAgICAgICAgdmFyIHRleHQgPSB4bWwudGV4dCgpO1xuICAgICAgICBpZiAodGV4dCAhPT0gXCJcIikge1xuICAgICAgICAgICAgdGl0bGUgPSBuZXcgVGl0bGUobmV3IFRleHQodGV4dCksIGdyYXBoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gICAgICAgICAgICAgICAgXG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiZnJhbWVcIiksICAgICAgICB0aXRsZS5mcmFtZSwgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTsgfSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYm9yZGVyXCIpLCAgICAgICB0aXRsZS5ib3JkZXIsICAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiY29sb3JcIiksICAgICAgICB0aXRsZS5jb2xvciwgICAgICAgIHBhcnNlUkdCQ29sb3IpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJvcmRlcmNvbG9yXCIpLCAgdGl0bGUuYm9yZGVyY29sb3IsICBwYXJzZVJHQkNvbG9yKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJvcGFjaXR5XCIpLCAgICAgIHRpdGxlLm9wYWNpdHksICAgICAgcGFyc2VGbG9hdCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwicGFkZGluZ1wiKSwgICAgICB0aXRsZS5wYWRkaW5nLCAgICAgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiY29ybmVycmFkaXVzXCIpLCB0aXRsZS5jb3JuZXJyYWRpdXMsIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYW5jaG9yXCIpLCAgICAgICB0aXRsZS5hbmNob3IsICAgICAgIHBhcnNlUG9pbnQpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJhc2VcIiksICAgICAgICAgdGl0bGUuYmFzZSwgICAgICAgICBwYXJzZVBvaW50KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJwb3NpdGlvblwiKSwgICAgIHRpdGxlLnBvc2l0aW9uLCAgICAgcGFyc2VQb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0aXRsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGl0bGU7XG4iLCJ2YXIgV2luZG93ID0gcmVxdWlyZSgnLi4vLi4vY29yZS93aW5kb3cuanMnKTtcblxuLy8gPHdpbmRvd1xuLy8gICAgICAgd2lkdGg9XCJJTlRFR0VSXCJcbi8vICAgICAgIGhlaWdodD1cIklOVEVHRVJcIlxuLy8gICAgICAgYm9yZGVyPVwiSU5URUdFUigyKVwiXG4vLyAgICAgICBib3JkZXJjb2xvcj1cIkNPTE9SKGJsYWNrKVwiXG4vLyAgICAgICBtYXJnaW49XCJJTlRFR0VSKDIpXCJcbi8vICAgICAgIHBhZGRpbmc9XCJJTlRFR0VSKDUpXCI+XG4vLyAgIDwvd2luZG93PlxuV2luZG93LnBhcnNlWE1MID0gZnVuY3Rpb24gKHhtbCkge1xuICAgIHZhciB3ID0gbmV3IFdpbmRvdygpLFxuICAgICAgICBSR0JDb2xvciAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9yZ2JfY29sb3IuanMnKSxcbiAgICAgICAgcEYgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcGFyc2luZ0Z1bmN0aW9ucy5qcycpLFxuICAgICAgICBwYXJzZUF0dHJpYnV0ZSAgID0gcEYucGFyc2VBdHRyaWJ1dGUsXG4gICAgICAgIHBhcnNlSW50ZWdlciAgICAgPSBwRi5wYXJzZUludGVnZXIsXG4gICAgICAgIGF0dHI7XG4gICAgaWYgKHhtbCkge1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcIndpZHRoXCIpLCAgdy53aWR0aCwgIHBhcnNlSW50ZWdlcik7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiaGVpZ2h0XCIpLCB3LmhlaWdodCwgcGFyc2VJbnRlZ2VyKTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGUocEYuZ2V0WE1MQXR0cih4bWwsXCJib3JkZXJcIiksIHcuYm9yZGVyLCBwYXJzZUludGVnZXIpO1xuXG4gICAgICAgIGF0dHIgPSBwRi5nZXRYTUxBdHRyKHhtbCxcIm1hcmdpblwiKTtcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgdy5tYXJnaW4oKS5zZXQobSxtLG0sbSk7XG4gICAgICAgICAgICB9KHBhcnNlSW50KGF0dHIsIDEwKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0ciA9IHBGLmdldFhNTEF0dHIoeG1sLFwicGFkZGluZ1wiKTtcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgdy5wYWRkaW5nKCkuc2V0KG0sbSxtLG0pO1xuICAgICAgICAgICAgfShwYXJzZUludChhdHRyLCAxMCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZWQgZGVwcmVjYXRlZCBjb2xvciBuYW1lIGNoZWNrIGZyb20gY29tbWl0ICMxNzY2NWUyXG4gICAgICAgIC8vICAgIGpyZnJpbW1lIFR1ZXMgQXByIDIgMTE6NDcgMjAxM1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcImJvcmRlcmNvbG9yXCIpLCB3LmJvcmRlcmNvbG9yLCBSR0JDb2xvci5wYXJzZSk7XG4gICAgfVxuICAgIHJldHVybiB3O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaW5kb3c7XG4iLCJ2YXIgWm9vbSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvem9vbS5qcycpO1xuXG4vLyA8em9vbSBhbGxvd2VkPVwidHJ1ZVwiIG1pbj1cIjEwXCIgbWF4PVwiMTAwXCIgYW5jaG9yPVwiMFwiLz5cblpvb20ucGFyc2VYTUwgPSBmdW5jdGlvbiAoeG1sLCB0eXBlKSB7XG4gICAgdmFyIHpvb20gICAgICAgICAgICAgPSBuZXcgWm9vbSgpLFxuICAgICAgICBEYXRhVmFsdWUgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kYXRhX3ZhbHVlLmpzJyksXG4gICAgICAgIERhdGFNZWFzdXJlICAgICAgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RhdGFfbWVhc3VyZS5qcycpLFxuICAgICAgICBwRiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wYXJzaW5nRnVuY3Rpb25zLmpzJyksXG4gICAgICAgIHBhcnNlQXR0cmlidXRlICAgPSBwRi5wYXJzZUF0dHJpYnV0ZSxcbiAgICAgICAgcGFyc2VEYXRhTWVhc3VyZSA9IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIERhdGFNZWFzdXJlLnBhcnNlKHR5cGUsIHYpOyB9LCAvL3BGLnBhcnNlRGF0YU1lYXN1cmVcbiAgICAgICAgYXR0cjtcbiAgICBpZiAoeG1sKSB7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwiYWxsb3dlZFwiKSwgem9vbS5hbGxvd2VkLCBwRi5wYXJzZUJvb2xlYW4pO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZShwRi5nZXRYTUxBdHRyKHhtbCxcIm1pblwiKSwgICAgIHpvb20ubWluLCAgICAgcGFyc2VEYXRhTWVhc3VyZSk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlKHBGLmdldFhNTEF0dHIoeG1sLFwibWF4XCIpLCAgICAgem9vbS5tYXgsICAgICBwYXJzZURhdGFNZWFzdXJlKTtcbiAgICAgICAgYXR0ciA9IHBGLmdldFhNTEF0dHIoeG1sLFwiYW5jaG9yXCIpO1xuICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgIHpvb20uYW5jaG9yKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB6b29tLmFuY2hvciggRGF0YVZhbHVlLnBhcnNlKHR5cGUsIGF0dHIpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHpvb207XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFpvb207XG4iLCJ2YXIgUGFyc2luZ0Z1bmN0aW9ucyA9IHt9O1xuXG4vKipcbiAqIFRoZSBVdGlsaXR5IEZ1bmN0aW9ucyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byBnZW5lcmFsIGNvbmNlcHRzLlxuICpcbiAqIEBtb2R1bGUgbXVsdGlncmFwaFxuICogQHN1Ym1vZHVsZSB1dGlsaXR5ZnVuY3Rpb25zXG4gKiBAbWFpbiB1dGlsaXR5ZnVuY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBGdW5jdGlvbnMgd2hpY2ggcHJvdmlkZSBhYnN0cmFjdGlvbnMgZm9yIHRoZSBwYXJzZXIuXG4gKlxuICogQGNsYXNzIFBhcnNpbmdGdW5jdGlvbnNcbiAqIEBmb3IgUGFyc2luZ0Z1bmN0aW9uc1xuICogQHN0YXRpY1xuICovXG5cbi8qKlxuICogQWJzdHJhY3QgZnVuY3Rpb24gZm9yIHBhcnNpbmcgYW5kIHNldHRpbmcgamVybWFpbmUgYXR0cmlidXRlcyB3aGljaCBkbyBub3QgcmVxdWlyZVxuICogZXh0cmVtZWx5IGNvbXBsaWNhdGVkIGxvZ2ljIHRvIGRldGVybWluZSB0aGVpciB2YWx1ZXMuIEFueSBhdHRyaWJ1dGVzIHdoaWNoIHJlcXVpcmVcbiAqIGNvbXBsZXggbG9naWMgdG8gZGV0ZXJtaW5lIHRoZWlyIHByb3BlciB2YWx1ZXMgc2hvdWxkIGJlIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBwYXJzZXIuXG4gKlxuICogQG1ldGhvZCBwYXJzZUF0dHJpYnV0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXByb2Nlc3NvclxuICogQHN0YXRpY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUGFyc2luZ0Z1bmN0aW9ucy5wYXJzZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXR0cmlidXRlLCBwcmVwcm9jZXNzb3IpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhdHRyaWJ1dGUoKHByZXByb2Nlc3NvciAhPT0gdW5kZWZpbmVkKSA/IHByZXByb2Nlc3Nvcih2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHN0cmluZyBhcmd1bWVudCB3aXRoIGEgcmFkaXggb2YgMTAgYW5kIHJldHVybnMgYW4gaW50ZWdlci5cbiAqXG4gKiBAbWV0aG9kIHBhcnNlSW50ZWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAc3RhdGljXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfVxuICovXG5QYXJzaW5nRnVuY3Rpb25zLnBhcnNlSW50ZWdlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xufTtcblxuLy9tYnBcbi8vLyoqXG4vLyAqIFJldHVybnMgYSBjdXJyaWVkIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgdmFsdWUgaW50byBhIERhdGFWYWx1ZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuXG4vLyAqXG4vLyAqIEBtZXRob2QgcGFyc2VEYXRhVmFsdWVcbi8vICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbi8vICogQHN0YXRpY1xuLy8gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbi8vICovXG4vL1BhcnNpbmdGdW5jdGlvbnMucGFyc2VEYXRhVmFsdWUgPSBmdW5jdGlvbiAodHlwZSkge1xuLy8gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuLy8gICAgICAgIHJldHVybiB3aW5kb3cubXVsdGlncmFwaC5jb3JlLkRhdGFWYWx1ZS5wYXJzZSh0eXBlLCB2YWx1ZSk7XG4vLyAgICB9O1xuLy99O1xuXG4vL21icFxuLy8vKipcbi8vICogUmV0dXJucyBhIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYSB2YWx1ZSBpbnRvIGEgRGF0YU1lYXN1cmUgb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxuLy8gKlxuLy8gKiBAbWV0aG9kIHBhcnNlRGF0YU1lYXN1cmVcbi8vICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbi8vICogQHN0YXRpY1xuLy8gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbi8vICovXG4vL1BhcnNpbmdGdW5jdGlvbnMucGFyc2VEYXRhTWVhc3VyZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4vLyAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4vLyAgICAgICAgcmV0dXJuIHdpbmRvdy5tdWx0aWdyYXBoLmNvcmUuRGF0YU1lYXN1cmUucGFyc2UodHlwZSwgdmFsdWUpO1xuLy8gICAgfTtcbi8vfTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGFsbG93ZWQgQm9vbGVhbiBTdHJpbmdzIGFuZCByZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZS4gSWYgdGhlIHBhcmFtZXRlclxuICogaXMgbm90IG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMgdGhlbiB0aGUgcGFyYW1ldGVyIGlzIHJldHVybmVkIGFzIGFuIGVycm9yIG1pZ2h0IG5vdFxuICogbmVlZCB0byBiZSB0aHJvd24gaW1tZWRpYXRlbHkuXG4gKlxuICogQG1ldGhvZCBwYXJzZUJvb2xlYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbVxuICogQHN0YXRpY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUGFyc2luZ0Z1bmN0aW9ucy5wYXJzZUJvb2xlYW4gPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBpZiAodHlwZW9mKHBhcmFtKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAgY2FzZSBcInllc1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgICBjYXNlIFwibm9cIjpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9XG59O1xuXG4vKlxuICogVGhlIFBhcnNpbmdGdW5jdGlvbnMuZ2V0WE1MQXR0cigpIGZ1bmN0aW9uIHJldHVybnMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBmb3JcbiAqIGFuIFhNTCBkb2N1bWVudCBub2RlLlxuICogXG4gKiBUaGUgYG5vZGVgIGFyZ3VtZW50IHNob3VsZCBiZSBhIG5vZGUgaW4gYW4gWE1MIGRvY3VtZW50IGFzIHJldHVybmVkIGJ5IHRoZSBqUXVlcnlcbiAqIHBhcnNlWE1MIGZ1bmN0aW9uLlxuICogXG4gKiBUaGUgYGF0dHJuYW1lYCBhcmd1bWVudCBzaG91bGQgYmUgYSBzdHJpbmcgd2hpY2ggaXMgdGhlIG5hbWUgb2YgYW4gYXR0cmlidXRlLlxuICogXG4gKiBUaGlzIGZ1bmN0aW9uIGVuc3VyZXMgdG8gcmV0dXJuIFwidW5kZWZpbmVkXCIgaWYgdGhlIG5vZGUgZG9lcyBub3QgaGF2ZSB0aGUgYXR0cmlidXRlLlxuICogXG4gKiBUaGlzIGZ1bmN0aW9uIGl0c2VsZiBkb2VzIG5vdCBkZXBlbmQgb24galF1ZXJ5LCB3aGljaCBpcyB3aHkgaXQgaXMgbG9jYXRlZCBpbiB0aGlzXG4gKiBmaWxlIC0tIHNvIHRoYXQgY29kZSBuZWVkaW5nIHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGRvbid0IGhhdmUgdG8gcmVxdWlyZSBqUXVlcnkganVzdFxuICogZm9yIHRoaXMgZnVuY3Rpb24uICAoVGhlIHVzZSBvZiB0aGlzIGZ1bmN0aW9uIGRvZXMgcmVxdWlyZSBqUXVlcnkgYXQgc29tZSBwb2ludCBpblxuICogdGhlIHByb2dyYW0sIGJlY2F1c2UgdGhpcyBgbm9kZWAgb2JqZWN0IG11c3QgYmUgYSBqUXVlcnkgb2JqZWN0IHJlcHJlc2VudGluZyBhbiBYTUxcbiAqIGRvY3VtZW50LilcbiAqIFxuICogVGhlIHJlYXNvbiB3ZSBoYXZlIHRoaXMgZnVuY3Rpb24gZm9yIGV4dHJhY3RpbmcgYXR0cmlidXRlIHZhbHVlcywgcmF0aGVyIHRoYW5cbiAqIGp1c3QgY2FsbGluZyBub2RlLmF0dHIoYXR0cm5hbWUpIGRpcmVjdGx5LCBpcyB0aGF0IGluIHNvbWUgY2FzZXMgbm9kZS5hdHRyKClcbiAqIHJldHVybnMgdGhlIGVtcHR5IHN0cmluZyBmb3IgYXR0cmlidXRlcyB3aGljaCBoYXZlIG5vdCBiZWVuIHNldC4gIFRoaXMgZnVuY3Rpb25cbiAqIHVzZXMgdGhlIGhhc0F0dHJpYnV0ZSgpIG1ldGhvZCB0byBjaGVjayB0byBzZWUgd2hldGhlciB0aGUgYXR0cmlidXRlIHZhbHVlXG4gKiBpcyBwcmVzZW50LCBhbmQgYWx3YXlzIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgaXQgaXMgbm90LlxuICovXG5QYXJzaW5nRnVuY3Rpb25zLmdldFhNTEF0dHIgPSBmdW5jdGlvbihub2RlLCBhdHRybmFtZSkge1xuICAgIGlmIChub2RlLmxlbmd0aCA+PSAxICYmIG5vZGVbMF0uaGFzQXR0cmlidXRlKGF0dHJuYW1lKSkge1xuICAgICAgICByZXR1cm4gbm9kZS5hdHRyKGF0dHJuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2luZ0Z1bmN0aW9ucztcbiIsInV0aWxpdHlGdW5jdGlvbnMgPSB7fTtcblxuLy8gV2h5IG5vdCB1c2UgT2JqZWN0LmdldEtleXMoKSA/PyAgbWJwIEZyaSBNYXIgMTMgMDA6MjE6NTcgMjAxNVxudXRpbGl0eUZ1bmN0aW9ucy5nZXRLZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBrZXlzID0gW10sXG4gICAgICAgIGtleTtcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbi8vIGNvZXJjZSBhIHZhbHVlIHRvIGEgc3RyaW5nLCBidXQgbm90IGlmIGl0IGlzIHRoZSB1bmRlZmluZWQgdmFsdWVcbnV0aWxpdHlGdW5jdGlvbnMuY29lcmNlVG9TdHJpbmcgPSBmdW5jdGlvbihzKSB7XG4gICAgaWYgKHR5cGVvZihzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG59O1xuXG51dGlsaXR5RnVuY3Rpb25zLmluc2VydERlZmF1bHRzID0gZnVuY3Rpb24gKGVsZW0sIGRlZmF1bHRzLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzW2F0dHJpYnV0ZXNbaV1dICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZihkZWZhdWx0c1thdHRyaWJ1dGVzW2ldXSkgIT09IFwib2JqZWN0XCIgfHwgZGVmYXVsdHNbYXR0cmlidXRlc1tpXV0gPT09IG51bGwpKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5hdHRyaWJ1dGVzKCkuaW5kZXhPZihhdHRyaWJ1dGVzW2ldKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5hdHRyaWJ1dGUoYXR0cmlidXRlc1tpXSkuZGVmYXVsdHNUbyhkZWZhdWx0c1thdHRyaWJ1dGVzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW07XG59O1xuXG5cbi8vIFRoaXMgc2hvdWxkIGJlIHJlbmFtZWQ7IHRoZSBuYW1lICdnZXREZWZhdWx0VmFsdWVzRnJvbVhTRCcgaXMgYSBob2xkb3ZlciBmcm9tIHdoZW4gd2Vcbi8vIGhhZCBhbiBYU0QgdGhhdCBjb250YWluZWQgZGVmYXVsdCB2YWx1ZXMsIGFuZCB0aGlzIGZ1bmN0aW9uIGNvbnN1bHRlZCBpdC4gIE9yIG1heWJlXG4vLyB3ZSBuZXZlciBhY3R1YWxseSBoYWQgdGhhdCwgYnV0IGludGVuZGVkIHRvIGltcGxlbWVudCBpdD8gIEluIGFueSBjYXNlLCBpdCBzZWVtcyBjbGVhclxuLy8gd2Ugd29uJ3QgYmUgdXNpbmcgYW4gWFNEIGhlcmUsIHNvIHRoaXMgc2hvdWxkIGJlIHJlbmFtZWQuICBtYnAgRnJpIE1hciAxMyAwMDoyMzo0MiAyMDE1XG51dGlsaXR5RnVuY3Rpb25zLmdldERlZmF1bHRWYWx1ZXNGcm9tWFNEID0gZnVuY3Rpb24gKCkge1xuICAgIFxuICAgIHZhciBEYXRldGltZVZhbHVlID0gcmVxdWlyZSgnLi4vY29yZS9kYXRldGltZV92YWx1ZS5qcycpLFxuICAgICAgICBOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4uL2NvcmUvbnVtYmVyX3ZhbHVlLmpzJyksXG4gICAgICAgIERpc3BsYWNlbWVudCA9IHJlcXVpcmUoJy4uL21hdGgvZGlzcGxhY2VtZW50LmpzJyksXG4gICAgICAgIEluc2V0cyA9IHJlcXVpcmUoJy4uL21hdGgvaW5zZXRzLmpzJyksXG4gICAgICAgIFBvaW50ID0gcmVxdWlyZSgnLi4vbWF0aC9wb2ludC5qcycpLFxuICAgICAgICBSR0JDb2xvciA9IHJlcXVpcmUoJy4uL21hdGgvcmdiX2NvbG9yLmpzJyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBcIndpbmRvd1wiOiB7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgXCJ3aWR0aFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgXCJoZWlnaHRcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgXCJib3JkZXJcIjogMixcbiAgICAgICAgICAgIFwibWFyZ2luXCIgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSW5zZXRzKC8qdG9wKi8yLCAvKmxlZnQqLzIsIC8qYm90dG9tKi8yLCAvKnJpZ2h0Ki8yKTsgfSxcbiAgICAgICAgICAgIFwicGFkZGluZ1wiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSW5zZXRzKC8qdG9wKi81LCAvKmxlZnQqLzUsIC8qYm90dG9tKi81LCAvKnJpZ2h0Ki81KTsgfSxcbiAgICAgICAgICAgIFwiYm9yZGVyY29sb3JcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJHQkNvbG9yLnBhcnNlKFwiMHgwMDAwMDBcIik7IH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJsZWdlbmRcIjoge1xuICAgICAgICAgICAgXCJpY29uXCIgOiB7XG4gICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogMzAsXG4gICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiA0MCxcbiAgICAgICAgICAgICAgICBcImJvcmRlclwiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ2aXNpYmxlXCI6IG51bGwsXG4gICAgICAgICAgICBcImJhc2VcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDEsMSk7IH0sXG4gICAgICAgICAgICBcImFuY2hvclwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMSwxKTsgfSxcbiAgICAgICAgICAgIFwicG9zaXRpb25cIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsMCk7IH0sXG4gICAgICAgICAgICBcImZyYW1lXCI6IFwicGxvdFwiLFxuICAgICAgICAgICAgXCJjb2xvclwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUkdCQ29sb3IucGFyc2UoXCIweGZmZmZmZlwiKTsgfSxcbiAgICAgICAgICAgIFwiYm9yZGVyY29sb3JcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJHQkNvbG9yLnBhcnNlKFwiMHgwMDAwMDBcIik7IH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjogMS4wLFxuICAgICAgICAgICAgXCJib3JkZXJcIjogMSxcbiAgICAgICAgICAgIFwicm93c1wiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBcImNvbHVtbnNcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgXCJjb3JuZXJyYWRpdXNcIjogMCxcbiAgICAgICAgICAgIFwicGFkZGluZ1wiOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiYmFja2dyb3VuZFwiOiB7XG4gICAgICAgICAgICBcImltZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJzcmNcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwiYW5jaG9yXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgtMSwtMSk7IH0sXG4gICAgICAgICAgICAgICAgXCJiYXNlXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgtMSwtMSk7IH0sXG4gICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwwKTsgfSxcbiAgICAgICAgICAgICAgICBcImZyYW1lXCI6IFwicGFkZGluZ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb2xvclwiOiBcIjB4ZmZmZmZmXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJwbG90YXJlYVwiOiB7XG4gICAgICAgICAgICBcIm1hcmdpblwiIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEluc2V0cygvKnRvcCovMTAgLCAvKmxlZnQqLzM4LCAvKmJvdHRvbSovMzUsIC8qcmlnaHQqLzM1KTsgfSxcbiAgICAgICAgICAgIFwiYm9yZGVyXCI6IDAsXG4gICAgICAgICAgICBcImNvbG9yXCIgOiBudWxsLFxuICAgICAgICAgICAgXCJib3JkZXJjb2xvclwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUkdCQ29sb3IucGFyc2UoXCIweGVlZWVlZVwiKTsgfVxuICAgICAgICB9LFxuICAgICAgICBcInRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwidGV4dFwiICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBcImZyYW1lXCIgICAgICAgIDogXCJwYWRkaW5nXCIsXG4gICAgICAgICAgICBcImJvcmRlclwiICAgICAgIDogMCxcbiAgICAgICAgICAgIFwiY29sb3JcIiAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUkdCQ29sb3IucGFyc2UoXCIweGZmZmZmZlwiKTsgfSxcbiAgICAgICAgICAgIFwiYm9yZGVyY29sb3JcIiAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUkdCQ29sb3IucGFyc2UoXCIweDAwMDAwMFwiKTsgfSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiICAgICAgOiAxLjAsXG4gICAgICAgICAgICBcInBhZGRpbmdcIiAgICAgIDogMCxcbiAgICAgICAgICAgIFwiY29ybmVycmFkaXVzXCIgOiAxNSxcbiAgICAgICAgICAgIFwiYW5jaG9yXCIgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwxKTsgfSxcbiAgICAgICAgICAgIFwiYmFzZVwiICAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwxKTsgfSxcbiAgICAgICAgICAgIFwicG9zaXRpb25cIiAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwwKTsgfVxuICAgICAgICB9LFxuICAgICAgICBcImhvcml6b250YWxheGlzXCI6IHtcbiAgICAgICAgICAgIFwidGl0bGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY29udGVudFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwiZm9udG5hbWVcIjogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwiZm9udHNpemVcIjogXCIxMlwiLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImZvbnRjb2xvclwiOiBcIjB4MDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgXCJhbmNob3JcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwiYmFzZVwiIDogMCxcbiAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgICAgIFwicG9zaXRpb24taG9yaXpvbnRhbC10b3BcIiAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgwLCAxNSk7IH0sXG4gICAgICAgICAgICAgICAgXCJwb3NpdGlvbi1ob3Jpem9udGFsLWJvdHRvbVwiIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsIC0xOCk7IH0sXG4gICAgICAgICAgICAgICAgXCJwb3NpdGlvbi12ZXJ0aWNhbC1yaWdodFwiICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDMzLCAwKTsgfSxcbiAgICAgICAgICAgICAgICBcInBvc2l0aW9uLXZlcnRpY2FsLWxlZnRcIiAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoLTI1LCAwKTsgfSxcblxuICAgICAgICAgICAgICAgIFwiYW5jaG9yLWhvcml6b250YWwtdG9wXCIgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgwLCAtMSk7IH0sXG4gICAgICAgICAgICAgICAgXCJhbmNob3ItaG9yaXpvbnRhbC1ib3R0b21cIiAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsIDEpOyB9LFxuICAgICAgICAgICAgICAgIFwiYW5jaG9yLXZlcnRpY2FsLXJpZ2h0XCIgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgtMSwgMCk7IH0sXG4gICAgICAgICAgICAgICAgXCJhbmNob3ItdmVydGljYWwtbGVmdFwiICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDEsIDApOyB9LFxuXG4gICAgICAgICAgICAgICAgXCJhbmdsZVwiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJsYWJlbHNcIjoge1xuICAgICAgICAgICAgICAgIFwibGFiZWxcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImZvcm1hdFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHRoZSBMYWJlbGVyIG9iamVjdCdzIGRlZmF1bHQgdmFsdWVzIGZvciBwb3NpdGlvbiBhbmQgYW5jaG9yIHNob3VsZCBiZSB1bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIElmIHRob3NlIGF0dHJpYnV0ZXMgYXJlIG5vdCBzcGVjaWZpZWQgaW4gdGhlIE1VR0wsIHRoZSBMYWJlbGVyJ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgaW5pdGlhbGl6ZUdlb21ldHJ5KCkgbWV0aG9kIHNldHMgdGhlbSB0byBvbmUgb2YgdGhlIGNvbnRleHQtZGVwZW5kZW50IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYW5jaG9yXCI6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uLWhvcml6b250YWwtdG9wXCIgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwgNSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb24taG9yaXpvbnRhbC1ib3R0b21cIiA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgwLCAtNSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb24tdmVydGljYWwtcmlnaHRcIiAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCg1LCAwKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJwb3NpdGlvbi12ZXJ0aWNhbC1sZWZ0XCIgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KC04LCAwKTsgfSxcblxuICAgICAgICAgICAgICAgICAgICBcImFuY2hvci1ob3Jpem9udGFsLXRvcFwiICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwgLTEpOyB9LFxuICAgICAgICAgICAgICAgICAgICBcImFuY2hvci1ob3Jpem9udGFsLWJvdHRvbVwiICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwgMSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYW5jaG9yLXZlcnRpY2FsLXJpZ2h0XCIgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgtMSwgMCk7IH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYW5jaG9yLXZlcnRpY2FsLWxlZnRcIiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgxLCAwKTsgfSxcblxuICAgICAgICAgICAgICAgICAgICBcImFuZ2xlXCI6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgXCJzcGFjaW5nXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgXCJkZW5zaXR5ZmFjdG9yXCI6IDEuMCxcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJHQkNvbG9yLnBhcnNlKFwiMHgwMDAwMDBcIik7IH0sXG4gICAgICAgICAgICAgICAgICAgIFwidmlzaWJsZVwiIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udG5hbWVcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udHNpemVcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udGNvbG9yXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwiZm9udG5hbWVcIjogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwiZm9udHNpemVcIjogXCIxMlwiLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImZvbnRjb2xvclwiOiBcIjB4MDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwiZm9ybWF0XCI6IFwiJTFkXCIsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwidmlzaWJsZVwiOiBcInRydWVcIixcbiAgICAgICAgICAgICAgICBcInN0YXJ0LW51bWJlclwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTnVtYmVyVmFsdWUoMCk7IH0sXG4gICAgICAgICAgICAgICAgXCJzdGFydC1kYXRldGltZVwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGF0ZXRpbWVWYWx1ZSgwKTsgfSxcbiAgICAgICAgICAgICAgICBcImFuZ2xlXCI6IDAuMCxcbiAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgwLDApOyB9LFxuICAgICAgICAgICAgICAgIFwiYW5jaG9yXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgwLDApOyB9LFxuICAgICAgICAgICAgICAgIFwiY29sb3JcIiA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBSR0JDb2xvci5wYXJzZShcIjB4MDAwMDAwXCIpOyB9LFxuICAgICAgICAgICAgICAgIFwidmlzaWJsZVwiIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvL1wiZGVmYXVsdE51bWJlclNwYWNpbmdcIjogXCIxMDAwMCA1MDAwIDIwMDAgMTAwMCA1MDAgMjAwIDEwMCA1MCAyMCAxMCA1IDIgMSAwLjEgMC4wMSAwLjAwMVwiLFxuICAgICAgICAgICAgICAgIC8vXCJkZWZhdWx0RGF0ZXRpbWVTcGFjaW5nXCI6IFwiMTAwMFkgNTAwWSAyMDBZIDEwMFkgNTBZIDIwWSAxMFkgNVkgMlkgMVkgNk0gM00gMk0gMU0gN0QgM0QgMkQgMUQgMTJIIDZIIDNIIDJIIDFIXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0TnVtYmVyU3BhY2luZ1wiOiBbMTAwMDAsIDUwMDAsIDIwMDAsIDEwMDAsIDUwMCwgMjAwLCAxMDAsIDUwLCAyMCwgMTAsIDUsIDIsIDEsIDAuMSwgMC4wMSwgMC4wMDFdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdERhdGV0aW1lU3BhY2luZ1wiOiBbXCIxMDAwWVwiLCBcIjUwMFlcIiwgXCIyMDBZXCIsIFwiMTAwWVwiLCBcIjUwWVwiLCBcIjIwWVwiLCBcIjEwWVwiLCBcIjVZXCIsIFwiMllcIiwgXCIxWVwiLCBcIjZNXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIzTVwiLCBcIjJNXCIsIFwiMU1cIiwgXCI3RFwiLCBcIjNEXCIsIFwiMkRcIiwgXCIxRFwiLCBcIjEySFwiLCBcIjZIXCIsIFwiM0hcIiwgXCIySFwiLCBcIjFIXCJdLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwiZGVuc2l0eWZhY3RvclwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdyaWRcIjoge1xuICAgICAgICAgICAgICAgIFwiY29sb3JcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJHQkNvbG9yLnBhcnNlKFwiMHhlZWVlZWVcIik7IH0sXG4gICAgICAgICAgICAgICAgXCJ2aXNpYmxlXCI6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwYW5cIjoge1xuICAgICAgICAgICAgICAgIFwiYWxsb3dlZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWluXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJtYXhcIjogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiem9vbVwiOiB7XG4gICAgICAgICAgICAgICAgXCJhbGxvd2VkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtaW5cIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwibWF4XCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcImFuY2hvclwiOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJiaW5kaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcIm1pblwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJtYXhcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJpZFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IDEuMCxcbiAgICAgICAgICAgIFwibGVuZ3RoXCIgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGlzcGxhY2VtZW50KDEsMCk7IH0sXG4gICAgICAgICAgICBcInBvc2l0aW9uXCI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCgwLDApOyB9LFxuICAgICAgICAgICAgXCJwcmVnYXBcIjogMCxcbiAgICAgICAgICAgIFwicG9zdGdhcFwiOiAwLFxuICAgICAgICAgICAgXCJhbmNob3JcIjogLTEsXG4gICAgICAgICAgICBcImJhc2VcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KC0xLC0xKTsgfSxcbiAgICAgICAgICAgIFwibWluXCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgXCJtaW5vZmZzZXRcIjogMCxcbiAgICAgICAgICAgIC8vXCJtaW5wb3NpdGlvblwiOiAtMSxcbiAgICAgICAgICAgIFwibWlucG9zaXRpb25cIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERpc3BsYWNlbWVudCgtMSwwKTsgfSxcbiAgICAgICAgICAgIFwibWF4XCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgXCJtYXhvZmZzZXRcIjogMCxcbiAgICAgICAgICAgIC8vXCJtYXhwb3NpdGlvblwiOiAxLFxuICAgICAgICAgICAgXCJtYXhwb3NpdGlvblwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGlzcGxhY2VtZW50KDEsMCk7IH0sXG4gICAgICAgICAgICBcInBvc2l0aW9uYmFzZVwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBcImNvbG9yXCI6IFwiMHgwMDAwMDBcIixcbiAgICAgICAgICAgIFwiY29sb3JcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJHQkNvbG9yKDAsMCwwKTsgfSxcbiAgICAgICAgICAgIFwidGlja21pblwiOiAtMyxcbiAgICAgICAgICAgIFwidGlja21heFwiOiAzLFxuICAgICAgICAgICAgXCJ0aWNrY29sb3JcIjogbnVsbCxcbiAgICAgICAgICAgIFwiaGlnaGxpZ2h0c3R5bGVcIjogXCJheGlzXCIsXG4gICAgICAgICAgICBcImxpbmV3aWR0aFwiOiAxLFxuICAgICAgICAgICAgXCJvcmllbnRhdGlvblwiOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgXCJ2ZXJ0aWNhbGF4aXNcIjoge1xuICAgICAgICAgICAgXCJ0aXRsZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjb250ZW50XCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJmb250bmFtZVwiOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJmb250c2l6ZVwiOiBcIjEyXCIsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFwiZm9udGNvbG9yXCI6IFwiMHgwMDAwMDBcIixcbiAgICAgICAgICAgICAgICBcImFuY2hvclwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQoMCwtMjApOyB9LFxuICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KDAsMSk7IH0sXG4gICAgICAgICAgICAgICAgXCJhbmdsZVwiOiBcIjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibGFiZWxzXCI6IHtcbiAgICAgICAgICAgICAgICBcImxhYmVsXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJmb3JtYXRcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcInN0YXJ0XCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhbmdsZVwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcImFuY2hvclwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwic3BhY2luZ1wiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZGVuc2l0eWZhY3RvclwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBcImZvbnRuYW1lXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBcImZvbnRzaXplXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBcImZvbnRjb2xvclwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImZvbnRuYW1lXCI6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImZvbnRzaXplXCI6IFwiMTJcIixcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJmb250Y29sb3JcIjogXCIweDAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwiZm9ybWF0XCI6IFwiJTFkXCIsXG4gICAgICAgICAgICAgICAgXCJ2aXNpYmxlXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgICAgIFwic3RhcnRcIjogXCIwXCIsXG4gICAgICAgICAgICAgICAgXCJhbmdsZVwiOiBcIjAuMFwiLFxuICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogXCIwIDBcIixcbiAgICAgICAgICAgICAgICBcImFuY2hvclwiOiBcIjAgMFwiLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcInNwYWNpbmdcIjogXCIxMDAwMCA1MDAwIDIwMDAgMTAwMCA1MDAgMjAwIDEwMCA1MCAyMCAxMCA1IDIgMSAwLjEgMC4wMSAwLjAwMVwiLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHREYXRldGltZVNwYWNpbmdcIjogXCIxMDAwWSA1MDBZIDIwMFkgMTAwWSA1MFkgMjBZIDEwWSA1WSAyWSAxWSA2TSAzTSAyTSAxTSA3RCAzRCAyRCAxRCAxMkggNkggM0ggMkggMUhcIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcImRlbnNpdHlmYWN0b3JcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJncmlkXCI6IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBcIjB4ZWVlZWVlXCIsXG4gICAgICAgICAgICAgICAgXCJ2aXNpYmxlXCI6IFwiZmFsc2VcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGFuXCI6IHtcbiAgICAgICAgICAgICAgICBcImFsbG93ZWRcIjogXCJ5ZXNcIixcbiAgICAgICAgICAgICAgICBcIm1pblwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJtYXhcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ6b29tXCI6IHtcbiAgICAgICAgICAgICAgICBcImFsbG93ZWRcIjogXCJ5ZXNcIixcbiAgICAgICAgICAgICAgICBcIm1pblwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJtYXhcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwiYW5jaG9yXCI6IFwibm9uZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJiaW5kaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcIm1pblwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJtYXhcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJpZFwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IFwiMS4wXCIsXG4gICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiMCAwXCIsXG4gICAgICAgICAgICBcInByZWdhcFwiOiBcIjBcIixcbiAgICAgICAgICAgIFwicG9zdGdhcFwiOiBcIjBcIixcbiAgICAgICAgICAgIFwiYW5jaG9yXCI6IFwiLTFcIixcbiAgICAgICAgICAgIFwiYmFzZVwiOiBcIi0xIDFcIixcbiAgICAgICAgICAgIFwibWluXCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgXCJtaW5vZmZzZXRcIjogXCIwXCIsXG4gICAgICAgICAgICBcIm1pbnBvc2l0aW9uXCI6IFwiLTFcIixcbiAgICAgICAgICAgIFwibWF4XCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgXCJtYXhvZmZzZXRcIjogXCIwXCIsXG4gICAgICAgICAgICBcIm1heHBvc2l0aW9uXCI6IFwiMVwiLFxuICAgICAgICAgICAgXCJwb3NpdGlvbmJhc2VcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgXCJjb2xvclwiOiBcIjB4MDAwMDAwXCIsXG4gICAgICAgICAgICBcInRpY2ttaW5cIjogXCItM1wiLFxuICAgICAgICAgICAgXCJ0aWNrbWF4XCI6IFwiM1wiLFxuICAgICAgICAgICAgXCJoaWdobGlnaHRzdHlsZVwiOiBcImF4aXNcIixcbiAgICAgICAgICAgIFwibGluZXdpZHRoXCI6IFwiMVwiLFxuICAgICAgICAgICAgXCJvcmllbnRhdGlvblwiOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgXCJwbG90XCI6IHtcbiAgICAgICAgICAgIFwibGVnZW5kXCI6IHtcbiAgICAgICAgICAgICAgICBcInZpc2libGVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImxhYmVsXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaG9yaXpvbnRhbGF4aXNcIjoge1xuICAgICAgICAgICAgICAgIFwidmFyaWFibGVcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInJlZlwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZmFjdG9yXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjb25zdGFudFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJlZlwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInZlcnRpY2FsYXhpc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJ2YXJpYWJsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwicmVmXCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgXCJmYWN0b3JcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNvbnN0YW50XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwicmVmXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBcIm9wdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJyZW5kZXJlclwiOntcbiAgICAgICAgICAgICAgICBcIm9wdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcIm1pblwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwibWF4XCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vY29yZS9yZW5kZXJlci5qcycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVuZGVyZXIuVHlwZS5wYXJzZShcImxpbmVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZGF0YXRpcHNcIjp7XG4gICAgICAgICAgICAgICAgXCJ2YXJpYWJsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiZm9ybWF0U3RyaW5nLW51bWJlclwiIDogXCIlLjJmXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZm9ybWF0U3RyaW5nLWRhdGV0aW1lXCIgOiBcIiVkICVuICVZXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBcInZpc2libGVcIjogXCJmYWxzZVwiLFxuICAgICAgICAgICAgICAgIFwiZm9ybWF0U3RyaW5nXCI6IFwiezB9OiB7MX1cIixcbiAgICAgICAgICAgICAgICBcImJnY29sb3JcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gUkdCQ29sb3IucGFyc2UoXCIweGVlZWVlZVwiKTsgfSxcbiAgICAgICAgICAgICAgICBcImJnYWxwaGFcIjogMS4wLFxuICAgICAgICAgICAgICAgIFwiYm9yZGVyXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJib3JkZXJjb2xvclwiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBSR0JDb2xvci5wYXJzZShcIjB4MDAwMDAwXCIpOyB9LFxuICAgICAgICAgICAgICAgIFwicGFkXCI6IDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFwidGhyb3R0bGVcIjoge1xuICAgICAgICAgICAgXCJwYXR0ZXJuXCIgICAgOiBcIlwiLFxuICAgICAgICAgICAgXCJyZXF1ZXN0c1wiICAgOiAwLFxuICAgICAgICAgICAgXCJwZXJpb2RcIiAgICAgOiAwLFxuICAgICAgICAgICAgXCJjb25jdXJyZW50XCIgOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcInZhcmlhYmxlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJ2YXJpYWJsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBcImNvbHVtblwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pc3Npbmd2YWx1ZVwiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIFwibWlzc2luZ29wXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJtaXNzaW5ndmFsdWVcIjogXCItOTAwMFwiLFxuICAgICAgICAgICAgICAgIFwibWlzc2luZ29wXCI6IFwiZXFcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgICAgICAgICBcImNvbnRlbnRcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjc3ZcIjoge1xuICAgICAgICAgICAgICAgIFwibG9jYXRpb25cIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzZXJ2aWNlXCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbGl0eUZ1bmN0aW9ucztcblxuIiwidmFyIFZhbGlkYXRpb25GdW5jdGlvbnMgPSB7fTtcblxuVmFsaWRhdGlvbkZ1bmN0aW9ucy52YWxpZGF0ZU51bWJlclJhbmdlID0gZnVuY3Rpb24gKG51bWJlciwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiB0eXBlb2YobnVtYmVyKSA9PT0gXCJudW1iZXJcIiAmJiBudW1iZXIgPj0gbG93ZXJCb3VuZCAmJiBudW1iZXIgPD0gdXBwZXJCb3VuZDtcbn07XG5cbi8vIFRoaXMgZnVuY3Rpb24sIGZyb20gaHR0cDovL2phdmFzY3JpcHQuY3JvY2tmb3JkLmNvbS9yZW1lZGlhbC5odG1sLCBzaG91bGQgY29ycmVjdGx5XG4vLyByZXR1cm4gJ2FycmF5JyBmb3IgYW55IEFycmF5IG9iamVjdCwgaW5jbHVkaW5nIFtdLlxuLy8gUmV0dXJucyAnb2JqZWN0JyBmb3IgYW55IEpTIG9iamVjdC5cblZhbGlkYXRpb25GdW5jdGlvbnMudHlwZU9mID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcyA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAocyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAvL05PVEU6IENyb2NrZm9yZCB1c2VkIFwiPT1cIiAgID8/Pz8/ISEhISEgIG1icCBGcmkgU2VwIDI4IDA4OjQ0OjM0IDIwMTJcbiAgICAgICAgICAgIC8vaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBzID0gJ2FycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSAnbnVsbCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHM7XG59O1xuXG5WYWxpZGF0aW9uRnVuY3Rpb25zLmlzTnVtYmVyTm90TmFOID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAodHlwZW9mKHgpID09PSBcIm51bWJlclwiKSAmJiAoeCA9PT0geCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRpb25GdW5jdGlvbnM7XG4iXX0=
